import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// browser-external:node-fetch
var require_node_fetch = __commonJS({
  "browser-external:node-fetch"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node-fetch" has been externalized for browser compatibility. Cannot access "node-fetch.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "�";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "�";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "�";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "�";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@tensorflow/tfjs/dist/tf.min.js
var require_tf_min = __commonJS({
  "node_modules/@tensorflow/tfjs/dist/tf.min.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).tf = e.tf || {});
    }(exports, function(e) {
      "use strict";
      function t(e10, t10) {
        return t10.forEach(function(t11) {
          t11 && "string" != typeof t11 && !Array.isArray(t11) && Object.keys(t11).forEach(function(n10) {
            if ("default" !== n10 && !(n10 in e10)) {
              var r10 = Object.getOwnPropertyDescriptor(t11, n10);
              Object.defineProperty(e10, n10, r10.get ? r10 : { enumerable: true, get: function() {
                return t11[n10];
              } });
            }
          });
        }), e10;
      }
      var n = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
      function r(e10) {
        return e10 && e10.__esModule && Object.prototype.hasOwnProperty.call(e10, "default") ? e10.default : e10;
      }
      function a(e10) {
        var t10, n10;
        function r10(t11, n11) {
          try {
            var o10 = e10[t11](n11), s10 = o10.value, u10 = s10 instanceof i;
            Promise.resolve(u10 ? s10.v : s10).then(function(n12) {
              if (u10) {
                var i10 = "return" === t11 ? "return" : "next";
                if (!s10.k || n12.done) return r10(i10, n12);
                n12 = e10[i10](n12).value;
              }
              a10(o10.done ? "return" : "normal", n12);
            }, function(e11) {
              r10("throw", e11);
            });
          } catch (e11) {
            a10("throw", e11);
          }
        }
        function a10(e11, a11) {
          switch (e11) {
            case "return":
              t10.resolve({ value: a11, done: true });
              break;
            case "throw":
              t10.reject(a11);
              break;
            default:
              t10.resolve({ value: a11, done: false });
          }
          (t10 = t10.next) ? r10(t10.key, t10.arg) : n10 = null;
        }
        this._invoke = function(e11, a11) {
          return new Promise(function(i10, o10) {
            var s10 = { key: e11, arg: a11, resolve: i10, reject: o10, next: null };
            n10 ? n10 = n10.next = s10 : (t10 = n10 = s10, r10(e11, a11));
          });
        }, "function" != typeof e10.return && (this.return = void 0);
      }
      function i(e10, t10) {
        this.v = e10, this.k = t10;
      }
      function o() {
        o = function() {
          return e10;
        };
        var e10 = {}, t10 = Object.prototype, n10 = t10.hasOwnProperty, r10 = Object.defineProperty || function(e11, t11, n11) {
          e11[t11] = n11.value;
        }, a10 = "function" == typeof Symbol ? Symbol : {}, i10 = a10.iterator || "@@iterator", s10 = a10.asyncIterator || "@@asyncIterator", u10 = a10.toStringTag || "@@toStringTag";
        function c10(e11, t11, n11) {
          return Object.defineProperty(e11, t11, { value: n11, enumerable: true, configurable: true, writable: true }), e11[t11];
        }
        try {
          c10({}, "");
        } catch (e11) {
          c10 = function(e12, t11, n11) {
            return e12[t11] = n11;
          };
        }
        function l10(e11, t11, n11, a11) {
          var i11 = t11 && t11.prototype instanceof f10 ? t11 : f10, o10 = Object.create(i11.prototype), s11 = new T10(a11 || []);
          return r10(o10, "_invoke", { value: w10(e11, n11, s11) }), o10;
        }
        function h10(e11, t11, n11) {
          try {
            return { type: "normal", arg: e11.call(t11, n11) };
          } catch (e12) {
            return { type: "throw", arg: e12 };
          }
        }
        e10.wrap = l10;
        var p10 = {};
        function f10() {
        }
        function d10() {
        }
        function v10() {
        }
        var m10 = {};
        c10(m10, i10, function() {
          return this;
        });
        var g10 = Object.getPrototypeOf, y10 = g10 && g10(g10(E10([])));
        y10 && y10 !== t10 && n10.call(y10, i10) && (m10 = y10);
        var b10 = v10.prototype = f10.prototype = Object.create(m10);
        function x10(e11) {
          ["next", "throw", "return"].forEach(function(t11) {
            c10(e11, t11, function(e12) {
              return this._invoke(t11, e12);
            });
          });
        }
        function k10(e11, t11) {
          function a11(r11, i12, o10, s11) {
            var u11 = h10(e11[r11], e11, i12);
            if ("throw" !== u11.type) {
              var c11 = u11.arg, l11 = c11.value;
              return l11 && "object" == typeof l11 && n10.call(l11, "__await") ? t11.resolve(l11.__await).then(function(e12) {
                a11("next", e12, o10, s11);
              }, function(e12) {
                a11("throw", e12, o10, s11);
              }) : t11.resolve(l11).then(function(e12) {
                c11.value = e12, o10(c11);
              }, function(e12) {
                return a11("throw", e12, o10, s11);
              });
            }
            s11(u11.arg);
          }
          var i11;
          r10(this, "_invoke", { value: function(e12, n11) {
            function r11() {
              return new t11(function(t12, r12) {
                a11(e12, n11, t12, r12);
              });
            }
            return i11 = i11 ? i11.then(r11, r11) : r11();
          } });
        }
        function w10(e11, t11, n11) {
          var r11 = "suspendedStart";
          return function(a11, i11) {
            if ("executing" === r11) throw new Error("Generator is already running");
            if ("completed" === r11) {
              if ("throw" === a11) throw i11;
              return C10();
            }
            for (n11.method = a11, n11.arg = i11; ; ) {
              var o10 = n11.delegate;
              if (o10) {
                var s11 = I10(o10, n11);
                if (s11) {
                  if (s11 === p10) continue;
                  return s11;
                }
              }
              if ("next" === n11.method) n11.sent = n11._sent = n11.arg;
              else if ("throw" === n11.method) {
                if ("suspendedStart" === r11) throw r11 = "completed", n11.arg;
                n11.dispatchException(n11.arg);
              } else "return" === n11.method && n11.abrupt("return", n11.arg);
              r11 = "executing";
              var u11 = h10(e11, t11, n11);
              if ("normal" === u11.type) {
                if (r11 = n11.done ? "completed" : "suspendedYield", u11.arg === p10) continue;
                return { value: u11.arg, done: n11.done };
              }
              "throw" === u11.type && (r11 = "completed", n11.method = "throw", n11.arg = u11.arg);
            }
          };
        }
        function I10(e11, t11) {
          var n11 = t11.method, r11 = e11.iterator[n11];
          if (void 0 === r11) return t11.delegate = null, "throw" === n11 && e11.iterator.return && (t11.method = "return", t11.arg = void 0, I10(e11, t11), "throw" === t11.method) || "return" !== n11 && (t11.method = "throw", t11.arg = new TypeError("The iterator does not provide a '" + n11 + "' method")), p10;
          var a11 = h10(r11, e11.iterator, t11.arg);
          if ("throw" === a11.type) return t11.method = "throw", t11.arg = a11.arg, t11.delegate = null, p10;
          var i11 = a11.arg;
          return i11 ? i11.done ? (t11[e11.resultName] = i11.value, t11.next = e11.nextLoc, "return" !== t11.method && (t11.method = "next", t11.arg = void 0), t11.delegate = null, p10) : i11 : (t11.method = "throw", t11.arg = new TypeError("iterator result is not an object"), t11.delegate = null, p10);
        }
        function N10(e11) {
          var t11 = { tryLoc: e11[0] };
          1 in e11 && (t11.catchLoc = e11[1]), 2 in e11 && (t11.finallyLoc = e11[2], t11.afterLoc = e11[3]), this.tryEntries.push(t11);
        }
        function S10(e11) {
          var t11 = e11.completion || {};
          t11.type = "normal", delete t11.arg, e11.completion = t11;
        }
        function T10(e11) {
          this.tryEntries = [{ tryLoc: "root" }], e11.forEach(N10, this), this.reset(true);
        }
        function E10(e11) {
          if (e11) {
            var t11 = e11[i10];
            if (t11) return t11.call(e11);
            if ("function" == typeof e11.next) return e11;
            if (!isNaN(e11.length)) {
              var r11 = -1, a11 = function t12() {
                for (; ++r11 < e11.length; ) if (n10.call(e11, r11)) return t12.value = e11[r11], t12.done = false, t12;
                return t12.value = void 0, t12.done = true, t12;
              };
              return a11.next = a11;
            }
          }
          return { next: C10 };
        }
        function C10() {
          return { value: void 0, done: true };
        }
        return d10.prototype = v10, r10(b10, "constructor", { value: v10, configurable: true }), r10(v10, "constructor", { value: d10, configurable: true }), d10.displayName = c10(v10, u10, "GeneratorFunction"), e10.isGeneratorFunction = function(e11) {
          var t11 = "function" == typeof e11 && e11.constructor;
          return !!t11 && (t11 === d10 || "GeneratorFunction" === (t11.displayName || t11.name));
        }, e10.mark = function(e11) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(e11, v10) : (e11.__proto__ = v10, c10(e11, u10, "GeneratorFunction")), e11.prototype = Object.create(b10), e11;
        }, e10.awrap = function(e11) {
          return { __await: e11 };
        }, x10(k10.prototype), c10(k10.prototype, s10, function() {
          return this;
        }), e10.AsyncIterator = k10, e10.async = function(t11, n11, r11, a11, i11) {
          void 0 === i11 && (i11 = Promise);
          var o10 = new k10(l10(t11, n11, r11, a11), i11);
          return e10.isGeneratorFunction(n11) ? o10 : o10.next().then(function(e11) {
            return e11.done ? e11.value : o10.next();
          });
        }, x10(b10), c10(b10, u10, "Generator"), c10(b10, i10, function() {
          return this;
        }), c10(b10, "toString", function() {
          return "[object Generator]";
        }), e10.keys = function(e11) {
          var t11 = Object(e11), n11 = [];
          for (var r11 in t11) n11.push(r11);
          return n11.reverse(), function e12() {
            for (; n11.length; ) {
              var r12 = n11.pop();
              if (r12 in t11) return e12.value = r12, e12.done = false, e12;
            }
            return e12.done = true, e12;
          };
        }, e10.values = E10, T10.prototype = { constructor: T10, reset: function(e11) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(S10), !e11) for (var t11 in this) "t" === t11.charAt(0) && n10.call(this, t11) && !isNaN(+t11.slice(1)) && (this[t11] = void 0);
        }, stop: function() {
          this.done = true;
          var e11 = this.tryEntries[0].completion;
          if ("throw" === e11.type) throw e11.arg;
          return this.rval;
        }, dispatchException: function(e11) {
          if (this.done) throw e11;
          var t11 = this;
          function r11(n11, r12) {
            return o10.type = "throw", o10.arg = e11, t11.next = n11, r12 && (t11.method = "next", t11.arg = void 0), !!r12;
          }
          for (var a11 = this.tryEntries.length - 1; a11 >= 0; --a11) {
            var i11 = this.tryEntries[a11], o10 = i11.completion;
            if ("root" === i11.tryLoc) return r11("end");
            if (i11.tryLoc <= this.prev) {
              var s11 = n10.call(i11, "catchLoc"), u11 = n10.call(i11, "finallyLoc");
              if (s11 && u11) {
                if (this.prev < i11.catchLoc) return r11(i11.catchLoc, true);
                if (this.prev < i11.finallyLoc) return r11(i11.finallyLoc);
              } else if (s11) {
                if (this.prev < i11.catchLoc) return r11(i11.catchLoc, true);
              } else {
                if (!u11) throw new Error("try statement without catch or finally");
                if (this.prev < i11.finallyLoc) return r11(i11.finallyLoc);
              }
            }
          }
        }, abrupt: function(e11, t11) {
          for (var r11 = this.tryEntries.length - 1; r11 >= 0; --r11) {
            var a11 = this.tryEntries[r11];
            if (a11.tryLoc <= this.prev && n10.call(a11, "finallyLoc") && this.prev < a11.finallyLoc) {
              var i11 = a11;
              break;
            }
          }
          i11 && ("break" === e11 || "continue" === e11) && i11.tryLoc <= t11 && t11 <= i11.finallyLoc && (i11 = null);
          var o10 = i11 ? i11.completion : {};
          return o10.type = e11, o10.arg = t11, i11 ? (this.method = "next", this.next = i11.finallyLoc, p10) : this.complete(o10);
        }, complete: function(e11, t11) {
          if ("throw" === e11.type) throw e11.arg;
          return "break" === e11.type || "continue" === e11.type ? this.next = e11.arg : "return" === e11.type ? (this.rval = this.arg = e11.arg, this.method = "return", this.next = "end") : "normal" === e11.type && t11 && (this.next = t11), p10;
        }, finish: function(e11) {
          for (var t11 = this.tryEntries.length - 1; t11 >= 0; --t11) {
            var n11 = this.tryEntries[t11];
            if (n11.finallyLoc === e11) return this.complete(n11.completion, n11.afterLoc), S10(n11), p10;
          }
        }, catch: function(e11) {
          for (var t11 = this.tryEntries.length - 1; t11 >= 0; --t11) {
            var n11 = this.tryEntries[t11];
            if (n11.tryLoc === e11) {
              var r11 = n11.completion;
              if ("throw" === r11.type) {
                var a11 = r11.arg;
                S10(n11);
              }
              return a11;
            }
          }
          throw new Error("illegal catch attempt");
        }, delegateYield: function(e11, t11, n11) {
          return this.delegate = { iterator: E10(e11), resultName: t11, nextLoc: n11 }, "next" === this.method && (this.arg = void 0), p10;
        } }, e10;
      }
      function s(e10) {
        return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e11) {
          return typeof e11;
        } : function(e11) {
          return e11 && "function" == typeof Symbol && e11.constructor === Symbol && e11 !== Symbol.prototype ? "symbol" : typeof e11;
        }, s(e10);
      }
      function u(e10, t10, n10, r10, a10, i10, o10) {
        try {
          var s10 = e10[i10](o10), u10 = s10.value;
        } catch (e11) {
          return void n10(e11);
        }
        s10.done ? t10(u10) : Promise.resolve(u10).then(r10, a10);
      }
      function c(e10) {
        return function() {
          var t10 = this, n10 = arguments;
          return new Promise(function(r10, a10) {
            var i10 = e10.apply(t10, n10);
            function o10(e11) {
              u(i10, r10, a10, o10, s10, "next", e11);
            }
            function s10(e11) {
              u(i10, r10, a10, o10, s10, "throw", e11);
            }
            o10(void 0);
          });
        };
      }
      function l(e10, t10) {
        if (!(e10 instanceof t10)) throw new TypeError("Cannot call a class as a function");
      }
      function h(e10, t10) {
        for (var n10 = 0; n10 < t10.length; n10++) {
          var r10 = t10[n10];
          r10.enumerable = r10.enumerable || false, r10.configurable = true, "value" in r10 && (r10.writable = true), Object.defineProperty(e10, F(r10.key), r10);
        }
      }
      function p(e10, t10, n10) {
        return t10 && h(e10.prototype, t10), n10 && h(e10, n10), Object.defineProperty(e10, "prototype", { writable: false }), e10;
      }
      function f(e10, t10, n10) {
        return (t10 = F(t10)) in e10 ? Object.defineProperty(e10, t10, { value: n10, enumerable: true, configurable: true, writable: true }) : e10[t10] = n10, e10;
      }
      function d(e10, t10) {
        if ("function" != typeof t10 && null !== t10) throw new TypeError("Super expression must either be null or a function");
        e10.prototype = Object.create(t10 && t10.prototype, { constructor: { value: e10, writable: true, configurable: true } }), Object.defineProperty(e10, "prototype", { writable: false }), t10 && m(e10, t10);
      }
      function v(e10) {
        return v = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e11) {
          return e11.__proto__ || Object.getPrototypeOf(e11);
        }, v(e10);
      }
      function m(e10, t10) {
        return m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e11, t11) {
          return e11.__proto__ = t11, e11;
        }, m(e10, t10);
      }
      function g() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if ("function" == typeof Proxy) return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (e10) {
          return false;
        }
      }
      function y(e10, t10, n10) {
        return y = g() ? Reflect.construct.bind() : function(e11, t11, n11) {
          var r10 = [null];
          r10.push.apply(r10, t11);
          var a10 = new (Function.bind.apply(e11, r10))();
          return n11 && m(a10, n11.prototype), a10;
        }, y.apply(null, arguments);
      }
      function b(e10) {
        var t10 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return b = function(e11) {
          if (null === e11 || (n10 = e11, -1 === Function.toString.call(n10).indexOf("[native code]"))) return e11;
          var n10;
          if ("function" != typeof e11) throw new TypeError("Super expression must either be null or a function");
          if (void 0 !== t10) {
            if (t10.has(e11)) return t10.get(e11);
            t10.set(e11, r10);
          }
          function r10() {
            return y(e11, arguments, v(this).constructor);
          }
          return r10.prototype = Object.create(e11.prototype, { constructor: { value: r10, enumerable: false, writable: true, configurable: true } }), m(r10, e11);
        }, b(e10);
      }
      function x(e10) {
        if (void 0 === e10) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e10;
      }
      function k(e10, t10) {
        if (t10 && ("object" == typeof t10 || "function" == typeof t10)) return t10;
        if (void 0 !== t10) throw new TypeError("Derived constructors may only return object or undefined");
        return x(e10);
      }
      function w(e10) {
        var t10 = g();
        return function() {
          var n10, r10 = v(e10);
          if (t10) {
            var a10 = v(this).constructor;
            n10 = Reflect.construct(r10, arguments, a10);
          } else n10 = r10.apply(this, arguments);
          return k(this, n10);
        };
      }
      function I(e10, t10) {
        for (; !Object.prototype.hasOwnProperty.call(e10, t10) && null !== (e10 = v(e10)); ) ;
        return e10;
      }
      function N() {
        return N = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e10, t10, n10) {
          var r10 = I(e10, t10);
          if (r10) {
            var a10 = Object.getOwnPropertyDescriptor(r10, t10);
            return a10.get ? a10.get.call(arguments.length < 3 ? e10 : n10) : a10.value;
          }
        }, N.apply(this, arguments);
      }
      function S(e10, t10) {
        return E(e10) || function(e11, t11) {
          var n10 = null == e11 ? null : "undefined" != typeof Symbol && e11[Symbol.iterator] || e11["@@iterator"];
          if (null != n10) {
            var r10, a10, i10, o10, s10 = [], u10 = true, c10 = false;
            try {
              if (i10 = (n10 = n10.call(e11)).next, 0 === t11) {
                if (Object(n10) !== n10) return;
                u10 = false;
              } else for (; !(u10 = (r10 = i10.call(n10)).done) && (s10.push(r10.value), s10.length !== t11); u10 = true) ;
            } catch (e12) {
              c10 = true, a10 = e12;
            } finally {
              try {
                if (!u10 && null != n10.return && (o10 = n10.return(), Object(o10) !== o10)) return;
              } finally {
                if (c10) throw a10;
              }
            }
            return s10;
          }
        }(e10, t10) || A(e10, t10) || _();
      }
      function T(e10) {
        return function(e11) {
          if (Array.isArray(e11)) return R(e11);
        }(e10) || C(e10) || A(e10) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function E(e10) {
        if (Array.isArray(e10)) return e10;
      }
      function C(e10) {
        if ("undefined" != typeof Symbol && null != e10[Symbol.iterator] || null != e10["@@iterator"]) return Array.from(e10);
      }
      function A(e10, t10) {
        if (e10) {
          if ("string" == typeof e10) return R(e10, t10);
          var n10 = Object.prototype.toString.call(e10).slice(8, -1);
          return "Object" === n10 && e10.constructor && (n10 = e10.constructor.name), "Map" === n10 || "Set" === n10 ? Array.from(e10) : "Arguments" === n10 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n10) ? R(e10, t10) : void 0;
        }
      }
      function R(e10, t10) {
        (null == t10 || t10 > e10.length) && (t10 = e10.length);
        for (var n10 = 0, r10 = new Array(t10); n10 < t10; n10++) r10[n10] = e10[n10];
        return r10;
      }
      function _() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function O(e10, t10) {
        var n10 = "undefined" != typeof Symbol && e10[Symbol.iterator] || e10["@@iterator"];
        if (!n10) {
          if (Array.isArray(e10) || (n10 = A(e10)) || t10 && e10 && "number" == typeof e10.length) {
            n10 && (e10 = n10);
            var r10 = 0, a10 = function() {
            };
            return { s: a10, n: function() {
              return r10 >= e10.length ? { done: true } : { done: false, value: e10[r10++] };
            }, e: function(e11) {
              throw e11;
            }, f: a10 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var i10, o10 = true, s10 = false;
        return { s: function() {
          n10 = n10.call(e10);
        }, n: function() {
          var e11 = n10.next();
          return o10 = e11.done, e11;
        }, e: function(e11) {
          s10 = true, i10 = e11;
        }, f: function() {
          try {
            o10 || null == n10.return || n10.return();
          } finally {
            if (s10) throw i10;
          }
        } };
      }
      function F(e10) {
        var t10 = function(e11, t11) {
          if ("object" != typeof e11 || null === e11) return e11;
          var n10 = e11[Symbol.toPrimitive];
          if (void 0 !== n10) {
            var r10 = n10.call(e11, t11 || "default");
            if ("object" != typeof r10) return r10;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === t11 ? String : Number)(e11);
        }(e10, "string");
        return "symbol" == typeof t10 ? t10 : String(t10);
      }
      a.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
        return this;
      }, a.prototype.next = function(e10) {
        return this._invoke("next", e10);
      }, a.prototype.throw = function(e10) {
        return this._invoke("throw", e10);
      }, a.prototype.return = function(e10) {
        return this._invoke("return", e10);
      };
      var D, M, L = function(e10) {
        return e10 && e10.Math == Math && e10;
      }, z = L("object" == ("undefined" == typeof globalThis ? "undefined" : s(globalThis)) && globalThis) || L("object" == ("undefined" == typeof window ? "undefined" : s(window)) && window) || L("object" == ("undefined" == typeof self ? "undefined" : s(self)) && self) || L("object" == s(n) && n) || /* @__PURE__ */ function() {
        return this;
      }() || Function("return this")(), P = {}, B = function(e10) {
        try {
          return !!e10();
        } catch (e11) {
          return true;
        }
      }, W = !B(function() {
        return 7 != Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1];
      }), U = !B(function() {
        var e10 = (function() {
        }).bind();
        return "function" != typeof e10 || e10.hasOwnProperty("prototype");
      }), V = U, G = Function.prototype.call, j = V ? G.bind(G) : function() {
        return G.apply(G, arguments);
      }, H = {}, q = {}.propertyIsEnumerable, K = Object.getOwnPropertyDescriptor, X = K && !q.call({ 1: 2 }, 1), Y = (H.f = X ? function(e10) {
        var t10 = K(this, e10);
        return !!t10 && t10.enumerable;
      } : q, function(e10, t10) {
        return { enumerable: !(1 & e10), configurable: !(2 & e10), writable: !(4 & e10), value: t10 };
      }), J = U, Z = Function.prototype, Q = Z.call, $ = J && Z.bind.bind(Q, Q), ee = J ? $ : function(e10) {
        return function() {
          return Q.apply(e10, arguments);
        };
      }, te = ee, ne = te({}.toString), re = te("".slice), ae = function(e10) {
        return re(ne(e10), 8, -1);
      }, ie = B, oe = ae, se = Object, ue = ee("".split), ce = ie(function() {
        return !se("z").propertyIsEnumerable(0);
      }) ? function(e10) {
        return "String" == oe(e10) ? ue(e10, "") : se(e10);
      } : se, le = function(e10) {
        return null == e10;
      }, he = le, pe = TypeError, fe = function(e10) {
        if (he(e10)) throw pe("Can't call method on " + e10);
        return e10;
      }, de = ce, ve = fe, me = function(e10) {
        return de(ve(e10));
      }, ge = "object" == ("undefined" == typeof document ? "undefined" : s(document)) && document.all, ye = { all: ge, IS_HTMLDDA: void 0 === ge && void 0 !== ge }, be = ye.all, xe = ye.IS_HTMLDDA ? function(e10) {
        return "function" == typeof e10 || e10 === be;
      } : function(e10) {
        return "function" == typeof e10;
      }, ke = xe, we = ye.all, Ie = ye.IS_HTMLDDA ? function(e10) {
        return "object" == s(e10) ? null !== e10 : ke(e10) || e10 === we;
      } : function(e10) {
        return "object" == s(e10) ? null !== e10 : ke(e10);
      }, Ne = z, Se = xe, Te = function(e10) {
        return Se(e10) ? e10 : void 0;
      }, Ee = function(e10, t10) {
        return arguments.length < 2 ? Te(Ne[e10]) : Ne[e10] && Ne[e10][t10];
      }, Ce = ee({}.isPrototypeOf), Ae = "undefined" != typeof navigator && String(navigator.userAgent) || "", Re = z, _e = Ae, Oe = Re.process, Fe = Re.Deno, De = Oe && Oe.versions || Fe && Fe.version, Me = De && De.v8;
      Me && (M = (D = Me.split("."))[0] > 0 && D[0] < 4 ? 1 : +(D[0] + D[1])), !M && _e && (!(D = _e.match(/Edge\/(\d+)/)) || D[1] >= 74) && (D = _e.match(/Chrome\/(\d+)/)) && (M = +D[1]);
      var Le = M, ze = Le, Pe = B, Be = !!Object.getOwnPropertySymbols && !Pe(function() {
        var e10 = Symbol();
        return !String(e10) || !(Object(e10) instanceof Symbol) || !Symbol.sham && ze && ze < 41;
      }), We = Be && !Symbol.sham && "symbol" == s(Symbol.iterator), Ue = Ee, Ve = xe, Ge = Ce, je = Object, He = We ? function(e10) {
        return "symbol" == s(e10);
      } : function(e10) {
        var t10 = Ue("Symbol");
        return Ve(t10) && Ge(t10.prototype, je(e10));
      }, qe = String, Ke = function(e10) {
        try {
          return qe(e10);
        } catch (e11) {
          return "Object";
        }
      }, Xe = xe, Ye = Ke, Je = TypeError, Ze = function(e10) {
        if (Xe(e10)) return e10;
        throw Je(Ye(e10) + " is not a function");
      }, Qe = Ze, $e = le, et = function(e10, t10) {
        var n10 = e10[t10];
        return $e(n10) ? void 0 : Qe(n10);
      }, tt = j, nt = xe, rt = Ie, at = TypeError, it = function(e10, t10) {
        var n10, r10;
        if ("string" === t10 && nt(n10 = e10.toString) && !rt(r10 = tt(n10, e10))) return r10;
        if (nt(n10 = e10.valueOf) && !rt(r10 = tt(n10, e10))) return r10;
        if ("string" !== t10 && nt(n10 = e10.toString) && !rt(r10 = tt(n10, e10))) return r10;
        throw at("Can't convert object to primitive value");
      }, ot = { exports: {} }, st = false, ut = z, ct = Object.defineProperty, lt = function(e10, t10) {
        try {
          ct(ut, e10, { value: t10, configurable: true, writable: true });
        } catch (n10) {
          ut[e10] = t10;
        }
        return t10;
      }, ht = lt, pt = "__core-js_shared__", ft = z[pt] || ht(pt, {}), dt = (ot.exports, ft);
      (ot.exports = function(e10, t10) {
        return dt[e10] || (dt[e10] = void 0 !== t10 ? t10 : {});
      })("versions", []).push({ version: "3.29.1", mode: "global", copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.29.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      var vt = ot.exports, mt = fe, gt = Object, yt = function(e10) {
        return gt(mt(e10));
      }, bt = yt, xt = ee({}.hasOwnProperty), kt = Object.hasOwn || function(e10, t10) {
        return xt(bt(e10), t10);
      }, wt = ee, It = 0, Nt = Math.random(), St = wt(1 .toString), Tt = function(e10) {
        return "Symbol(" + (void 0 === e10 ? "" : e10) + ")_" + St(++It + Nt, 36);
      }, Et = vt, Ct = kt, At = Tt, Rt = Be, _t = We, Ot = z.Symbol, Ft = Et("wks"), Dt = _t ? Ot.for || Ot : Ot && Ot.withoutSetter || At, Mt = function(e10) {
        return Ct(Ft, e10) || (Ft[e10] = Rt && Ct(Ot, e10) ? Ot[e10] : Dt("Symbol." + e10)), Ft[e10];
      }, Lt = j, zt = Ie, Pt = He, Bt = et, Wt = it, Ut = TypeError, Vt = Mt("toPrimitive"), Gt = function(e10, t10) {
        if (!zt(e10) || Pt(e10)) return e10;
        var n10, r10 = Bt(e10, Vt);
        if (r10) {
          if (void 0 === t10 && (t10 = "default"), n10 = Lt(r10, e10, t10), !zt(n10) || Pt(n10)) return n10;
          throw Ut("Can't convert object to primitive value");
        }
        return void 0 === t10 && (t10 = "number"), Wt(e10, t10);
      }, jt = Gt, Ht = He, qt = function(e10) {
        var t10 = jt(e10, "string");
        return Ht(t10) ? t10 : t10 + "";
      }, Kt = Ie, Xt = z.document, Yt = Kt(Xt) && Kt(Xt.createElement), Jt = function(e10) {
        return Yt ? Xt.createElement(e10) : {};
      }, Zt = Jt, Qt = !W && !B(function() {
        return 7 != Object.defineProperty(Zt("div"), "a", { get: function() {
          return 7;
        } }).a;
      }), $t = W, en = j, tn = H, nn = Y, rn = me, an = qt, on = kt, sn = Qt, un = Object.getOwnPropertyDescriptor, cn = (P.f = $t ? un : function(e10, t10) {
        if (e10 = rn(e10), t10 = an(t10), sn) try {
          return un(e10, t10);
        } catch (e11) {
        }
        if (on(e10, t10)) return nn(!en(tn.f, e10, t10), e10[t10]);
      }, {}), ln = W && B(function() {
        return 42 != Object.defineProperty(function() {
        }, "prototype", { value: 42, writable: false }).prototype;
      }), hn = Ie, pn = String, fn = TypeError, dn = function(e10) {
        if (hn(e10)) return e10;
        throw fn(pn(e10) + " is not an object");
      }, vn = W, mn = Qt, gn = ln, yn = dn, bn = qt, xn = TypeError, kn = Object.defineProperty, wn = Object.getOwnPropertyDescriptor, In = "enumerable", Nn = "configurable", Sn = "writable", Tn = (cn.f = vn ? gn ? function(e10, t10, n10) {
        if (yn(e10), t10 = bn(t10), yn(n10), "function" == typeof e10 && "prototype" === t10 && "value" in n10 && Sn in n10 && !n10.writable) {
          var r10 = wn(e10, t10);
          r10 && r10.writable && (e10[t10] = n10.value, n10 = { configurable: Nn in n10 ? n10.configurable : r10.configurable, enumerable: In in n10 ? n10.enumerable : r10.enumerable, writable: false });
        }
        return kn(e10, t10, n10);
      } : kn : function(e10, t10, n10) {
        if (yn(e10), t10 = bn(t10), yn(n10), mn) try {
          return kn(e10, t10, n10);
        } catch (e11) {
        }
        if ("get" in n10 || "set" in n10) throw xn("Accessors not supported");
        return "value" in n10 && (e10[t10] = n10.value), e10;
      }, cn), En = Y, Cn = W ? function(e10, t10, n10) {
        return Tn.f(e10, t10, En(1, n10));
      } : function(e10, t10, n10) {
        return e10[t10] = n10, e10;
      }, An = { exports: {} }, Rn = W, _n = kt, On = Function.prototype, Fn = Rn && Object.getOwnPropertyDescriptor, Dn = _n(On, "name"), Mn = { EXISTS: Dn, PROPER: Dn && "something" === (function() {
      }).name, CONFIGURABLE: Dn && (!Rn || Rn && Fn(On, "name").configurable) }, Ln = xe, zn = ft, Pn = ee(Function.toString);
      Ln(zn.inspectSource) || (zn.inspectSource = function(e10) {
        return Pn(e10);
      });
      var Bn, Wn, Un, Vn = zn.inspectSource, Gn = xe, jn = z.WeakMap, Hn = Gn(jn) && /native code/.test(String(jn)), qn = Tt, Kn = vt("keys"), Xn = function(e10) {
        return Kn[e10] || (Kn[e10] = qn(e10));
      }, Yn = {}, Jn = Hn, Zn = z, Qn = Ie, $n = Cn, er = kt, tr = ft, nr = Xn, rr = Yn, ar = "Object already initialized", ir = Zn.TypeError, or = Zn.WeakMap;
      if (Jn || tr.state) {
        var sr = tr.state || (tr.state = new or());
        sr.get = sr.get, sr.has = sr.has, sr.set = sr.set, Bn = function(e10, t10) {
          if (sr.has(e10)) throw ir(ar);
          return t10.facade = e10, sr.set(e10, t10), t10;
        }, Wn = function(e10) {
          return sr.get(e10) || {};
        }, Un = function(e10) {
          return sr.has(e10);
        };
      } else {
        var ur = nr("state");
        rr[ur] = true, Bn = function(e10, t10) {
          if (er(e10, ur)) throw ir(ar);
          return t10.facade = e10, $n(e10, ur, t10), t10;
        }, Wn = function(e10) {
          return er(e10, ur) ? e10[ur] : {};
        }, Un = function(e10) {
          return er(e10, ur);
        };
      }
      var cr = { set: Bn, get: Wn, has: Un, enforce: function(e10) {
        return Un(e10) ? Wn(e10) : Bn(e10, {});
      }, getterFor: function(e10) {
        return function(t10) {
          var n10;
          if (!Qn(t10) || (n10 = Wn(t10)).type !== e10) throw ir("Incompatible receiver, " + e10 + " required");
          return n10;
        };
      } }, lr = (An.exports, ee), hr = B, pr = xe, fr = kt, dr = W, vr = Mn.CONFIGURABLE, mr = Vn, gr = cr.enforce, yr = cr.get, br = String, xr = Object.defineProperty, kr = lr("".slice), wr = lr("".replace), Ir = lr([].join), Nr = dr && !hr(function() {
        return 8 !== xr(function() {
        }, "length", { value: 8 }).length;
      }), Sr = String(String).split("String"), Tr = An.exports = function(e10, t10, n10) {
        "Symbol(" === kr(br(t10), 0, 7) && (t10 = "[" + wr(br(t10), /^Symbol\(([^)]*)\)/, "$1") + "]"), n10 && n10.getter && (t10 = "get " + t10), n10 && n10.setter && (t10 = "set " + t10), (!fr(e10, "name") || vr && e10.name !== t10) && (dr ? xr(e10, "name", { value: t10, configurable: true }) : e10.name = t10), Nr && n10 && fr(n10, "arity") && e10.length !== n10.arity && xr(e10, "length", { value: n10.arity });
        try {
          n10 && fr(n10, "constructor") && n10.constructor ? dr && xr(e10, "prototype", { writable: false }) : e10.prototype && (e10.prototype = void 0);
        } catch (e11) {
        }
        var r10 = gr(e10);
        return fr(r10, "source") || (r10.source = Ir(Sr, "string" == typeof t10 ? t10 : "")), e10;
      };
      Function.prototype.toString = Tr(function() {
        return pr(this) && yr(this).source || mr(this);
      }, "toString");
      var Er = An.exports, Cr = xe, Ar = cn, Rr = Er, _r = lt, Or = function(e10, t10, n10, r10) {
        r10 || (r10 = {});
        var a10 = r10.enumerable, i10 = void 0 !== r10.name ? r10.name : t10;
        if (Cr(n10) && Rr(n10, i10, r10), r10.global) a10 ? e10[t10] = n10 : _r(t10, n10);
        else {
          try {
            r10.unsafe ? e10[t10] && (a10 = true) : delete e10[t10];
          } catch (e11) {
          }
          a10 ? e10[t10] = n10 : Ar.f(e10, t10, { value: n10, enumerable: false, configurable: !r10.nonConfigurable, writable: !r10.nonWritable });
        }
        return e10;
      }, Fr = {}, Dr = Math.ceil, Mr = Math.floor, Lr = Math.trunc || function(e10) {
        var t10 = +e10;
        return (t10 > 0 ? Mr : Dr)(t10);
      }, zr = Lr, Pr = function(e10) {
        var t10 = +e10;
        return t10 != t10 || 0 === t10 ? 0 : zr(t10);
      }, Br = Pr, Wr = Math.max, Ur = Math.min, Vr = function(e10, t10) {
        var n10 = Br(e10);
        return n10 < 0 ? Wr(n10 + t10, 0) : Ur(n10, t10);
      }, Gr = Pr, jr = Math.min, Hr = function(e10) {
        return e10 > 0 ? jr(Gr(e10), 9007199254740991) : 0;
      }, qr = Hr, Kr = function(e10) {
        return qr(e10.length);
      }, Xr = me, Yr = Vr, Jr = Kr, Zr = function(e10) {
        return function(t10, n10, r10) {
          var a10, i10 = Xr(t10), o10 = Jr(i10), s10 = Yr(r10, o10);
          if (e10 && n10 != n10) {
            for (; o10 > s10; ) if ((a10 = i10[s10++]) != a10) return true;
          } else for (; o10 > s10; s10++) if ((e10 || s10 in i10) && i10[s10] === n10) return e10 || s10 || 0;
          return !e10 && -1;
        };
      }, Qr = { includes: Zr(true), indexOf: Zr(false) }, $r = kt, ea = me, ta = Qr.indexOf, na = Yn, ra = ee([].push), aa = function(e10, t10) {
        var n10, r10 = ea(e10), a10 = 0, i10 = [];
        for (n10 in r10) !$r(na, n10) && $r(r10, n10) && ra(i10, n10);
        for (; t10.length > a10; ) $r(r10, n10 = t10[a10++]) && (~ta(i10, n10) || ra(i10, n10));
        return i10;
      }, ia = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], oa = aa, sa = ia.concat("length", "prototype"), ua = (Fr.f = Object.getOwnPropertyNames || function(e10) {
        return oa(e10, sa);
      }, {}), ca = (ua.f = Object.getOwnPropertySymbols, Ee), la = Fr, ha = ua, pa = dn, fa = ee([].concat), da = ca("Reflect", "ownKeys") || function(e10) {
        var t10 = la.f(pa(e10)), n10 = ha.f;
        return n10 ? fa(t10, n10(e10)) : t10;
      }, va = kt, ma = da, ga = P, ya = cn, ba = function(e10, t10, n10) {
        for (var r10 = ma(t10), a10 = ya.f, i10 = ga.f, o10 = 0; o10 < r10.length; o10++) {
          var s10 = r10[o10];
          va(e10, s10) || n10 && va(n10, s10) || a10(e10, s10, i10(t10, s10));
        }
      }, xa = B, ka = xe, wa = /#|\.prototype\./, Ia = function(e10, t10) {
        var n10 = Sa[Na(e10)];
        return n10 == Ea || n10 != Ta && (ka(t10) ? xa(t10) : !!t10);
      }, Na = Ia.normalize = function(e10) {
        return String(e10).replace(wa, ".").toLowerCase();
      }, Sa = Ia.data = {}, Ta = Ia.NATIVE = "N", Ea = Ia.POLYFILL = "P", Ca = Ia, Aa = z, Ra = P.f, _a = Cn, Oa = Or, Fa = lt, Da = ba, Ma = Ca, La = function(e10, t10) {
        var n10, r10, a10, i10, o10, u10 = e10.target, c10 = e10.global, l10 = e10.stat;
        if (n10 = c10 ? Aa : l10 ? Aa[u10] || Fa(u10, {}) : (Aa[u10] || {}).prototype) for (r10 in t10) {
          if (i10 = t10[r10], a10 = e10.dontCallGetSet ? (o10 = Ra(n10, r10)) && o10.value : n10[r10], !Ma(c10 ? r10 : u10 + (l10 ? "." : "#") + r10, e10.forced) && void 0 !== a10) {
            if (s(i10) == s(a10)) continue;
            Da(i10, a10);
          }
          (e10.sham || a10 && a10.sham) && _a(i10, "sham", true), Oa(n10, r10, i10, e10);
        }
      }, za = {};
      za[Mt("toStringTag")] = "z";
      var Pa, Ba = "[object z]" === String(za), Wa = Ba, Ua = xe, Va = ae, Ga = Mt("toStringTag"), ja = Object, Ha = "Arguments" == Va(/* @__PURE__ */ function() {
        return arguments;
      }()), qa = Wa ? Va : function(e10) {
        var t10, n10, r10;
        return void 0 === e10 ? "Undefined" : null === e10 ? "Null" : "string" == typeof (n10 = function(e11, t11) {
          try {
            return e11[t11];
          } catch (e12) {
          }
        }(t10 = ja(e10), Ga)) ? n10 : Ha ? Va(t10) : "Object" == (r10 = Va(t10)) && Ua(t10.callee) ? "Arguments" : r10;
      }, Ka = qa, Xa = String, Ya = function(e10) {
        if ("Symbol" === Ka(e10)) throw TypeError("Cannot convert a Symbol value to a string");
        return Xa(e10);
      }, Ja = {}, Za = aa, Qa = ia, $a = Object.keys || function(e10) {
        return Za(e10, Qa);
      }, ei = W, ti = ln, ni = cn, ri = dn, ai = me, ii = $a, oi = (Ja.f = ei && !ti ? Object.defineProperties : function(e10, t10) {
        ri(e10);
        for (var n10, r10 = ai(t10), a10 = ii(t10), i10 = a10.length, o10 = 0; i10 > o10; ) ni.f(e10, n10 = a10[o10++], r10[n10]);
        return e10;
      }, Ee("document", "documentElement")), si = dn, ui = Ja, ci = ia, li = Yn, hi = oi, pi = Jt, fi = Xn("IE_PROTO"), di = function() {
      }, vi = function(e10) {
        return "<script>" + e10 + "<\/script>";
      }, mi = function(e10) {
        e10.write(vi("")), e10.close();
        var t10 = e10.parentWindow.Object;
        return e10 = null, t10;
      }, gi = function() {
        try {
          Pa = new ActiveXObject("htmlfile");
        } catch (e11) {
        }
        var e10, t10;
        gi = "undefined" != typeof document ? document.domain && Pa ? mi(Pa) : ((t10 = pi("iframe")).style.display = "none", hi.appendChild(t10), t10.src = String("javascript:"), (e10 = t10.contentWindow.document).open(), e10.write(vi("document.F=Object")), e10.close(), e10.F) : mi(Pa);
        for (var n10 = ci.length; n10--; ) delete gi.prototype[ci[n10]];
        return gi();
      };
      li[fi] = true;
      var yi = Object.create || function(e10, t10) {
        var n10;
        return null !== e10 ? (di.prototype = si(e10), n10 = new di(), di.prototype = null, n10[fi] = e10) : n10 = gi(), void 0 === t10 ? n10 : ui.f(n10, t10);
      }, bi = {}, xi = qt, ki = cn, wi = Y, Ii = function(e10, t10, n10) {
        var r10 = xi(t10);
        r10 in e10 ? ki.f(e10, r10, wi(0, n10)) : e10[r10] = n10;
      }, Ni = Vr, Si = Kr, Ti = Ii, Ei = Array, Ci = Math.max, Ai = function(e10, t10, n10) {
        for (var r10 = Si(e10), a10 = Ni(t10, r10), i10 = Ni(void 0 === n10 ? r10 : n10, r10), o10 = Ei(Ci(i10 - a10, 0)), s10 = 0; a10 < i10; a10++, s10++) Ti(o10, s10, e10[a10]);
        return o10.length = s10, o10;
      }, Ri = ae, _i = me, Oi = Fr.f, Fi = Ai, Di = "object" == ("undefined" == typeof window ? "undefined" : s(window)) && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], Mi = (bi.f = function(e10) {
        return Di && "Window" == Ri(e10) ? function(e11) {
          try {
            return Oi(e11);
          } catch (e12) {
            return Fi(Di);
          }
        }(e10) : Oi(_i(e10));
      }, Er), Li = cn, zi = function(e10, t10, n10) {
        return n10.get && Mi(n10.get, t10, { getter: true }), n10.set && Mi(n10.set, t10, { setter: true }), Li.f(e10, t10, n10);
      }, Pi = {}, Bi = Mt, Wi = (Pi.f = Bi, z), Ui = Wi, Vi = kt, Gi = Pi, ji = cn.f, Hi = function(e10) {
        var t10 = Ui.Symbol || (Ui.Symbol = {});
        Vi(t10, e10) || ji(t10, e10, { value: Gi.f(e10) });
      }, qi = j, Ki = Ee, Xi = Mt, Yi = Or, Ji = function() {
        var e10 = Ki("Symbol"), t10 = e10 && e10.prototype, n10 = t10 && t10.valueOf, r10 = Xi("toPrimitive");
        t10 && !t10[r10] && Yi(t10, r10, function(e11) {
          return qi(n10, this);
        }, { arity: 1 });
      }, Zi = cn.f, Qi = kt, $i = Mt("toStringTag"), eo = function(e10, t10, n10) {
        e10 && !n10 && (e10 = e10.prototype), e10 && !Qi(e10, $i) && Zi(e10, $i, { configurable: true, value: t10 });
      }, to = ae, no = ee, ro = function(e10) {
        if ("Function" === to(e10)) return no(e10);
      }, ao = Ze, io = U, oo = ro(ro.bind), so = function(e10, t10) {
        return ao(e10), void 0 === t10 ? e10 : io ? oo(e10, t10) : function() {
          return e10.apply(t10, arguments);
        };
      }, uo = ae, co = Array.isArray || function(e10) {
        return "Array" == uo(e10);
      }, lo = ee, ho = B, po = xe, fo = qa, vo = Vn, mo = function() {
      }, go = [], yo = Ee("Reflect", "construct"), bo = /^\s*(?:class|function)\b/, xo = lo(bo.exec), ko = !bo.exec(mo), wo = function(e10) {
        if (!po(e10)) return false;
        try {
          return yo(mo, go, e10), true;
        } catch (e11) {
          return false;
        }
      }, Io = function(e10) {
        if (!po(e10)) return false;
        switch (fo(e10)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return ko || !!xo(bo, vo(e10));
        } catch (e11) {
          return true;
        }
      };
      Io.sham = true;
      var No = !yo || ho(function() {
        var e10;
        return wo(wo.call) || !wo(Object) || !wo(function() {
          e10 = true;
        }) || e10;
      }) ? Io : wo, So = co, To = No, Eo = Ie, Co = Mt("species"), Ao = Array, Ro = function(e10) {
        var t10;
        return So(e10) && (t10 = e10.constructor, (To(t10) && (t10 === Ao || So(t10.prototype)) || Eo(t10) && null === (t10 = t10[Co])) && (t10 = void 0)), void 0 === t10 ? Ao : t10;
      }, _o = Ro, Oo = function(e10, t10) {
        return new (_o(e10))(0 === t10 ? 0 : t10);
      }, Fo = so, Do = ce, Mo = yt, Lo = Kr, zo = Oo, Po = ee([].push), Bo = function(e10) {
        var t10 = 1 == e10, n10 = 2 == e10, r10 = 3 == e10, a10 = 4 == e10, i10 = 6 == e10, o10 = 7 == e10, s10 = 5 == e10 || i10;
        return function(u10, c10, l10, h10) {
          for (var p10, f10, d10 = Mo(u10), v10 = Do(d10), m10 = Fo(c10, l10), g10 = Lo(v10), y10 = 0, b10 = h10 || zo, x10 = t10 ? b10(u10, g10) : n10 || o10 ? b10(u10, 0) : void 0; g10 > y10; y10++) if ((s10 || y10 in v10) && (f10 = m10(p10 = v10[y10], y10, d10), e10)) if (t10) x10[y10] = f10;
          else if (f10) switch (e10) {
            case 3:
              return true;
            case 5:
              return p10;
            case 6:
              return y10;
            case 2:
              Po(x10, p10);
          }
          else switch (e10) {
            case 4:
              return false;
            case 7:
              Po(x10, p10);
          }
          return i10 ? -1 : r10 || a10 ? a10 : x10;
        };
      }, Wo = { forEach: Bo(0), map: Bo(1), filter: Bo(2), some: Bo(3), every: Bo(4), find: Bo(5), findIndex: Bo(6), filterReject: Bo(7) }, Uo = La, Vo = z, Go = j, jo = ee, Ho = W, qo = Be, Ko = B, Xo = kt, Yo = Ce, Jo = dn, Zo = me, Qo = qt, $o = Ya, es = Y, ts = yi, ns = $a, rs = Fr, as = bi, is = ua, os = P, ss = cn, us = Ja, cs = H, ls = Or, hs = zi, ps = vt, fs = Yn, ds = Tt, vs = Mt, ms = Pi, gs = Hi, ys = Ji, bs = eo, xs = cr, ks = Wo.forEach, ws = Xn("hidden"), Is = "Symbol", Ns = xs.set, Ss = xs.getterFor(Is), Ts = Object.prototype, Es = Vo.Symbol, Cs = Es && Es.prototype, As = Vo.TypeError, Rs = Vo.QObject, _s = os.f, Os = ss.f, Fs = as.f, Ds = cs.f, Ms = jo([].push), Ls = ps("symbols"), zs = ps("op-symbols"), Ps = ps("wks"), Bs = !Rs || !Rs.prototype || !Rs.prototype.findChild, Ws = Ho && Ko(function() {
        return 7 != ts(Os({}, "a", { get: function() {
          return Os(this, "a", { value: 7 }).a;
        } })).a;
      }) ? function(e10, t10, n10) {
        var r10 = _s(Ts, t10);
        r10 && delete Ts[t10], Os(e10, t10, n10), r10 && e10 !== Ts && Os(Ts, t10, r10);
      } : Os, Us = function(e10, t10) {
        var n10 = Ls[e10] = ts(Cs);
        return Ns(n10, { type: Is, tag: e10, description: t10 }), Ho || (n10.description = t10), n10;
      }, Vs = function(e10, t10, n10) {
        e10 === Ts && Vs(zs, t10, n10), Jo(e10);
        var r10 = Qo(t10);
        return Jo(n10), Xo(Ls, r10) ? (n10.enumerable ? (Xo(e10, ws) && e10[ws][r10] && (e10[ws][r10] = false), n10 = ts(n10, { enumerable: es(0, false) })) : (Xo(e10, ws) || Os(e10, ws, es(1, {})), e10[ws][r10] = true), Ws(e10, r10, n10)) : Os(e10, r10, n10);
      }, Gs = function(e10, t10) {
        Jo(e10);
        var n10 = Zo(t10), r10 = ns(n10).concat(Ks(n10));
        return ks(r10, function(t11) {
          Ho && !Go(js, n10, t11) || Vs(e10, t11, n10[t11]);
        }), e10;
      }, js = function(e10) {
        var t10 = Qo(e10), n10 = Go(Ds, this, t10);
        return !(this === Ts && Xo(Ls, t10) && !Xo(zs, t10)) && (!(n10 || !Xo(this, t10) || !Xo(Ls, t10) || Xo(this, ws) && this[ws][t10]) || n10);
      }, Hs = function(e10, t10) {
        var n10 = Zo(e10), r10 = Qo(t10);
        if (n10 !== Ts || !Xo(Ls, r10) || Xo(zs, r10)) {
          var a10 = _s(n10, r10);
          return !a10 || !Xo(Ls, r10) || Xo(n10, ws) && n10[ws][r10] || (a10.enumerable = true), a10;
        }
      }, qs = function(e10) {
        var t10 = Fs(Zo(e10)), n10 = [];
        return ks(t10, function(e11) {
          Xo(Ls, e11) || Xo(fs, e11) || Ms(n10, e11);
        }), n10;
      }, Ks = function(e10) {
        var t10 = e10 === Ts, n10 = Fs(t10 ? zs : Zo(e10)), r10 = [];
        return ks(n10, function(e11) {
          !Xo(Ls, e11) || t10 && !Xo(Ts, e11) || Ms(r10, Ls[e11]);
        }), r10;
      };
      qo || (Es = function() {
        if (Yo(Cs, this)) throw As("Symbol is not a constructor");
        var e10 = arguments.length && void 0 !== arguments[0] ? $o(arguments[0]) : void 0, t10 = ds(e10), n10 = function e11(n11) {
          this === Ts && Go(e11, zs, n11), Xo(this, ws) && Xo(this[ws], t10) && (this[ws][t10] = false), Ws(this, t10, es(1, n11));
        };
        return Ho && Bs && Ws(Ts, t10, { configurable: true, set: n10 }), Us(t10, e10);
      }, ls(Cs = Es.prototype, "toString", function() {
        return Ss(this).tag;
      }), ls(Es, "withoutSetter", function(e10) {
        return Us(ds(e10), e10);
      }), cs.f = js, ss.f = Vs, us.f = Gs, os.f = Hs, rs.f = as.f = qs, is.f = Ks, ms.f = function(e10) {
        return Us(vs(e10), e10);
      }, Ho && (hs(Cs, "description", { configurable: true, get: function() {
        return Ss(this).description;
      } }), ls(Ts, "propertyIsEnumerable", js, { unsafe: true }))), Uo({ global: true, constructor: true, wrap: true, forced: !qo, sham: !qo }, { Symbol: Es }), ks(ns(Ps), function(e10) {
        gs(e10);
      }), Uo({ target: Is, stat: true, forced: !qo }, { useSetter: function() {
        Bs = true;
      }, useSimple: function() {
        Bs = false;
      } }), Uo({ target: "Object", stat: true, forced: !qo, sham: !Ho }, { create: function(e10, t10) {
        return void 0 === t10 ? ts(e10) : Gs(ts(e10), t10);
      }, defineProperty: Vs, defineProperties: Gs, getOwnPropertyDescriptor: Hs }), Uo({ target: "Object", stat: true, forced: !qo }, { getOwnPropertyNames: qs }), ys(), bs(Es, Is), fs[ws] = true;
      var Xs = Be && !!Symbol.for && !!Symbol.keyFor, Ys = La, Js = Ee, Zs = kt, Qs = Ya, $s = vt, eu = Xs, tu = $s("string-to-symbol-registry"), nu = $s("symbol-to-string-registry");
      Ys({ target: "Symbol", stat: true, forced: !eu }, { for: function(e10) {
        var t10 = Qs(e10);
        if (Zs(tu, t10)) return tu[t10];
        var n10 = Js("Symbol")(t10);
        return tu[t10] = n10, nu[n10] = t10, n10;
      } });
      var ru = La, au = kt, iu = He, ou = Ke, su = Xs, uu = vt("symbol-to-string-registry");
      ru({ target: "Symbol", stat: true, forced: !su }, { keyFor: function(e10) {
        if (!iu(e10)) throw TypeError(ou(e10) + " is not a symbol");
        if (au(uu, e10)) return uu[e10];
      } });
      var cu = U, lu = Function.prototype, hu = lu.apply, pu = lu.call, fu = "object" == ("undefined" == typeof Reflect ? "undefined" : s(Reflect)) && Reflect.apply || (cu ? pu.bind(hu) : function() {
        return pu.apply(hu, arguments);
      }), du = ee([].slice), vu = co, mu = xe, gu = ae, yu = Ya, bu = ee([].push), xu = function(e10) {
        if (mu(e10)) return e10;
        if (vu(e10)) {
          for (var t10 = e10.length, n10 = [], r10 = 0; r10 < t10; r10++) {
            var a10 = e10[r10];
            "string" == typeof a10 ? bu(n10, a10) : "number" != typeof a10 && "Number" != gu(a10) && "String" != gu(a10) || bu(n10, yu(a10));
          }
          var i10 = n10.length, o10 = true;
          return function(e11, t11) {
            if (o10) return o10 = false, t11;
            if (vu(this)) return t11;
            for (var r11 = 0; r11 < i10; r11++) if (n10[r11] === e11) return t11;
          };
        }
      }, ku = La, wu = Ee, Iu = fu, Nu = j, Su = ee, Tu = B, Eu = xe, Cu = He, Au = du, Ru = xu, _u = Be, Ou = String, Fu = wu("JSON", "stringify"), Du = Su(/./.exec), Mu = Su("".charAt), Lu = Su("".charCodeAt), zu = Su("".replace), Pu = Su(1 .toString), Bu = /[\uD800-\uDFFF]/g, Wu = /^[\uD800-\uDBFF]$/, Uu = /^[\uDC00-\uDFFF]$/, Vu = !_u || Tu(function() {
        var e10 = wu("Symbol")();
        return "[null]" != Fu([e10]) || "{}" != Fu({ a: e10 }) || "{}" != Fu(Object(e10));
      }), Gu = Tu(function() {
        return '"\\udf06\\ud834"' !== Fu("\uDF06\uD834") || '"\\udead"' !== Fu("\uDEAD");
      }), ju = function(e10, t10) {
        var n10 = Au(arguments), r10 = Ru(t10);
        if (Eu(r10) || void 0 !== e10 && !Cu(e10)) return n10[1] = function(e11, t11) {
          if (Eu(r10) && (t11 = Nu(r10, this, Ou(e11), t11)), !Cu(t11)) return t11;
        }, Iu(Fu, null, n10);
      }, Hu = function(e10, t10, n10) {
        var r10 = Mu(n10, t10 - 1), a10 = Mu(n10, t10 + 1);
        return Du(Wu, e10) && !Du(Uu, a10) || Du(Uu, e10) && !Du(Wu, r10) ? "\\u" + Pu(Lu(e10, 0), 16) : e10;
      };
      Fu && ku({ target: "JSON", stat: true, arity: 3, forced: Vu || Gu }, { stringify: function(e10, t10, n10) {
        var r10 = Au(arguments), a10 = Iu(Vu ? ju : Fu, null, r10);
        return Gu && "string" == typeof a10 ? zu(a10, Bu, Hu) : a10;
      } });
      var qu = ua, Ku = yt;
      La({ target: "Object", stat: true, forced: !Be || B(function() {
        qu.f(1);
      }) }, { getOwnPropertySymbols: function(e10) {
        var t10 = qu.f;
        return t10 ? t10(Ku(e10)) : [];
      } });
      var Xu = La, Yu = W, Ju = ee, Zu = kt, Qu = xe, $u = Ce, ec = Ya, tc = zi, nc = ba, rc = z.Symbol, ac = rc && rc.prototype;
      if (Yu && Qu(rc) && (!("description" in ac) || void 0 !== rc().description)) {
        var ic = {}, oc = function() {
          var e10 = arguments.length < 1 || void 0 === arguments[0] ? void 0 : ec(arguments[0]), t10 = $u(ac, this) ? new rc(e10) : void 0 === e10 ? rc() : rc(e10);
          return "" === e10 && (ic[t10] = true), t10;
        };
        nc(oc, rc), oc.prototype = ac, ac.constructor = oc;
        var sc = "Symbol(test)" == String(rc("test")), uc = Ju(ac.valueOf), cc = Ju(ac.toString), lc = /^Symbol\((.*)\)[^)]+$/, hc = Ju("".replace), pc = Ju("".slice);
        tc(ac, "description", { configurable: true, get: function() {
          var e10 = uc(this);
          if (Zu(ic, e10)) return "";
          var t10 = cc(e10), n10 = sc ? pc(t10, 7, -1) : hc(t10, lc, "$1");
          return "" === n10 ? void 0 : n10;
        } }), Xu({ global: true, constructor: true, forced: true }, { Symbol: oc });
      }
      Hi("asyncIterator"), Hi("hasInstance"), Hi("isConcatSpreadable"), Hi("iterator"), Hi("match"), Hi("matchAll"), Hi("replace"), Hi("search"), Hi("species"), Hi("split");
      var fc = Ji;
      Hi("toPrimitive"), fc();
      var dc = Ee, vc = eo;
      Hi("toStringTag"), vc(dc("Symbol"), "Symbol"), Hi("unscopables");
      var mc = ee, gc = Ze, yc = function(e10, t10, n10) {
        try {
          return mc(gc(Object.getOwnPropertyDescriptor(e10, t10)[n10]));
        } catch (e11) {
        }
      }, bc = xe, xc = String, kc = TypeError, wc = function(e10) {
        if ("object" == s(e10) || bc(e10)) return e10;
        throw kc("Can't set " + xc(e10) + " as a prototype");
      }, Ic = yc, Nc = dn, Sc = wc, Tc = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var e10, t10 = false, n10 = {};
        try {
          (e10 = Ic(Object.prototype, "__proto__", "set"))(n10, []), t10 = n10 instanceof Array;
        } catch (e11) {
        }
        return function(n11, r10) {
          return Nc(n11), Sc(r10), t10 ? e10(n11, r10) : n11.__proto__ = r10, n11;
        };
      }() : void 0), Ec = cn.f, Cc = function(e10, t10, n10) {
        n10 in e10 || Ec(e10, n10, { configurable: true, get: function() {
          return t10[n10];
        }, set: function(e11) {
          t10[n10] = e11;
        } });
      }, Ac = xe, Rc = Ie, _c = Tc, Oc = function(e10, t10, n10) {
        var r10, a10;
        return _c && Ac(r10 = t10.constructor) && r10 !== n10 && Rc(a10 = r10.prototype) && a10 !== n10.prototype && _c(e10, a10), e10;
      }, Fc = Ya, Dc = function(e10, t10) {
        return void 0 === e10 ? arguments.length < 2 ? "" : t10 : Fc(e10);
      }, Mc = Ie, Lc = Cn, zc = function(e10, t10) {
        Mc(t10) && "cause" in t10 && Lc(e10, "cause", t10.cause);
      }, Pc = Error, Bc = ee("".replace), Wc = String(Pc("zxcasd").stack), Uc = /\n\s*at [^:]*:[^\n]*/, Vc = Uc.test(Wc), Gc = function(e10, t10) {
        if (Vc && "string" == typeof e10 && !Pc.prepareStackTrace) for (; t10--; ) e10 = Bc(e10, Uc, "");
        return e10;
      }, jc = Y, Hc = !B(function() {
        var e10 = Error("a");
        return !("stack" in e10) || (Object.defineProperty(e10, "stack", jc(1, 7)), 7 !== e10.stack);
      }), qc = Cn, Kc = Gc, Xc = Hc, Yc = Error.captureStackTrace, Jc = function(e10, t10, n10, r10) {
        Xc && (Yc ? Yc(e10, t10) : qc(e10, "stack", Kc(n10, r10)));
      }, Zc = Ee, Qc = kt, $c = Cn, el = Ce, tl = Tc, nl = ba, rl = Cc, al = Oc, il = Dc, ol = zc, sl = Jc, ul = W, cl = function(e10, t10, n10, r10) {
        var a10 = "stackTraceLimit", i10 = r10 ? 2 : 1, o10 = e10.split("."), s10 = o10[o10.length - 1], u10 = Zc.apply(null, o10);
        if (u10) {
          var c10 = u10.prototype;
          if (Qc(c10, "cause") && delete c10.cause, !n10) return u10;
          var l10 = Zc("Error"), h10 = t10(function(e11, t11) {
            var n11 = il(r10 ? t11 : e11, void 0), a11 = r10 ? new u10(e11) : new u10();
            return void 0 !== n11 && $c(a11, "message", n11), sl(a11, h10, a11.stack, 2), this && el(c10, this) && al(a11, this, h10), arguments.length > i10 && ol(a11, arguments[i10]), a11;
          });
          h10.prototype = c10, "Error" !== s10 ? tl ? tl(h10, l10) : nl(h10, l10, { name: true }) : ul && a10 in u10 && (rl(h10, u10, a10), rl(h10, u10, "prepareStackTrace")), nl(h10, u10);
          try {
            c10.name !== s10 && $c(c10, "name", s10), c10.constructor = h10;
          } catch (e11) {
          }
          return h10;
        }
      }, ll = La, hl = fu, pl = cl, fl = "WebAssembly", dl = z.WebAssembly, vl = 7 !== Error("e", { cause: 7 }).cause, ml = function(e10, t10) {
        var n10 = {};
        n10[e10] = pl(e10, t10, vl), ll({ global: true, constructor: true, arity: 1, forced: vl }, n10);
      }, gl = function(e10, t10) {
        if (dl && dl[e10]) {
          var n10 = {};
          n10[e10] = pl("WebAssembly." + e10, t10, vl), ll({ target: fl, stat: true, constructor: true, arity: 1, forced: vl }, n10);
        }
      };
      ml("Error", function(e10) {
        return function(t10) {
          return hl(e10, this, arguments);
        };
      }), ml("EvalError", function(e10) {
        return function(t10) {
          return hl(e10, this, arguments);
        };
      }), ml("RangeError", function(e10) {
        return function(t10) {
          return hl(e10, this, arguments);
        };
      }), ml("ReferenceError", function(e10) {
        return function(t10) {
          return hl(e10, this, arguments);
        };
      }), ml("SyntaxError", function(e10) {
        return function(t10) {
          return hl(e10, this, arguments);
        };
      }), ml("TypeError", function(e10) {
        return function(t10) {
          return hl(e10, this, arguments);
        };
      }), ml("URIError", function(e10) {
        return function(t10) {
          return hl(e10, this, arguments);
        };
      }), gl("CompileError", function(e10) {
        return function(t10) {
          return hl(e10, this, arguments);
        };
      }), gl("LinkError", function(e10) {
        return function(t10) {
          return hl(e10, this, arguments);
        };
      }), gl("RuntimeError", function(e10) {
        return function(t10) {
          return hl(e10, this, arguments);
        };
      });
      var yl = W, bl = B, xl = dn, kl = yi, wl = Dc, Il = Error.prototype.toString, Nl = bl(function() {
        if (yl) {
          var e10 = kl(Object.defineProperty({}, "name", { get: function() {
            return this === e10;
          } }));
          if ("true" !== Il.call(e10)) return true;
        }
        return "2: 1" !== Il.call({ message: 1, name: 2 }) || "Error" !== Il.call({});
      }) ? function() {
        var e10 = xl(this), t10 = wl(e10.name, "Error"), n10 = wl(e10.message);
        return t10 ? n10 ? t10 + ": " + n10 : t10 : n10;
      } : Il, Sl = Or, Tl = Nl, El = Error.prototype;
      El.toString !== Tl && Sl(El, "toString", Tl);
      var Cl = !B(function() {
        function e10() {
        }
        return e10.prototype.constructor = null, Object.getPrototypeOf(new e10()) !== e10.prototype;
      }), Al = kt, Rl = xe, _l = yt, Ol = Cl, Fl = Xn("IE_PROTO"), Dl = Object, Ml = Dl.prototype, Ll = Ol ? Dl.getPrototypeOf : function(e10) {
        var t10 = _l(e10);
        if (Al(t10, Fl)) return t10[Fl];
        var n10 = t10.constructor;
        return Rl(n10) && t10 instanceof n10 ? n10.prototype : t10 instanceof Dl ? Ml : null;
      }, zl = {}, Pl = zl, Bl = Mt("iterator"), Wl = Array.prototype, Ul = function(e10) {
        return void 0 !== e10 && (Pl.Array === e10 || Wl[Bl] === e10);
      }, Vl = qa, Gl = et, jl = le, Hl = zl, ql = Mt("iterator"), Kl = function(e10) {
        if (!jl(e10)) return Gl(e10, ql) || Gl(e10, "@@iterator") || Hl[Vl(e10)];
      }, Xl = j, Yl = Ze, Jl = dn, Zl = Ke, Ql = Kl, $l = TypeError, eh = function(e10, t10) {
        var n10 = arguments.length < 2 ? Ql(e10) : t10;
        if (Yl(n10)) return Jl(Xl(n10, e10));
        throw $l(Zl(e10) + " is not iterable");
      }, th = j, nh = dn, rh = et, ah = function(e10, t10, n10) {
        var r10, a10;
        nh(e10);
        try {
          if (!(r10 = rh(e10, "return"))) {
            if ("throw" === t10) throw n10;
            return n10;
          }
          r10 = th(r10, e10);
        } catch (e11) {
          a10 = true, r10 = e11;
        }
        if ("throw" === t10) throw n10;
        if (a10) throw r10;
        return nh(r10), n10;
      }, ih = so, oh = j, sh = dn, uh = Ke, ch = Ul, lh = Kr, hh = Ce, ph = eh, fh = Kl, dh = ah, vh = TypeError, mh = function(e10, t10) {
        this.stopped = e10, this.result = t10;
      }, gh = mh.prototype, yh = function(e10, t10, n10) {
        var r10, a10, i10, o10, u10, c10, l10, h10 = n10 && n10.that, p10 = !(!n10 || !n10.AS_ENTRIES), f10 = !(!n10 || !n10.IS_RECORD), d10 = !(!n10 || !n10.IS_ITERATOR), v10 = !(!n10 || !n10.INTERRUPTED), m10 = ih(t10, h10), g10 = function(e11) {
          return r10 && dh(r10, "normal", e11), new mh(true, e11);
        }, y10 = function(e11) {
          return p10 ? (sh(e11), v10 ? m10(e11[0], e11[1], g10) : m10(e11[0], e11[1])) : v10 ? m10(e11, g10) : m10(e11);
        };
        if (f10) r10 = e10.iterator;
        else if (d10) r10 = e10;
        else {
          if (!(a10 = fh(e10))) throw vh(uh(e10) + " is not iterable");
          if (ch(a10)) {
            for (i10 = 0, o10 = lh(e10); o10 > i10; i10++) if ((u10 = y10(e10[i10])) && hh(gh, u10)) return u10;
            return new mh(false);
          }
          r10 = ph(e10, a10);
        }
        for (c10 = f10 ? e10.next : r10.next; !(l10 = oh(c10, r10)).done; ) {
          try {
            u10 = y10(l10.value);
          } catch (e11) {
            dh(r10, "throw", e11);
          }
          if ("object" == s(u10) && u10 && hh(gh, u10)) return u10;
        }
        return new mh(false);
      }, bh = La, xh = Ce, kh = Ll, wh = Tc, Ih = ba, Nh = yi, Sh = Cn, Th = Y, Eh = zc, Ch = Jc, Ah = yh, Rh = Dc, _h = Mt("toStringTag"), Oh = Error, Fh = [].push, Dh = function(e10, t10) {
        var n10, r10 = xh(Mh, this);
        wh ? n10 = wh(Oh(), r10 ? kh(this) : Mh) : (n10 = r10 ? this : Nh(Mh), Sh(n10, _h, "Error")), void 0 !== t10 && Sh(n10, "message", Rh(t10)), Ch(n10, Dh, n10.stack, 1), arguments.length > 2 && Eh(n10, arguments[2]);
        var a10 = [];
        return Ah(e10, Fh, { that: a10 }), Sh(n10, "errors", a10), n10;
      };
      wh ? wh(Dh, Oh) : Ih(Dh, Oh, { name: true });
      var Mh = Dh.prototype = Nh(Oh.prototype, { constructor: Th(1, Dh), message: Th(1, ""), name: Th(1, "AggregateError") });
      bh({ global: true, constructor: true, arity: 2 }, { AggregateError: Dh });
      var Lh = La, zh = fu, Ph = B, Bh = cl, Wh = "AggregateError", Uh = Ee(Wh), Vh = !Ph(function() {
        return 1 !== Uh([1]).errors[0];
      }) && Ph(function() {
        return 7 !== Uh([1], Wh, { cause: 7 }).cause;
      });
      Lh({ global: true, constructor: true, arity: 2, forced: Vh }, { AggregateError: Bh(Wh, function(e10) {
        return function(t10, n10) {
          return zh(e10, this, arguments);
        };
      }, Vh, true) });
      var Gh = Mt, jh = yi, Hh = cn.f, qh = Gh("unscopables"), Kh = Array.prototype;
      null == Kh[qh] && Hh(Kh, qh, { configurable: true, value: jh(null) });
      var Xh = function(e10) {
        Kh[qh][e10] = true;
      }, Yh = yt, Jh = Kr, Zh = Pr, Qh = Xh;
      La({ target: "Array", proto: true }, { at: function(e10) {
        var t10 = Yh(this), n10 = Jh(t10), r10 = Zh(e10), a10 = r10 >= 0 ? r10 : n10 + r10;
        return a10 < 0 || a10 >= n10 ? void 0 : t10[a10];
      } }), Qh("at");
      var $h = TypeError, ep = function(e10) {
        if (e10 > 9007199254740991) throw $h("Maximum allowed index exceeded");
        return e10;
      }, tp = B, np = Le, rp = Mt("species"), ap = function(e10) {
        return np >= 51 || !tp(function() {
          var t10 = [];
          return (t10.constructor = {})[rp] = function() {
            return { foo: 1 };
          }, 1 !== t10[e10](Boolean).foo;
        });
      }, ip = La, op = B, sp = co, up = Ie, cp = yt, lp = Kr, hp = ep, pp = Ii, fp = Oo, dp = ap, vp = Le, mp = Mt("isConcatSpreadable"), gp = vp >= 51 || !op(function() {
        var e10 = [];
        return e10[mp] = false, e10.concat()[0] !== e10;
      }), yp = function(e10) {
        if (!up(e10)) return false;
        var t10 = e10[mp];
        return void 0 !== t10 ? !!t10 : sp(e10);
      };
      ip({ target: "Array", proto: true, arity: 1, forced: !gp || !dp("concat") }, { concat: function(e10) {
        var t10, n10, r10, a10, i10, o10 = cp(this), s10 = fp(o10, 0), u10 = 0;
        for (t10 = -1, r10 = arguments.length; t10 < r10; t10++) if (yp(i10 = -1 === t10 ? o10 : arguments[t10])) for (a10 = lp(i10), hp(u10 + a10), n10 = 0; n10 < a10; n10++, u10++) n10 in i10 && pp(s10, u10, i10[n10]);
        else hp(u10 + 1), pp(s10, u10++, i10);
        return s10.length = u10, s10;
      } });
      var bp = Ke, xp = TypeError, kp = function(e10, t10) {
        if (!delete e10[t10]) throw xp("Cannot delete property " + bp(t10) + " of " + bp(e10));
      }, wp = yt, Ip = Vr, Np = Kr, Sp = kp, Tp = Math.min, Ep = [].copyWithin || function(e10, t10) {
        var n10 = wp(this), r10 = Np(n10), a10 = Ip(e10, r10), i10 = Ip(t10, r10), o10 = arguments.length > 2 ? arguments[2] : void 0, s10 = Tp((void 0 === o10 ? r10 : Ip(o10, r10)) - i10, r10 - a10), u10 = 1;
        for (i10 < a10 && a10 < i10 + s10 && (u10 = -1, i10 += s10 - 1, a10 += s10 - 1); s10-- > 0; ) i10 in n10 ? n10[a10] = n10[i10] : Sp(n10, a10), a10 += u10, i10 += u10;
        return n10;
      }, Cp = Xh;
      La({ target: "Array", proto: true }, { copyWithin: Ep }), Cp("copyWithin");
      var Ap = B, Rp = function(e10, t10) {
        var n10 = [][e10];
        return !!n10 && Ap(function() {
          n10.call(null, t10 || function() {
            return 1;
          }, 1);
        });
      }, _p = Wo.every;
      La({ target: "Array", proto: true, forced: !Rp("every") }, { every: function(e10) {
        return _p(this, e10, arguments.length > 1 ? arguments[1] : void 0);
      } });
      var Op = yt, Fp = Vr, Dp = Kr, Mp = function(e10) {
        for (var t10 = Op(this), n10 = Dp(t10), r10 = arguments.length, a10 = Fp(r10 > 1 ? arguments[1] : void 0, n10), i10 = r10 > 2 ? arguments[2] : void 0, o10 = void 0 === i10 ? n10 : Fp(i10, n10); o10 > a10; ) t10[a10++] = e10;
        return t10;
      }, Lp = Xh;
      La({ target: "Array", proto: true }, { fill: Mp }), Lp("fill");
      var zp = Wo.filter;
      La({ target: "Array", proto: true, forced: !ap("filter") }, { filter: function(e10) {
        return zp(this, e10, arguments.length > 1 ? arguments[1] : void 0);
      } });
      var Pp = La, Bp = Wo.find, Wp = Xh, Up = "find", Vp = true;
      Up in [] && Array(1).find(function() {
        Vp = false;
      }), Pp({ target: "Array", proto: true, forced: Vp }, { find: function(e10) {
        return Bp(this, e10, arguments.length > 1 ? arguments[1] : void 0);
      } }), Wp(Up);
      var Gp = La, jp = Wo.findIndex, Hp = Xh, qp = "findIndex", Kp = true;
      qp in [] && Array(1).findIndex(function() {
        Kp = false;
      }), Gp({ target: "Array", proto: true, forced: Kp }, { findIndex: function(e10) {
        return jp(this, e10, arguments.length > 1 ? arguments[1] : void 0);
      } }), Hp(qp);
      var Xp = so, Yp = ce, Jp = yt, Zp = Kr, Qp = function(e10) {
        var t10 = 1 == e10;
        return function(n10, r10, a10) {
          for (var i10, o10 = Jp(n10), s10 = Yp(o10), u10 = Xp(r10, a10), c10 = Zp(s10); c10-- > 0; ) if (u10(i10 = s10[c10], c10, o10)) switch (e10) {
            case 0:
              return i10;
            case 1:
              return c10;
          }
          return t10 ? -1 : void 0;
        };
      }, $p = { findLast: Qp(0), findLastIndex: Qp(1) }, ef = $p.findLast, tf = Xh;
      La({ target: "Array", proto: true }, { findLast: function(e10) {
        return ef(this, e10, arguments.length > 1 ? arguments[1] : void 0);
      } }), tf("findLast");
      var nf = $p.findLastIndex, rf = Xh;
      La({ target: "Array", proto: true }, { findLastIndex: function(e10) {
        return nf(this, e10, arguments.length > 1 ? arguments[1] : void 0);
      } }), rf("findLastIndex");
      var af = co, of = Kr, sf = ep, uf = so, cf = function e10(t10, n10, r10, a10, i10, o10, s10, u10) {
        for (var c10, l10 = i10, h10 = 0, p10 = !!s10 && uf(s10, u10); h10 < a10; ) h10 in r10 && (c10 = p10 ? p10(r10[h10], h10, n10) : r10[h10], o10 > 0 && af(c10) ? l10 = e10(t10, n10, c10, of(c10), l10, o10 - 1) - 1 : (sf(l10 + 1), t10[l10] = c10), l10++), h10++;
        return l10;
      }, lf = cf, hf = yt, pf = Kr, ff = Pr, df = Oo;
      La({ target: "Array", proto: true }, { flat: function() {
        var e10 = arguments.length ? arguments[0] : void 0, t10 = hf(this), n10 = pf(t10), r10 = df(t10, 0);
        return r10.length = lf(r10, t10, t10, n10, 0, void 0 === e10 ? 1 : ff(e10)), r10;
      } });
      var vf = cf, mf = Ze, gf = yt, yf = Kr, bf = Oo;
      La({ target: "Array", proto: true }, { flatMap: function(e10) {
        var t10, n10 = gf(this), r10 = yf(n10);
        return mf(e10), (t10 = bf(n10, 0)).length = vf(t10, n10, n10, r10, 0, 1, e10, arguments.length > 1 ? arguments[1] : void 0), t10;
      } });
      var xf = Wo.forEach, kf = Rp("forEach") ? [].forEach : function(e10) {
        return xf(this, e10, arguments.length > 1 ? arguments[1] : void 0);
      };
      La({ target: "Array", proto: true, forced: [].forEach != kf }, { forEach: kf });
      var wf = dn, If = ah, Nf = function(e10, t10, n10, r10) {
        try {
          return r10 ? t10(wf(n10)[0], n10[1]) : t10(n10);
        } catch (t11) {
          If(e10, "throw", t11);
        }
      }, Sf = so, Tf = j, Ef = yt, Cf = Nf, Af = Ul, Rf = No, _f = Kr, Of = Ii, Ff = eh, Df = Kl, Mf = Array, Lf = function(e10) {
        var t10 = Ef(e10), n10 = Rf(this), r10 = arguments.length, a10 = r10 > 1 ? arguments[1] : void 0, i10 = void 0 !== a10;
        i10 && (a10 = Sf(a10, r10 > 2 ? arguments[2] : void 0));
        var o10, s10, u10, c10, l10, h10, p10 = Df(t10), f10 = 0;
        if (!p10 || this === Mf && Af(p10)) for (o10 = _f(t10), s10 = n10 ? new this(o10) : Mf(o10); o10 > f10; f10++) h10 = i10 ? a10(t10[f10], f10) : t10[f10], Of(s10, f10, h10);
        else for (l10 = (c10 = Ff(t10, p10)).next, s10 = n10 ? new this() : []; !(u10 = Tf(l10, c10)).done; f10++) h10 = i10 ? Cf(c10, a10, [u10.value, f10], true) : u10.value, Of(s10, f10, h10);
        return s10.length = f10, s10;
      }, zf = Mt("iterator"), Pf = false;
      try {
        var Bf = 0, Wf = { next: function() {
          return { done: !!Bf++ };
        }, return: function() {
          Pf = true;
        } };
        Wf[zf] = function() {
          return this;
        }, Array.from(Wf, function() {
          throw 2;
        });
      } catch (e10) {
      }
      var Uf = function(e10, t10) {
        if (!t10 && !Pf) return false;
        var n10 = false;
        try {
          var r10 = {};
          r10[zf] = function() {
            return { next: function() {
              return { done: n10 = true };
            } };
          }, e10(r10);
        } catch (e11) {
        }
        return n10;
      }, Vf = Lf;
      La({ target: "Array", stat: true, forced: !Uf(function(e10) {
        Array.from(e10);
      }) }, { from: Vf });
      var Gf = Qr.includes, jf = Xh;
      La({ target: "Array", proto: true, forced: B(function() {
        return !Array(1).includes();
      }) }, { includes: function(e10) {
        return Gf(this, e10, arguments.length > 1 ? arguments[1] : void 0);
      } }), jf("includes");
      var Hf = La, qf = Qr.indexOf, Kf = Rp, Xf = ro([].indexOf), Yf = !!Xf && 1 / Xf([1], 1, -0) < 0;
      Hf({ target: "Array", proto: true, forced: Yf || !Kf("indexOf") }, { indexOf: function(e10) {
        var t10 = arguments.length > 1 ? arguments[1] : void 0;
        return Yf ? Xf(this, e10, t10) || 0 : qf(this, e10, t10);
      } }), La({ target: "Array", stat: true }, { isArray: co });
      var Jf, Zf, Qf, $f = B, ed = xe, td = Ie, nd = Ll, rd = Or, ad = Mt("iterator"), id = false;
      [].keys && ("next" in (Qf = [].keys()) ? (Zf = nd(nd(Qf))) !== Object.prototype && (Jf = Zf) : id = true);
      var od = !td(Jf) || $f(function() {
        var e10 = {};
        return Jf[ad].call(e10) !== e10;
      });
      od && (Jf = {}), ed(Jf[ad]) || rd(Jf, ad, function() {
        return this;
      });
      var sd = { IteratorPrototype: Jf, BUGGY_SAFARI_ITERATORS: id }, ud = sd.IteratorPrototype, cd = yi, ld = Y, hd = eo, pd = zl, fd = function() {
        return this;
      }, dd = function(e10, t10, n10, r10) {
        var a10 = t10 + " Iterator";
        return e10.prototype = cd(ud, { next: ld(+!r10, n10) }), hd(e10, a10, false, true), pd[a10] = fd, e10;
      }, vd = La, md = j, gd = xe, yd = dd, bd = Ll, xd = Tc, kd = eo, wd = Cn, Id = Or, Nd = zl, Sd = Mn.PROPER, Td = Mn.CONFIGURABLE, Ed = sd.IteratorPrototype, Cd = sd.BUGGY_SAFARI_ITERATORS, Ad = Mt("iterator"), Rd = "keys", _d = "values", Od = "entries", Fd = function() {
        return this;
      }, Dd = function(e10, t10, n10, r10, a10, i10, o10) {
        yd(n10, t10, r10);
        var s10, u10, c10, l10 = function(e11) {
          if (e11 === a10 && v10) return v10;
          if (!Cd && e11 in f10) return f10[e11];
          switch (e11) {
            case Rd:
            case _d:
            case Od:
              return function() {
                return new n10(this, e11);
              };
          }
          return function() {
            return new n10(this);
          };
        }, h10 = t10 + " Iterator", p10 = false, f10 = e10.prototype, d10 = f10[Ad] || f10["@@iterator"] || a10 && f10[a10], v10 = !Cd && d10 || l10(a10), m10 = "Array" == t10 && f10.entries || d10;
        if (m10 && (s10 = bd(m10.call(new e10()))) !== Object.prototype && s10.next && (bd(s10) !== Ed && (xd ? xd(s10, Ed) : gd(s10[Ad]) || Id(s10, Ad, Fd)), kd(s10, h10, true, true)), Sd && a10 == _d && d10 && d10.name !== _d && (Td ? wd(f10, "name", _d) : (p10 = true, v10 = function() {
          return md(d10, this);
        })), a10) if (u10 = { values: l10(_d), keys: i10 ? v10 : l10(Rd), entries: l10(Od) }, o10) for (c10 in u10) (Cd || p10 || !(c10 in f10)) && Id(f10, c10, u10[c10]);
        else vd({ target: t10, proto: true, forced: Cd || p10 }, u10);
        return f10[Ad] !== v10 && Id(f10, Ad, v10, { name: a10 }), Nd[t10] = v10, u10;
      }, Md = function(e10, t10) {
        return { value: e10, done: t10 };
      }, Ld = me, zd = Xh, Pd = zl, Bd = cr, Wd = cn.f, Ud = Dd, Vd = Md, Gd = W, jd = "Array Iterator", Hd = Bd.set, qd = Bd.getterFor(jd), Kd = Ud(Array, "Array", function(e10, t10) {
        Hd(this, { type: jd, target: Ld(e10), index: 0, kind: t10 });
      }, function() {
        var e10 = qd(this), t10 = e10.target, n10 = e10.kind, r10 = e10.index++;
        return !t10 || r10 >= t10.length ? (e10.target = void 0, Vd(void 0, true)) : Vd("keys" == n10 ? r10 : "values" == n10 ? t10[r10] : [r10, t10[r10]], false);
      }, "values"), Xd = Pd.Arguments = Pd.Array;
      if (zd("keys"), zd("values"), zd("entries"), Gd && "values" !== Xd.name) try {
        Wd(Xd, "name", { value: "values" });
      } catch (e10) {
      }
      var Yd = La, Jd = ce, Zd = me, Qd = Rp, $d = ee([].join);
      Yd({ target: "Array", proto: true, forced: Jd != Object || !Qd("join", ",") }, { join: function(e10) {
        return $d(Zd(this), void 0 === e10 ? "," : e10);
      } });
      var ev = fu, tv = me, nv = Pr, rv = Kr, av = Rp, iv = Math.min, ov = [].lastIndexOf, sv = !!ov && 1 / [1].lastIndexOf(1, -0) < 0, uv = av("lastIndexOf"), cv = sv || !uv ? function(e10) {
        if (sv) return ev(ov, this, arguments) || 0;
        var t10 = tv(this), n10 = rv(t10), r10 = n10 - 1;
        for (arguments.length > 1 && (r10 = iv(r10, nv(arguments[1]))), r10 < 0 && (r10 = n10 + r10); r10 >= 0; r10--) if (r10 in t10 && t10[r10] === e10) return r10 || 0;
        return -1;
      } : ov;
      La({ target: "Array", proto: true, forced: cv !== [].lastIndexOf }, { lastIndexOf: cv });
      var lv = Wo.map;
      La({ target: "Array", proto: true, forced: !ap("map") }, { map: function(e10) {
        return lv(this, e10, arguments.length > 1 ? arguments[1] : void 0);
      } });
      var hv = No, pv = Ii, fv = Array;
      La({ target: "Array", stat: true, forced: B(function() {
        function e10() {
        }
        return !(fv.of.call(e10) instanceof e10);
      }) }, { of: function() {
        for (var e10 = 0, t10 = arguments.length, n10 = new (hv(this) ? this : fv)(t10); t10 > e10; ) pv(n10, e10, arguments[e10++]);
        return n10.length = t10, n10;
      } });
      var dv = W, vv = co, mv = TypeError, gv = Object.getOwnPropertyDescriptor, yv = dv && !function() {
        if (void 0 !== this) return true;
        try {
          Object.defineProperty([], "length", { writable: false }).length = 1;
        } catch (e10) {
          return e10 instanceof TypeError;
        }
      }() ? function(e10, t10) {
        if (vv(e10) && !gv(e10, "length").writable) throw mv("Cannot set read only .length");
        return e10.length = t10;
      } : function(e10, t10) {
        return e10.length = t10;
      }, bv = yt, xv = Kr, kv = yv, wv = ep;
      La({ target: "Array", proto: true, arity: 1, forced: B(function() {
        return 4294967297 !== [].push.call({ length: 4294967296 }, 1);
      }) || !function() {
        try {
          Object.defineProperty([], "length", { writable: false }).push();
        } catch (e10) {
          return e10 instanceof TypeError;
        }
      }() }, { push: function(e10) {
        var t10 = bv(this), n10 = xv(t10), r10 = arguments.length;
        wv(n10 + r10);
        for (var a10 = 0; a10 < r10; a10++) t10[n10] = arguments[a10], n10++;
        return kv(t10, n10), n10;
      } });
      var Iv = Ze, Nv = yt, Sv = ce, Tv = Kr, Ev = TypeError, Cv = function(e10) {
        return function(t10, n10, r10, a10) {
          Iv(n10);
          var i10 = Nv(t10), o10 = Sv(i10), s10 = Tv(i10), u10 = e10 ? s10 - 1 : 0, c10 = e10 ? -1 : 1;
          if (r10 < 2) for (; ; ) {
            if (u10 in o10) {
              a10 = o10[u10], u10 += c10;
              break;
            }
            if (u10 += c10, e10 ? u10 < 0 : s10 <= u10) throw Ev("Reduce of empty array with no initial value");
          }
          for (; e10 ? u10 >= 0 : s10 > u10; u10 += c10) u10 in o10 && (a10 = n10(a10, o10[u10], u10, i10));
          return a10;
        };
      }, Av = { left: Cv(false), right: Cv(true) }, Rv = "undefined" != typeof process && "process" == ae(process), _v = Av.left;
      La({ target: "Array", proto: true, forced: !Rv && Le > 79 && Le < 83 || !Rp("reduce") }, { reduce: function(e10) {
        var t10 = arguments.length;
        return _v(this, e10, t10, t10 > 1 ? arguments[1] : void 0);
      } });
      var Ov = Av.right;
      La({ target: "Array", proto: true, forced: !Rv && Le > 79 && Le < 83 || !Rp("reduceRight") }, { reduceRight: function(e10) {
        return Ov(this, e10, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
      } });
      var Fv = La, Dv = co, Mv = ee([].reverse), Lv = [1, 2];
      Fv({ target: "Array", proto: true, forced: String(Lv) === String(Lv.reverse()) }, { reverse: function() {
        return Dv(this) && (this.length = this.length), Mv(this);
      } });
      var zv = La, Pv = co, Bv = No, Wv = Ie, Uv = Vr, Vv = Kr, Gv = me, jv = Ii, Hv = Mt, qv = du, Kv = ap("slice"), Xv = Hv("species"), Yv = Array, Jv = Math.max;
      zv({ target: "Array", proto: true, forced: !Kv }, { slice: function(e10, t10) {
        var n10, r10, a10, i10 = Gv(this), o10 = Vv(i10), s10 = Uv(e10, o10), u10 = Uv(void 0 === t10 ? o10 : t10, o10);
        if (Pv(i10) && (n10 = i10.constructor, (Bv(n10) && (n10 === Yv || Pv(n10.prototype)) || Wv(n10) && null === (n10 = n10[Xv])) && (n10 = void 0), n10 === Yv || void 0 === n10)) return qv(i10, s10, u10);
        for (r10 = new (void 0 === n10 ? Yv : n10)(Jv(u10 - s10, 0)), a10 = 0; s10 < u10; s10++, a10++) s10 in i10 && jv(r10, a10, i10[s10]);
        return r10.length = a10, r10;
      } });
      var Zv = Wo.some;
      La({ target: "Array", proto: true, forced: !Rp("some") }, { some: function(e10) {
        return Zv(this, e10, arguments.length > 1 ? arguments[1] : void 0);
      } });
      var Qv = Ai, $v = Math.floor, em = function(e10, t10) {
        for (var n10, r10, a10 = e10.length, i10 = 1; i10 < a10; ) {
          for (r10 = i10, n10 = e10[i10]; r10 && t10(e10[r10 - 1], n10) > 0; ) e10[r10] = e10[--r10];
          r10 !== i10++ && (e10[r10] = n10);
        }
        return e10;
      }, tm = function(e10, t10, n10, r10) {
        for (var a10 = t10.length, i10 = n10.length, o10 = 0, s10 = 0; o10 < a10 || s10 < i10; ) e10[o10 + s10] = o10 < a10 && s10 < i10 ? r10(t10[o10], n10[s10]) <= 0 ? t10[o10++] : n10[s10++] : o10 < a10 ? t10[o10++] : n10[s10++];
        return e10;
      }, nm = function e10(t10, n10) {
        var r10 = t10.length, a10 = $v(r10 / 2);
        return r10 < 8 ? em(t10, n10) : tm(t10, e10(Qv(t10, 0, a10), n10), e10(Qv(t10, a10), n10), n10);
      }, rm = Ae.match(/firefox\/(\d+)/i), am = !!rm && +rm[1], im = /MSIE|Trident/.test(Ae), om = Ae.match(/AppleWebKit\/(\d+)\./), sm = !!om && +om[1], um = La, cm = ee, lm = Ze, hm = yt, pm = Kr, fm = kp, dm = Ya, vm = B, mm = nm, gm = Rp, ym = am, bm = im, xm = Le, km = sm, wm = [], Im = cm(wm.sort), Nm = cm(wm.push), Sm = vm(function() {
        wm.sort(void 0);
      }), Tm = vm(function() {
        wm.sort(null);
      }), Em = gm("sort"), Cm = !vm(function() {
        if (xm) return xm < 70;
        if (!(ym && ym > 3)) {
          if (bm) return true;
          if (km) return km < 603;
          var e10, t10, n10, r10, a10 = "";
          for (e10 = 65; e10 < 76; e10++) {
            switch (t10 = String.fromCharCode(e10), e10) {
              case 66:
              case 69:
              case 70:
              case 72:
                n10 = 3;
                break;
              case 68:
              case 71:
                n10 = 4;
                break;
              default:
                n10 = 2;
            }
            for (r10 = 0; r10 < 47; r10++) wm.push({ k: t10 + r10, v: n10 });
          }
          for (wm.sort(function(e11, t11) {
            return t11.v - e11.v;
          }), r10 = 0; r10 < wm.length; r10++) t10 = wm[r10].k.charAt(0), a10.charAt(a10.length - 1) !== t10 && (a10 += t10);
          return "DGBEFHACIJK" !== a10;
        }
      });
      um({ target: "Array", proto: true, forced: Sm || !Tm || !Em || !Cm }, { sort: function(e10) {
        void 0 !== e10 && lm(e10);
        var t10 = hm(this);
        if (Cm) return void 0 === e10 ? Im(t10) : Im(t10, e10);
        var n10, r10, a10 = [], i10 = pm(t10);
        for (r10 = 0; r10 < i10; r10++) r10 in t10 && Nm(a10, t10[r10]);
        for (mm(a10, /* @__PURE__ */ function(e11) {
          return function(t11, n11) {
            return void 0 === n11 ? -1 : void 0 === t11 ? 1 : void 0 !== e11 ? +e11(t11, n11) || 0 : dm(t11) > dm(n11) ? 1 : -1;
          };
        }(e10)), n10 = pm(a10), r10 = 0; r10 < n10; ) t10[r10] = a10[r10++];
        for (; r10 < i10; ) fm(t10, r10++);
        return t10;
      } });
      var Am = Ee, Rm = zi, _m = W, Om = Mt("species"), Fm = function(e10) {
        var t10 = Am(e10);
        _m && t10 && !t10[Om] && Rm(t10, Om, { configurable: true, get: function() {
          return this;
        } });
      };
      Fm("Array");
      var Dm = La, Mm = yt, Lm = Vr, zm = Pr, Pm = Kr, Bm = yv, Wm = ep, Um = Oo, Vm = Ii, Gm = kp, jm = ap("splice"), Hm = Math.max, qm = Math.min;
      Dm({ target: "Array", proto: true, forced: !jm }, { splice: function(e10, t10) {
        var n10, r10, a10, i10, o10, s10, u10 = Mm(this), c10 = Pm(u10), l10 = Lm(e10, c10), h10 = arguments.length;
        for (0 === h10 ? n10 = r10 = 0 : 1 === h10 ? (n10 = 0, r10 = c10 - l10) : (n10 = h10 - 2, r10 = qm(Hm(zm(t10), 0), c10 - l10)), Wm(c10 + n10 - r10), a10 = Um(u10, r10), i10 = 0; i10 < r10; i10++) (o10 = l10 + i10) in u10 && Vm(a10, i10, u10[o10]);
        if (a10.length = r10, n10 < r10) {
          for (i10 = l10; i10 < c10 - r10; i10++) s10 = i10 + n10, (o10 = i10 + r10) in u10 ? u10[s10] = u10[o10] : Gm(u10, s10);
          for (i10 = c10; i10 > c10 - r10 + n10; i10--) Gm(u10, i10 - 1);
        } else if (n10 > r10) for (i10 = c10 - r10; i10 > l10; i10--) s10 = i10 + n10 - 1, (o10 = i10 + r10 - 1) in u10 ? u10[s10] = u10[o10] : Gm(u10, s10);
        for (i10 = 0; i10 < n10; i10++) u10[i10 + l10] = arguments[i10 + 2];
        return Bm(u10, c10 - r10 + n10), a10;
      } });
      var Km = Kr, Xm = function(e10, t10) {
        for (var n10 = Km(e10), r10 = new t10(n10), a10 = 0; a10 < n10; a10++) r10[a10] = e10[n10 - a10 - 1];
        return r10;
      }, Ym = Xm, Jm = me, Zm = Xh, Qm = Array;
      La({ target: "Array", proto: true }, { toReversed: function() {
        return Ym(Jm(this), Qm);
      } }), Zm("toReversed");
      var $m = Kr, eg = function(e10, t10) {
        for (var n10 = 0, r10 = $m(t10), a10 = new e10(r10); r10 > n10; ) a10[n10] = t10[n10++];
        return a10;
      }, tg = z, ng = function(e10) {
        return tg[e10].prototype;
      }, rg = La, ag = Ze, ig = me, og = eg, sg = Xh, ug = Array, cg = ee(ng("Array").sort);
      rg({ target: "Array", proto: true }, { toSorted: function(e10) {
        void 0 !== e10 && ag(e10);
        var t10 = ig(this), n10 = og(ug, t10);
        return cg(n10, e10);
      } }), sg("toSorted");
      var lg = La, hg = Xh, pg = ep, fg = Kr, dg = Vr, vg = me, mg = Pr, gg = Array, yg = Math.max, bg = Math.min;
      lg({ target: "Array", proto: true }, { toSpliced: function(e10, t10) {
        var n10, r10, a10, i10, o10 = vg(this), s10 = fg(o10), u10 = dg(e10, s10), c10 = arguments.length, l10 = 0;
        for (0 === c10 ? n10 = r10 = 0 : 1 === c10 ? (n10 = 0, r10 = s10 - u10) : (n10 = c10 - 2, r10 = bg(yg(mg(t10), 0), s10 - u10)), a10 = pg(s10 + n10 - r10), i10 = gg(a10); l10 < u10; l10++) i10[l10] = o10[l10];
        for (; l10 < u10 + n10; l10++) i10[l10] = arguments[l10 - u10 + 2];
        for (; l10 < a10; l10++) i10[l10] = o10[l10 + r10 - n10];
        return i10;
      } }), hg("toSpliced"), Xh("flat"), Xh("flatMap");
      var xg = yt, kg = Kr, wg = yv, Ig = kp, Ng = ep;
      La({ target: "Array", proto: true, arity: 1, forced: 1 !== [].unshift(0) || !function() {
        try {
          Object.defineProperty([], "length", { writable: false }).unshift();
        } catch (e10) {
          return e10 instanceof TypeError;
        }
      }() }, { unshift: function(e10) {
        var t10 = xg(this), n10 = kg(t10), r10 = arguments.length;
        if (r10) {
          Ng(n10 + r10);
          for (var a10 = n10; a10--; ) {
            var i10 = a10 + r10;
            a10 in t10 ? t10[i10] = t10[a10] : Ig(t10, i10);
          }
          for (var o10 = 0; o10 < r10; o10++) t10[o10] = arguments[o10];
        }
        return wg(t10, n10 + r10);
      } });
      var Sg = Kr, Tg = Pr, Eg = RangeError, Cg = function(e10, t10, n10, r10) {
        var a10 = Sg(e10), i10 = Tg(n10), o10 = i10 < 0 ? a10 + i10 : i10;
        if (o10 >= a10 || o10 < 0) throw Eg("Incorrect index");
        for (var s10 = new t10(a10), u10 = 0; u10 < a10; u10++) s10[u10] = u10 === o10 ? r10 : e10[u10];
        return s10;
      }, Ag = Cg, Rg = me, _g = Array;
      La({ target: "Array", proto: true }, { with: function(e10, t10) {
        return Ag(Rg(this), _g, e10, t10);
      } });
      var Og = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView, Fg = Or, Dg = function(e10, t10, n10) {
        for (var r10 in t10) Fg(e10, r10, t10[r10], n10);
        return e10;
      }, Mg = Ce, Lg = TypeError, zg = function(e10, t10) {
        if (Mg(t10, e10)) return e10;
        throw Lg("Incorrect invocation");
      }, Pg = Pr, Bg = Hr, Wg = RangeError, Ug = function(e10) {
        if (void 0 === e10) return 0;
        var t10 = Pg(e10), n10 = Bg(t10);
        if (t10 !== n10) throw Wg("Wrong length or index");
        return n10;
      }, Vg = Array, Gg = Math.abs, jg = Math.pow, Hg = Math.floor, qg = Math.log, Kg = Math.LN2, Xg = { pack: function(e10, t10, n10) {
        var r10, a10, i10, o10 = Vg(n10), s10 = 8 * n10 - t10 - 1, u10 = (1 << s10) - 1, c10 = u10 >> 1, l10 = 23 === t10 ? jg(2, -24) - jg(2, -77) : 0, h10 = e10 < 0 || 0 === e10 && 1 / e10 < 0 ? 1 : 0, p10 = 0;
        for ((e10 = Gg(e10)) != e10 || e10 === 1 / 0 ? (a10 = e10 != e10 ? 1 : 0, r10 = u10) : (r10 = Hg(qg(e10) / Kg), e10 * (i10 = jg(2, -r10)) < 1 && (r10--, i10 *= 2), (e10 += r10 + c10 >= 1 ? l10 / i10 : l10 * jg(2, 1 - c10)) * i10 >= 2 && (r10++, i10 /= 2), r10 + c10 >= u10 ? (a10 = 0, r10 = u10) : r10 + c10 >= 1 ? (a10 = (e10 * i10 - 1) * jg(2, t10), r10 += c10) : (a10 = e10 * jg(2, c10 - 1) * jg(2, t10), r10 = 0)); t10 >= 8; ) o10[p10++] = 255 & a10, a10 /= 256, t10 -= 8;
        for (r10 = r10 << t10 | a10, s10 += t10; s10 > 0; ) o10[p10++] = 255 & r10, r10 /= 256, s10 -= 8;
        return o10[--p10] |= 128 * h10, o10;
      }, unpack: function(e10, t10) {
        var n10, r10 = e10.length, a10 = 8 * r10 - t10 - 1, i10 = (1 << a10) - 1, o10 = i10 >> 1, s10 = a10 - 7, u10 = r10 - 1, c10 = e10[u10--], l10 = 127 & c10;
        for (c10 >>= 7; s10 > 0; ) l10 = 256 * l10 + e10[u10--], s10 -= 8;
        for (n10 = l10 & (1 << -s10) - 1, l10 >>= -s10, s10 += t10; s10 > 0; ) n10 = 256 * n10 + e10[u10--], s10 -= 8;
        if (0 === l10) l10 = 1 - o10;
        else {
          if (l10 === i10) return n10 ? NaN : c10 ? -1 / 0 : 1 / 0;
          n10 += jg(2, t10), l10 -= o10;
        }
        return (c10 ? -1 : 1) * n10 * jg(2, l10 - t10);
      } }, Yg = z, Jg = ee, Zg = W, Qg = Og, $g = Mn, ey = Cn, ty = zi, ny = Dg, ry = B, ay = zg, iy = Pr, oy = Hr, sy = Ug, uy = Xg, cy = Ll, ly = Tc, hy = Fr.f, py = Mp, fy = Ai, dy = eo, vy = cr, my = $g.PROPER, gy = $g.CONFIGURABLE, yy = "ArrayBuffer", by = "DataView", xy = "Wrong index", ky = vy.getterFor(yy), wy = vy.getterFor(by), Iy = vy.set, Ny = Yg.ArrayBuffer, Sy = Ny, Ty = Sy && Sy.prototype, Ey = Yg.DataView, Cy = Ey && Ey.prototype, Ay = Object.prototype, Ry = Yg.Array, _y = Yg.RangeError, Oy = Jg(py), Fy = Jg([].reverse), Dy = uy.pack, My = uy.unpack, Ly = function(e10) {
        return [255 & e10];
      }, zy = function(e10) {
        return [255 & e10, e10 >> 8 & 255];
      }, Py = function(e10) {
        return [255 & e10, e10 >> 8 & 255, e10 >> 16 & 255, e10 >> 24 & 255];
      }, By = function(e10) {
        return e10[3] << 24 | e10[2] << 16 | e10[1] << 8 | e10[0];
      }, Wy = function(e10) {
        return Dy(e10, 23, 4);
      }, Uy = function(e10) {
        return Dy(e10, 52, 8);
      }, Vy = function(e10, t10, n10) {
        ty(e10.prototype, t10, { configurable: true, get: function() {
          return n10(this)[t10];
        } });
      }, Gy = function(e10, t10, n10, r10) {
        var a10 = sy(n10), i10 = wy(e10);
        if (a10 + t10 > i10.byteLength) throw _y(xy);
        var o10 = i10.bytes, s10 = a10 + i10.byteOffset, u10 = fy(o10, s10, s10 + t10);
        return r10 ? u10 : Fy(u10);
      }, jy = function(e10, t10, n10, r10, a10, i10) {
        var o10 = sy(n10), s10 = wy(e10);
        if (o10 + t10 > s10.byteLength) throw _y(xy);
        for (var u10 = s10.bytes, c10 = o10 + s10.byteOffset, l10 = r10(+a10), h10 = 0; h10 < t10; h10++) u10[c10 + h10] = l10[i10 ? h10 : t10 - h10 - 1];
      };
      if (Qg) {
        var Hy = my && Ny.name !== yy;
        if (ry(function() {
          Ny(1);
        }) && ry(function() {
          new Ny(-1);
        }) && !ry(function() {
          return new Ny(), new Ny(1.5), new Ny(NaN), 1 != Ny.length || Hy && !gy;
        })) Hy && gy && ey(Ny, "name", yy);
        else {
          (Sy = function(e10) {
            return ay(this, Ty), new Ny(sy(e10));
          }).prototype = Ty;
          for (var qy, Ky = hy(Ny), Xy = 0; Ky.length > Xy; ) (qy = Ky[Xy++]) in Sy || ey(Sy, qy, Ny[qy]);
          Ty.constructor = Sy;
        }
        ly && cy(Cy) !== Ay && ly(Cy, Ay);
        var Yy = new Ey(new Sy(2)), Jy = Jg(Cy.setInt8);
        Yy.setInt8(0, 2147483648), Yy.setInt8(1, 2147483649), !Yy.getInt8(0) && Yy.getInt8(1) || ny(Cy, { setInt8: function(e10, t10) {
          Jy(this, e10, t10 << 24 >> 24);
        }, setUint8: function(e10, t10) {
          Jy(this, e10, t10 << 24 >> 24);
        } }, { unsafe: true });
      } else Ty = (Sy = function(e10) {
        ay(this, Ty);
        var t10 = sy(e10);
        Iy(this, { type: yy, bytes: Oy(Ry(t10), 0), byteLength: t10 }), Zg || (this.byteLength = t10, this.detached = false);
      }).prototype, Ey = function(e10, t10, n10) {
        ay(this, Cy), ay(e10, Ty);
        var r10 = ky(e10), a10 = r10.byteLength, i10 = iy(t10);
        if (i10 < 0 || i10 > a10) throw _y("Wrong offset");
        if (i10 + (n10 = void 0 === n10 ? a10 - i10 : oy(n10)) > a10) throw _y("Wrong length");
        Iy(this, { type: by, buffer: e10, byteLength: n10, byteOffset: i10, bytes: r10.bytes }), Zg || (this.buffer = e10, this.byteLength = n10, this.byteOffset = i10);
      }, Cy = Ey.prototype, Zg && (Vy(Sy, "byteLength", ky), Vy(Ey, "buffer", wy), Vy(Ey, "byteLength", wy), Vy(Ey, "byteOffset", wy)), ny(Cy, { getInt8: function(e10) {
        return Gy(this, 1, e10)[0] << 24 >> 24;
      }, getUint8: function(e10) {
        return Gy(this, 1, e10)[0];
      }, getInt16: function(e10) {
        var t10 = Gy(this, 2, e10, arguments.length > 1 ? arguments[1] : void 0);
        return (t10[1] << 8 | t10[0]) << 16 >> 16;
      }, getUint16: function(e10) {
        var t10 = Gy(this, 2, e10, arguments.length > 1 ? arguments[1] : void 0);
        return t10[1] << 8 | t10[0];
      }, getInt32: function(e10) {
        return By(Gy(this, 4, e10, arguments.length > 1 ? arguments[1] : void 0));
      }, getUint32: function(e10) {
        return By(Gy(this, 4, e10, arguments.length > 1 ? arguments[1] : void 0)) >>> 0;
      }, getFloat32: function(e10) {
        return My(Gy(this, 4, e10, arguments.length > 1 ? arguments[1] : void 0), 23);
      }, getFloat64: function(e10) {
        return My(Gy(this, 8, e10, arguments.length > 1 ? arguments[1] : void 0), 52);
      }, setInt8: function(e10, t10) {
        jy(this, 1, e10, Ly, t10);
      }, setUint8: function(e10, t10) {
        jy(this, 1, e10, Ly, t10);
      }, setInt16: function(e10, t10) {
        jy(this, 2, e10, zy, t10, arguments.length > 2 ? arguments[2] : void 0);
      }, setUint16: function(e10, t10) {
        jy(this, 2, e10, zy, t10, arguments.length > 2 ? arguments[2] : void 0);
      }, setInt32: function(e10, t10) {
        jy(this, 4, e10, Py, t10, arguments.length > 2 ? arguments[2] : void 0);
      }, setUint32: function(e10, t10) {
        jy(this, 4, e10, Py, t10, arguments.length > 2 ? arguments[2] : void 0);
      }, setFloat32: function(e10, t10) {
        jy(this, 4, e10, Wy, t10, arguments.length > 2 ? arguments[2] : void 0);
      }, setFloat64: function(e10, t10) {
        jy(this, 8, e10, Uy, t10, arguments.length > 2 ? arguments[2] : void 0);
      } });
      dy(Sy, yy), dy(Ey, by);
      var Zy = { ArrayBuffer: Sy, DataView: Ey }, Qy = Fm, $y = "ArrayBuffer", eb = Zy.ArrayBuffer;
      La({ global: true, constructor: true, forced: z.ArrayBuffer !== eb }, { ArrayBuffer: eb }), Qy($y);
      var tb, nb, rb, ab = Og, ib = W, ob = z, sb = xe, ub = Ie, cb = kt, lb = qa, hb = Ke, pb = Cn, fb = Or, db = zi, vb = Ce, mb = Ll, gb = Tc, yb = Mt, bb = Tt, xb = cr.enforce, kb = cr.get, wb = ob.Int8Array, Ib = wb && wb.prototype, Nb = ob.Uint8ClampedArray, Sb = Nb && Nb.prototype, Tb = wb && mb(wb), Eb = Ib && mb(Ib), Cb = Object.prototype, Ab = ob.TypeError, Rb = yb("toStringTag"), _b = bb("TYPED_ARRAY_TAG"), Ob = "TypedArrayConstructor", Fb = ab && !!gb && "Opera" !== lb(ob.opera), Db = false, Mb = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, Lb = { BigInt64Array: 8, BigUint64Array: 8 }, zb = function(e10) {
        if (!ub(e10)) return false;
        var t10 = lb(e10);
        return cb(Mb, t10) || cb(Lb, t10);
      };
      for (tb in Mb) (rb = (nb = ob[tb]) && nb.prototype) ? xb(rb).TypedArrayConstructor = nb : Fb = false;
      for (tb in Lb) (rb = (nb = ob[tb]) && nb.prototype) && (xb(rb).TypedArrayConstructor = nb);
      if ((!Fb || !sb(Tb) || Tb === Function.prototype) && (Tb = function() {
        throw Ab("Incorrect invocation");
      }, Fb)) for (tb in Mb) ob[tb] && gb(ob[tb], Tb);
      if ((!Fb || !Eb || Eb === Cb) && (Eb = Tb.prototype, Fb)) for (tb in Mb) ob[tb] && gb(ob[tb].prototype, Eb);
      if (Fb && mb(Sb) !== Eb && gb(Sb, Eb), ib && !cb(Eb, Rb)) for (tb in Db = true, db(Eb, Rb, { configurable: true, get: function() {
        return ub(this) ? this[_b] : void 0;
      } }), Mb) ob[tb] && pb(ob[tb], _b, tb);
      var Pb = { NATIVE_ARRAY_BUFFER_VIEWS: Fb, TYPED_ARRAY_TAG: Db && _b, aTypedArray: function(e10) {
        if (zb(e10)) return e10;
        throw Ab("Target is not a typed array");
      }, aTypedArrayConstructor: function(e10) {
        if (sb(e10) && (!gb || vb(Tb, e10))) return e10;
        throw Ab(hb(e10) + " is not a typed array constructor");
      }, exportTypedArrayMethod: function(e10, t10, n10, r10) {
        if (ib) {
          if (n10) for (var a10 in Mb) {
            var i10 = ob[a10];
            if (i10 && cb(i10.prototype, e10)) try {
              delete i10.prototype[e10];
            } catch (n11) {
              try {
                i10.prototype[e10] = t10;
              } catch (e11) {
              }
            }
          }
          Eb[e10] && !n10 || fb(Eb, e10, n10 ? t10 : Fb && Ib[e10] || t10, r10);
        }
      }, exportTypedArrayStaticMethod: function(e10, t10, n10) {
        var r10, a10;
        if (ib) {
          if (gb) {
            if (n10) {
              for (r10 in Mb) if ((a10 = ob[r10]) && cb(a10, e10)) try {
                delete a10[e10];
              } catch (e11) {
              }
            }
            if (Tb[e10] && !n10) return;
            try {
              return fb(Tb, e10, n10 ? t10 : Fb && Tb[e10] || t10);
            } catch (e11) {
            }
          }
          for (r10 in Mb) !(a10 = ob[r10]) || a10[e10] && !n10 || fb(a10, e10, t10);
        }
      }, getTypedArrayConstructor: function e10(t10) {
        var n10 = mb(t10);
        if (ub(n10)) {
          var r10 = kb(n10);
          return r10 && cb(r10, Ob) ? r10.TypedArrayConstructor : e10(n10);
        }
      }, isView: function(e10) {
        if (!ub(e10)) return false;
        var t10 = lb(e10);
        return "DataView" === t10 || cb(Mb, t10) || cb(Lb, t10);
      }, isTypedArray: zb, TypedArray: Tb, TypedArrayPrototype: Eb };
      La({ target: "ArrayBuffer", stat: true, forced: !Pb.NATIVE_ARRAY_BUFFER_VIEWS }, { isView: Pb.isView });
      var Bb = No, Wb = Ke, Ub = TypeError, Vb = function(e10) {
        if (Bb(e10)) return e10;
        throw Ub(Wb(e10) + " is not a constructor");
      }, Gb = dn, jb = Vb, Hb = le, qb = Mt("species"), Kb = function(e10, t10) {
        var n10, r10 = Gb(e10).constructor;
        return void 0 === r10 || Hb(n10 = Gb(r10)[qb]) ? t10 : jb(n10);
      }, Xb = La, Yb = ro, Jb = B, Zb = dn, Qb = Vr, $b = Hr, ex = Kb, tx = Zy.ArrayBuffer, nx = Zy.DataView, rx = nx.prototype, ax = Yb(tx.prototype.slice), ix = Yb(rx.getUint8), ox = Yb(rx.setUint8);
      Xb({ target: "ArrayBuffer", proto: true, unsafe: true, forced: Jb(function() {
        return !new tx(2).slice(1, void 0).byteLength;
      }) }, { slice: function(e10, t10) {
        if (ax && void 0 === t10) return ax(Zb(this), e10);
        for (var n10 = Zb(this).byteLength, r10 = Qb(e10, n10), a10 = Qb(void 0 === t10 ? n10 : t10, n10), i10 = new (ex(this, tx))($b(a10 - r10)), o10 = new nx(this), s10 = new nx(i10), u10 = 0; r10 < a10; ) ox(s10, u10++, ix(o10, r10++));
        return i10;
      } }), La({ global: true, constructor: true, forced: !Og }, { DataView: Zy.DataView });
      var sx = La, ux = ee, cx = B(function() {
        return 120 !== (/* @__PURE__ */ new Date(16e11)).getYear();
      }), lx = ux(Date.prototype.getFullYear);
      sx({ target: "Date", proto: true, forced: cx }, { getYear: function() {
        return lx(this) - 1900;
      } });
      var hx = La, px = Date, fx = ee(px.prototype.getTime);
      hx({ target: "Date", stat: true }, { now: function() {
        return fx(new px());
      } });
      var dx = La, vx = ee, mx = Pr, gx = Date.prototype, yx = vx(gx.getTime), bx = vx(gx.setFullYear);
      dx({ target: "Date", proto: true }, { setYear: function(e10) {
        yx(this);
        var t10 = mx(e10);
        return bx(this, 0 <= t10 && t10 <= 99 ? t10 + 1900 : t10);
      } }), La({ target: "Date", proto: true }, { toGMTString: Date.prototype.toUTCString });
      var xx = Pr, kx = Ya, wx = fe, Ix = RangeError, Nx = function(e10) {
        var t10 = kx(wx(this)), n10 = "", r10 = xx(e10);
        if (r10 < 0 || r10 == 1 / 0) throw Ix("Wrong number of repetitions");
        for (; r10 > 0; (r10 >>>= 1) && (t10 += t10)) 1 & r10 && (n10 += t10);
        return n10;
      }, Sx = ee, Tx = Hr, Ex = Ya, Cx = fe, Ax = Sx(Nx), Rx = Sx("".slice), _x = Math.ceil, Ox = function(e10) {
        return function(t10, n10, r10) {
          var a10, i10, o10 = Ex(Cx(t10)), s10 = Tx(n10), u10 = o10.length, c10 = void 0 === r10 ? " " : Ex(r10);
          return s10 <= u10 || "" == c10 ? o10 : ((i10 = Ax(c10, _x((a10 = s10 - u10) / c10.length))).length > a10 && (i10 = Rx(i10, 0, a10)), e10 ? o10 + i10 : i10 + o10);
        };
      }, Fx = { start: Ox(false), end: Ox(true) }, Dx = ee, Mx = B, Lx = Fx.start, zx = RangeError, Px = isFinite, Bx = Math.abs, Wx = Date.prototype, Ux = Wx.toISOString, Vx = Dx(Wx.getTime), Gx = Dx(Wx.getUTCDate), jx = Dx(Wx.getUTCFullYear), Hx = Dx(Wx.getUTCHours), qx = Dx(Wx.getUTCMilliseconds), Kx = Dx(Wx.getUTCMinutes), Xx = Dx(Wx.getUTCMonth), Yx = Dx(Wx.getUTCSeconds), Jx = Mx(function() {
        return "0385-07-25T07:06:39.999Z" != Ux.call(/* @__PURE__ */ new Date(-50000000000001));
      }) || !Mx(function() {
        Ux.call(/* @__PURE__ */ new Date(NaN));
      }) ? function() {
        if (!Px(Vx(this))) throw zx("Invalid time value");
        var e10 = this, t10 = jx(e10), n10 = qx(e10), r10 = t10 < 0 ? "-" : t10 > 9999 ? "+" : "";
        return r10 + Lx(Bx(t10), r10 ? 6 : 4, 0) + "-" + Lx(Xx(e10) + 1, 2, 0) + "-" + Lx(Gx(e10), 2, 0) + "T" + Lx(Hx(e10), 2, 0) + ":" + Lx(Kx(e10), 2, 0) + ":" + Lx(Yx(e10), 2, 0) + "." + Lx(n10, 3, 0) + "Z";
      } : Ux, Zx = Jx;
      La({ target: "Date", proto: true, forced: Date.prototype.toISOString !== Zx }, { toISOString: Zx });
      var Qx = yt, $x = Gt;
      La({ target: "Date", proto: true, arity: 1, forced: B(function() {
        return null !== (/* @__PURE__ */ new Date(NaN)).toJSON() || 1 !== Date.prototype.toJSON.call({ toISOString: function() {
          return 1;
        } });
      }) }, { toJSON: function(e10) {
        var t10 = Qx(this), n10 = $x(t10, "number");
        return "number" != typeof n10 || isFinite(n10) ? t10.toISOString() : null;
      } });
      var ek = dn, tk = it, nk = TypeError, rk = function(e10) {
        if (ek(this), "string" === e10 || "default" === e10) e10 = "string";
        else if ("number" !== e10) throw nk("Incorrect hint");
        return tk(this, e10);
      }, ak = kt, ik = Or, ok = rk, sk = Mt("toPrimitive"), uk = Date.prototype;
      ak(uk, sk) || ik(uk, sk, ok);
      var ck = ee, lk = Or, hk = Date.prototype, pk = "Invalid Date", fk = "toString", dk = ck(hk.toString), vk = ck(hk.getTime);
      String(/* @__PURE__ */ new Date(NaN)) != pk && lk(hk, fk, function() {
        var e10 = vk(this);
        return e10 == e10 ? dk(this) : pk;
      });
      var mk = La, gk = ee, yk = Ya, bk = gk("".charAt), xk = gk("".charCodeAt), kk = gk(/./.exec), wk = gk(1 .toString), Ik = gk("".toUpperCase), Nk = /[\w*+\-./@]/, Sk = function(e10, t10) {
        for (var n10 = wk(e10, 16); n10.length < t10; ) n10 = "0" + n10;
        return n10;
      };
      mk({ global: true }, { escape: function(e10) {
        for (var t10, n10, r10 = yk(e10), a10 = "", i10 = r10.length, o10 = 0; o10 < i10; ) t10 = bk(r10, o10++), kk(Nk, t10) ? a10 += t10 : a10 += (n10 = xk(t10, 0)) < 256 ? "%" + Sk(n10, 2) : "%u" + Ik(Sk(n10, 4));
        return a10;
      } });
      var Tk = ee, Ek = Ze, Ck = Ie, Ak = kt, Rk = du, _k = U, Ok = Function, Fk = Tk([].concat), Dk = Tk([].join), Mk = {}, Lk = function(e10, t10, n10) {
        if (!Ak(Mk, t10)) {
          for (var r10 = [], a10 = 0; a10 < t10; a10++) r10[a10] = "a[" + a10 + "]";
          Mk[t10] = Ok("C,a", "return new C(" + Dk(r10, ",") + ")");
        }
        return Mk[t10](e10, n10);
      }, zk = _k ? Ok.bind : function(e10) {
        var t10 = Ek(this), n10 = t10.prototype, r10 = Rk(arguments, 1), a10 = function() {
          var n11 = Fk(r10, Rk(arguments));
          return this instanceof a10 ? Lk(t10, n11.length, n11) : t10.apply(e10, n11);
        };
        return Ck(n10) && (a10.prototype = n10), a10;
      }, Pk = zk;
      La({ target: "Function", proto: true, forced: Function.bind !== Pk }, { bind: Pk });
      var Bk = xe, Wk = Ie, Uk = cn, Vk = Ll, Gk = Er, jk = Mt("hasInstance"), Hk = Function.prototype;
      jk in Hk || Uk.f(Hk, jk, { value: Gk(function(e10) {
        if (!Bk(this) || !Wk(e10)) return false;
        var t10 = this.prototype;
        if (!Wk(t10)) return e10 instanceof this;
        for (; e10 = Vk(e10); ) if (t10 === e10) return true;
        return false;
      }, jk) });
      var qk = W, Kk = Mn.EXISTS, Xk = ee, Yk = zi, Jk = Function.prototype, Zk = Xk(Jk.toString), Qk = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/, $k = Xk(Qk.exec);
      qk && !Kk && Yk(Jk, "name", { configurable: true, get: function() {
        try {
          return $k(Qk, Zk(this))[1];
        } catch (e10) {
          return "";
        }
      } });
      var ew = z;
      La({ global: true, forced: ew.globalThis !== ew }, { globalThis: ew }), eo(z.JSON, "JSON", true);
      var tw = { exports: {} }, nw = B(function() {
        if ("function" == typeof ArrayBuffer) {
          var e10 = new ArrayBuffer(8);
          Object.isExtensible(e10) && Object.defineProperty(e10, "a", { value: 8 });
        }
      }), rw = B, aw = Ie, iw = ae, ow = nw, sw = Object.isExtensible, uw = rw(function() {
        sw(1);
      }) || ow ? function(e10) {
        return !!aw(e10) && ((!ow || "ArrayBuffer" != iw(e10)) && (!sw || sw(e10)));
      } : sw, cw = !B(function() {
        return Object.isExtensible(Object.preventExtensions({}));
      }), lw = (tw.exports, La), hw = ee, pw = Yn, fw = Ie, dw = kt, vw = cn.f, mw = Fr, gw = bi, yw = uw, bw = cw, xw = false, kw = Tt("meta"), ww = 0, Iw = function(e10) {
        vw(e10, kw, { value: { objectID: "O" + ww++, weakData: {} } });
      }, Nw = tw.exports = { enable: function() {
        Nw.enable = function() {
        }, xw = true;
        var e10 = mw.f, t10 = hw([].splice), n10 = {};
        n10[kw] = 1, e10(n10).length && (mw.f = function(n11) {
          for (var r10 = e10(n11), a10 = 0, i10 = r10.length; a10 < i10; a10++) if (r10[a10] === kw) {
            t10(r10, a10, 1);
            break;
          }
          return r10;
        }, lw({ target: "Object", stat: true, forced: true }, { getOwnPropertyNames: gw.f }));
      }, fastKey: function(e10, t10) {
        if (!fw(e10)) return "symbol" == s(e10) ? e10 : ("string" == typeof e10 ? "S" : "P") + e10;
        if (!dw(e10, kw)) {
          if (!yw(e10)) return "F";
          if (!t10) return "E";
          Iw(e10);
        }
        return e10[kw].objectID;
      }, getWeakData: function(e10, t10) {
        if (!dw(e10, kw)) {
          if (!yw(e10)) return true;
          if (!t10) return false;
          Iw(e10);
        }
        return e10[kw].weakData;
      }, onFreeze: function(e10) {
        return bw && xw && yw(e10) && !dw(e10, kw) && Iw(e10), e10;
      } };
      pw[kw] = true;
      var Sw = tw.exports, Tw = La, Ew = z, Cw = ee, Aw = Ca, Rw = Or, _w = Sw, Ow = yh, Fw = zg, Dw = xe, Mw = le, Lw = Ie, zw = B, Pw = Uf, Bw = eo, Ww = Oc, Uw = function(e10, t10, n10) {
        var r10 = -1 !== e10.indexOf("Map"), a10 = -1 !== e10.indexOf("Weak"), i10 = r10 ? "set" : "add", o10 = Ew[e10], s10 = o10 && o10.prototype, u10 = o10, c10 = {}, l10 = function(e11) {
          var t11 = Cw(s10[e11]);
          Rw(s10, e11, "add" == e11 ? function(e12) {
            return t11(this, 0 === e12 ? 0 : e12), this;
          } : "delete" == e11 ? function(e12) {
            return !(a10 && !Lw(e12)) && t11(this, 0 === e12 ? 0 : e12);
          } : "get" == e11 ? function(e12) {
            return a10 && !Lw(e12) ? void 0 : t11(this, 0 === e12 ? 0 : e12);
          } : "has" == e11 ? function(e12) {
            return !(a10 && !Lw(e12)) && t11(this, 0 === e12 ? 0 : e12);
          } : function(e12, n11) {
            return t11(this, 0 === e12 ? 0 : e12, n11), this;
          });
        };
        if (Aw(e10, !Dw(o10) || !(a10 || s10.forEach && !zw(function() {
          new o10().entries().next();
        })))) u10 = n10.getConstructor(t10, e10, r10, i10), _w.enable();
        else if (Aw(e10, true)) {
          var h10 = new u10(), p10 = h10[i10](a10 ? {} : -0, 1) != h10, f10 = zw(function() {
            h10.has(1);
          }), d10 = Pw(function(e11) {
            new o10(e11);
          }), v10 = !a10 && zw(function() {
            for (var e11 = new o10(), t11 = 5; t11--; ) e11[i10](t11, t11);
            return !e11.has(-0);
          });
          d10 || ((u10 = t10(function(e11, t11) {
            Fw(e11, s10);
            var n11 = Ww(new o10(), e11, u10);
            return Mw(t11) || Ow(t11, n11[i10], { that: n11, AS_ENTRIES: r10 }), n11;
          })).prototype = s10, s10.constructor = u10), (f10 || v10) && (l10("delete"), l10("has"), r10 && l10("get")), (v10 || p10) && l10(i10), a10 && s10.clear && delete s10.clear;
        }
        return c10[e10] = u10, Tw({ global: true, constructor: true, forced: u10 != o10 }, c10), Bw(u10, e10), a10 || n10.setStrong(u10, e10, r10), u10;
      }, Vw = yi, Gw = zi, jw = Dg, Hw = so, qw = zg, Kw = le, Xw = yh, Yw = Dd, Jw = Md, Zw = Fm, Qw = W, $w = Sw.fastKey, eI = cr.set, tI = cr.getterFor, nI = { getConstructor: function(e10, t10, n10, r10) {
        var a10 = e10(function(e11, a11) {
          qw(e11, i10), eI(e11, { type: t10, index: Vw(null), first: void 0, last: void 0, size: 0 }), Qw || (e11.size = 0), Kw(a11) || Xw(a11, e11[r10], { that: e11, AS_ENTRIES: n10 });
        }), i10 = a10.prototype, o10 = tI(t10), s10 = function(e11, t11, n11) {
          var r11, a11, i11 = o10(e11), s11 = u10(e11, t11);
          return s11 ? s11.value = n11 : (i11.last = s11 = { index: a11 = $w(t11, true), key: t11, value: n11, previous: r11 = i11.last, next: void 0, removed: false }, i11.first || (i11.first = s11), r11 && (r11.next = s11), Qw ? i11.size++ : e11.size++, "F" !== a11 && (i11.index[a11] = s11)), e11;
        }, u10 = function(e11, t11) {
          var n11, r11 = o10(e11), a11 = $w(t11);
          if ("F" !== a11) return r11.index[a11];
          for (n11 = r11.first; n11; n11 = n11.next) if (n11.key == t11) return n11;
        };
        return jw(i10, { clear: function() {
          for (var e11 = o10(this), t11 = e11.index, n11 = e11.first; n11; ) n11.removed = true, n11.previous && (n11.previous = n11.previous.next = void 0), delete t11[n11.index], n11 = n11.next;
          e11.first = e11.last = void 0, Qw ? e11.size = 0 : this.size = 0;
        }, delete: function(e11) {
          var t11 = this, n11 = o10(t11), r11 = u10(t11, e11);
          if (r11) {
            var a11 = r11.next, i11 = r11.previous;
            delete n11.index[r11.index], r11.removed = true, i11 && (i11.next = a11), a11 && (a11.previous = i11), n11.first == r11 && (n11.first = a11), n11.last == r11 && (n11.last = i11), Qw ? n11.size-- : t11.size--;
          }
          return !!r11;
        }, forEach: function(e11) {
          for (var t11, n11 = o10(this), r11 = Hw(e11, arguments.length > 1 ? arguments[1] : void 0); t11 = t11 ? t11.next : n11.first; ) for (r11(t11.value, t11.key, this); t11 && t11.removed; ) t11 = t11.previous;
        }, has: function(e11) {
          return !!u10(this, e11);
        } }), jw(i10, n10 ? { get: function(e11) {
          var t11 = u10(this, e11);
          return t11 && t11.value;
        }, set: function(e11, t11) {
          return s10(this, 0 === e11 ? 0 : e11, t11);
        } } : { add: function(e11) {
          return s10(this, e11 = 0 === e11 ? 0 : e11, e11);
        } }), Qw && Gw(i10, "size", { configurable: true, get: function() {
          return o10(this).size;
        } }), a10;
      }, setStrong: function(e10, t10, n10) {
        var r10 = t10 + " Iterator", a10 = tI(t10), i10 = tI(r10);
        Yw(e10, t10, function(e11, t11) {
          eI(this, { type: r10, target: e11, state: a10(e11), kind: t11, last: void 0 });
        }, function() {
          for (var e11 = i10(this), t11 = e11.kind, n11 = e11.last; n11 && n11.removed; ) n11 = n11.previous;
          return e11.target && (e11.last = n11 = n11 ? n11.next : e11.state.first) ? Jw("keys" == t11 ? n11.key : "values" == t11 ? n11.value : [n11.key, n11.value], false) : (e11.target = void 0, Jw(void 0, true));
        }, n10 ? "entries" : "values", !n10, true), Zw(t10);
      } };
      Uw("Map", function(e10) {
        return function() {
          return e10(this, arguments.length ? arguments[0] : void 0);
        };
      }, nI);
      var rI = Math.log, aI = Math.log1p || function(e10) {
        var t10 = +e10;
        return t10 > -1e-8 && t10 < 1e-8 ? t10 - t10 * t10 / 2 : rI(1 + t10);
      }, iI = La, oI = aI, sI = Math.acosh, uI = Math.log, cI = Math.sqrt, lI = Math.LN2;
      iI({ target: "Math", stat: true, forced: !sI || 710 != Math.floor(sI(Number.MAX_VALUE)) || sI(1 / 0) != 1 / 0 }, { acosh: function(e10) {
        var t10 = +e10;
        return t10 < 1 ? NaN : t10 > 9490626562425156e-8 ? uI(t10) + lI : oI(t10 - 1 + cI(t10 - 1) * cI(t10 + 1));
      } });
      var hI = La, pI = Math.asinh, fI = Math.log, dI = Math.sqrt;
      hI({ target: "Math", stat: true, forced: !(pI && 1 / pI(0) > 0) }, { asinh: function e10(t10) {
        var n10 = +t10;
        return isFinite(n10) && 0 != n10 ? n10 < 0 ? -e10(-n10) : fI(n10 + dI(n10 * n10 + 1)) : n10;
      } });
      var vI = La, mI = Math.atanh, gI = Math.log;
      vI({ target: "Math", stat: true, forced: !(mI && 1 / mI(-0) < 0) }, { atanh: function(e10) {
        var t10 = +e10;
        return 0 == t10 ? t10 : gI((1 + t10) / (1 - t10)) / 2;
      } });
      var yI = Math.sign || function(e10) {
        var t10 = +e10;
        return 0 == t10 || t10 != t10 ? t10 : t10 < 0 ? -1 : 1;
      }, bI = La, xI = yI, kI = Math.abs, wI = Math.pow;
      bI({ target: "Math", stat: true }, { cbrt: function(e10) {
        var t10 = +e10;
        return xI(t10) * wI(kI(t10), 1 / 3);
      } });
      var II = La, NI = Math.floor, SI = Math.log, TI = Math.LOG2E;
      II({ target: "Math", stat: true }, { clz32: function(e10) {
        var t10 = e10 >>> 0;
        return t10 ? 31 - NI(SI(t10 + 0.5) * TI) : 32;
      } });
      var EI = Math.expm1, CI = Math.exp, AI = !EI || EI(10) > 22025.465794806718 || EI(10) < 22025.465794806718 || -2e-17 != EI(-2e-17) ? function(e10) {
        var t10 = +e10;
        return 0 == t10 ? t10 : t10 > -1e-6 && t10 < 1e-6 ? t10 + t10 * t10 / 2 : CI(t10) - 1;
      } : EI, RI = La, _I = AI, OI = Math.cosh, FI = Math.abs, DI = Math.E;
      RI({ target: "Math", stat: true, forced: !OI || OI(710) === 1 / 0 }, { cosh: function(e10) {
        var t10 = _I(FI(e10) - 1) + 1;
        return (t10 + 1 / (t10 * DI * DI)) * (DI / 2);
      } });
      var MI = AI;
      La({ target: "Math", stat: true, forced: MI != Math.expm1 }, { expm1: MI });
      var LI = yI, zI = Math.abs, PI = Math.pow, BI = PI(2, -52), WI = PI(2, -23), UI = PI(2, 127) * (2 - WI), VI = PI(2, -126), GI = Math.fround || function(e10) {
        var t10, n10, r10 = +e10, a10 = zI(r10), i10 = LI(r10);
        return a10 < VI ? i10 * function(e11) {
          return e11 + 1 / BI - 1 / BI;
        }(a10 / VI / WI) * VI * WI : (n10 = (t10 = (1 + WI / BI) * a10) - (t10 - a10)) > UI || n10 != n10 ? i10 * (1 / 0) : i10 * n10;
      };
      La({ target: "Math", stat: true }, { fround: GI });
      var jI = La, HI = Math.hypot, qI = Math.abs, KI = Math.sqrt;
      jI({ target: "Math", stat: true, arity: 2, forced: !!HI && HI(1 / 0, NaN) !== 1 / 0 }, { hypot: function(e10, t10) {
        for (var n10, r10, a10 = 0, i10 = 0, o10 = arguments.length, s10 = 0; i10 < o10; ) s10 < (n10 = qI(arguments[i10++])) ? (a10 = a10 * (r10 = s10 / n10) * r10 + 1, s10 = n10) : a10 += n10 > 0 ? (r10 = n10 / s10) * r10 : n10;
        return s10 === 1 / 0 ? 1 / 0 : s10 * KI(a10);
      } });
      var XI = La, YI = B, JI = Math.imul;
      XI({ target: "Math", stat: true, forced: YI(function() {
        return -5 != JI(4294967295, 5) || 2 != JI.length;
      }) }, { imul: function(e10, t10) {
        var n10 = 65535, r10 = +e10, a10 = +t10, i10 = n10 & r10, o10 = n10 & a10;
        return 0 | i10 * o10 + ((n10 & r10 >>> 16) * o10 + i10 * (n10 & a10 >>> 16) << 16 >>> 0);
      } });
      var ZI = Math.log, QI = Math.LOG10E, $I = Math.log10 || function(e10) {
        return ZI(e10) * QI;
      };
      La({ target: "Math", stat: true }, { log10: $I }), La({ target: "Math", stat: true }, { log1p: aI });
      var eN = La, tN = Math.log, nN = Math.LN2;
      eN({ target: "Math", stat: true }, { log2: function(e10) {
        return tN(e10) / nN;
      } }), La({ target: "Math", stat: true }, { sign: yI });
      var rN = La, aN = B, iN = AI, oN = Math.abs, sN = Math.exp, uN = Math.E;
      rN({ target: "Math", stat: true, forced: aN(function() {
        return -2e-17 != Math.sinh(-2e-17);
      }) }, { sinh: function(e10) {
        var t10 = +e10;
        return oN(t10) < 1 ? (iN(t10) - iN(-t10)) / 2 : (sN(t10 - 1) - sN(-t10 - 1)) * (uN / 2);
      } });
      var cN = La, lN = AI, hN = Math.exp;
      cN({ target: "Math", stat: true }, { tanh: function(e10) {
        var t10 = +e10, n10 = lN(t10), r10 = lN(-t10);
        return n10 == 1 / 0 ? 1 : r10 == 1 / 0 ? -1 : (n10 - r10) / (hN(t10) + hN(-t10));
      } }), eo(Math, "Math", true), La({ target: "Math", stat: true }, { trunc: Lr });
      var pN = ee(1 .valueOf), fN = "	\n\v\f\r                　\u2028\u2029\uFEFF", dN = fe, vN = Ya, mN = fN, gN = ee("".replace), yN = RegExp("^[" + mN + "]+"), bN = RegExp("(^|[^" + mN + "])[" + mN + "]+$"), xN = function(e10) {
        return function(t10) {
          var n10 = vN(dN(t10));
          return 1 & e10 && (n10 = gN(n10, yN, "")), 2 & e10 && (n10 = gN(n10, bN, "$1")), n10;
        };
      }, kN = { start: xN(1), end: xN(2), trim: xN(3) }, wN = La, IN = st, NN = W, SN = z, TN = Wi, EN = ee, CN = Ca, AN = kt, RN = Oc, _N = Ce, ON = He, FN = Gt, DN = B, MN = Fr.f, LN = P.f, zN = cn.f, PN = pN, BN = kN.trim, WN = "Number", UN = SN.Number, VN = (TN.Number, UN.prototype), GN = SN.TypeError, jN = EN("".slice), HN = EN("".charCodeAt), qN = function(e10) {
        var t10 = FN(e10, "number");
        return "bigint" == typeof t10 ? t10 : KN(t10);
      }, KN = function(e10) {
        var t10, n10, r10, a10, i10, o10, s10, u10, c10 = FN(e10, "number");
        if (ON(c10)) throw GN("Cannot convert a Symbol value to a number");
        if ("string" == typeof c10 && c10.length > 2) {
          if (c10 = BN(c10), 43 === (t10 = HN(c10, 0)) || 45 === t10) {
            if (88 === (n10 = HN(c10, 2)) || 120 === n10) return NaN;
          } else if (48 === t10) {
            switch (HN(c10, 1)) {
              case 66:
              case 98:
                r10 = 2, a10 = 49;
                break;
              case 79:
              case 111:
                r10 = 8, a10 = 55;
                break;
              default:
                return +c10;
            }
            for (o10 = (i10 = jN(c10, 2)).length, s10 = 0; s10 < o10; s10++) if ((u10 = HN(i10, s10)) < 48 || u10 > a10) return NaN;
            return parseInt(i10, r10);
          }
        }
        return +c10;
      }, XN = CN(WN, !UN(" 0o1") || !UN("0b1") || UN("+0x1")), YN = function(e10) {
        return _N(VN, e10) && DN(function() {
          PN(e10);
        });
      }, JN = function(e10) {
        var t10 = arguments.length < 1 ? 0 : UN(qN(e10));
        return YN(this) ? RN(Object(t10), this, JN) : t10;
      };
      JN.prototype = VN, XN && (VN.constructor = JN), wN({ global: true, constructor: true, wrap: true, forced: XN }, { Number: JN });
      var ZN = function(e10, t10) {
        for (var n10, r10 = NN ? MN(t10) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","), a10 = 0; r10.length > a10; a10++) AN(t10, n10 = r10[a10]) && !AN(e10, n10) && zN(e10, n10, LN(t10, n10));
      };
      XN && ZN(TN.Number, UN), La({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, { EPSILON: Math.pow(2, -52) });
      var QN = z.isFinite, $N = Number.isFinite || function(e10) {
        return "number" == typeof e10 && QN(e10);
      };
      La({ target: "Number", stat: true }, { isFinite: $N });
      var eS = Ie, tS = Math.floor, nS = Number.isInteger || function(e10) {
        return !eS(e10) && isFinite(e10) && tS(e10) === e10;
      };
      La({ target: "Number", stat: true }, { isInteger: nS }), La({ target: "Number", stat: true }, { isNaN: function(e10) {
        return e10 != e10;
      } });
      var rS = La, aS = nS, iS = Math.abs;
      rS({ target: "Number", stat: true }, { isSafeInteger: function(e10) {
        return aS(e10) && iS(e10) <= 9007199254740991;
      } }), La({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, { MAX_SAFE_INTEGER: 9007199254740991 }), La({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, { MIN_SAFE_INTEGER: -9007199254740991 });
      var oS = z, sS = B, uS = Ya, cS = kN.trim, lS = ee("".charAt), hS = oS.parseFloat, pS = oS.Symbol, fS = pS && pS.iterator, dS = 1 / hS("	\n\v\f\r                　\u2028\u2029\uFEFF-0") != -1 / 0 || fS && !sS(function() {
        hS(Object(fS));
      }) ? function(e10) {
        var t10 = cS(uS(e10)), n10 = hS(t10);
        return 0 === n10 && "-" == lS(t10, 0) ? -0 : n10;
      } : hS, vS = dS;
      La({ target: "Number", stat: true, forced: Number.parseFloat != vS }, { parseFloat: vS });
      var mS = z, gS = B, yS = ee, bS = Ya, xS = kN.trim, kS = fN, wS = mS.parseInt, IS = mS.Symbol, NS = IS && IS.iterator, SS = /^[+-]?0x/i, TS = yS(SS.exec), ES = 8 !== wS(kS + "08") || 22 !== wS(kS + "0x16") || NS && !gS(function() {
        wS(Object(NS));
      }) ? function(e10, t10) {
        var n10 = xS(bS(e10));
        return wS(n10, t10 >>> 0 || (TS(SS, n10) ? 16 : 10));
      } : wS, CS = ES;
      La({ target: "Number", stat: true, forced: Number.parseInt != CS }, { parseInt: CS });
      var AS = La, RS = ee, _S = Pr, OS = pN, FS = Nx, DS = $I, MS = B, LS = RangeError, zS = String, PS = isFinite, BS = Math.abs, WS = Math.floor, US = Math.pow, VS = Math.round, GS = RS(1 .toExponential), jS = RS(FS), HS = RS("".slice), qS = "-6.9000e-11" === GS(-69e-12, 4) && "1.25e+0" === GS(1.255, 2) && "1.235e+4" === GS(12345, 3) && "3e+1" === GS(25, 0);
      AS({ target: "Number", proto: true, forced: !qS || !(MS(function() {
        GS(1, 1 / 0);
      }) && MS(function() {
        GS(1, -1 / 0);
      })) || !!MS(function() {
        GS(1 / 0, 1 / 0), GS(NaN, 1 / 0);
      }) }, { toExponential: function(e10) {
        var t10 = OS(this);
        if (void 0 === e10) return GS(t10);
        var n10 = _S(e10);
        if (!PS(t10)) return String(t10);
        if (n10 < 0 || n10 > 20) throw LS("Incorrect fraction digits");
        if (qS) return GS(t10, n10);
        var r10 = "", a10 = "", i10 = 0, o10 = "", s10 = "";
        if (t10 < 0 && (r10 = "-", t10 = -t10), 0 === t10) i10 = 0, a10 = jS("0", n10 + 1);
        else {
          var u10 = DS(t10);
          i10 = WS(u10);
          var c10 = 0, l10 = US(10, i10 - n10);
          2 * t10 >= (2 * (c10 = VS(t10 / l10)) + 1) * l10 && (c10 += 1), c10 >= US(10, n10 + 1) && (c10 /= 10, i10 += 1), a10 = zS(c10);
        }
        return 0 !== n10 && (a10 = HS(a10, 0, 1) + "." + HS(a10, 1)), 0 === i10 ? (o10 = "+", s10 = "0") : (o10 = i10 > 0 ? "+" : "-", s10 = zS(BS(i10))), r10 + (a10 += "e" + o10 + s10);
      } });
      var KS = La, XS = ee, YS = Pr, JS = pN, ZS = Nx, QS = B, $S = RangeError, eT = String, tT = Math.floor, nT = XS(ZS), rT = XS("".slice), aT = XS(1 .toFixed), iT = function e10(t10, n10, r10) {
        return 0 === n10 ? r10 : n10 % 2 == 1 ? e10(t10, n10 - 1, r10 * t10) : e10(t10 * t10, n10 / 2, r10);
      }, oT = function(e10, t10, n10) {
        for (var r10 = -1, a10 = n10; ++r10 < 6; ) a10 += t10 * e10[r10], e10[r10] = a10 % 1e7, a10 = tT(a10 / 1e7);
      }, sT = function(e10, t10) {
        for (var n10 = 6, r10 = 0; --n10 >= 0; ) r10 += e10[n10], e10[n10] = tT(r10 / t10), r10 = r10 % t10 * 1e7;
      }, uT = function(e10) {
        for (var t10 = 6, n10 = ""; --t10 >= 0; ) if ("" !== n10 || 0 === t10 || 0 !== e10[t10]) {
          var r10 = eT(e10[t10]);
          n10 = "" === n10 ? r10 : n10 + nT("0", 7 - r10.length) + r10;
        }
        return n10;
      };
      KS({ target: "Number", proto: true, forced: QS(function() {
        return "0.000" !== aT(8e-5, 3) || "1" !== aT(0.9, 0) || "1.25" !== aT(1.255, 2) || "1000000000000000128" !== aT(1000000000000000100, 0);
      }) || !QS(function() {
        aT({});
      }) }, { toFixed: function(e10) {
        var t10, n10, r10, a10, i10 = JS(this), o10 = YS(e10), s10 = [0, 0, 0, 0, 0, 0], u10 = "", c10 = "0";
        if (o10 < 0 || o10 > 20) throw $S("Incorrect fraction digits");
        if (i10 != i10) return "NaN";
        if (i10 <= -1e21 || i10 >= 1e21) return eT(i10);
        if (i10 < 0 && (u10 = "-", i10 = -i10), i10 > 1e-21) if (n10 = (t10 = function(e11) {
          for (var t11 = 0, n11 = e11; n11 >= 4096; ) t11 += 12, n11 /= 4096;
          for (; n11 >= 2; ) t11 += 1, n11 /= 2;
          return t11;
        }(i10 * iT(2, 69, 1)) - 69) < 0 ? i10 * iT(2, -t10, 1) : i10 / iT(2, t10, 1), n10 *= 4503599627370496, (t10 = 52 - t10) > 0) {
          for (oT(s10, 0, n10), r10 = o10; r10 >= 7; ) oT(s10, 1e7, 0), r10 -= 7;
          for (oT(s10, iT(10, r10, 1), 0), r10 = t10 - 1; r10 >= 23; ) sT(s10, 1 << 23), r10 -= 23;
          sT(s10, 1 << r10), oT(s10, 1, 1), sT(s10, 2), c10 = uT(s10);
        } else oT(s10, 0, n10), oT(s10, 1 << -t10, 0), c10 = uT(s10) + nT("0", o10);
        return c10 = o10 > 0 ? u10 + ((a10 = c10.length) <= o10 ? "0." + nT("0", o10 - a10) + c10 : rT(c10, 0, a10 - o10) + "." + rT(c10, a10 - o10)) : u10 + c10;
      } });
      var cT = La, lT = B, hT = pN, pT = ee(1 .toPrecision);
      cT({ target: "Number", proto: true, forced: lT(function() {
        return "1" !== pT(1, void 0);
      }) || !lT(function() {
        pT({});
      }) }, { toPrecision: function(e10) {
        return void 0 === e10 ? pT(hT(this)) : pT(hT(this), e10);
      } });
      var fT = W, dT = ee, vT = j, mT = B, gT = $a, yT = ua, bT = H, xT = yt, kT = ce, wT = Object.assign, IT = Object.defineProperty, NT = dT([].concat), ST = !wT || mT(function() {
        if (fT && 1 !== wT({ b: 1 }, wT(IT({}, "a", { enumerable: true, get: function() {
          IT(this, "b", { value: 3, enumerable: false });
        } }), { b: 2 })).b) return true;
        var e10 = {}, t10 = {}, n10 = Symbol(), r10 = "abcdefghijklmnopqrst";
        return e10[n10] = 7, r10.split("").forEach(function(e11) {
          t10[e11] = e11;
        }), 7 != wT({}, e10)[n10] || gT(wT({}, t10)).join("") != r10;
      }) ? function(e10, t10) {
        for (var n10 = xT(e10), r10 = arguments.length, a10 = 1, i10 = yT.f, o10 = bT.f; r10 > a10; ) for (var s10, u10 = kT(arguments[a10++]), c10 = i10 ? NT(gT(u10), i10(u10)) : gT(u10), l10 = c10.length, h10 = 0; l10 > h10; ) s10 = c10[h10++], fT && !vT(o10, u10, s10) || (n10[s10] = u10[s10]);
        return n10;
      } : wT, TT = ST;
      La({ target: "Object", stat: true, arity: 2, forced: Object.assign !== TT }, { assign: TT }), La({ target: "Object", stat: true, sham: !W }, { create: yi });
      var ET = z, CT = sm, AT = !B(function() {
        if (!(CT && CT < 535)) {
          var e10 = Math.random();
          __defineSetter__.call(null, e10, function() {
          }), delete ET[e10];
        }
      }), RT = Ze, _T = yt, OT = cn;
      W && La({ target: "Object", proto: true, forced: AT }, { __defineGetter__: function(e10, t10) {
        OT.f(_T(this), e10, { get: RT(t10), enumerable: true, configurable: true });
      } });
      var FT = La, DT = W, MT = Ja.f;
      FT({ target: "Object", stat: true, forced: Object.defineProperties !== MT, sham: !DT }, { defineProperties: MT });
      var LT = La, zT = W, PT = cn.f;
      LT({ target: "Object", stat: true, forced: Object.defineProperty !== PT, sham: !zT }, { defineProperty: PT });
      var BT = Ze, WT = yt, UT = cn;
      W && La({ target: "Object", proto: true, forced: AT }, { __defineSetter__: function(e10, t10) {
        UT.f(WT(this), e10, { set: BT(t10), enumerable: true, configurable: true });
      } });
      var VT = W, GT = ee, jT = $a, HT = me, qT = GT(H.f), KT = GT([].push), XT = function(e10) {
        return function(t10) {
          for (var n10, r10 = HT(t10), a10 = jT(r10), i10 = a10.length, o10 = 0, s10 = []; i10 > o10; ) n10 = a10[o10++], VT && !qT(r10, n10) || KT(s10, e10 ? [n10, r10[n10]] : r10[n10]);
          return s10;
        };
      }, YT = { entries: XT(true), values: XT(false) }, JT = YT.entries;
      La({ target: "Object", stat: true }, { entries: function(e10) {
        return JT(e10);
      } });
      var ZT = La, QT = cw, $T = B, eE = Ie, tE = Sw.onFreeze, nE = Object.freeze;
      ZT({ target: "Object", stat: true, forced: $T(function() {
        nE(1);
      }), sham: !QT }, { freeze: function(e10) {
        return nE && eE(e10) ? nE(tE(e10)) : e10;
      } });
      var rE = yh, aE = Ii;
      La({ target: "Object", stat: true }, { fromEntries: function(e10) {
        var t10 = {};
        return rE(e10, function(e11, n10) {
          aE(t10, e11, n10);
        }, { AS_ENTRIES: true }), t10;
      } });
      var iE = La, oE = B, sE = me, uE = P.f, cE = W;
      iE({ target: "Object", stat: true, forced: !cE || oE(function() {
        uE(1);
      }), sham: !cE }, { getOwnPropertyDescriptor: function(e10, t10) {
        return uE(sE(e10), t10);
      } });
      var lE = da, hE = me, pE = P, fE = Ii;
      La({ target: "Object", stat: true, sham: !W }, { getOwnPropertyDescriptors: function(e10) {
        for (var t10, n10, r10 = hE(e10), a10 = pE.f, i10 = lE(r10), o10 = {}, s10 = 0; i10.length > s10; ) void 0 !== (n10 = a10(r10, t10 = i10[s10++])) && fE(o10, t10, n10);
        return o10;
      } });
      var dE = La, vE = B, mE = bi.f;
      dE({ target: "Object", stat: true, forced: vE(function() {
        return !Object.getOwnPropertyNames(1);
      }) }, { getOwnPropertyNames: mE });
      var gE = yt, yE = Ll, bE = Cl;
      La({ target: "Object", stat: true, forced: B(function() {
        yE(1);
      }), sham: !bE }, { getPrototypeOf: function(e10) {
        return yE(gE(e10));
      } }), La({ target: "Object", stat: true }, { hasOwn: kt });
      var xE = Object.is || function(e10, t10) {
        return e10 === t10 ? 0 !== e10 || 1 / e10 == 1 / t10 : e10 != e10 && t10 != t10;
      };
      La({ target: "Object", stat: true }, { is: xE });
      var kE = uw;
      La({ target: "Object", stat: true, forced: Object.isExtensible !== kE }, { isExtensible: kE });
      var wE = La, IE = B, NE = Ie, SE = ae, TE = nw, EE = Object.isFrozen;
      wE({ target: "Object", stat: true, forced: TE || IE(function() {
        EE(1);
      }) }, { isFrozen: function(e10) {
        return !NE(e10) || (!(!TE || "ArrayBuffer" != SE(e10)) || !!EE && EE(e10));
      } });
      var CE = La, AE = B, RE = Ie, _E = ae, OE = nw, FE = Object.isSealed;
      CE({ target: "Object", stat: true, forced: OE || AE(function() {
        FE(1);
      }) }, { isSealed: function(e10) {
        return !RE(e10) || (!(!OE || "ArrayBuffer" != _E(e10)) || !!FE && FE(e10));
      } });
      var DE = yt, ME = $a;
      La({ target: "Object", stat: true, forced: B(function() {
        ME(1);
      }) }, { keys: function(e10) {
        return ME(DE(e10));
      } });
      var LE = La, zE = W, PE = AT, BE = yt, WE = qt, UE = Ll, VE = P.f;
      zE && LE({ target: "Object", proto: true, forced: PE }, { __lookupGetter__: function(e10) {
        var t10, n10 = BE(this), r10 = WE(e10);
        do {
          if (t10 = VE(n10, r10)) return t10.get;
        } while (n10 = UE(n10));
      } });
      var GE = La, jE = W, HE = AT, qE = yt, KE = qt, XE = Ll, YE = P.f;
      jE && GE({ target: "Object", proto: true, forced: HE }, { __lookupSetter__: function(e10) {
        var t10, n10 = qE(this), r10 = KE(e10);
        do {
          if (t10 = YE(n10, r10)) return t10.set;
        } while (n10 = XE(n10));
      } });
      var JE = La, ZE = Ie, QE = Sw.onFreeze, $E = cw, eC = B, tC = Object.preventExtensions;
      JE({ target: "Object", stat: true, forced: eC(function() {
        tC(1);
      }), sham: !$E }, { preventExtensions: function(e10) {
        return tC && ZE(e10) ? tC(QE(e10)) : e10;
      } });
      var nC = W, rC = zi, aC = Ie, iC = yt, oC = fe, sC = Object.getPrototypeOf, uC = Object.setPrototypeOf, cC = Object.prototype, lC = "__proto__";
      if (nC && sC && uC && !(lC in cC)) try {
        rC(cC, lC, { configurable: true, get: function() {
          return sC(iC(this));
        }, set: function(e10) {
          var t10 = oC(this);
          (aC(e10) || null === e10) && aC(t10) && uC(t10, e10);
        } });
      } catch (e10) {
      }
      var hC = La, pC = Ie, fC = Sw.onFreeze, dC = cw, vC = B, mC = Object.seal;
      hC({ target: "Object", stat: true, forced: vC(function() {
        mC(1);
      }), sham: !dC }, { seal: function(e10) {
        return mC && pC(e10) ? mC(fC(e10)) : e10;
      } }), La({ target: "Object", stat: true }, { setPrototypeOf: Tc });
      var gC = qa, yC = Ba ? {}.toString : function() {
        return "[object " + gC(this) + "]";
      }, bC = yC;
      Ba || Or(Object.prototype, "toString", bC, { unsafe: true });
      var xC = YT.values;
      La({ target: "Object", stat: true }, { values: function(e10) {
        return xC(e10);
      } });
      La({ global: true, forced: parseFloat != dS }, { parseFloat: dS });
      La({ global: true, forced: parseInt != ES }, { parseInt: ES });
      var kC, wC, IC, NC, SC = TypeError, TC = function(e10, t10) {
        if (e10 < t10) throw SC("Not enough arguments");
        return e10;
      }, EC = /(?:ipad|iphone|ipod).*applewebkit/i.test(Ae), CC = z, AC = fu, RC = so, _C = xe, OC = kt, FC = B, DC = oi, MC = du, LC = Jt, zC = TC, PC = EC, BC = Rv, WC = CC.setImmediate, UC = CC.clearImmediate, VC = CC.process, GC = CC.Dispatch, jC = CC.Function, HC = CC.MessageChannel, qC = CC.String, KC = 0, XC = {}, YC = "onreadystatechange";
      FC(function() {
        kC = CC.location;
      });
      var JC = function(e10) {
        if (OC(XC, e10)) {
          var t10 = XC[e10];
          delete XC[e10], t10();
        }
      }, ZC = function(e10) {
        return function() {
          JC(e10);
        };
      }, QC = function(e10) {
        JC(e10.data);
      }, $C = function(e10) {
        CC.postMessage(qC(e10), kC.protocol + "//" + kC.host);
      };
      WC && UC || (WC = function(e10) {
        zC(arguments.length, 1);
        var t10 = _C(e10) ? e10 : jC(e10), n10 = MC(arguments, 1);
        return XC[++KC] = function() {
          AC(t10, void 0, n10);
        }, wC(KC), KC;
      }, UC = function(e10) {
        delete XC[e10];
      }, BC ? wC = function(e10) {
        VC.nextTick(ZC(e10));
      } : GC && GC.now ? wC = function(e10) {
        GC.now(ZC(e10));
      } : HC && !PC ? (NC = (IC = new HC()).port2, IC.port1.onmessage = QC, wC = RC(NC.postMessage, NC)) : CC.addEventListener && _C(CC.postMessage) && !CC.importScripts && kC && "file:" !== kC.protocol && !FC($C) ? (wC = $C, CC.addEventListener("message", QC, false)) : wC = YC in LC("script") ? function(e10) {
        DC.appendChild(LC("script")).onreadystatechange = function() {
          DC.removeChild(this), JC(e10);
        };
      } : function(e10) {
        setTimeout(ZC(e10), 0);
      });
      var eA = { set: WC, clear: UC }, tA = function() {
        this.head = null, this.tail = null;
      };
      tA.prototype = { add: function(e10) {
        var t10 = { item: e10, next: null }, n10 = this.tail;
        n10 ? n10.next = t10 : this.head = t10, this.tail = t10;
      }, get: function() {
        var e10 = this.head;
        if (e10) return null === (this.head = e10.next) && (this.tail = null), e10.item;
      } };
      var nA, rA, aA, iA, oA, sA = tA, uA = /ipad|iphone|ipod/i.test(Ae) && "undefined" != typeof Pebble, cA = /web0s(?!.*chrome)/i.test(Ae), lA = z, hA = so, pA = P.f, fA = eA.set, dA = sA, vA = EC, mA = uA, gA = cA, yA = Rv, bA = lA.MutationObserver || lA.WebKitMutationObserver, xA = lA.document, kA = lA.process, wA = lA.Promise, IA = pA(lA, "queueMicrotask"), NA = IA && IA.value;
      if (!NA) {
        var SA = new dA(), TA = function() {
          var e10, t10;
          for (yA && (e10 = kA.domain) && e10.exit(); t10 = SA.get(); ) try {
            t10();
          } catch (e11) {
            throw SA.head && nA(), e11;
          }
          e10 && e10.enter();
        };
        vA || yA || gA || !bA || !xA ? !mA && wA && wA.resolve ? ((iA = wA.resolve(void 0)).constructor = wA, oA = hA(iA.then, iA), nA = function() {
          oA(TA);
        }) : yA ? nA = function() {
          kA.nextTick(TA);
        } : (fA = hA(fA, lA), nA = function() {
          fA(TA);
        }) : (rA = true, aA = xA.createTextNode(""), new bA(TA).observe(aA, { characterData: true }), nA = function() {
          aA.data = rA = !rA;
        }), NA = function(e10) {
          SA.head || nA(), SA.add(e10);
        };
      }
      var EA, CA, AA, RA = NA, _A = function(e10, t10) {
        try {
          1 == arguments.length ? console.error(e10) : console.error(e10, t10);
        } catch (e11) {
        }
      }, OA = function(e10) {
        try {
          return { error: false, value: e10() };
        } catch (e11) {
          return { error: true, value: e11 };
        }
      }, FA = z.Promise, DA = "object" == ("undefined" == typeof Deno ? "undefined" : s(Deno)) && Deno && "object" == s(Deno.version), MA = !DA && !Rv && "object" == ("undefined" == typeof window ? "undefined" : s(window)) && "object" == ("undefined" == typeof document ? "undefined" : s(document)), LA = z, zA = FA, PA = xe, BA = Ca, WA = Vn, UA = Mt, VA = MA, GA = DA, jA = Le, HA = (zA && zA.prototype, UA("species")), qA = false, KA = PA(LA.PromiseRejectionEvent), XA = BA("Promise", function() {
        var e10 = WA(zA), t10 = e10 !== String(zA);
        if (!t10 && 66 === jA) return true;
        if (!jA || jA < 51 || !/native code/.test(e10)) {
          var n10 = new zA(function(e11) {
            e11(1);
          }), r10 = function(e11) {
            e11(function() {
            }, function() {
            });
          };
          if ((n10.constructor = {})[HA] = r10, !(qA = n10.then(function() {
          }) instanceof r10)) return true;
        }
        return !t10 && (VA || GA) && !KA;
      }), YA = { CONSTRUCTOR: XA, REJECTION_EVENT: KA, SUBCLASSING: qA }, JA = {}, ZA = Ze, QA = TypeError, $A = function(e10) {
        var t10, n10;
        this.promise = new e10(function(e11, r10) {
          if (void 0 !== t10 || void 0 !== n10) throw QA("Bad Promise constructor");
          t10 = e11, n10 = r10;
        }), this.resolve = ZA(t10), this.reject = ZA(n10);
      }, eR = (JA.f = function(e10) {
        return new $A(e10);
      }, La), tR = Rv, nR = z, rR = j, aR = Or, iR = Tc, oR = eo, sR = Fm, uR = Ze, cR = xe, lR = Ie, hR = zg, pR = Kb, fR = eA.set, dR = RA, vR = _A, mR = OA, gR = sA, yR = cr, bR = FA, xR = JA, kR = "Promise", wR = YA.CONSTRUCTOR, IR = YA.REJECTION_EVENT, NR = YA.SUBCLASSING, SR = yR.getterFor(kR), TR = yR.set, ER = bR && bR.prototype, CR = bR, AR = ER, RR = nR.TypeError, _R = nR.document, OR = nR.process, FR = xR.f, DR = FR, MR = !!(_R && _R.createEvent && nR.dispatchEvent), LR = "unhandledrejection", zR = function(e10) {
        var t10;
        return !(!lR(e10) || !cR(t10 = e10.then)) && t10;
      }, PR = function(e10, t10) {
        var n10, r10, a10, i10 = t10.value, o10 = 1 == t10.state, s10 = o10 ? e10.ok : e10.fail, u10 = e10.resolve, c10 = e10.reject, l10 = e10.domain;
        try {
          s10 ? (o10 || (2 === t10.rejection && GR(t10), t10.rejection = 1), true === s10 ? n10 = i10 : (l10 && l10.enter(), n10 = s10(i10), l10 && (l10.exit(), a10 = true)), n10 === e10.promise ? c10(RR("Promise-chain cycle")) : (r10 = zR(n10)) ? rR(r10, n10, u10, c10) : u10(n10)) : c10(i10);
        } catch (e11) {
          l10 && !a10 && l10.exit(), c10(e11);
        }
      }, BR = function(e10, t10) {
        e10.notified || (e10.notified = true, dR(function() {
          for (var n10, r10 = e10.reactions; n10 = r10.get(); ) PR(n10, e10);
          e10.notified = false, t10 && !e10.rejection && UR(e10);
        }));
      }, WR = function(e10, t10, n10) {
        var r10, a10;
        MR ? ((r10 = _R.createEvent("Event")).promise = t10, r10.reason = n10, r10.initEvent(e10, false, true), nR.dispatchEvent(r10)) : r10 = { promise: t10, reason: n10 }, !IR && (a10 = nR["on" + e10]) ? a10(r10) : e10 === LR && vR("Unhandled promise rejection", n10);
      }, UR = function(e10) {
        rR(fR, nR, function() {
          var t10, n10 = e10.facade, r10 = e10.value;
          if (VR(e10) && (t10 = mR(function() {
            tR ? OR.emit("unhandledRejection", r10, n10) : WR(LR, n10, r10);
          }), e10.rejection = tR || VR(e10) ? 2 : 1, t10.error)) throw t10.value;
        });
      }, VR = function(e10) {
        return 1 !== e10.rejection && !e10.parent;
      }, GR = function(e10) {
        rR(fR, nR, function() {
          var t10 = e10.facade;
          tR ? OR.emit("rejectionHandled", t10) : WR("rejectionhandled", t10, e10.value);
        });
      }, jR = function(e10, t10, n10) {
        return function(r10) {
          e10(t10, r10, n10);
        };
      }, HR = function(e10, t10, n10) {
        e10.done || (e10.done = true, n10 && (e10 = n10), e10.value = t10, e10.state = 2, BR(e10, true));
      }, qR = function e10(t10, n10, r10) {
        if (!t10.done) {
          t10.done = true, r10 && (t10 = r10);
          try {
            if (t10.facade === n10) throw RR("Promise can't be resolved itself");
            var a10 = zR(n10);
            a10 ? dR(function() {
              var r11 = { done: false };
              try {
                rR(a10, n10, jR(e10, r11, t10), jR(HR, r11, t10));
              } catch (e11) {
                HR(r11, e11, t10);
              }
            }) : (t10.value = n10, t10.state = 1, BR(t10, false));
          } catch (e11) {
            HR({ done: false }, e11, t10);
          }
        }
      };
      if (wR && (AR = (CR = function(e10) {
        hR(this, AR), uR(e10), rR(EA, this);
        var t10 = SR(this);
        try {
          e10(jR(qR, t10), jR(HR, t10));
        } catch (e11) {
          HR(t10, e11);
        }
      }).prototype, (EA = function(e10) {
        TR(this, { type: kR, done: false, notified: false, parent: false, reactions: new gR(), rejection: false, state: 0, value: void 0 });
      }).prototype = aR(AR, "then", function(e10, t10) {
        var n10 = SR(this), r10 = FR(pR(this, CR));
        return n10.parent = true, r10.ok = !cR(e10) || e10, r10.fail = cR(t10) && t10, r10.domain = tR ? OR.domain : void 0, 0 == n10.state ? n10.reactions.add(r10) : dR(function() {
          PR(r10, n10);
        }), r10.promise;
      }), CA = function() {
        var e10 = new EA(), t10 = SR(e10);
        this.promise = e10, this.resolve = jR(qR, t10), this.reject = jR(HR, t10);
      }, xR.f = FR = function(e10) {
        return e10 === CR || void 0 === e10 ? new CA(e10) : DR(e10);
      }, cR(bR) && ER !== Object.prototype)) {
        AA = ER.then, NR || aR(ER, "then", function(e10, t10) {
          var n10 = this;
          return new CR(function(e11, t11) {
            rR(AA, n10, e11, t11);
          }).then(e10, t10);
        }, { unsafe: true });
        try {
          delete ER.constructor;
        } catch (e10) {
        }
        iR && iR(ER, AR);
      }
      eR({ global: true, constructor: true, wrap: true, forced: wR }, { Promise: CR }), oR(CR, kR, false, true), sR(kR);
      var KR = FA, XR = YA.CONSTRUCTOR || !Uf(function(e10) {
        KR.all(e10).then(void 0, function() {
        });
      }), YR = j, JR = Ze, ZR = JA, QR = OA, $R = yh;
      La({ target: "Promise", stat: true, forced: XR }, { all: function(e10) {
        var t10 = this, n10 = ZR.f(t10), r10 = n10.resolve, a10 = n10.reject, i10 = QR(function() {
          var n11 = JR(t10.resolve), i11 = [], o10 = 0, s10 = 1;
          $R(e10, function(e11) {
            var u10 = o10++, c10 = false;
            s10++, YR(n11, t10, e11).then(function(e12) {
              c10 || (c10 = true, i11[u10] = e12, --s10 || r10(i11));
            }, a10);
          }), --s10 || r10(i11);
        });
        return i10.error && a10(i10.value), n10.promise;
      } });
      var e_ = La, t_ = YA.CONSTRUCTOR, n_ = FA, r_ = Ee, a_ = xe, i_ = Or, o_ = n_ && n_.prototype;
      if (e_({ target: "Promise", proto: true, forced: t_, real: true }, { catch: function(e10) {
        return this.then(void 0, e10);
      } }), a_(n_)) {
        var s_ = r_("Promise").prototype.catch;
        o_.catch !== s_ && i_(o_, "catch", s_, { unsafe: true });
      }
      var u_ = j, c_ = Ze, l_ = JA, h_ = OA, p_ = yh;
      La({ target: "Promise", stat: true, forced: XR }, { race: function(e10) {
        var t10 = this, n10 = l_.f(t10), r10 = n10.reject, a10 = h_(function() {
          var a11 = c_(t10.resolve);
          p_(e10, function(e11) {
            u_(a11, t10, e11).then(n10.resolve, r10);
          });
        });
        return a10.error && r10(a10.value), n10.promise;
      } });
      var f_ = j, d_ = JA;
      La({ target: "Promise", stat: true, forced: YA.CONSTRUCTOR }, { reject: function(e10) {
        var t10 = d_.f(this);
        return f_(t10.reject, void 0, e10), t10.promise;
      } });
      var v_ = dn, m_ = Ie, g_ = JA, y_ = function(e10, t10) {
        if (v_(e10), m_(t10) && t10.constructor === e10) return t10;
        var n10 = g_.f(e10);
        return (0, n10.resolve)(t10), n10.promise;
      }, b_ = La, x_ = YA.CONSTRUCTOR, k_ = y_;
      Ee("Promise");
      b_({ target: "Promise", stat: true, forced: x_ }, { resolve: function(e10) {
        return k_(this, e10);
      } });
      var w_ = j, I_ = Ze, N_ = JA, S_ = OA, T_ = yh;
      La({ target: "Promise", stat: true, forced: XR }, { allSettled: function(e10) {
        var t10 = this, n10 = N_.f(t10), r10 = n10.resolve, a10 = n10.reject, i10 = S_(function() {
          var n11 = I_(t10.resolve), a11 = [], i11 = 0, o10 = 1;
          T_(e10, function(e11) {
            var s10 = i11++, u10 = false;
            o10++, w_(n11, t10, e11).then(function(e12) {
              u10 || (u10 = true, a11[s10] = { status: "fulfilled", value: e12 }, --o10 || r10(a11));
            }, function(e12) {
              u10 || (u10 = true, a11[s10] = { status: "rejected", reason: e12 }, --o10 || r10(a11));
            });
          }), --o10 || r10(a11);
        });
        return i10.error && a10(i10.value), n10.promise;
      } });
      var E_ = j, C_ = Ze, A_ = Ee, R_ = JA, __ = OA, O_ = yh, F_ = "No one promise resolved";
      La({ target: "Promise", stat: true, forced: XR }, { any: function(e10) {
        var t10 = this, n10 = A_("AggregateError"), r10 = R_.f(t10), a10 = r10.resolve, i10 = r10.reject, o10 = __(function() {
          var r11 = C_(t10.resolve), o11 = [], s10 = 0, u10 = 1, c10 = false;
          O_(e10, function(e11) {
            var l10 = s10++, h10 = false;
            u10++, E_(r11, t10, e11).then(function(e12) {
              h10 || c10 || (c10 = true, a10(e12));
            }, function(e12) {
              h10 || c10 || (h10 = true, o11[l10] = e12, --u10 || i10(new n10(o11, F_)));
            });
          }), --u10 || i10(new n10(o11, F_));
        });
        return o10.error && i10(o10.value), r10.promise;
      } });
      var D_ = La, M_ = FA, L_ = B, z_ = Ee, P_ = xe, B_ = Kb, W_ = y_, U_ = Or, V_ = M_ && M_.prototype;
      if (D_({ target: "Promise", proto: true, real: true, forced: !!M_ && L_(function() {
        V_.finally.call({ then: function() {
        } }, function() {
        });
      }) }, { finally: function(e10) {
        var t10 = B_(this, z_("Promise")), n10 = P_(e10);
        return this.then(n10 ? function(n11) {
          return W_(t10, e10()).then(function() {
            return n11;
          });
        } : e10, n10 ? function(n11) {
          return W_(t10, e10()).then(function() {
            throw n11;
          });
        } : e10);
      } }), P_(M_)) {
        var G_ = z_("Promise").prototype.finally;
        V_.finally !== G_ && U_(V_, "finally", G_, { unsafe: true });
      }
      var j_ = fu, H_ = Ze, q_ = dn;
      La({ target: "Reflect", stat: true, forced: !B(function() {
        Reflect.apply(function() {
        });
      }) }, { apply: function(e10, t10, n10) {
        return j_(H_(e10), t10, q_(n10));
      } });
      var K_ = La, X_ = fu, Y_ = zk, J_ = Vb, Z_ = dn, Q_ = Ie, $_ = yi, eO = B, tO = Ee("Reflect", "construct"), nO = Object.prototype, rO = [].push, aO = eO(function() {
        function e10() {
        }
        return !(tO(function() {
        }, [], e10) instanceof e10);
      }), iO = !eO(function() {
        tO(function() {
        });
      }), oO = aO || iO;
      K_({ target: "Reflect", stat: true, forced: oO, sham: oO }, { construct: function(e10, t10) {
        J_(e10), Z_(t10);
        var n10 = arguments.length < 3 ? e10 : J_(arguments[2]);
        if (iO && !aO) return tO(e10, t10, n10);
        if (e10 == n10) {
          switch (t10.length) {
            case 0:
              return new e10();
            case 1:
              return new e10(t10[0]);
            case 2:
              return new e10(t10[0], t10[1]);
            case 3:
              return new e10(t10[0], t10[1], t10[2]);
            case 4:
              return new e10(t10[0], t10[1], t10[2], t10[3]);
          }
          var r10 = [null];
          return X_(rO, r10, t10), new (X_(Y_, e10, r10))();
        }
        var a10 = n10.prototype, i10 = $_(Q_(a10) ? a10 : nO), o10 = X_(e10, i10, t10);
        return Q_(o10) ? o10 : i10;
      } });
      var sO = W, uO = dn, cO = qt, lO = cn;
      La({ target: "Reflect", stat: true, forced: B(function() {
        Reflect.defineProperty(lO.f({}, 1, { value: 1 }), 1, { value: 2 });
      }), sham: !sO }, { defineProperty: function(e10, t10, n10) {
        uO(e10);
        var r10 = cO(t10);
        uO(n10);
        try {
          return lO.f(e10, r10, n10), true;
        } catch (e11) {
          return false;
        }
      } });
      var hO = La, pO = dn, fO = P.f;
      hO({ target: "Reflect", stat: true }, { deleteProperty: function(e10, t10) {
        var n10 = fO(pO(e10), t10);
        return !(n10 && !n10.configurable) && delete e10[t10];
      } });
      var dO = kt, vO = function(e10) {
        return void 0 !== e10 && (dO(e10, "value") || dO(e10, "writable"));
      }, mO = j, gO = Ie, yO = dn, bO = vO, xO = P, kO = Ll;
      La({ target: "Reflect", stat: true }, { get: function e10(t10, n10) {
        var r10, a10, i10 = arguments.length < 3 ? t10 : arguments[2];
        return yO(t10) === i10 ? t10[n10] : (r10 = xO.f(t10, n10)) ? bO(r10) ? r10.value : void 0 === r10.get ? void 0 : mO(r10.get, i10) : gO(a10 = kO(t10)) ? e10(a10, n10, i10) : void 0;
      } });
      var wO = dn, IO = P;
      La({ target: "Reflect", stat: true, sham: !W }, { getOwnPropertyDescriptor: function(e10, t10) {
        return IO.f(wO(e10), t10);
      } });
      var NO = dn, SO = Ll;
      La({ target: "Reflect", stat: true, sham: !Cl }, { getPrototypeOf: function(e10) {
        return SO(NO(e10));
      } }), La({ target: "Reflect", stat: true }, { has: function(e10, t10) {
        return t10 in e10;
      } });
      var TO = dn, EO = uw;
      La({ target: "Reflect", stat: true }, { isExtensible: function(e10) {
        return TO(e10), EO(e10);
      } }), La({ target: "Reflect", stat: true }, { ownKeys: da });
      var CO = Ee, AO = dn;
      La({ target: "Reflect", stat: true, sham: !cw }, { preventExtensions: function(e10) {
        AO(e10);
        try {
          var t10 = CO("Object", "preventExtensions");
          return t10 && t10(e10), true;
        } catch (e11) {
          return false;
        }
      } });
      var RO = La, _O = j, OO = dn, FO = Ie, DO = vO, MO = cn, LO = P, zO = Ll, PO = Y;
      var BO = B(function() {
        var e10 = function() {
        }, t10 = MO.f(new e10(), "a", { configurable: true });
        return false !== Reflect.set(e10.prototype, "a", 1, t10);
      });
      RO({ target: "Reflect", stat: true, forced: BO }, { set: function e10(t10, n10, r10) {
        var a10, i10, o10, s10 = arguments.length < 4 ? t10 : arguments[3], u10 = LO.f(OO(t10), n10);
        if (!u10) {
          if (FO(i10 = zO(t10))) return e10(i10, n10, r10, s10);
          u10 = PO(0);
        }
        if (DO(u10)) {
          if (false === u10.writable || !FO(s10)) return false;
          if (a10 = LO.f(s10, n10)) {
            if (a10.get || a10.set || false === a10.writable) return false;
            a10.value = r10, MO.f(s10, n10, a10);
          } else MO.f(s10, n10, PO(0, r10));
        } else {
          if (void 0 === (o10 = u10.set)) return false;
          _O(o10, s10, r10);
        }
        return true;
      } });
      var WO = dn, UO = wc, VO = Tc;
      VO && La({ target: "Reflect", stat: true }, { setPrototypeOf: function(e10, t10) {
        WO(e10), UO(t10);
        try {
          return VO(e10, t10), true;
        } catch (e11) {
          return false;
        }
      } });
      var GO = z, jO = eo;
      La({ global: true }, { Reflect: {} }), jO(GO.Reflect, "Reflect", true);
      var HO = Ie, qO = ae, KO = Mt("match"), XO = function(e10) {
        var t10;
        return HO(e10) && (void 0 !== (t10 = e10[KO]) ? !!t10 : "RegExp" == qO(e10));
      }, YO = dn, JO = function() {
        var e10 = YO(this), t10 = "";
        return e10.hasIndices && (t10 += "d"), e10.global && (t10 += "g"), e10.ignoreCase && (t10 += "i"), e10.multiline && (t10 += "m"), e10.dotAll && (t10 += "s"), e10.unicode && (t10 += "u"), e10.unicodeSets && (t10 += "v"), e10.sticky && (t10 += "y"), t10;
      }, ZO = j, QO = kt, $O = Ce, eF = JO, tF = RegExp.prototype, nF = function(e10) {
        var t10 = e10.flags;
        return void 0 !== t10 || "flags" in tF || QO(e10, "flags") || !$O(tF, e10) ? t10 : ZO(eF, e10);
      }, rF = B, aF = z.RegExp, iF = rF(function() {
        var e10 = aF("a", "y");
        return e10.lastIndex = 2, null != e10.exec("abcd");
      }), oF = iF || rF(function() {
        return !aF("a", "y").sticky;
      }), sF = iF || rF(function() {
        var e10 = aF("^r", "gy");
        return e10.lastIndex = 2, null != e10.exec("str");
      }), uF = { BROKEN_CARET: sF, MISSED_STICKY: oF, UNSUPPORTED_Y: iF }, cF = B, lF = z.RegExp, hF = cF(function() {
        var e10 = lF(".", "s");
        return !(e10.dotAll && e10.exec("\n") && "s" === e10.flags);
      }), pF = B, fF = z.RegExp, dF = pF(function() {
        var e10 = fF("(?<a>b)", "g");
        return "b" !== e10.exec("b").groups.a || "bc" !== "b".replace(e10, "$<a>c");
      }), vF = W, mF = z, gF = ee, yF = Ca, bF = Oc, xF = Cn, kF = Fr.f, wF = Ce, IF = XO, NF = Ya, SF = nF, TF = uF, EF = Cc, CF = Or, AF = B, RF = kt, _F = cr.enforce, OF = Fm, FF = hF, DF = dF, MF = Mt("match"), LF = mF.RegExp, zF = LF.prototype, PF = mF.SyntaxError, BF = gF(zF.exec), WF = gF("".charAt), UF = gF("".replace), VF = gF("".indexOf), GF = gF("".slice), jF = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/, HF = /a/g, qF = /a/g, KF = new LF(HF) !== HF, XF = TF.MISSED_STICKY, YF = TF.UNSUPPORTED_Y, JF = vF && (!KF || XF || FF || DF || AF(function() {
        return qF[MF] = false, LF(HF) != HF || LF(qF) == qF || "/a/i" != LF(HF, "i");
      }));
      if (yF("RegExp", JF)) {
        for (var ZF = function(e10, t10) {
          var n10, r10, a10, i10, o10, s10, u10 = wF(zF, this), c10 = IF(e10), l10 = void 0 === t10, h10 = [], p10 = e10;
          if (!u10 && c10 && l10 && e10.constructor === ZF) return e10;
          if ((c10 || wF(zF, e10)) && (e10 = e10.source, l10 && (t10 = SF(p10))), e10 = void 0 === e10 ? "" : NF(e10), t10 = void 0 === t10 ? "" : NF(t10), p10 = e10, FF && "dotAll" in HF && (r10 = !!t10 && VF(t10, "s") > -1) && (t10 = UF(t10, /s/g, "")), n10 = t10, XF && "sticky" in HF && (a10 = !!t10 && VF(t10, "y") > -1) && YF && (t10 = UF(t10, /y/g, "")), DF && (i10 = function(e11) {
            for (var t11, n11 = e11.length, r11 = 0, a11 = "", i11 = [], o11 = {}, s11 = false, u11 = false, c11 = 0, l11 = ""; r11 <= n11; r11++) {
              if ("\\" === (t11 = WF(e11, r11))) t11 += WF(e11, ++r11);
              else if ("]" === t11) s11 = false;
              else if (!s11) switch (true) {
                case "[" === t11:
                  s11 = true;
                  break;
                case "(" === t11:
                  BF(jF, GF(e11, r11 + 1)) && (r11 += 2, u11 = true), a11 += t11, c11++;
                  continue;
                case (">" === t11 && u11):
                  if ("" === l11 || RF(o11, l11)) throw new PF("Invalid capture group name");
                  o11[l11] = true, i11[i11.length] = [l11, c11], u11 = false, l11 = "";
                  continue;
              }
              u11 ? l11 += t11 : a11 += t11;
            }
            return [a11, i11];
          }(e10), e10 = i10[0], h10 = i10[1]), o10 = bF(LF(e10, t10), u10 ? this : zF, ZF), (r10 || a10 || h10.length) && (s10 = _F(o10), r10 && (s10.dotAll = true, s10.raw = ZF(function(e11) {
            for (var t11, n11 = e11.length, r11 = 0, a11 = "", i11 = false; r11 <= n11; r11++) "\\" !== (t11 = WF(e11, r11)) ? i11 || "." !== t11 ? ("[" === t11 ? i11 = true : "]" === t11 && (i11 = false), a11 += t11) : a11 += "[\\s\\S]" : a11 += t11 + WF(e11, ++r11);
            return a11;
          }(e10), n10)), a10 && (s10.sticky = true), h10.length && (s10.groups = h10)), e10 !== p10) try {
            xF(o10, "source", "" === p10 ? "(?:)" : p10);
          } catch (e11) {
          }
          return o10;
        }, QF = kF(LF), $F = 0; QF.length > $F; ) EF(ZF, LF, QF[$F++]);
        zF.constructor = ZF, ZF.prototype = zF, CF(mF, "RegExp", ZF, { constructor: true });
      }
      OF("RegExp");
      var eD = W, tD = hF, nD = ae, rD = zi, aD = cr.get, iD = RegExp.prototype, oD = TypeError;
      eD && tD && rD(iD, "dotAll", { configurable: true, get: function() {
        if (this !== iD) {
          if ("RegExp" === nD(this)) return !!aD(this).dotAll;
          throw oD("Incompatible receiver, RegExp required");
        }
      } });
      var sD = j, uD = ee, cD = Ya, lD = JO, hD = uF, pD = yi, fD = cr.get, dD = hF, vD = dF, mD = vt("native-string-replace", String.prototype.replace), gD = RegExp.prototype.exec, yD = gD, bD = uD("".charAt), xD = uD("".indexOf), kD = uD("".replace), wD = uD("".slice), ID = function() {
        var e10 = /a/, t10 = /b*/g;
        return sD(gD, e10, "a"), sD(gD, t10, "a"), 0 !== e10.lastIndex || 0 !== t10.lastIndex;
      }(), ND = hD.BROKEN_CARET, SD = void 0 !== /()??/.exec("")[1];
      (ID || SD || ND || dD || vD) && (yD = function(e10) {
        var t10, n10, r10, a10, i10, o10, s10, u10 = this, c10 = fD(u10), l10 = cD(e10), h10 = c10.raw;
        if (h10) return h10.lastIndex = u10.lastIndex, t10 = sD(yD, h10, l10), u10.lastIndex = h10.lastIndex, t10;
        var p10 = c10.groups, f10 = ND && u10.sticky, d10 = sD(lD, u10), v10 = u10.source, m10 = 0, g10 = l10;
        if (f10 && (d10 = kD(d10, "y", ""), -1 === xD(d10, "g") && (d10 += "g"), g10 = wD(l10, u10.lastIndex), u10.lastIndex > 0 && (!u10.multiline || u10.multiline && "\n" !== bD(l10, u10.lastIndex - 1)) && (v10 = "(?: " + v10 + ")", g10 = " " + g10, m10++), n10 = new RegExp("^(?:" + v10 + ")", d10)), SD && (n10 = new RegExp("^" + v10 + "$(?!\\s)", d10)), ID && (r10 = u10.lastIndex), a10 = sD(gD, f10 ? n10 : u10, g10), f10 ? a10 ? (a10.input = wD(a10.input, m10), a10[0] = wD(a10[0], m10), a10.index = u10.lastIndex, u10.lastIndex += a10[0].length) : u10.lastIndex = 0 : ID && a10 && (u10.lastIndex = u10.global ? a10.index + a10[0].length : r10), SD && a10 && a10.length > 1 && sD(mD, a10[0], n10, function() {
          for (i10 = 1; i10 < arguments.length - 2; i10++) void 0 === arguments[i10] && (a10[i10] = void 0);
        }), a10 && p10) for (a10.groups = o10 = pD(null), i10 = 0; i10 < p10.length; i10++) o10[(s10 = p10[i10])[0]] = a10[s10[1]];
        return a10;
      });
      var TD = yD;
      La({ target: "RegExp", proto: true, forced: /./.exec !== TD }, { exec: TD });
      var ED = W, CD = zi, AD = JO, RD = B, _D = z.RegExp, OD = _D.prototype, FD = ED && RD(function() {
        var e10 = true;
        try {
          _D(".", "d");
        } catch (t11) {
          e10 = false;
        }
        var t10 = {}, n10 = "", r10 = e10 ? "dgimsy" : "gimsy", a10 = function(e11, r11) {
          Object.defineProperty(t10, e11, { get: function() {
            return n10 += r11, true;
          } });
        }, i10 = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
        for (var o10 in e10 && (i10.hasIndices = "d"), i10) a10(o10, i10[o10]);
        return Object.getOwnPropertyDescriptor(OD, "flags").get.call(t10) !== r10 || n10 !== r10;
      });
      FD && CD(OD, "flags", { configurable: true, get: AD });
      var DD = W, MD = uF.MISSED_STICKY, LD = ae, zD = zi, PD = cr.get, BD = RegExp.prototype, WD = TypeError;
      DD && MD && zD(BD, "sticky", { configurable: true, get: function() {
        if (this !== BD) {
          if ("RegExp" === LD(this)) return !!PD(this).sticky;
          throw WD("Incompatible receiver, RegExp required");
        }
      } });
      var UD, VD, GD = La, jD = j, HD = xe, qD = dn, KD = Ya, XD = (UD = false, (VD = /[ac]/).exec = function() {
        return UD = true, /./.exec.apply(this, arguments);
      }, true === VD.test("abc") && UD), YD = /./.test;
      GD({ target: "RegExp", proto: true, forced: !XD }, { test: function(e10) {
        var t10 = qD(this), n10 = KD(e10), r10 = t10.exec;
        if (!HD(r10)) return jD(YD, t10, n10);
        var a10 = jD(r10, t10, n10);
        return null !== a10 && (qD(a10), true);
      } });
      var JD = Mn.PROPER, ZD = Or, QD = dn, $D = Ya, eM = B, tM = nF, nM = "toString", rM = RegExp.prototype.toString, aM = eM(function() {
        return "/a/b" != rM.call({ source: "a", flags: "b" });
      }), iM = JD && rM.name != nM;
      (aM || iM) && ZD(RegExp.prototype, nM, function() {
        var e10 = QD(this);
        return "/" + $D(e10.source) + "/" + $D(tM(e10));
      }, { unsafe: true }), Uw("Set", function(e10) {
        return function() {
          return e10(this, arguments.length ? arguments[0] : void 0);
        };
      }, nI);
      var oM = La, sM = fe, uM = Pr, cM = Ya, lM = B, hM = ee("".charAt);
      oM({ target: "String", proto: true, forced: lM(function() {
        return "\uD842" !== "𠮷".at(-2);
      }) }, { at: function(e10) {
        var t10 = cM(sM(this)), n10 = t10.length, r10 = uM(e10), a10 = r10 >= 0 ? r10 : n10 + r10;
        return a10 < 0 || a10 >= n10 ? void 0 : hM(t10, a10);
      } });
      var pM = ee, fM = Pr, dM = Ya, vM = fe, mM = pM("".charAt), gM = pM("".charCodeAt), yM = pM("".slice), bM = function(e10) {
        return function(t10, n10) {
          var r10, a10, i10 = dM(vM(t10)), o10 = fM(n10), s10 = i10.length;
          return o10 < 0 || o10 >= s10 ? e10 ? "" : void 0 : (r10 = gM(i10, o10)) < 55296 || r10 > 56319 || o10 + 1 === s10 || (a10 = gM(i10, o10 + 1)) < 56320 || a10 > 57343 ? e10 ? mM(i10, o10) : r10 : e10 ? yM(i10, o10, o10 + 2) : a10 - 56320 + (r10 - 55296 << 10) + 65536;
        };
      }, xM = { codeAt: bM(false), charAt: bM(true) }, kM = xM.codeAt;
      La({ target: "String", proto: true }, { codePointAt: function(e10) {
        return kM(this, e10);
      } });
      var wM = XO, IM = TypeError, NM = function(e10) {
        if (wM(e10)) throw IM("The method doesn't accept regular expressions");
        return e10;
      }, SM = Mt("match"), TM = function(e10) {
        var t10 = /./;
        try {
          "/./"[e10](t10);
        } catch (n10) {
          try {
            return t10[SM] = false, "/./"[e10](t10);
          } catch (e11) {
          }
        }
        return false;
      }, EM = La, CM = ro, AM = P.f, RM = Hr, _M = Ya, OM = NM, FM = fe, DM = TM, MM = CM("".endsWith), LM = CM("".slice), zM = Math.min, PM = DM("endsWith"), BM = !PM && !!function() {
        var e10 = AM(String.prototype, "endsWith");
        return e10 && !e10.writable;
      }();
      EM({ target: "String", proto: true, forced: !BM && !PM }, { endsWith: function(e10) {
        var t10 = _M(FM(this));
        OM(e10);
        var n10 = arguments.length > 1 ? arguments[1] : void 0, r10 = t10.length, a10 = void 0 === n10 ? r10 : zM(RM(n10), r10), i10 = _M(e10);
        return MM ? MM(t10, i10, a10) : LM(t10, a10 - i10.length, a10) === i10;
      } });
      var WM = La, UM = ee, VM = Vr, GM = RangeError, jM = String.fromCharCode, HM = String.fromCodePoint, qM = UM([].join);
      WM({ target: "String", stat: true, arity: 1, forced: !!HM && 1 != HM.length }, { fromCodePoint: function(e10) {
        for (var t10, n10 = [], r10 = arguments.length, a10 = 0; r10 > a10; ) {
          if (t10 = +arguments[a10++], VM(t10, 1114111) !== t10) throw GM(t10 + " is not a valid code point");
          n10[a10] = t10 < 65536 ? jM(t10) : jM(55296 + ((t10 -= 65536) >> 10), t10 % 1024 + 56320);
        }
        return qM(n10, "");
      } });
      var KM = La, XM = NM, YM = fe, JM = Ya, ZM = TM, QM = ee("".indexOf);
      KM({ target: "String", proto: true, forced: !ZM("includes") }, { includes: function(e10) {
        return !!~QM(JM(YM(this)), JM(XM(e10)), arguments.length > 1 ? arguments[1] : void 0);
      } });
      var $M = xM.charAt, eL = Ya, tL = cr, nL = Dd, rL = Md, aL = "String Iterator", iL = tL.set, oL = tL.getterFor(aL);
      nL(String, "String", function(e10) {
        iL(this, { type: aL, string: eL(e10), index: 0 });
      }, function() {
        var e10, t10 = oL(this), n10 = t10.string, r10 = t10.index;
        return r10 >= n10.length ? rL(void 0, true) : (e10 = $M(n10, r10), t10.index += e10.length, rL(e10, false));
      });
      var sL = ro, uL = Or, cL = TD, lL = B, hL = Mt, pL = Cn, fL = hL("species"), dL = RegExp.prototype, vL = function(e10, t10, n10, r10) {
        var a10 = hL(e10), i10 = !lL(function() {
          var t11 = {};
          return t11[a10] = function() {
            return 7;
          }, 7 != ""[e10](t11);
        }), o10 = i10 && !lL(function() {
          var t11 = false, n11 = /a/;
          return "split" === e10 && ((n11 = {}).constructor = {}, n11.constructor[fL] = function() {
            return n11;
          }, n11.flags = "", n11[a10] = /./[a10]), n11.exec = function() {
            return t11 = true, null;
          }, n11[a10](""), !t11;
        });
        if (!i10 || !o10 || n10) {
          var s10 = sL(/./[a10]), u10 = t10(a10, ""[e10], function(e11, t11, n11, r11, a11) {
            var o11 = sL(e11), u11 = t11.exec;
            return u11 === cL || u11 === dL.exec ? i10 && !a11 ? { done: true, value: s10(t11, n11, r11) } : { done: true, value: o11(n11, t11, r11) } : { done: false };
          });
          uL(String.prototype, e10, u10[0]), uL(dL, a10, u10[1]);
        }
        r10 && pL(dL[a10], "sham", true);
      }, mL = xM.charAt, gL = function(e10, t10, n10) {
        return t10 + (n10 ? mL(e10, t10).length : 1);
      }, yL = j, bL = dn, xL = xe, kL = ae, wL = TD, IL = TypeError, NL = function(e10, t10) {
        var n10 = e10.exec;
        if (xL(n10)) {
          var r10 = yL(n10, e10, t10);
          return null !== r10 && bL(r10), r10;
        }
        if ("RegExp" === kL(e10)) return yL(wL, e10, t10);
        throw IL("RegExp#exec called on incompatible receiver");
      }, SL = j, TL = dn, EL = le, CL = Hr, AL = Ya, RL = fe, _L = et, OL = gL, FL = NL;
      vL("match", function(e10, t10, n10) {
        return [function(t11) {
          var n11 = RL(this), r10 = EL(t11) ? void 0 : _L(t11, e10);
          return r10 ? SL(r10, t11, n11) : new RegExp(t11)[e10](AL(n11));
        }, function(e11) {
          var r10 = TL(this), a10 = AL(e11), i10 = n10(t10, r10, a10);
          if (i10.done) return i10.value;
          if (!r10.global) return FL(r10, a10);
          var o10 = r10.unicode;
          r10.lastIndex = 0;
          for (var s10, u10 = [], c10 = 0; null !== (s10 = FL(r10, a10)); ) {
            var l10 = AL(s10[0]);
            u10[c10] = l10, "" === l10 && (r10.lastIndex = OL(a10, CL(r10.lastIndex), o10)), c10++;
          }
          return 0 === c10 ? null : u10;
        }];
      });
      var DL = La, ML = j, LL = ro, zL = dd, PL = Md, BL = fe, WL = Hr, UL = Ya, VL = dn, GL = le, jL = XO, HL = nF, qL = et, KL = Or, XL = B, YL = Kb, JL = gL, ZL = NL, QL = cr, $L = Mt("matchAll"), ez = "RegExp String", tz = "RegExp String Iterator", nz = QL.set, rz = QL.getterFor(tz), az = RegExp.prototype, iz = TypeError, oz = LL("".indexOf), sz = LL("".matchAll), uz = !!sz && !XL(function() {
        sz("a", /./);
      }), cz = zL(function(e10, t10, n10, r10) {
        nz(this, { type: tz, regexp: e10, string: t10, global: n10, unicode: r10, done: false });
      }, ez, function() {
        var e10 = rz(this);
        if (e10.done) return PL(void 0, true);
        var t10 = e10.regexp, n10 = e10.string, r10 = ZL(t10, n10);
        return null === r10 ? (e10.done = true, PL(void 0, true)) : e10.global ? ("" === UL(r10[0]) && (t10.lastIndex = JL(n10, WL(t10.lastIndex), e10.unicode)), PL(r10, false)) : (e10.done = true, PL(r10, false));
      }), lz = function(e10) {
        var t10, n10, r10, a10 = VL(this), i10 = UL(e10), o10 = YL(a10, RegExp), s10 = UL(HL(a10));
        return t10 = new o10(o10 === RegExp ? a10.source : a10, s10), n10 = !!~oz(s10, "g"), r10 = !!~oz(s10, "u"), t10.lastIndex = WL(a10.lastIndex), new cz(t10, i10, n10, r10);
      };
      DL({ target: "String", proto: true, forced: uz }, { matchAll: function(e10) {
        var t10, n10, r10, a10 = BL(this);
        if (GL(e10)) {
          if (uz) return sz(a10, e10);
        } else {
          if (jL(e10) && (t10 = UL(BL(HL(e10))), !~oz(t10, "g"))) throw iz("`.matchAll` does not allow non-global regexes");
          if (uz) return sz(a10, e10);
          if (r10 = qL(e10, $L)) return ML(r10, e10, a10);
        }
        return n10 = UL(a10), new RegExp(e10, "g")[$L](n10);
      } }), $L in az || KL(az, $L, lz);
      var hz = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(Ae), pz = Fx.end;
      La({ target: "String", proto: true, forced: hz }, { padEnd: function(e10) {
        return pz(this, e10, arguments.length > 1 ? arguments[1] : void 0);
      } });
      var fz = Fx.start;
      La({ target: "String", proto: true, forced: hz }, { padStart: function(e10) {
        return fz(this, e10, arguments.length > 1 ? arguments[1] : void 0);
      } });
      var dz = La, vz = ee, mz = me, gz = yt, yz = Ya, bz = Kr, xz = vz([].push), kz = vz([].join);
      dz({ target: "String", stat: true }, { raw: function(e10) {
        var t10 = mz(gz(e10).raw), n10 = bz(t10);
        if (!n10) return "";
        for (var r10 = arguments.length, a10 = [], i10 = 0; ; ) {
          if (xz(a10, yz(t10[i10++])), i10 === n10) return kz(a10, "");
          i10 < r10 && xz(a10, yz(arguments[i10]));
        }
      } }), La({ target: "String", proto: true }, { repeat: Nx });
      var wz = ee, Iz = yt, Nz = Math.floor, Sz = wz("".charAt), Tz = wz("".replace), Ez = wz("".slice), Cz = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, Az = /\$([$&'`]|\d{1,2})/g, Rz = function(e10, t10, n10, r10, a10, i10) {
        var o10 = n10 + e10.length, s10 = r10.length, u10 = Az;
        return void 0 !== a10 && (a10 = Iz(a10), u10 = Cz), Tz(i10, u10, function(i11, u11) {
          var c10;
          switch (Sz(u11, 0)) {
            case "$":
              return "$";
            case "&":
              return e10;
            case "`":
              return Ez(t10, 0, n10);
            case "'":
              return Ez(t10, o10);
            case "<":
              c10 = a10[Ez(u11, 1, -1)];
              break;
            default:
              var l10 = +u11;
              if (0 === l10) return i11;
              if (l10 > s10) {
                var h10 = Nz(l10 / 10);
                return 0 === h10 ? i11 : h10 <= s10 ? void 0 === r10[h10 - 1] ? Sz(u11, 1) : r10[h10 - 1] + Sz(u11, 1) : i11;
              }
              c10 = r10[l10 - 1];
          }
          return void 0 === c10 ? "" : c10;
        });
      }, _z = fu, Oz = j, Fz = ee, Dz = vL, Mz = B, Lz = dn, zz = xe, Pz = le, Bz = Pr, Wz = Hr, Uz = Ya, Vz = fe, Gz = gL, jz = et, Hz = Rz, qz = NL, Kz = Mt("replace"), Xz = Math.max, Yz = Math.min, Jz = Fz([].concat), Zz = Fz([].push), Qz = Fz("".indexOf), $z = Fz("".slice), eP = "$0" === "a".replace(/./, "$0"), tP = !!/./[Kz] && "" === /./[Kz]("a", "$0"), nP = !Mz(function() {
        var e10 = /./;
        return e10.exec = function() {
          var e11 = [];
          return e11.groups = { a: "7" }, e11;
        }, "7" !== "".replace(e10, "$<a>");
      });
      Dz("replace", function(e10, t10, n10) {
        var r10 = tP ? "$" : "$0";
        return [function(e11, n11) {
          var r11 = Vz(this), a10 = Pz(e11) ? void 0 : jz(e11, Kz);
          return a10 ? Oz(a10, e11, r11, n11) : Oz(t10, Uz(r11), e11, n11);
        }, function(e11, a10) {
          var i10 = Lz(this), o10 = Uz(e11);
          if ("string" == typeof a10 && -1 === Qz(a10, r10) && -1 === Qz(a10, "$<")) {
            var s10 = n10(t10, i10, o10, a10);
            if (s10.done) return s10.value;
          }
          var u10 = zz(a10);
          u10 || (a10 = Uz(a10));
          var c10 = i10.global;
          if (c10) {
            var l10 = i10.unicode;
            i10.lastIndex = 0;
          }
          for (var h10 = []; ; ) {
            var p10 = qz(i10, o10);
            if (null === p10) break;
            if (Zz(h10, p10), !c10) break;
            "" === Uz(p10[0]) && (i10.lastIndex = Gz(o10, Wz(i10.lastIndex), l10));
          }
          for (var f10, d10 = "", v10 = 0, m10 = 0; m10 < h10.length; m10++) {
            for (var g10 = Uz((p10 = h10[m10])[0]), y10 = Xz(Yz(Bz(p10.index), o10.length), 0), b10 = [], x10 = 1; x10 < p10.length; x10++) Zz(b10, void 0 === (f10 = p10[x10]) ? f10 : String(f10));
            var k10 = p10.groups;
            if (u10) {
              var w10 = Jz([g10], b10, y10, o10);
              void 0 !== k10 && Zz(w10, k10);
              var I10 = Uz(_z(a10, void 0, w10));
            } else I10 = Hz(g10, o10, y10, b10, k10, a10);
            y10 >= v10 && (d10 += $z(o10, v10, y10) + I10, v10 = y10 + g10.length);
          }
          return d10 + $z(o10, v10);
        }];
      }, !nP || !eP || tP);
      var rP = La, aP = j, iP = ee, oP = fe, sP = xe, uP = le, cP = XO, lP = Ya, hP = et, pP = nF, fP = Rz, dP = Mt("replace"), vP = TypeError, mP = iP("".indexOf), gP = (iP("".replace), iP("".slice)), yP = Math.max, bP = function(e10, t10, n10) {
        return n10 > e10.length ? -1 : "" === t10 ? n10 : mP(e10, t10, n10);
      };
      rP({ target: "String", proto: true }, { replaceAll: function(e10, t10) {
        var n10, r10, a10, i10, o10, s10, u10, c10, l10 = oP(this), h10 = 0, p10 = 0, f10 = "";
        if (!uP(e10)) {
          if (cP(e10) && (n10 = lP(oP(pP(e10))), !~mP(n10, "g"))) throw vP("`.replaceAll` does not allow non-global regexes");
          if (r10 = hP(e10, dP)) return aP(r10, e10, l10, t10);
        }
        for (a10 = lP(l10), i10 = lP(e10), (o10 = sP(t10)) || (t10 = lP(t10)), s10 = i10.length, u10 = yP(1, s10), h10 = bP(a10, i10, 0); -1 !== h10; ) c10 = o10 ? lP(t10(i10, h10, a10)) : fP(i10, a10, h10, [], void 0, t10), f10 += gP(a10, p10, h10) + c10, p10 = h10 + s10, h10 = bP(a10, i10, h10 + u10);
        return p10 < a10.length && (f10 += gP(a10, p10)), f10;
      } });
      var xP = j, kP = dn, wP = le, IP = fe, NP = xE, SP = Ya, TP = et, EP = NL;
      vL("search", function(e10, t10, n10) {
        return [function(t11) {
          var n11 = IP(this), r10 = wP(t11) ? void 0 : TP(t11, e10);
          return r10 ? xP(r10, t11, n11) : new RegExp(t11)[e10](SP(n11));
        }, function(e11) {
          var r10 = kP(this), a10 = SP(e11), i10 = n10(t10, r10, a10);
          if (i10.done) return i10.value;
          var o10 = r10.lastIndex;
          NP(o10, 0) || (r10.lastIndex = 0);
          var s10 = EP(r10, a10);
          return NP(r10.lastIndex, o10) || (r10.lastIndex = o10), null === s10 ? -1 : s10.index;
        }];
      });
      var CP = fu, AP = j, RP = ee, _P = vL, OP = dn, FP = le, DP = XO, MP = fe, LP = Kb, zP = gL, PP = Hr, BP = Ya, WP = et, UP = Ai, VP = NL, GP = TD, jP = B, HP = uF.UNSUPPORTED_Y, qP = 4294967295, KP = Math.min, XP = [].push, YP = RP(/./.exec), JP = RP(XP), ZP = RP("".slice), QP = !jP(function() {
        var e10 = /(?:)/, t10 = e10.exec;
        e10.exec = function() {
          return t10.apply(this, arguments);
        };
        var n10 = "ab".split(e10);
        return 2 !== n10.length || "a" !== n10[0] || "b" !== n10[1];
      });
      _P("split", function(e10, t10, n10) {
        var r10;
        return r10 = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(e11, n11) {
          var r11 = BP(MP(this)), a10 = void 0 === n11 ? qP : n11 >>> 0;
          if (0 === a10) return [];
          if (void 0 === e11) return [r11];
          if (!DP(e11)) return AP(t10, r11, e11, a10);
          for (var i10, o10, s10, u10 = [], c10 = (e11.ignoreCase ? "i" : "") + (e11.multiline ? "m" : "") + (e11.unicode ? "u" : "") + (e11.sticky ? "y" : ""), l10 = 0, h10 = new RegExp(e11.source, c10 + "g"); (i10 = AP(GP, h10, r11)) && !((o10 = h10.lastIndex) > l10 && (JP(u10, ZP(r11, l10, i10.index)), i10.length > 1 && i10.index < r11.length && CP(XP, u10, UP(i10, 1)), s10 = i10[0].length, l10 = o10, u10.length >= a10)); ) h10.lastIndex === i10.index && h10.lastIndex++;
          return l10 === r11.length ? !s10 && YP(h10, "") || JP(u10, "") : JP(u10, ZP(r11, l10)), u10.length > a10 ? UP(u10, 0, a10) : u10;
        } : "0".split(void 0, 0).length ? function(e11, n11) {
          return void 0 === e11 && 0 === n11 ? [] : AP(t10, this, e11, n11);
        } : t10, [function(t11, n11) {
          var a10 = MP(this), i10 = FP(t11) ? void 0 : WP(t11, e10);
          return i10 ? AP(i10, t11, a10, n11) : AP(r10, BP(a10), t11, n11);
        }, function(e11, a10) {
          var i10 = OP(this), o10 = BP(e11), s10 = n10(r10, i10, o10, a10, r10 !== t10);
          if (s10.done) return s10.value;
          var u10 = LP(i10, RegExp), c10 = i10.unicode, l10 = (i10.ignoreCase ? "i" : "") + (i10.multiline ? "m" : "") + (i10.unicode ? "u" : "") + (HP ? "g" : "y"), h10 = new u10(HP ? "^(?:" + i10.source + ")" : i10, l10), p10 = void 0 === a10 ? qP : a10 >>> 0;
          if (0 === p10) return [];
          if (0 === o10.length) return null === VP(h10, o10) ? [o10] : [];
          for (var f10 = 0, d10 = 0, v10 = []; d10 < o10.length; ) {
            h10.lastIndex = HP ? 0 : d10;
            var m10, g10 = VP(h10, HP ? ZP(o10, d10) : o10);
            if (null === g10 || (m10 = KP(PP(h10.lastIndex + (HP ? d10 : 0)), o10.length)) === f10) d10 = zP(o10, d10, c10);
            else {
              if (JP(v10, ZP(o10, f10, d10)), v10.length === p10) return v10;
              for (var y10 = 1; y10 <= g10.length - 1; y10++) if (JP(v10, g10[y10]), v10.length === p10) return v10;
              d10 = f10 = m10;
            }
          }
          return JP(v10, ZP(o10, f10)), v10;
        }];
      }, !QP, HP);
      var $P = La, eB = ro, tB = P.f, nB = Hr, rB = Ya, aB = NM, iB = fe, oB = TM, sB = eB("".startsWith), uB = eB("".slice), cB = Math.min, lB = oB("startsWith"), hB = !lB && !!function() {
        var e10 = tB(String.prototype, "startsWith");
        return e10 && !e10.writable;
      }();
      $P({ target: "String", proto: true, forced: !hB && !lB }, { startsWith: function(e10) {
        var t10 = rB(iB(this));
        aB(e10);
        var n10 = nB(cB(arguments.length > 1 ? arguments[1] : void 0, t10.length)), r10 = rB(e10);
        return sB ? sB(t10, r10, n10) : uB(t10, n10, n10 + r10.length) === r10;
      } });
      var pB = La, fB = fe, dB = Pr, vB = Ya, mB = ee("".slice), gB = Math.max, yB = Math.min;
      pB({ target: "String", proto: true, forced: !"".substr || "b" !== "ab".substr(-1) }, { substr: function(e10, t10) {
        var n10, r10, a10 = vB(fB(this)), i10 = a10.length, o10 = dB(e10);
        return o10 === 1 / 0 && (o10 = 0), o10 < 0 && (o10 = gB(i10 + o10, 0)), (n10 = void 0 === t10 ? i10 : dB(t10)) <= 0 || n10 === 1 / 0 || o10 >= (r10 = yB(o10 + n10, i10)) ? "" : mB(a10, o10, r10);
      } });
      var bB = Mn.PROPER, xB = B, kB = fN, wB = function(e10) {
        return xB(function() {
          return !!kB[e10]() || "​᠎" !== "​᠎"[e10]() || bB && kB[e10].name !== e10;
        });
      }, IB = kN.trim;
      La({ target: "String", proto: true, forced: wB("trim") }, { trim: function() {
        return IB(this);
      } });
      var NB = kN.end, SB = wB("trimEnd") ? function() {
        return NB(this);
      } : "".trimEnd;
      La({ target: "String", proto: true, name: "trimEnd", forced: "".trimRight !== SB }, { trimRight: SB });
      La({ target: "String", proto: true, name: "trimEnd", forced: "".trimEnd !== SB }, { trimEnd: SB });
      var TB = kN.start, EB = wB("trimStart") ? function() {
        return TB(this);
      } : "".trimStart;
      La({ target: "String", proto: true, name: "trimStart", forced: "".trimLeft !== EB }, { trimLeft: EB });
      La({ target: "String", proto: true, name: "trimStart", forced: "".trimStart !== EB }, { trimStart: EB });
      var CB = fe, AB = Ya, RB = /"/g, _B = ee("".replace), OB = function(e10, t10, n10, r10) {
        var a10 = AB(CB(e10)), i10 = "<" + t10;
        return "" !== n10 && (i10 += " " + n10 + '="' + _B(AB(r10), RB, "&quot;") + '"'), i10 + ">" + a10 + "</" + t10 + ">";
      }, FB = B, DB = function(e10) {
        return FB(function() {
          var t10 = ""[e10]('"');
          return t10 !== t10.toLowerCase() || t10.split('"').length > 3;
        });
      }, MB = OB;
      La({ target: "String", proto: true, forced: DB("anchor") }, { anchor: function(e10) {
        return MB(this, "a", "name", e10);
      } });
      var LB = OB;
      La({ target: "String", proto: true, forced: DB("big") }, { big: function() {
        return LB(this, "big", "", "");
      } });
      var zB = OB;
      La({ target: "String", proto: true, forced: DB("blink") }, { blink: function() {
        return zB(this, "blink", "", "");
      } });
      var PB = OB;
      La({ target: "String", proto: true, forced: DB("bold") }, { bold: function() {
        return PB(this, "b", "", "");
      } });
      var BB = OB;
      La({ target: "String", proto: true, forced: DB("fixed") }, { fixed: function() {
        return BB(this, "tt", "", "");
      } });
      var WB = OB;
      La({ target: "String", proto: true, forced: DB("fontcolor") }, { fontcolor: function(e10) {
        return WB(this, "font", "color", e10);
      } });
      var UB = OB;
      La({ target: "String", proto: true, forced: DB("fontsize") }, { fontsize: function(e10) {
        return UB(this, "font", "size", e10);
      } });
      var VB = OB;
      La({ target: "String", proto: true, forced: DB("italics") }, { italics: function() {
        return VB(this, "i", "", "");
      } });
      var GB = OB;
      La({ target: "String", proto: true, forced: DB("link") }, { link: function(e10) {
        return GB(this, "a", "href", e10);
      } });
      var jB = OB;
      La({ target: "String", proto: true, forced: DB("small") }, { small: function() {
        return jB(this, "small", "", "");
      } });
      var HB = OB;
      La({ target: "String", proto: true, forced: DB("strike") }, { strike: function() {
        return HB(this, "strike", "", "");
      } });
      var qB = OB;
      La({ target: "String", proto: true, forced: DB("sub") }, { sub: function() {
        return qB(this, "sub", "", "");
      } });
      var KB = OB;
      La({ target: "String", proto: true, forced: DB("sup") }, { sup: function() {
        return KB(this, "sup", "", "");
      } });
      var XB = { exports: {} }, YB = z, JB = B, ZB = Uf, QB = Pb.NATIVE_ARRAY_BUFFER_VIEWS, $B = YB.ArrayBuffer, eW = YB.Int8Array, tW = !QB || !JB(function() {
        eW(1);
      }) || !JB(function() {
        new eW(-1);
      }) || !ZB(function(e10) {
        new eW(), new eW(null), new eW(1.5), new eW(e10);
      }, true) || JB(function() {
        return 1 !== new eW(new $B(2), 1, void 0).length;
      }), nW = Pr, rW = RangeError, aW = function(e10) {
        var t10 = nW(e10);
        if (t10 < 0) throw rW("The argument can't be less than 0");
        return t10;
      }, iW = aW, oW = RangeError, sW = function(e10, t10) {
        var n10 = iW(e10);
        if (n10 % t10) throw oW("Wrong offset");
        return n10;
      }, uW = qa, cW = function(e10) {
        var t10 = uW(e10);
        return "BigInt64Array" == t10 || "BigUint64Array" == t10;
      }, lW = Gt, hW = TypeError, pW = function(e10) {
        var t10 = lW(e10, "number");
        if ("number" == typeof t10) throw hW("Can't convert number to bigint");
        return BigInt(t10);
      }, fW = so, dW = j, vW = Vb, mW = yt, gW = Kr, yW = eh, bW = Kl, xW = Ul, kW = cW, wW = Pb.aTypedArrayConstructor, IW = pW, NW = function(e10) {
        var t10, n10, r10, a10, i10, o10, s10, u10, c10 = vW(this), l10 = mW(e10), h10 = arguments.length, p10 = h10 > 1 ? arguments[1] : void 0, f10 = void 0 !== p10, d10 = bW(l10);
        if (d10 && !xW(d10)) for (u10 = (s10 = yW(l10, d10)).next, l10 = []; !(o10 = dW(u10, s10)).done; ) l10.push(o10.value);
        for (f10 && h10 > 2 && (p10 = fW(p10, arguments[2])), n10 = gW(l10), r10 = new (wW(c10))(n10), a10 = kW(r10), t10 = 0; n10 > t10; t10++) i10 = f10 ? p10(l10[t10], t10) : l10[t10], r10[t10] = a10 ? IW(i10) : +i10;
        return r10;
      }, SW = (XB.exports, La), TW = z, EW = j, CW = W, AW = tW, RW = Pb, _W = Zy, OW = zg, FW = Y, DW = Cn, MW = nS, LW = Hr, zW = Ug, PW = sW, BW = qt, WW = kt, UW = qa, VW = Ie, GW = He, jW = yi, HW = Ce, qW = Tc, KW = Fr.f, XW = NW, YW = Wo.forEach, JW = Fm, ZW = zi, QW = cn, $W = P, eU = Oc, tU = cr.get, nU = cr.set, rU = cr.enforce, aU = QW.f, iU = $W.f, oU = Math.round, sU = TW.RangeError, uU = _W.ArrayBuffer, cU = uU.prototype, lU = _W.DataView, hU = RW.NATIVE_ARRAY_BUFFER_VIEWS, pU = RW.TYPED_ARRAY_TAG, fU = RW.TypedArray, dU = RW.TypedArrayPrototype, vU = RW.aTypedArrayConstructor, mU = RW.isTypedArray, gU = "BYTES_PER_ELEMENT", yU = "Wrong length", bU = function(e10, t10) {
        vU(e10);
        for (var n10 = 0, r10 = t10.length, a10 = new e10(r10); r10 > n10; ) a10[n10] = t10[n10++];
        return a10;
      }, xU = function(e10, t10) {
        ZW(e10, t10, { configurable: true, get: function() {
          return tU(this)[t10];
        } });
      }, kU = function(e10) {
        var t10;
        return HW(cU, e10) || "ArrayBuffer" == (t10 = UW(e10)) || "SharedArrayBuffer" == t10;
      }, wU = function(e10, t10) {
        return mU(e10) && !GW(t10) && t10 in e10 && MW(+t10) && t10 >= 0;
      }, IU = function(e10, t10) {
        return t10 = BW(t10), wU(e10, t10) ? FW(2, e10[t10]) : iU(e10, t10);
      }, NU = function(e10, t10, n10) {
        return t10 = BW(t10), !(wU(e10, t10) && VW(n10) && WW(n10, "value")) || WW(n10, "get") || WW(n10, "set") || n10.configurable || WW(n10, "writable") && !n10.writable || WW(n10, "enumerable") && !n10.enumerable ? aU(e10, t10, n10) : (e10[t10] = n10.value, e10);
      };
      CW ? (hU || ($W.f = IU, QW.f = NU, xU(dU, "buffer"), xU(dU, "byteOffset"), xU(dU, "byteLength"), xU(dU, "length")), SW({ target: "Object", stat: true, forced: !hU }, { getOwnPropertyDescriptor: IU, defineProperty: NU }), XB.exports = function(e10, t10, n10) {
        var r10 = e10.match(/\d+/)[0] / 8, a10 = e10 + (n10 ? "Clamped" : "") + "Array", i10 = "get" + e10, o10 = "set" + e10, s10 = TW[a10], u10 = s10, c10 = u10 && u10.prototype, l10 = {}, h10 = function(e11, t11) {
          aU(e11, t11, { get: function() {
            return function(e12, t12) {
              var n11 = tU(e12);
              return n11.view[i10](t12 * r10 + n11.byteOffset, true);
            }(this, t11);
          }, set: function(e12) {
            return function(e13, t12, a11) {
              var i11 = tU(e13);
              n10 && (a11 = (a11 = oU(a11)) < 0 ? 0 : a11 > 255 ? 255 : 255 & a11), i11.view[o10](t12 * r10 + i11.byteOffset, a11, true);
            }(this, t11, e12);
          }, enumerable: true });
        };
        hU ? AW && (u10 = t10(function(e11, t11, n11, a11) {
          return OW(e11, c10), eU(VW(t11) ? kU(t11) ? void 0 !== a11 ? new s10(t11, PW(n11, r10), a11) : void 0 !== n11 ? new s10(t11, PW(n11, r10)) : new s10(t11) : mU(t11) ? bU(u10, t11) : EW(XW, u10, t11) : new s10(zW(t11)), e11, u10);
        }), qW && qW(u10, fU), YW(KW(s10), function(e11) {
          e11 in u10 || DW(u10, e11, s10[e11]);
        }), u10.prototype = c10) : (u10 = t10(function(e11, t11, n11, a11) {
          OW(e11, c10);
          var i11, o11, s11, l11 = 0, p11 = 0;
          if (VW(t11)) {
            if (!kU(t11)) return mU(t11) ? bU(u10, t11) : EW(XW, u10, t11);
            i11 = t11, p11 = PW(n11, r10);
            var f10 = t11.byteLength;
            if (void 0 === a11) {
              if (f10 % r10) throw sU(yU);
              if ((o11 = f10 - p11) < 0) throw sU(yU);
            } else if ((o11 = LW(a11) * r10) + p11 > f10) throw sU(yU);
            s11 = o11 / r10;
          } else s11 = zW(t11), i11 = new uU(o11 = s11 * r10);
          for (nU(e11, { buffer: i11, byteOffset: p11, byteLength: o11, length: s11, view: new lU(i11) }); l11 < s11; ) h10(e11, l11++);
        }), qW && qW(u10, fU), c10 = u10.prototype = jW(dU)), c10.constructor !== u10 && DW(c10, "constructor", u10), rU(c10).TypedArrayConstructor = u10, pU && DW(c10, pU, a10);
        var p10 = u10 != s10;
        l10[a10] = u10, SW({ global: true, constructor: true, forced: p10, sham: !hU }, l10), gU in u10 || DW(u10, gU, r10), gU in c10 || DW(c10, gU, r10), JW(a10);
      }) : XB.exports = function() {
      };
      var SU = XB.exports;
      SU("Float32", function(e10) {
        return function(t10, n10, r10) {
          return e10(this, t10, n10, r10);
        };
      }), SU("Float64", function(e10) {
        return function(t10, n10, r10) {
          return e10(this, t10, n10, r10);
        };
      }), SU("Int8", function(e10) {
        return function(t10, n10, r10) {
          return e10(this, t10, n10, r10);
        };
      }), SU("Int16", function(e10) {
        return function(t10, n10, r10) {
          return e10(this, t10, n10, r10);
        };
      }), SU("Int32", function(e10) {
        return function(t10, n10, r10) {
          return e10(this, t10, n10, r10);
        };
      }), SU("Uint8", function(e10) {
        return function(t10, n10, r10) {
          return e10(this, t10, n10, r10);
        };
      }), SU("Uint8", function(e10) {
        return function(t10, n10, r10) {
          return e10(this, t10, n10, r10);
        };
      }, true), SU("Uint16", function(e10) {
        return function(t10, n10, r10) {
          return e10(this, t10, n10, r10);
        };
      }), SU("Uint32", function(e10) {
        return function(t10, n10, r10) {
          return e10(this, t10, n10, r10);
        };
      });
      var TU = Kr, EU = Pr, CU = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("at", function(e10) {
        var t10 = CU(this), n10 = TU(t10), r10 = EU(e10), a10 = r10 >= 0 ? r10 : n10 + r10;
        return a10 < 0 || a10 >= n10 ? void 0 : t10[a10];
      });
      var AU = Pb, RU = ee(Ep), _U = AU.aTypedArray;
      (0, AU.exportTypedArrayMethod)("copyWithin", function(e10, t10) {
        return RU(_U(this), e10, t10, arguments.length > 2 ? arguments[2] : void 0);
      });
      var OU = Wo.every, FU = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("every", function(e10) {
        return OU(FU(this), e10, arguments.length > 1 ? arguments[1] : void 0);
      });
      var DU = Mp, MU = pW, LU = qa, zU = j, PU = B, BU = Pb.aTypedArray, WU = Pb.exportTypedArrayMethod, UU = ee("".slice), VU = PU(function() {
        var e10 = 0;
        return new Int8Array(2).fill({ valueOf: function() {
          return e10++;
        } }), 1 !== e10;
      });
      WU("fill", function(e10) {
        var t10 = arguments.length;
        BU(this);
        var n10 = "Big" === UU(LU(this), 0, 3) ? MU(e10) : +e10;
        return zU(DU, this, n10, t10 > 1 ? arguments[1] : void 0, t10 > 2 ? arguments[2] : void 0);
      }, VU);
      var GU = Kb, jU = Pb.aTypedArrayConstructor, HU = Pb.getTypedArrayConstructor, qU = function(e10) {
        return jU(GU(e10, HU(e10)));
      }, KU = eg, XU = qU, YU = function(e10, t10) {
        return KU(XU(e10), t10);
      }, JU = Wo.filter, ZU = YU, QU = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("filter", function(e10) {
        var t10 = JU(QU(this), e10, arguments.length > 1 ? arguments[1] : void 0);
        return ZU(this, t10);
      });
      var $U = Wo.find, eV = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("find", function(e10) {
        return $U(eV(this), e10, arguments.length > 1 ? arguments[1] : void 0);
      });
      var tV = Wo.findIndex, nV = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("findIndex", function(e10) {
        return tV(nV(this), e10, arguments.length > 1 ? arguments[1] : void 0);
      });
      var rV = $p.findLast, aV = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("findLast", function(e10) {
        return rV(aV(this), e10, arguments.length > 1 ? arguments[1] : void 0);
      });
      var iV = $p.findLastIndex, oV = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("findLastIndex", function(e10) {
        return iV(oV(this), e10, arguments.length > 1 ? arguments[1] : void 0);
      });
      var sV = Wo.forEach, uV = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("forEach", function(e10) {
        sV(uV(this), e10, arguments.length > 1 ? arguments[1] : void 0);
      }), (0, Pb.exportTypedArrayStaticMethod)("from", NW, tW);
      var cV = Qr.includes, lV = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("includes", function(e10) {
        return cV(lV(this), e10, arguments.length > 1 ? arguments[1] : void 0);
      });
      var hV = Qr.indexOf, pV = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("indexOf", function(e10) {
        return hV(pV(this), e10, arguments.length > 1 ? arguments[1] : void 0);
      });
      var fV = z, dV = B, vV = ee, mV = Pb, gV = Kd, yV = Mt("iterator"), bV = fV.Uint8Array, xV = vV(gV.values), kV = vV(gV.keys), wV = vV(gV.entries), IV = mV.aTypedArray, NV = mV.exportTypedArrayMethod, SV = bV && bV.prototype, TV = !dV(function() {
        SV[yV].call([1]);
      }), EV = !!SV && SV.values && SV[yV] === SV.values && "values" === SV.values.name, CV = function() {
        return xV(IV(this));
      };
      NV("entries", function() {
        return wV(IV(this));
      }, TV), NV("keys", function() {
        return kV(IV(this));
      }, TV), NV("values", CV, TV || !EV, { name: "values" }), NV(yV, CV, TV || !EV, { name: "values" });
      var AV = Pb.aTypedArray, RV = Pb.exportTypedArrayMethod, _V = ee([].join);
      RV("join", function(e10) {
        return _V(AV(this), e10);
      });
      var OV = fu, FV = cv, DV = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("lastIndexOf", function(e10) {
        var t10 = arguments.length;
        return OV(FV, DV(this), t10 > 1 ? [e10, arguments[1]] : [e10]);
      });
      var MV = Wo.map, LV = qU, zV = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("map", function(e10) {
        return MV(zV(this), e10, arguments.length > 1 ? arguments[1] : void 0, function(e11, t10) {
          return new (LV(e11))(t10);
        });
      });
      var PV = Pb.aTypedArrayConstructor;
      (0, Pb.exportTypedArrayStaticMethod)("of", function() {
        for (var e10 = 0, t10 = arguments.length, n10 = new (PV(this))(t10); t10 > e10; ) n10[e10] = arguments[e10++];
        return n10;
      }, tW);
      var BV = Av.left, WV = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("reduce", function(e10) {
        var t10 = arguments.length;
        return BV(WV(this), e10, t10, t10 > 1 ? arguments[1] : void 0);
      });
      var UV = Av.right, VV = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("reduceRight", function(e10) {
        var t10 = arguments.length;
        return UV(VV(this), e10, t10, t10 > 1 ? arguments[1] : void 0);
      });
      var GV = Pb.aTypedArray, jV = Pb.exportTypedArrayMethod, HV = Math.floor;
      jV("reverse", function() {
        for (var e10, t10 = this, n10 = GV(t10).length, r10 = HV(n10 / 2), a10 = 0; a10 < r10; ) e10 = t10[a10], t10[a10++] = t10[--n10], t10[n10] = e10;
        return t10;
      });
      var qV = z, KV = j, XV = Pb, YV = Kr, JV = sW, ZV = yt, QV = B, $V = qV.RangeError, eG = qV.Int8Array, tG = eG && eG.prototype, nG = tG && tG.set, rG = XV.aTypedArray, aG = XV.exportTypedArrayMethod, iG = !QV(function() {
        var e10 = new Uint8ClampedArray(2);
        return KV(nG, e10, { length: 1, 0: 3 }, 1), 3 !== e10[1];
      }), oG = iG && XV.NATIVE_ARRAY_BUFFER_VIEWS && QV(function() {
        var e10 = new eG(2);
        return e10.set(1), e10.set("2", 1), 0 !== e10[0] || 2 !== e10[1];
      });
      aG("set", function(e10) {
        rG(this);
        var t10 = JV(arguments.length > 1 ? arguments[1] : void 0, 1), n10 = ZV(e10);
        if (iG) return KV(nG, this, n10, t10);
        var r10 = this.length, a10 = YV(n10), i10 = 0;
        if (a10 + t10 > r10) throw $V("Wrong length");
        for (; i10 < a10; ) this[t10 + i10] = n10[i10++];
      }, !iG || oG);
      var sG = qU, uG = du, cG = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("slice", function(e10, t10) {
        for (var n10 = uG(cG(this), e10, t10), r10 = sG(this), a10 = 0, i10 = n10.length, o10 = new r10(i10); i10 > a10; ) o10[a10] = n10[a10++];
        return o10;
      }, B(function() {
        new Int8Array(1).slice();
      }));
      var lG = Wo.some, hG = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("some", function(e10) {
        return lG(hG(this), e10, arguments.length > 1 ? arguments[1] : void 0);
      });
      var pG = ro, fG = B, dG = Ze, vG = nm, mG = am, gG = im, yG = Le, bG = sm, xG = Pb.aTypedArray, kG = Pb.exportTypedArrayMethod, wG = z.Uint16Array, IG = wG && pG(wG.prototype.sort), NG = !(!IG || fG(function() {
        IG(new wG(2), null);
      }) && fG(function() {
        IG(new wG(2), {});
      })), SG = !!IG && !fG(function() {
        if (yG) return yG < 74;
        if (mG) return mG < 67;
        if (gG) return true;
        if (bG) return bG < 602;
        var e10, t10, n10 = new wG(516), r10 = Array(516);
        for (e10 = 0; e10 < 516; e10++) t10 = e10 % 4, n10[e10] = 515 - e10, r10[e10] = e10 - 2 * t10 + 3;
        for (IG(n10, function(e11, t11) {
          return (e11 / 4 | 0) - (t11 / 4 | 0);
        }), e10 = 0; e10 < 516; e10++) if (n10[e10] !== r10[e10]) return true;
      });
      kG("sort", function(e10) {
        return void 0 !== e10 && dG(e10), SG ? IG(this, e10) : vG(xG(this), /* @__PURE__ */ function(e11) {
          return function(t10, n10) {
            return void 0 !== e11 ? +e11(t10, n10) || 0 : n10 != n10 ? -1 : t10 != t10 ? 1 : 0 === t10 && 0 === n10 ? 1 / t10 > 0 && 1 / n10 < 0 ? 1 : -1 : t10 > n10;
          };
        }(e10));
      }, !SG || NG);
      var TG = Hr, EG = Vr, CG = qU, AG = Pb.aTypedArray;
      (0, Pb.exportTypedArrayMethod)("subarray", function(e10, t10) {
        var n10 = AG(this), r10 = n10.length, a10 = EG(e10, r10);
        return new (CG(n10))(n10.buffer, n10.byteOffset + a10 * n10.BYTES_PER_ELEMENT, TG((void 0 === t10 ? r10 : EG(t10, r10)) - a10));
      });
      var RG = fu, _G = Pb, OG = B, FG = du, DG = z.Int8Array, MG = _G.aTypedArray, LG = _G.exportTypedArrayMethod, zG = [].toLocaleString, PG = !!DG && OG(function() {
        zG.call(new DG(1));
      });
      LG("toLocaleString", function() {
        return RG(zG, PG ? FG(MG(this)) : MG(this), FG(arguments));
      }, OG(function() {
        return [1, 2].toLocaleString() != new DG([1, 2]).toLocaleString();
      }) || !OG(function() {
        DG.prototype.toLocaleString.call([1, 2]);
      }));
      var BG = Xm, WG = Pb.aTypedArray, UG = Pb.getTypedArrayConstructor;
      (0, Pb.exportTypedArrayMethod)("toReversed", function() {
        return BG(WG(this), UG(this));
      });
      var VG = Ze, GG = eg, jG = Pb.aTypedArray, HG = Pb.getTypedArrayConstructor, qG = Pb.exportTypedArrayMethod, KG = ee(Pb.TypedArrayPrototype.sort);
      qG("toSorted", function(e10) {
        void 0 !== e10 && VG(e10);
        var t10 = jG(this), n10 = GG(HG(t10), t10);
        return KG(n10, e10);
      });
      var XG = Pb.exportTypedArrayMethod, YG = B, JG = ee, ZG = z.Uint8Array, QG = ZG && ZG.prototype || {}, $G = [].toString, ej = JG([].join);
      YG(function() {
        $G.call({});
      }) && ($G = function() {
        return ej(this);
      });
      var tj = QG.toString != $G;
      XG("toString", $G, tj);
      var nj = Cg, rj = cW, aj = Pr, ij = pW, oj = Pb.aTypedArray, sj = Pb.getTypedArrayConstructor, uj = Pb.exportTypedArrayMethod, cj = !!function() {
        try {
          new Int8Array(1).with(2, { valueOf: function() {
            throw 8;
          } });
        } catch (e10) {
          return 8 === e10;
        }
      }();
      uj("with", { with: function(e10, t10) {
        var n10 = oj(this), r10 = aj(e10), a10 = rj(n10) ? ij(t10) : +t10;
        return nj(n10, sj(n10), r10, a10);
      } }.with, !cj);
      var lj = La, hj = ee, pj = Ya, fj = String.fromCharCode, dj = hj("".charAt), vj = hj(/./.exec), mj = hj("".slice), gj = /^[\da-f]{2}$/i, yj = /^[\da-f]{4}$/i;
      lj({ global: true }, { unescape: function(e10) {
        for (var t10, n10, r10 = pj(e10), a10 = "", i10 = r10.length, o10 = 0; o10 < i10; ) {
          if ("%" === (t10 = dj(r10, o10++))) {
            if ("u" === dj(r10, o10)) {
              if (n10 = mj(r10, o10 + 1, o10 + 5), vj(yj, n10)) {
                a10 += fj(parseInt(n10, 16)), o10 += 5;
                continue;
              }
            } else if (n10 = mj(r10, o10, o10 + 2), vj(gj, n10)) {
              a10 += fj(parseInt(n10, 16)), o10 += 2;
              continue;
            }
          }
          a10 += t10;
        }
        return a10;
      } });
      var bj = ee, xj = Dg, kj = Sw.getWeakData, wj = zg, Ij = dn, Nj = le, Sj = Ie, Tj = yh, Ej = kt, Cj = cr.set, Aj = cr.getterFor, Rj = Wo.find, _j = Wo.findIndex, Oj = bj([].splice), Fj = 0, Dj = function(e10) {
        return e10.frozen || (e10.frozen = new Mj());
      }, Mj = function() {
        this.entries = [];
      }, Lj = function(e10, t10) {
        return Rj(e10.entries, function(e11) {
          return e11[0] === t10;
        });
      };
      Mj.prototype = { get: function(e10) {
        var t10 = Lj(this, e10);
        if (t10) return t10[1];
      }, has: function(e10) {
        return !!Lj(this, e10);
      }, set: function(e10, t10) {
        var n10 = Lj(this, e10);
        n10 ? n10[1] = t10 : this.entries.push([e10, t10]);
      }, delete: function(e10) {
        var t10 = _j(this.entries, function(t11) {
          return t11[0] === e10;
        });
        return ~t10 && Oj(this.entries, t10, 1), !!~t10;
      } };
      var zj, Pj = { getConstructor: function(e10, t10, n10, r10) {
        var a10 = e10(function(e11, a11) {
          wj(e11, i10), Cj(e11, { type: t10, id: Fj++, frozen: void 0 }), Nj(a11) || Tj(a11, e11[r10], { that: e11, AS_ENTRIES: n10 });
        }), i10 = a10.prototype, o10 = Aj(t10), s10 = function(e11, t11, n11) {
          var r11 = o10(e11), a11 = kj(Ij(t11), true);
          return true === a11 ? Dj(r11).set(t11, n11) : a11[r11.id] = n11, e11;
        };
        return xj(i10, { delete: function(e11) {
          var t11 = o10(this);
          if (!Sj(e11)) return false;
          var n11 = kj(e11);
          return true === n11 ? Dj(t11).delete(e11) : n11 && Ej(n11, t11.id) && delete n11[t11.id];
        }, has: function(e11) {
          var t11 = o10(this);
          if (!Sj(e11)) return false;
          var n11 = kj(e11);
          return true === n11 ? Dj(t11).has(e11) : n11 && Ej(n11, t11.id);
        } }), xj(i10, n10 ? { get: function(e11) {
          var t11 = o10(this);
          if (Sj(e11)) {
            var n11 = kj(e11);
            return true === n11 ? Dj(t11).get(e11) : n11 ? n11[t11.id] : void 0;
          }
        }, set: function(e11, t11) {
          return s10(this, e11, t11);
        } } : { add: function(e11) {
          return s10(this, e11, true);
        } }), a10;
      } }, Bj = cw, Wj = z, Uj = ee, Vj = Dg, Gj = Sw, jj = Uw, Hj = Pj, qj = Ie, Kj = cr.enforce, Xj = B, Yj = Hn, Jj = Object, Zj = Array.isArray, Qj = Jj.isExtensible, $j = Jj.isFrozen, eH = Jj.isSealed, tH = Jj.freeze, nH = Jj.seal, rH = {}, aH = {}, iH = !Wj.ActiveXObject && "ActiveXObject" in Wj, oH = function(e10) {
        return function() {
          return e10(this, arguments.length ? arguments[0] : void 0);
        };
      }, sH = jj("WeakMap", oH, Hj), uH = sH.prototype, cH = Uj(uH.set);
      if (Yj) if (iH) {
        zj = Hj.getConstructor(oH, "WeakMap", true), Gj.enable();
        var lH = Uj(uH.delete), hH = Uj(uH.has), pH = Uj(uH.get);
        Vj(uH, { delete: function(e10) {
          if (qj(e10) && !Qj(e10)) {
            var t10 = Kj(this);
            return t10.frozen || (t10.frozen = new zj()), lH(this, e10) || t10.frozen.delete(e10);
          }
          return lH(this, e10);
        }, has: function(e10) {
          if (qj(e10) && !Qj(e10)) {
            var t10 = Kj(this);
            return t10.frozen || (t10.frozen = new zj()), hH(this, e10) || t10.frozen.has(e10);
          }
          return hH(this, e10);
        }, get: function(e10) {
          if (qj(e10) && !Qj(e10)) {
            var t10 = Kj(this);
            return t10.frozen || (t10.frozen = new zj()), hH(this, e10) ? pH(this, e10) : t10.frozen.get(e10);
          }
          return pH(this, e10);
        }, set: function(e10, t10) {
          if (qj(e10) && !Qj(e10)) {
            var n10 = Kj(this);
            n10.frozen || (n10.frozen = new zj()), hH(this, e10) ? cH(this, e10, t10) : n10.frozen.set(e10, t10);
          } else cH(this, e10, t10);
          return this;
        } });
      } else Bj && Xj(function() {
        var e10 = tH([]);
        return cH(new sH(), e10, 1), !$j(e10);
      }) && Vj(uH, { set: function(e10, t10) {
        var n10;
        return Zj(e10) && ($j(e10) ? n10 = rH : eH(e10) && (n10 = aH)), cH(this, e10, t10), n10 == rH && tH(e10), n10 == aH && nH(e10), this;
      } });
      Uw("WeakSet", function(e10) {
        return function() {
          return e10(this, arguments.length ? arguments[0] : void 0);
        };
      }, Pj);
      for (var fH = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", dH = {}, vH = 0; vH < 66; vH++) dH[fH.charAt(vH)] = vH;
      var mH = { itoc: fH, ctoi: dH }, gH = La, yH = z, bH = Ee, xH = ee, kH = j, wH = B, IH = Ya, NH = kt, SH = TC, TH = mH.ctoi, EH = /[^\d+/a-z]/i, CH = /[\t\n\f\r ]+/g, AH = /[=]{1,2}$/, RH = bH("atob"), _H = String.fromCharCode, OH = xH("".charAt), FH = xH("".replace), DH = xH(EH.exec), MH = wH(function() {
        return "" !== RH(" ");
      }), LH = !wH(function() {
        RH("a");
      }), zH = !MH && !LH && !wH(function() {
        RH();
      }), PH = !MH && !LH && 1 !== RH.length;
      gH({ global: true, bind: true, enumerable: true, forced: MH || LH || zH || PH }, { atob: function(e10) {
        if (SH(arguments.length, 1), zH || PH) return kH(RH, yH, e10);
        var t10, n10, r10 = FH(IH(e10), CH, ""), a10 = "", i10 = 0, o10 = 0;
        if (r10.length % 4 == 0 && (r10 = FH(r10, AH, "")), r10.length % 4 == 1 || DH(EH, r10)) throw new (bH("DOMException"))("The string is not correctly encoded", "InvalidCharacterError");
        for (; t10 = OH(r10, i10++); ) NH(TH, t10) && (n10 = o10 % 4 ? 64 * n10 + TH[t10] : TH[t10], o10++ % 4 && (a10 += _H(255 & n10 >> (-2 * o10 & 6))));
        return a10;
      } });
      var BH = La, WH = z, UH = Ee, VH = ee, GH = j, jH = B, HH = Ya, qH = TC, KH = mH.itoc, XH = UH("btoa"), YH = VH("".charAt), JH = VH("".charCodeAt), ZH = !!XH && !jH(function() {
        XH();
      }), QH = !!XH && jH(function() {
        return "bnVsbA==" !== XH(null);
      }), $H = !!XH && 1 !== XH.length;
      BH({ global: true, bind: true, enumerable: true, forced: ZH || QH || $H }, { btoa: function(e10) {
        if (qH(arguments.length, 1), ZH || QH || $H) return GH(XH, WH, HH(e10));
        for (var t10, n10, r10 = HH(e10), a10 = "", i10 = 0, o10 = KH; YH(r10, i10) || (o10 = "=", i10 % 1); ) {
          if ((n10 = JH(r10, i10 += 3 / 4)) > 255) throw new (UH("DOMException"))("The string contains characters outside of the Latin1 range", "InvalidCharacterError");
          a10 += YH(o10, 63 & (t10 = t10 << 8 | n10) >> 8 - i10 % 1 * 8);
        }
        return a10;
      } });
      var eq = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, tq = Jt("span").classList, nq = tq && tq.constructor && tq.constructor.prototype, rq = nq === Object.prototype ? void 0 : nq, aq = z, iq = eq, oq = rq, sq = kf, uq = Cn, cq = function(e10) {
        if (e10 && e10.forEach !== sq) try {
          uq(e10, "forEach", sq);
        } catch (t10) {
          e10.forEach = sq;
        }
      };
      for (var lq in iq) iq[lq] && cq(aq[lq] && aq[lq].prototype);
      cq(oq);
      var hq = z, pq = eq, fq = rq, dq = Kd, vq = Cn, mq = Mt, gq = mq("iterator"), yq = mq("toStringTag"), bq = dq.values, xq = function(e10, t10) {
        if (e10) {
          if (e10[gq] !== bq) try {
            vq(e10, gq, bq);
          } catch (t11) {
            e10[gq] = bq;
          }
          if (e10[yq] || vq(e10, yq, t10), pq[t10]) {
            for (var n10 in dq) if (e10[n10] !== dq[n10]) try {
              vq(e10, n10, dq[n10]);
            } catch (t11) {
              e10[n10] = dq[n10];
            }
          }
        }
      };
      for (var kq in pq) xq(hq[kq] && hq[kq].prototype, kq);
      xq(fq, "DOMTokenList");
      var wq = Rv, Iq = function(e10) {
        try {
          if (wq) return Function('return require("' + e10 + '")')();
        } catch (e11) {
        }
      }, Nq = { IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 }, DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 }, HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 }, WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 }, InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 }, NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 }, NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 }, NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 }, NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 }, InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 }, InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 }, SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 }, InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 }, NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 }, InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 }, ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 }, TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 }, SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 }, NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 }, AbortError: { s: "ABORT_ERR", c: 20, m: 1 }, URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 }, QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 }, TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 }, InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 }, DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 } }, Sq = La, Tq = Iq, Eq = Ee, Cq = B, Aq = yi, Rq = Y, _q = cn.f, Oq = Or, Fq = zi, Dq = kt, Mq = zg, Lq = dn, zq = Nl, Pq = Dc, Bq = Nq, Wq = Gc, Uq = cr, Vq = W, Gq = "DOMException", jq = "DATA_CLONE_ERR", Hq = Eq("Error"), qq = Eq(Gq) || function() {
        try {
          new (Eq("MessageChannel") || Tq("worker_threads").MessageChannel)().port1.postMessage(/* @__PURE__ */ new WeakMap());
        } catch (e10) {
          if (e10.name == jq && 25 == e10.code) return e10.constructor;
        }
      }(), Kq = qq && qq.prototype, Xq = Hq.prototype, Yq = Uq.set, Jq = Uq.getterFor(Gq), Zq = "stack" in Hq(Gq), Qq = function(e10) {
        return Dq(Bq, e10) && Bq[e10].m ? Bq[e10].c : 0;
      }, $q = function() {
        Mq(this, eK);
        var e10 = arguments.length, t10 = Pq(e10 < 1 ? void 0 : arguments[0]), n10 = Pq(e10 < 2 ? void 0 : arguments[1], "Error"), r10 = Qq(n10);
        if (Yq(this, { type: Gq, name: n10, message: t10, code: r10 }), Vq || (this.name = n10, this.message = t10, this.code = r10), Zq) {
          var a10 = Hq(t10);
          a10.name = Gq, _q(this, "stack", Rq(1, Wq(a10.stack, 1)));
        }
      }, eK = $q.prototype = Aq(Xq), tK = function(e10) {
        return { enumerable: true, configurable: true, get: e10 };
      }, nK = function(e10) {
        return tK(function() {
          return Jq(this)[e10];
        });
      };
      Vq && (Fq(eK, "code", nK("code")), Fq(eK, "message", nK("message")), Fq(eK, "name", nK("name"))), _q(eK, "constructor", Rq(1, $q));
      var rK = Cq(function() {
        return !(new qq() instanceof Hq);
      }), aK = rK || Cq(function() {
        return Xq.toString !== zq || "2: 1" !== String(new qq(1, 2));
      }), iK = rK || Cq(function() {
        return 25 !== new qq(1, "DataCloneError").code;
      });
      rK || 25 !== qq.DATA_CLONE_ERR || Kq.DATA_CLONE_ERR;
      Sq({ global: true, constructor: true, forced: rK }, { DOMException: rK ? $q : qq });
      var oK = Eq(Gq), sK = oK.prototype;
      for (var uK in aK && qq === oK && Oq(sK, "toString", zq), iK && Vq && qq === oK && Fq(sK, "code", tK(function() {
        return Qq(Lq(this).name);
      })), Bq) if (Dq(Bq, uK)) {
        var cK = Bq[uK], lK = cK.s, hK = Rq(6, cK.c);
        Dq(oK, lK) || _q(oK, lK, hK), Dq(sK, lK) || _q(sK, lK, hK);
      }
      var pK = La, fK = z, dK = Ee, vK = Y, mK = cn.f, gK = kt, yK = zg, bK = Oc, xK = Dc, kK = Nq, wK = Gc, IK = W, NK = "DOMException", SK = dK("Error"), TK = dK(NK), EK = function() {
        yK(this, CK);
        var e10 = arguments.length, t10 = xK(e10 < 1 ? void 0 : arguments[0]), n10 = xK(e10 < 2 ? void 0 : arguments[1], "Error"), r10 = new TK(t10, n10), a10 = SK(t10);
        return a10.name = NK, mK(r10, "stack", vK(1, wK(a10.stack, 1))), bK(r10, this, EK), r10;
      }, CK = EK.prototype = TK.prototype, AK = "stack" in SK(NK), RK = "stack" in new TK(1, 2), _K = TK && IK && Object.getOwnPropertyDescriptor(fK, NK), OK = !(!_K || _K.writable && _K.configurable), FK = AK && !OK && !RK;
      pK({ global: true, constructor: true, forced: FK }, { DOMException: FK ? EK : TK });
      var DK = dK(NK), MK = DK.prototype;
      if (MK.constructor !== DK) {
        for (var LK in mK(MK, "constructor", vK(1, DK)), kK) if (gK(kK, LK)) {
          var zK = kK[LK], PK = zK.s;
          gK(DK, PK) || mK(DK, PK, vK(6, zK.c));
        }
      }
      var BK = "DOMException";
      eo(Ee(BK), BK);
      var WK = eA.clear;
      La({ global: true, bind: true, enumerable: true, forced: z.clearImmediate !== WK }, { clearImmediate: WK });
      var UK = "function" == typeof Bun && Bun && "string" == typeof Bun.version, VK = z, GK = fu, jK = xe, HK = UK, qK = Ae, KK = du, XK = TC, YK = VK.Function, JK = /MSIE .\./.test(qK) || HK && function() {
        var e10 = VK.Bun.version.split(".");
        return e10.length < 3 || 0 == e10[0] && (e10[1] < 3 || 3 == e10[1] && 0 == e10[2]);
      }(), ZK = function(e10, t10) {
        var n10 = t10 ? 2 : 1;
        return JK ? function(r10, a10) {
          var i10 = XK(arguments.length, 1) > n10, o10 = jK(r10) ? r10 : YK(r10), s10 = i10 ? KK(arguments, n10) : [], u10 = i10 ? function() {
            GK(o10, this, s10);
          } : o10;
          return t10 ? e10(u10, a10) : e10(u10);
        } : e10;
      }, QK = La, $K = z, eX = eA.set, tX = ZK, nX = $K.setImmediate ? tX(eX, false) : eX;
      QK({ global: true, bind: true, enumerable: true, forced: $K.setImmediate !== nX }, { setImmediate: nX });
      var rX = La, aX = RA, iX = Ze, oX = TC, sX = Rv, uX = z.process;
      rX({ global: true, enumerable: true, dontCallGetSet: true }, { queueMicrotask: function(e10) {
        oX(arguments.length, 1), iX(e10);
        var t10 = sX && uX.domain;
        aX(t10 ? t10.bind(e10) : e10);
      } });
      var cX = La, lX = z, hX = zi, pX = W, fX = TypeError, dX = Object.defineProperty, vX = lX.self !== lX;
      try {
        if (pX) {
          var mX = Object.getOwnPropertyDescriptor(lX, "self");
          !vX && mX && mX.get && mX.enumerable || hX(lX, "self", { get: function() {
            return lX;
          }, set: function(e10) {
            if (this !== lX) throw fX("Illegal invocation");
            dX(lX, "self", { value: e10, writable: true, configurable: true, enumerable: true });
          }, configurable: true, enumerable: true });
        } else cX({ global: true, simple: true, forced: vX }, { self: lX });
      } catch (e10) {
      }
      var gX, yX = ee, bX = Map.prototype, xX = { Map, set: yX(bX.set), get: yX(bX.get), has: yX(bX.has), remove: yX(bX.delete), proto: bX }, kX = ee, wX = Set.prototype, IX = { Set, add: kX(wX.add), has: kX(wX.has), remove: kX(wX.delete), proto: wX, $has: wX.has, $keys: wX.keys }, NX = B, SX = Le, TX = MA, EX = DA, CX = Rv, AX = z.structuredClone, RX = !!AX && !NX(function() {
        if (EX && SX > 92 || CX && SX > 94 || TX && SX > 97) return false;
        var e10 = new ArrayBuffer(8), t10 = AX(e10, { transfer: [e10] });
        return 0 != e10.byteLength || 8 != t10.byteLength;
      }), _X = La, OX = z, FX = Ee, DX = ee, MX = B, LX = Tt, zX = xe, PX = No, BX = le, WX = Ie, UX = He, VX = yh, GX = dn, jX = qa, HX = kt, qX = Ii, KX = Cn, XX = Kr, YX = TC, JX = nF, ZX = xX, QX = IX, $X = Hc, eY = RX, tY = OX.Object, nY = OX.Array, rY = OX.Date, aY = OX.Error, iY = OX.EvalError, oY = OX.RangeError, sY = OX.ReferenceError, uY = OX.SyntaxError, cY = OX.TypeError, lY = OX.URIError, hY = OX.PerformanceMark, pY = OX.WebAssembly, fY = pY && pY.CompileError || aY, dY = pY && pY.LinkError || aY, vY = pY && pY.RuntimeError || aY, mY = FX("DOMException"), gY = ZX.Map, yY = ZX.has, bY = ZX.get, xY = ZX.set, kY = QX.Set, wY = QX.add, IY = FX("Object", "keys"), NY = DX([].push), SY = DX(true.valueOf), TY = DX(1 .valueOf), EY = DX("".valueOf), CY = DX(rY.prototype.getTime), AY = LX("structuredClone"), RY = "DataCloneError", _Y = "Transferring", OY = function(e10) {
        return !MX(function() {
          var t10 = new OX.Set([7]), n10 = e10(t10), r10 = e10(tY(7));
          return n10 == t10 || !n10.has(7) || "object" != s(r10) || 7 != r10;
        }) && e10;
      }, FY = function(e10, t10) {
        return !MX(function() {
          var n10 = new t10(), r10 = e10({ a: n10, b: n10 });
          return !(r10 && r10.a === r10.b && r10.a instanceof t10 && r10.a.stack === n10.stack);
        });
      }, DY = OX.structuredClone, MY = !FY(DY, aY) || !FY(DY, mY) || (gX = DY, !!MX(function() {
        var e10 = gX(new OX.AggregateError([1], AY, { cause: 3 }));
        return "AggregateError" != e10.name || 1 != e10.errors[0] || e10.message != AY || 3 != e10.cause;
      })), LY = !DY && OY(function(e10) {
        return new hY(AY, { detail: e10 }).detail;
      }), zY = OY(DY) || LY, PY = function(e10) {
        throw new mY("Uncloneable type: " + e10, RY);
      }, BY = function(e10, t10) {
        throw new mY((t10 || "Cloning") + " of " + e10 + " cannot be properly polyfilled in this engine", RY);
      }, WY = function e10(t10, n10) {
        if (UX(t10) && PY("Symbol"), !WX(t10)) return t10;
        if (n10) {
          if (yY(n10, t10)) return bY(n10, t10);
        } else n10 = new gY();
        var r10, a10, i10, o10, s10, u10, c10, l10, h10, p10, f10, d10 = jX(t10), v10 = false;
        switch (d10) {
          case "Array":
            i10 = nY(XX(t10)), v10 = true;
            break;
          case "Object":
            i10 = {}, v10 = true;
            break;
          case "Map":
            i10 = new gY(), v10 = true;
            break;
          case "Set":
            i10 = new kY(), v10 = true;
            break;
          case "RegExp":
            i10 = new RegExp(t10.source, JX(t10));
            break;
          case "Error":
            switch (a10 = t10.name) {
              case "AggregateError":
                i10 = FX("AggregateError")([]);
                break;
              case "EvalError":
                i10 = iY();
                break;
              case "RangeError":
                i10 = oY();
                break;
              case "ReferenceError":
                i10 = sY();
                break;
              case "SyntaxError":
                i10 = uY();
                break;
              case "TypeError":
                i10 = cY();
                break;
              case "URIError":
                i10 = lY();
                break;
              case "CompileError":
                i10 = fY();
                break;
              case "LinkError":
                i10 = dY();
                break;
              case "RuntimeError":
                i10 = vY();
                break;
              default:
                i10 = aY();
            }
            v10 = true;
            break;
          case "DOMException":
            i10 = new mY(t10.message, t10.name), v10 = true;
            break;
          case "DataView":
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array":
            r10 = OX[d10], WX(r10) || BY(d10), i10 = new r10(e10(t10.buffer, n10), t10.byteOffset, "DataView" === d10 ? t10.byteLength : t10.length);
            break;
          case "DOMQuad":
            try {
              i10 = new DOMQuad(e10(t10.p1, n10), e10(t10.p2, n10), e10(t10.p3, n10), e10(t10.p4, n10));
            } catch (e11) {
              zY ? i10 = zY(t10) : BY(d10);
            }
            break;
          case "FileList":
            if (o10 = function() {
              var e11;
              try {
                e11 = new OX.DataTransfer();
              } catch (t11) {
                try {
                  e11 = new OX.ClipboardEvent("").clipboardData;
                } catch (e12) {
                }
              }
              return e11 && e11.items && e11.files ? e11 : null;
            }()) {
              for (s10 = 0, u10 = XX(t10); s10 < u10; s10++) o10.items.add(e10(t10[s10], n10));
              i10 = o10.files;
            } else zY ? i10 = zY(t10) : BY(d10);
            break;
          case "ImageData":
            try {
              i10 = new ImageData(e10(t10.data, n10), t10.width, t10.height, { colorSpace: t10.colorSpace });
            } catch (e11) {
              zY ? i10 = zY(t10) : BY(d10);
            }
            break;
          default:
            if (zY) i10 = zY(t10);
            else switch (d10) {
              case "BigInt":
                i10 = tY(t10.valueOf());
                break;
              case "Boolean":
                i10 = tY(SY(t10));
                break;
              case "Number":
                i10 = tY(TY(t10));
                break;
              case "String":
                i10 = tY(EY(t10));
                break;
              case "Date":
                i10 = new rY(CY(t10));
                break;
              case "ArrayBuffer":
                (r10 = OX.DataView) || "function" == typeof t10.slice || BY(d10);
                try {
                  if ("function" != typeof t10.slice || t10.resizable) {
                    u10 = t10.byteLength, f10 = "maxByteLength" in t10 ? { maxByteLength: t10.maxByteLength } : void 0, i10 = new ArrayBuffer(u10, f10), h10 = new r10(t10), p10 = new r10(i10);
                    for (s10 = 0; s10 < u10; s10++) p10.setUint8(s10, h10.getUint8(s10));
                  } else i10 = t10.slice(0);
                } catch (e11) {
                  throw new mY("ArrayBuffer is detached", RY);
                }
                break;
              case "SharedArrayBuffer":
                i10 = t10;
                break;
              case "Blob":
                try {
                  i10 = t10.slice(0, t10.size, t10.type);
                } catch (e11) {
                  BY(d10);
                }
                break;
              case "DOMPoint":
              case "DOMPointReadOnly":
                r10 = OX[d10];
                try {
                  i10 = r10.fromPoint ? r10.fromPoint(t10) : new r10(t10.x, t10.y, t10.z, t10.w);
                } catch (e11) {
                  BY(d10);
                }
                break;
              case "DOMRect":
              case "DOMRectReadOnly":
                r10 = OX[d10];
                try {
                  i10 = r10.fromRect ? r10.fromRect(t10) : new r10(t10.x, t10.y, t10.width, t10.height);
                } catch (e11) {
                  BY(d10);
                }
                break;
              case "DOMMatrix":
              case "DOMMatrixReadOnly":
                r10 = OX[d10];
                try {
                  i10 = r10.fromMatrix ? r10.fromMatrix(t10) : new r10(t10);
                } catch (e11) {
                  BY(d10);
                }
                break;
              case "AudioData":
              case "VideoFrame":
                zX(t10.clone) || BY(d10);
                try {
                  i10 = t10.clone();
                } catch (e11) {
                  PY(d10);
                }
                break;
              case "File":
                try {
                  i10 = new File([t10], t10.name, t10);
                } catch (e11) {
                  BY(d10);
                }
                break;
              case "CropTarget":
              case "CryptoKey":
              case "FileSystemDirectoryHandle":
              case "FileSystemFileHandle":
              case "FileSystemHandle":
              case "GPUCompilationInfo":
              case "GPUCompilationMessage":
              case "ImageBitmap":
              case "RTCCertificate":
              case "WebAssembly.Module":
                BY(d10);
              default:
                PY(d10);
            }
        }
        if (xY(n10, t10, i10), v10) switch (d10) {
          case "Array":
          case "Object":
            for (c10 = IY(t10), s10 = 0, u10 = XX(c10); s10 < u10; s10++) l10 = c10[s10], qX(i10, l10, e10(t10[l10], n10));
            break;
          case "Map":
            t10.forEach(function(t11, r11) {
              xY(i10, e10(r11, n10), e10(t11, n10));
            });
            break;
          case "Set":
            t10.forEach(function(t11) {
              wY(i10, e10(t11, n10));
            });
            break;
          case "Error":
            KX(i10, "message", e10(t10.message, n10)), HX(t10, "cause") && KX(i10, "cause", e10(t10.cause, n10)), "AggregateError" == a10 && (i10.errors = e10(t10.errors, n10));
          case "DOMException":
            $X && KX(i10, "stack", e10(t10.stack, n10));
        }
        return i10;
      }, UY = function(e10, t10) {
        if (!WX(e10)) throw cY("Transfer option cannot be converted to a sequence");
        var n10 = [];
        VX(e10, function(e11) {
          NY(n10, GX(e11));
        });
        var r10, a10, i10, o10, s10, u10, c10 = 0, l10 = XX(n10);
        if (eY) for (o10 = DY(n10, { transfer: n10 }); c10 < l10; ) xY(t10, n10[c10], o10[c10++]);
        else for (; c10 < l10; ) {
          if (r10 = n10[c10++], yY(t10, r10)) throw new mY("Duplicate transferable", RY);
          switch (a10 = jX(r10)) {
            case "ImageBitmap":
              i10 = OX.OffscreenCanvas, PX(i10) || BY(a10, _Y);
              try {
                (u10 = new i10(r10.width, r10.height)).getContext("bitmaprenderer").transferFromImageBitmap(r10), s10 = u10.transferToImageBitmap();
              } catch (e11) {
              }
              break;
            case "AudioData":
            case "VideoFrame":
              zX(r10.clone) && zX(r10.close) || BY(a10, _Y);
              try {
                s10 = r10.clone(), r10.close();
              } catch (e11) {
              }
              break;
            case "ArrayBuffer":
              zX(r10.transfer) || BY(a10, _Y), s10 = r10.transfer();
              break;
            case "MediaSourceHandle":
            case "MessagePort":
            case "OffscreenCanvas":
            case "ReadableStream":
            case "TransformStream":
            case "WritableStream":
              BY(a10, _Y);
          }
          if (void 0 === s10) throw new mY("This object cannot be transferred: " + a10, RY);
          xY(t10, r10, s10);
        }
      };
      _X({ global: true, enumerable: true, sham: !eY, forced: MY }, { structuredClone: function(e10) {
        var t10, n10 = YX(arguments.length, 1) > 1 && !BX(arguments[1]) ? GX(arguments[1]) : void 0, r10 = n10 ? n10.transfer : void 0;
        return void 0 !== r10 && (t10 = new gY(), UY(r10, t10)), WY(e10, t10);
      } });
      var VY = La, GY = z, jY = ZK(GY.setInterval, true);
      VY({ global: true, bind: true, forced: GY.setInterval !== jY }, { setInterval: jY });
      var HY = La, qY = z, KY = ZK(qY.setTimeout, true);
      HY({ global: true, bind: true, forced: qY.setTimeout !== KY }, { setTimeout: KY });
      var XY = B, YY = W, JY = Mt("iterator"), ZY = !XY(function() {
        var e10 = new URL("b?a=1&b=2&c=3", "http://a"), t10 = e10.searchParams, n10 = "";
        return e10.pathname = "c%20d", t10.forEach(function(e11, r10) {
          t10.delete("b"), n10 += r10 + e11;
        }), !t10.size && !YY || !t10.sort || "http://a/c%20d?a=1&c=3" !== e10.href || "3" !== t10.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !t10[JY] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://тест").host || "#%D0%B1" !== new URL("http://a#б").hash || "a1c3" !== n10 || "x" !== new URL("http://x", void 0).host;
      }), QY = ee, $Y = 2147483647, eJ = /[^\0-\u007E]/, tJ = /[.\u3002\uFF0E\uFF61]/g, nJ = "Overflow: input needs wider integers to process", rJ = RangeError, aJ = QY(tJ.exec), iJ = Math.floor, oJ = String.fromCharCode, sJ = QY("".charCodeAt), uJ = QY([].join), cJ = QY([].push), lJ = QY("".replace), hJ = QY("".split), pJ = QY("".toLowerCase), fJ = function(e10) {
        return e10 + 22 + 75 * (e10 < 26);
      }, dJ = function(e10, t10, n10) {
        var r10 = 0;
        for (e10 = n10 ? iJ(e10 / 700) : e10 >> 1, e10 += iJ(e10 / t10); e10 > 455; ) e10 = iJ(e10 / 35), r10 += 36;
        return iJ(r10 + 36 * e10 / (e10 + 38));
      }, vJ = function(e10) {
        var t10 = [];
        e10 = function(e11) {
          for (var t11 = [], n11 = 0, r11 = e11.length; n11 < r11; ) {
            var a11 = sJ(e11, n11++);
            if (a11 >= 55296 && a11 <= 56319 && n11 < r11) {
              var i11 = sJ(e11, n11++);
              56320 == (64512 & i11) ? cJ(t11, ((1023 & a11) << 10) + (1023 & i11) + 65536) : (cJ(t11, a11), n11--);
            } else cJ(t11, a11);
          }
          return t11;
        }(e10);
        var n10, r10, a10 = e10.length, i10 = 128, o10 = 0, s10 = 72;
        for (n10 = 0; n10 < e10.length; n10++) (r10 = e10[n10]) < 128 && cJ(t10, oJ(r10));
        var u10 = t10.length, c10 = u10;
        for (u10 && cJ(t10, "-"); c10 < a10; ) {
          var l10 = $Y;
          for (n10 = 0; n10 < e10.length; n10++) (r10 = e10[n10]) >= i10 && r10 < l10 && (l10 = r10);
          var h10 = c10 + 1;
          if (l10 - i10 > iJ(($Y - o10) / h10)) throw rJ(nJ);
          for (o10 += (l10 - i10) * h10, i10 = l10, n10 = 0; n10 < e10.length; n10++) {
            if ((r10 = e10[n10]) < i10 && ++o10 > $Y) throw rJ(nJ);
            if (r10 == i10) {
              for (var p10 = o10, f10 = 36; ; ) {
                var d10 = f10 <= s10 ? 1 : f10 >= s10 + 26 ? 26 : f10 - s10;
                if (p10 < d10) break;
                var v10 = p10 - d10, m10 = 36 - d10;
                cJ(t10, oJ(fJ(d10 + v10 % m10))), p10 = iJ(v10 / m10), f10 += 36;
              }
              cJ(t10, oJ(fJ(p10))), s10 = dJ(o10, h10, c10 == u10), o10 = 0, c10++;
            }
          }
          o10++, i10++;
        }
        return uJ(t10, "");
      }, mJ = function(e10) {
        var t10, n10, r10 = [], a10 = hJ(lJ(pJ(e10), tJ, "."), ".");
        for (t10 = 0; t10 < a10.length; t10++) n10 = a10[t10], cJ(r10, aJ(eJ, n10) ? "xn--" + vJ(n10) : n10);
        return uJ(r10, ".");
      }, gJ = La, yJ = z, bJ = j, xJ = ee, kJ = W, wJ = ZY, IJ = Or, NJ = zi, SJ = Dg, TJ = eo, EJ = dd, CJ = cr, AJ = zg, RJ = xe, _J = kt, OJ = so, FJ = qa, DJ = dn, MJ = Ie, LJ = Ya, zJ = yi, PJ = Y, BJ = eh, WJ = Kl, UJ = TC, VJ = nm, GJ = Mt("iterator"), jJ = "URLSearchParams", HJ = "URLSearchParamsIterator", qJ = CJ.set, KJ = CJ.getterFor(jJ), XJ = CJ.getterFor(HJ), YJ = Object.getOwnPropertyDescriptor, JJ = function(e10) {
        if (!kJ) return yJ[e10];
        var t10 = YJ(yJ, e10);
        return t10 && t10.value;
      }, ZJ = JJ("fetch"), QJ = JJ("Request"), $J = JJ("Headers"), eZ = QJ && QJ.prototype, tZ = $J && $J.prototype, nZ = yJ.RegExp, rZ = yJ.TypeError, aZ = yJ.decodeURIComponent, iZ = yJ.encodeURIComponent, oZ = xJ("".charAt), sZ = xJ([].join), uZ = xJ([].push), cZ = xJ("".replace), lZ = xJ([].shift), hZ = xJ([].splice), pZ = xJ("".split), fZ = xJ("".slice), dZ = /\+/g, vZ = Array(4), mZ = function(e10) {
        return vZ[e10 - 1] || (vZ[e10 - 1] = nZ("((?:%[\\da-f]{2}){" + e10 + "})", "gi"));
      }, gZ = function(e10) {
        try {
          return aZ(e10);
        } catch (t10) {
          return e10;
        }
      }, yZ = function(e10) {
        var t10 = cZ(e10, dZ, " "), n10 = 4;
        try {
          return aZ(t10);
        } catch (e11) {
          for (; n10; ) t10 = cZ(t10, mZ(n10--), gZ);
          return t10;
        }
      }, bZ = /[!'()~]|%20/g, xZ = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" }, kZ = function(e10) {
        return xZ[e10];
      }, wZ = function(e10) {
        return cZ(iZ(e10), bZ, kZ);
      }, IZ = EJ(function(e10, t10) {
        qJ(this, { type: HJ, iterator: BJ(KJ(e10).entries), kind: t10 });
      }, "Iterator", function() {
        var e10 = XJ(this), t10 = e10.kind, n10 = e10.iterator.next(), r10 = n10.value;
        return n10.done || (n10.value = "keys" === t10 ? r10.key : "values" === t10 ? r10.value : [r10.key, r10.value]), n10;
      }, true), NZ = function(e10) {
        this.entries = [], this.url = null, void 0 !== e10 && (MJ(e10) ? this.parseObject(e10) : this.parseQuery("string" == typeof e10 ? "?" === oZ(e10, 0) ? fZ(e10, 1) : e10 : LJ(e10)));
      };
      NZ.prototype = { type: jJ, bindURL: function(e10) {
        this.url = e10, this.update();
      }, parseObject: function(e10) {
        var t10, n10, r10, a10, i10, o10, s10, u10 = WJ(e10);
        if (u10) for (n10 = (t10 = BJ(e10, u10)).next; !(r10 = bJ(n10, t10)).done; ) {
          if (i10 = (a10 = BJ(DJ(r10.value))).next, (o10 = bJ(i10, a10)).done || (s10 = bJ(i10, a10)).done || !bJ(i10, a10).done) throw rZ("Expected sequence with length 2");
          uZ(this.entries, { key: LJ(o10.value), value: LJ(s10.value) });
        }
        else for (var c10 in e10) _J(e10, c10) && uZ(this.entries, { key: c10, value: LJ(e10[c10]) });
      }, parseQuery: function(e10) {
        if (e10) for (var t10, n10, r10 = pZ(e10, "&"), a10 = 0; a10 < r10.length; ) (t10 = r10[a10++]).length && (n10 = pZ(t10, "="), uZ(this.entries, { key: yZ(lZ(n10)), value: yZ(sZ(n10, "=")) }));
      }, serialize: function() {
        for (var e10, t10 = this.entries, n10 = [], r10 = 0; r10 < t10.length; ) e10 = t10[r10++], uZ(n10, wZ(e10.key) + "=" + wZ(e10.value));
        return sZ(n10, "&");
      }, update: function() {
        this.entries.length = 0, this.parseQuery(this.url.query);
      }, updateURL: function() {
        this.url && this.url.update();
      } };
      var SZ = function() {
        AJ(this, TZ);
        var e10 = arguments.length > 0 ? arguments[0] : void 0, t10 = qJ(this, new NZ(e10));
        kJ || (this.length = t10.entries.length);
      }, TZ = SZ.prototype;
      if (SJ(TZ, { append: function(e10, t10) {
        UJ(arguments.length, 2);
        var n10 = KJ(this);
        uZ(n10.entries, { key: LJ(e10), value: LJ(t10) }), kJ || this.length++, n10.updateURL();
      }, delete: function(e10) {
        UJ(arguments.length, 1);
        for (var t10 = KJ(this), n10 = t10.entries, r10 = LJ(e10), a10 = 0; a10 < n10.length; ) n10[a10].key === r10 ? hZ(n10, a10, 1) : a10++;
        kJ || (this.length = n10.length), t10.updateURL();
      }, get: function(e10) {
        UJ(arguments.length, 1);
        for (var t10 = KJ(this).entries, n10 = LJ(e10), r10 = 0; r10 < t10.length; r10++) if (t10[r10].key === n10) return t10[r10].value;
        return null;
      }, getAll: function(e10) {
        UJ(arguments.length, 1);
        for (var t10 = KJ(this).entries, n10 = LJ(e10), r10 = [], a10 = 0; a10 < t10.length; a10++) t10[a10].key === n10 && uZ(r10, t10[a10].value);
        return r10;
      }, has: function(e10) {
        UJ(arguments.length, 1);
        for (var t10 = KJ(this).entries, n10 = LJ(e10), r10 = 0; r10 < t10.length; ) if (t10[r10++].key === n10) return true;
        return false;
      }, set: function(e10, t10) {
        UJ(arguments.length, 1);
        for (var n10, r10 = KJ(this), a10 = r10.entries, i10 = false, o10 = LJ(e10), s10 = LJ(t10), u10 = 0; u10 < a10.length; u10++) (n10 = a10[u10]).key === o10 && (i10 ? hZ(a10, u10--, 1) : (i10 = true, n10.value = s10));
        i10 || uZ(a10, { key: o10, value: s10 }), kJ || (this.length = a10.length), r10.updateURL();
      }, sort: function() {
        var e10 = KJ(this);
        VJ(e10.entries, function(e11, t10) {
          return e11.key > t10.key ? 1 : -1;
        }), e10.updateURL();
      }, forEach: function(e10) {
        for (var t10, n10 = KJ(this).entries, r10 = OJ(e10, arguments.length > 1 ? arguments[1] : void 0), a10 = 0; a10 < n10.length; ) r10((t10 = n10[a10++]).value, t10.key, this);
      }, keys: function() {
        return new IZ(this, "keys");
      }, values: function() {
        return new IZ(this, "values");
      }, entries: function() {
        return new IZ(this, "entries");
      } }, { enumerable: true }), IJ(TZ, GJ, TZ.entries, { name: "entries" }), IJ(TZ, "toString", function() {
        return KJ(this).serialize();
      }, { enumerable: true }), kJ && NJ(TZ, "size", { get: function() {
        return KJ(this).entries.length;
      }, configurable: true, enumerable: true }), TJ(SZ, jJ), gJ({ global: true, constructor: true, forced: !wJ }, { URLSearchParams: SZ }), !wJ && RJ($J)) {
        var EZ = xJ(tZ.has), CZ = xJ(tZ.set), AZ = function(e10) {
          if (MJ(e10)) {
            var t10, n10 = e10.body;
            if (FJ(n10) === jJ) return t10 = e10.headers ? new $J(e10.headers) : new $J(), EZ(t10, "content-type") || CZ(t10, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), zJ(e10, { body: PJ(0, LJ(n10)), headers: PJ(0, t10) });
          }
          return e10;
        };
        if (RJ(ZJ) && gJ({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, { fetch: function(e10) {
          return ZJ(e10, arguments.length > 1 ? AZ(arguments[1]) : {});
        } }), RJ(QJ)) {
          var RZ = function(e10) {
            return AJ(this, eZ), new QJ(e10, arguments.length > 1 ? AZ(arguments[1]) : {});
          };
          eZ.constructor = RZ, RZ.prototype = eZ, gJ({ global: true, constructor: true, dontCallGetSet: true, forced: true }, { Request: RZ });
        }
      }
      var _Z, OZ = { URLSearchParams: SZ, getState: KJ }, FZ = La, DZ = W, MZ = ZY, LZ = z, zZ = so, PZ = ee, BZ = Or, WZ = zi, UZ = zg, VZ = kt, GZ = ST, jZ = Lf, HZ = Ai, qZ = xM.codeAt, KZ = mJ, XZ = Ya, YZ = eo, JZ = TC, ZZ = OZ, QZ = cr, $Z = QZ.set, eQ = QZ.getterFor("URL"), tQ = ZZ.URLSearchParams, nQ = ZZ.getState, rQ = LZ.URL, aQ = LZ.TypeError, iQ = LZ.parseInt, oQ = Math.floor, sQ = Math.pow, uQ = PZ("".charAt), cQ = PZ(/./.exec), lQ = PZ([].join), hQ = PZ(1 .toString), pQ = PZ([].pop), fQ = PZ([].push), dQ = PZ("".replace), vQ = PZ([].shift), mQ = PZ("".split), gQ = PZ("".slice), yQ = PZ("".toLowerCase), bQ = PZ([].unshift), xQ = "Invalid scheme", kQ = "Invalid host", wQ = "Invalid port", IQ = /[a-z]/i, NQ = /[\d+-.a-z]/i, SQ = /\d/, TQ = /^0x/i, EQ = /^[0-7]+$/, CQ = /^\d+$/, AQ = /^[\da-f]+$/i, RQ = /[\0\t\n\r #%/:<>?@[\\\]^|]/, _Q = /[\0\t\n\r #/:<>?@[\\\]^|]/, OQ = /^[\u0000-\u0020]+/, FQ = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/, DQ = /[\t\n\r]/g, MQ = function(e10) {
        var t10, n10, r10, a10;
        if ("number" == typeof e10) {
          for (t10 = [], n10 = 0; n10 < 4; n10++) bQ(t10, e10 % 256), e10 = oQ(e10 / 256);
          return lQ(t10, ".");
        }
        if ("object" == s(e10)) {
          for (t10 = "", r10 = function(e11) {
            for (var t11 = null, n11 = 1, r11 = null, a11 = 0, i10 = 0; i10 < 8; i10++) 0 !== e11[i10] ? (a11 > n11 && (t11 = r11, n11 = a11), r11 = null, a11 = 0) : (null === r11 && (r11 = i10), ++a11);
            return a11 > n11 && (t11 = r11, n11 = a11), t11;
          }(e10), n10 = 0; n10 < 8; n10++) a10 && 0 === e10[n10] || (a10 && (a10 = false), r10 === n10 ? (t10 += n10 ? ":" : "::", a10 = true) : (t10 += hQ(e10[n10], 16), n10 < 7 && (t10 += ":")));
          return "[" + t10 + "]";
        }
        return e10;
      }, LQ = {}, zQ = GZ({}, LQ, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }), PQ = GZ({}, zQ, { "#": 1, "?": 1, "{": 1, "}": 1 }), BQ = GZ({}, PQ, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 }), WQ = function(e10, t10) {
        var n10 = qZ(e10, 0);
        return n10 > 32 && n10 < 127 && !VZ(t10, e10) ? e10 : encodeURIComponent(e10);
      }, UQ = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, VQ = function(e10, t10) {
        var n10;
        return 2 == e10.length && cQ(IQ, uQ(e10, 0)) && (":" == (n10 = uQ(e10, 1)) || !t10 && "|" == n10);
      }, GQ = function(e10) {
        var t10;
        return e10.length > 1 && VQ(gQ(e10, 0, 2)) && (2 == e10.length || "/" === (t10 = uQ(e10, 2)) || "\\" === t10 || "?" === t10 || "#" === t10);
      }, jQ = function(e10) {
        return "." === e10 || "%2e" === yQ(e10);
      }, HQ = {}, qQ = {}, KQ = {}, XQ = {}, YQ = {}, JQ = {}, ZQ = {}, QQ = {}, $Q = {}, e$ = {}, t$ = {}, n$ = {}, r$ = {}, a$ = {}, i$ = {}, o$ = {}, s$ = {}, u$ = {}, c$ = {}, l$ = {}, h$ = {}, p$ = function e10(t10, n10, r10) {
        var a10, i10, o10, s10 = XZ(t10);
        if (n10) {
          if (i10 = this.parse(s10)) throw aQ(i10);
          this.searchParams = null;
        } else {
          if (void 0 !== r10 && (a10 = new e10(r10, true)), i10 = this.parse(s10, null, a10)) throw aQ(i10);
          (o10 = nQ(new tQ())).bindURL(this), this.searchParams = o10;
        }
      };
      p$.prototype = { type: "URL", parse: function(e10, t10, n10) {
        var r10, a10, i10, o10, s10, u10 = this, c10 = t10 || HQ, l10 = 0, h10 = "", p10 = false, f10 = false, d10 = false;
        for (e10 = XZ(e10), t10 || (u10.scheme = "", u10.username = "", u10.password = "", u10.host = null, u10.port = null, u10.path = [], u10.query = null, u10.fragment = null, u10.cannotBeABaseURL = false, e10 = dQ(e10, OQ, ""), e10 = dQ(e10, FQ, "$1")), e10 = dQ(e10, DQ, ""), r10 = jZ(e10); l10 <= r10.length; ) {
          switch (a10 = r10[l10], c10) {
            case HQ:
              if (!a10 || !cQ(IQ, a10)) {
                if (t10) return xQ;
                c10 = KQ;
                continue;
              }
              h10 += yQ(a10), c10 = qQ;
              break;
            case qQ:
              if (a10 && (cQ(NQ, a10) || "+" == a10 || "-" == a10 || "." == a10)) h10 += yQ(a10);
              else {
                if (":" != a10) {
                  if (t10) return xQ;
                  h10 = "", c10 = KQ, l10 = 0;
                  continue;
                }
                if (t10 && (u10.isSpecial() != VZ(UQ, h10) || "file" == h10 && (u10.includesCredentials() || null !== u10.port) || "file" == u10.scheme && !u10.host)) return;
                if (u10.scheme = h10, t10) return void (u10.isSpecial() && UQ[u10.scheme] == u10.port && (u10.port = null));
                h10 = "", "file" == u10.scheme ? c10 = a$ : u10.isSpecial() && n10 && n10.scheme == u10.scheme ? c10 = XQ : u10.isSpecial() ? c10 = QQ : "/" == r10[l10 + 1] ? (c10 = YQ, l10++) : (u10.cannotBeABaseURL = true, fQ(u10.path, ""), c10 = c$);
              }
              break;
            case KQ:
              if (!n10 || n10.cannotBeABaseURL && "#" != a10) return xQ;
              if (n10.cannotBeABaseURL && "#" == a10) {
                u10.scheme = n10.scheme, u10.path = HZ(n10.path), u10.query = n10.query, u10.fragment = "", u10.cannotBeABaseURL = true, c10 = h$;
                break;
              }
              c10 = "file" == n10.scheme ? a$ : JQ;
              continue;
            case XQ:
              if ("/" != a10 || "/" != r10[l10 + 1]) {
                c10 = JQ;
                continue;
              }
              c10 = $Q, l10++;
              break;
            case YQ:
              if ("/" == a10) {
                c10 = e$;
                break;
              }
              c10 = u$;
              continue;
            case JQ:
              if (u10.scheme = n10.scheme, a10 == _Z) u10.username = n10.username, u10.password = n10.password, u10.host = n10.host, u10.port = n10.port, u10.path = HZ(n10.path), u10.query = n10.query;
              else if ("/" == a10 || "\\" == a10 && u10.isSpecial()) c10 = ZQ;
              else if ("?" == a10) u10.username = n10.username, u10.password = n10.password, u10.host = n10.host, u10.port = n10.port, u10.path = HZ(n10.path), u10.query = "", c10 = l$;
              else {
                if ("#" != a10) {
                  u10.username = n10.username, u10.password = n10.password, u10.host = n10.host, u10.port = n10.port, u10.path = HZ(n10.path), u10.path.length--, c10 = u$;
                  continue;
                }
                u10.username = n10.username, u10.password = n10.password, u10.host = n10.host, u10.port = n10.port, u10.path = HZ(n10.path), u10.query = n10.query, u10.fragment = "", c10 = h$;
              }
              break;
            case ZQ:
              if (!u10.isSpecial() || "/" != a10 && "\\" != a10) {
                if ("/" != a10) {
                  u10.username = n10.username, u10.password = n10.password, u10.host = n10.host, u10.port = n10.port, c10 = u$;
                  continue;
                }
                c10 = e$;
              } else c10 = $Q;
              break;
            case QQ:
              if (c10 = $Q, "/" != a10 || "/" != uQ(h10, l10 + 1)) continue;
              l10++;
              break;
            case $Q:
              if ("/" != a10 && "\\" != a10) {
                c10 = e$;
                continue;
              }
              break;
            case e$:
              if ("@" == a10) {
                p10 && (h10 = "%40" + h10), p10 = true, i10 = jZ(h10);
                for (var v10 = 0; v10 < i10.length; v10++) {
                  var m10 = i10[v10];
                  if (":" != m10 || d10) {
                    var g10 = WQ(m10, BQ);
                    d10 ? u10.password += g10 : u10.username += g10;
                  } else d10 = true;
                }
                h10 = "";
              } else if (a10 == _Z || "/" == a10 || "?" == a10 || "#" == a10 || "\\" == a10 && u10.isSpecial()) {
                if (p10 && "" == h10) return "Invalid authority";
                l10 -= jZ(h10).length + 1, h10 = "", c10 = t$;
              } else h10 += a10;
              break;
            case t$:
            case n$:
              if (t10 && "file" == u10.scheme) {
                c10 = o$;
                continue;
              }
              if (":" != a10 || f10) {
                if (a10 == _Z || "/" == a10 || "?" == a10 || "#" == a10 || "\\" == a10 && u10.isSpecial()) {
                  if (u10.isSpecial() && "" == h10) return kQ;
                  if (t10 && "" == h10 && (u10.includesCredentials() || null !== u10.port)) return;
                  if (o10 = u10.parseHost(h10)) return o10;
                  if (h10 = "", c10 = s$, t10) return;
                  continue;
                }
                "[" == a10 ? f10 = true : "]" == a10 && (f10 = false), h10 += a10;
              } else {
                if ("" == h10) return kQ;
                if (o10 = u10.parseHost(h10)) return o10;
                if (h10 = "", c10 = r$, t10 == n$) return;
              }
              break;
            case r$:
              if (!cQ(SQ, a10)) {
                if (a10 == _Z || "/" == a10 || "?" == a10 || "#" == a10 || "\\" == a10 && u10.isSpecial() || t10) {
                  if ("" != h10) {
                    var y10 = iQ(h10, 10);
                    if (y10 > 65535) return wQ;
                    u10.port = u10.isSpecial() && y10 === UQ[u10.scheme] ? null : y10, h10 = "";
                  }
                  if (t10) return;
                  c10 = s$;
                  continue;
                }
                return wQ;
              }
              h10 += a10;
              break;
            case a$:
              if (u10.scheme = "file", "/" == a10 || "\\" == a10) c10 = i$;
              else {
                if (!n10 || "file" != n10.scheme) {
                  c10 = u$;
                  continue;
                }
                if (a10 == _Z) u10.host = n10.host, u10.path = HZ(n10.path), u10.query = n10.query;
                else if ("?" == a10) u10.host = n10.host, u10.path = HZ(n10.path), u10.query = "", c10 = l$;
                else {
                  if ("#" != a10) {
                    GQ(lQ(HZ(r10, l10), "")) || (u10.host = n10.host, u10.path = HZ(n10.path), u10.shortenPath()), c10 = u$;
                    continue;
                  }
                  u10.host = n10.host, u10.path = HZ(n10.path), u10.query = n10.query, u10.fragment = "", c10 = h$;
                }
              }
              break;
            case i$:
              if ("/" == a10 || "\\" == a10) {
                c10 = o$;
                break;
              }
              n10 && "file" == n10.scheme && !GQ(lQ(HZ(r10, l10), "")) && (VQ(n10.path[0], true) ? fQ(u10.path, n10.path[0]) : u10.host = n10.host), c10 = u$;
              continue;
            case o$:
              if (a10 == _Z || "/" == a10 || "\\" == a10 || "?" == a10 || "#" == a10) {
                if (!t10 && VQ(h10)) c10 = u$;
                else if ("" == h10) {
                  if (u10.host = "", t10) return;
                  c10 = s$;
                } else {
                  if (o10 = u10.parseHost(h10)) return o10;
                  if ("localhost" == u10.host && (u10.host = ""), t10) return;
                  h10 = "", c10 = s$;
                }
                continue;
              }
              h10 += a10;
              break;
            case s$:
              if (u10.isSpecial()) {
                if (c10 = u$, "/" != a10 && "\\" != a10) continue;
              } else if (t10 || "?" != a10) if (t10 || "#" != a10) {
                if (a10 != _Z && (c10 = u$, "/" != a10)) continue;
              } else u10.fragment = "", c10 = h$;
              else u10.query = "", c10 = l$;
              break;
            case u$:
              if (a10 == _Z || "/" == a10 || "\\" == a10 && u10.isSpecial() || !t10 && ("?" == a10 || "#" == a10)) {
                if (".." === (s10 = yQ(s10 = h10)) || "%2e." === s10 || ".%2e" === s10 || "%2e%2e" === s10 ? (u10.shortenPath(), "/" == a10 || "\\" == a10 && u10.isSpecial() || fQ(u10.path, "")) : jQ(h10) ? "/" == a10 || "\\" == a10 && u10.isSpecial() || fQ(u10.path, "") : ("file" == u10.scheme && !u10.path.length && VQ(h10) && (u10.host && (u10.host = ""), h10 = uQ(h10, 0) + ":"), fQ(u10.path, h10)), h10 = "", "file" == u10.scheme && (a10 == _Z || "?" == a10 || "#" == a10)) for (; u10.path.length > 1 && "" === u10.path[0]; ) vQ(u10.path);
                "?" == a10 ? (u10.query = "", c10 = l$) : "#" == a10 && (u10.fragment = "", c10 = h$);
              } else h10 += WQ(a10, PQ);
              break;
            case c$:
              "?" == a10 ? (u10.query = "", c10 = l$) : "#" == a10 ? (u10.fragment = "", c10 = h$) : a10 != _Z && (u10.path[0] += WQ(a10, LQ));
              break;
            case l$:
              t10 || "#" != a10 ? a10 != _Z && ("'" == a10 && u10.isSpecial() ? u10.query += "%27" : u10.query += "#" == a10 ? "%23" : WQ(a10, LQ)) : (u10.fragment = "", c10 = h$);
              break;
            case h$:
              a10 != _Z && (u10.fragment += WQ(a10, zQ));
          }
          l10++;
        }
      }, parseHost: function(e10) {
        var t10, n10, r10;
        if ("[" == uQ(e10, 0)) {
          if ("]" != uQ(e10, e10.length - 1)) return kQ;
          if (t10 = function(e11) {
            var t11, n11, r11, a10, i10, o10, s10, u10 = [0, 0, 0, 0, 0, 0, 0, 0], c10 = 0, l10 = null, h10 = 0, p10 = function() {
              return uQ(e11, h10);
            };
            if (":" == p10()) {
              if (":" != uQ(e11, 1)) return;
              h10 += 2, l10 = ++c10;
            }
            for (; p10(); ) {
              if (8 == c10) return;
              if (":" != p10()) {
                for (t11 = n11 = 0; n11 < 4 && cQ(AQ, p10()); ) t11 = 16 * t11 + iQ(p10(), 16), h10++, n11++;
                if ("." == p10()) {
                  if (0 == n11) return;
                  if (h10 -= n11, c10 > 6) return;
                  for (r11 = 0; p10(); ) {
                    if (a10 = null, r11 > 0) {
                      if (!("." == p10() && r11 < 4)) return;
                      h10++;
                    }
                    if (!cQ(SQ, p10())) return;
                    for (; cQ(SQ, p10()); ) {
                      if (i10 = iQ(p10(), 10), null === a10) a10 = i10;
                      else {
                        if (0 == a10) return;
                        a10 = 10 * a10 + i10;
                      }
                      if (a10 > 255) return;
                      h10++;
                    }
                    u10[c10] = 256 * u10[c10] + a10, 2 != ++r11 && 4 != r11 || c10++;
                  }
                  if (4 != r11) return;
                  break;
                }
                if (":" == p10()) {
                  if (h10++, !p10()) return;
                } else if (p10()) return;
                u10[c10++] = t11;
              } else {
                if (null !== l10) return;
                h10++, l10 = ++c10;
              }
            }
            if (null !== l10) for (o10 = c10 - l10, c10 = 7; 0 != c10 && o10 > 0; ) s10 = u10[c10], u10[c10--] = u10[l10 + o10 - 1], u10[l10 + --o10] = s10;
            else if (8 != c10) return;
            return u10;
          }(gQ(e10, 1, -1)), !t10) return kQ;
          this.host = t10;
        } else if (this.isSpecial()) {
          if (e10 = KZ(e10), cQ(RQ, e10)) return kQ;
          if (t10 = function(e11) {
            var t11, n11, r11, a10, i10, o10, s10, u10 = mQ(e11, ".");
            if (u10.length && "" == u10[u10.length - 1] && u10.length--, (t11 = u10.length) > 4) return e11;
            for (n11 = [], r11 = 0; r11 < t11; r11++) {
              if ("" == (a10 = u10[r11])) return e11;
              if (i10 = 10, a10.length > 1 && "0" == uQ(a10, 0) && (i10 = cQ(TQ, a10) ? 16 : 8, a10 = gQ(a10, 8 == i10 ? 1 : 2)), "" === a10) o10 = 0;
              else {
                if (!cQ(10 == i10 ? CQ : 8 == i10 ? EQ : AQ, a10)) return e11;
                o10 = iQ(a10, i10);
              }
              fQ(n11, o10);
            }
            for (r11 = 0; r11 < t11; r11++) if (o10 = n11[r11], r11 == t11 - 1) {
              if (o10 >= sQ(256, 5 - t11)) return null;
            } else if (o10 > 255) return null;
            for (s10 = pQ(n11), r11 = 0; r11 < n11.length; r11++) s10 += n11[r11] * sQ(256, 3 - r11);
            return s10;
          }(e10), null === t10) return kQ;
          this.host = t10;
        } else {
          if (cQ(_Q, e10)) return kQ;
          for (t10 = "", n10 = jZ(e10), r10 = 0; r10 < n10.length; r10++) t10 += WQ(n10[r10], LQ);
          this.host = t10;
        }
      }, cannotHaveUsernamePasswordPort: function() {
        return !this.host || this.cannotBeABaseURL || "file" == this.scheme;
      }, includesCredentials: function() {
        return "" != this.username || "" != this.password;
      }, isSpecial: function() {
        return VZ(UQ, this.scheme);
      }, shortenPath: function() {
        var e10 = this.path, t10 = e10.length;
        !t10 || "file" == this.scheme && 1 == t10 && VQ(e10[0], true) || e10.length--;
      }, serialize: function() {
        var e10 = this, t10 = e10.scheme, n10 = e10.username, r10 = e10.password, a10 = e10.host, i10 = e10.port, o10 = e10.path, s10 = e10.query, u10 = e10.fragment, c10 = t10 + ":";
        return null !== a10 ? (c10 += "//", e10.includesCredentials() && (c10 += n10 + (r10 ? ":" + r10 : "") + "@"), c10 += MQ(a10), null !== i10 && (c10 += ":" + i10)) : "file" == t10 && (c10 += "//"), c10 += e10.cannotBeABaseURL ? o10[0] : o10.length ? "/" + lQ(o10, "/") : "", null !== s10 && (c10 += "?" + s10), null !== u10 && (c10 += "#" + u10), c10;
      }, setHref: function(e10) {
        var t10 = this.parse(e10);
        if (t10) throw aQ(t10);
        this.searchParams.update();
      }, getOrigin: function() {
        var e10 = this.scheme, t10 = this.port;
        if ("blob" == e10) try {
          return new f$(e10.path[0]).origin;
        } catch (e11) {
          return "null";
        }
        return "file" != e10 && this.isSpecial() ? e10 + "://" + MQ(this.host) + (null !== t10 ? ":" + t10 : "") : "null";
      }, getProtocol: function() {
        return this.scheme + ":";
      }, setProtocol: function(e10) {
        this.parse(XZ(e10) + ":", HQ);
      }, getUsername: function() {
        return this.username;
      }, setUsername: function(e10) {
        var t10 = jZ(XZ(e10));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.username = "";
          for (var n10 = 0; n10 < t10.length; n10++) this.username += WQ(t10[n10], BQ);
        }
      }, getPassword: function() {
        return this.password;
      }, setPassword: function(e10) {
        var t10 = jZ(XZ(e10));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.password = "";
          for (var n10 = 0; n10 < t10.length; n10++) this.password += WQ(t10[n10], BQ);
        }
      }, getHost: function() {
        var e10 = this.host, t10 = this.port;
        return null === e10 ? "" : null === t10 ? MQ(e10) : MQ(e10) + ":" + t10;
      }, setHost: function(e10) {
        this.cannotBeABaseURL || this.parse(e10, t$);
      }, getHostname: function() {
        var e10 = this.host;
        return null === e10 ? "" : MQ(e10);
      }, setHostname: function(e10) {
        this.cannotBeABaseURL || this.parse(e10, n$);
      }, getPort: function() {
        var e10 = this.port;
        return null === e10 ? "" : XZ(e10);
      }, setPort: function(e10) {
        this.cannotHaveUsernamePasswordPort() || ("" == (e10 = XZ(e10)) ? this.port = null : this.parse(e10, r$));
      }, getPathname: function() {
        var e10 = this.path;
        return this.cannotBeABaseURL ? e10[0] : e10.length ? "/" + lQ(e10, "/") : "";
      }, setPathname: function(e10) {
        this.cannotBeABaseURL || (this.path = [], this.parse(e10, s$));
      }, getSearch: function() {
        var e10 = this.query;
        return e10 ? "?" + e10 : "";
      }, setSearch: function(e10) {
        "" == (e10 = XZ(e10)) ? this.query = null : ("?" == uQ(e10, 0) && (e10 = gQ(e10, 1)), this.query = "", this.parse(e10, l$)), this.searchParams.update();
      }, getSearchParams: function() {
        return this.searchParams.facade;
      }, getHash: function() {
        var e10 = this.fragment;
        return e10 ? "#" + e10 : "";
      }, setHash: function(e10) {
        "" != (e10 = XZ(e10)) ? ("#" == uQ(e10, 0) && (e10 = gQ(e10, 1)), this.fragment = "", this.parse(e10, h$)) : this.fragment = null;
      }, update: function() {
        this.query = this.searchParams.serialize() || null;
      } };
      var f$ = function(e10) {
        var t10 = UZ(this, d$), n10 = JZ(arguments.length, 1) > 1 ? arguments[1] : void 0, r10 = $Z(t10, new p$(e10, false, n10));
        DZ || (t10.href = r10.serialize(), t10.origin = r10.getOrigin(), t10.protocol = r10.getProtocol(), t10.username = r10.getUsername(), t10.password = r10.getPassword(), t10.host = r10.getHost(), t10.hostname = r10.getHostname(), t10.port = r10.getPort(), t10.pathname = r10.getPathname(), t10.search = r10.getSearch(), t10.searchParams = r10.getSearchParams(), t10.hash = r10.getHash());
      }, d$ = f$.prototype, v$ = function(e10, t10) {
        return { get: function() {
          return eQ(this)[e10]();
        }, set: t10 && function(e11) {
          return eQ(this)[t10](e11);
        }, configurable: true, enumerable: true };
      };
      if (DZ && (WZ(d$, "href", v$("serialize", "setHref")), WZ(d$, "origin", v$("getOrigin")), WZ(d$, "protocol", v$("getProtocol", "setProtocol")), WZ(d$, "username", v$("getUsername", "setUsername")), WZ(d$, "password", v$("getPassword", "setPassword")), WZ(d$, "host", v$("getHost", "setHost")), WZ(d$, "hostname", v$("getHostname", "setHostname")), WZ(d$, "port", v$("getPort", "setPort")), WZ(d$, "pathname", v$("getPathname", "setPathname")), WZ(d$, "search", v$("getSearch", "setSearch")), WZ(d$, "searchParams", v$("getSearchParams")), WZ(d$, "hash", v$("getHash", "setHash"))), BZ(d$, "toJSON", function() {
        return eQ(this).serialize();
      }, { enumerable: true }), BZ(d$, "toString", function() {
        return eQ(this).serialize();
      }, { enumerable: true }), rQ) {
        var m$ = rQ.createObjectURL, g$ = rQ.revokeObjectURL;
        m$ && BZ(f$, "createObjectURL", zZ(m$, rQ)), g$ && BZ(f$, "revokeObjectURL", zZ(g$, rQ));
      }
      YZ(f$, "URL"), FZ({ global: true, constructor: true, forced: !MZ, sham: !DZ }, { URL: f$ });
      var y$ = j;
      La({ target: "URL", proto: true, enumerable: true }, { toJSON: function() {
        return y$(URL.prototype.toString, this);
      } });
      var b$ = W, x$ = ee, k$ = zi, w$ = URLSearchParams.prototype, I$ = x$(w$.forEach);
      b$ && !("size" in w$) && k$(w$, "size", { get: function() {
        var e10 = 0;
        return I$(this, function() {
          e10++;
        }), e10;
      }, configurable: true, enumerable: true });
      var N$ = { exports: {} };
      !function(e10) {
        var t10 = function(e11) {
          var t11, n10 = Object.prototype, r10 = n10.hasOwnProperty, a10 = "function" == typeof Symbol ? Symbol : {}, i10 = a10.iterator || "@@iterator", o10 = a10.asyncIterator || "@@asyncIterator", u10 = a10.toStringTag || "@@toStringTag";
          function c10(e12, t12, n11) {
            return Object.defineProperty(e12, t12, { value: n11, enumerable: true, configurable: true, writable: true }), e12[t12];
          }
          try {
            c10({}, "");
          } catch (e12) {
            c10 = function(e13, t12, n11) {
              return e13[t12] = n11;
            };
          }
          function l10(e12, t12, n11, r11) {
            var a11 = t12 && t12.prototype instanceof g10 ? t12 : g10, i11 = Object.create(a11.prototype), o11 = new A10(r11 || []);
            return i11._invoke = /* @__PURE__ */ function(e13, t13, n12) {
              var r12 = p10;
              return function(a12, i12) {
                if (r12 === d10) throw new Error("Generator is already running");
                if (r12 === v10) {
                  if ("throw" === a12) throw i12;
                  return _10();
                }
                for (n12.method = a12, n12.arg = i12; ; ) {
                  var o12 = n12.delegate;
                  if (o12) {
                    var s10 = T10(o12, n12);
                    if (s10) {
                      if (s10 === m10) continue;
                      return s10;
                    }
                  }
                  if ("next" === n12.method) n12.sent = n12._sent = n12.arg;
                  else if ("throw" === n12.method) {
                    if (r12 === p10) throw r12 = v10, n12.arg;
                    n12.dispatchException(n12.arg);
                  } else "return" === n12.method && n12.abrupt("return", n12.arg);
                  r12 = d10;
                  var u11 = h10(e13, t13, n12);
                  if ("normal" === u11.type) {
                    if (r12 = n12.done ? v10 : f10, u11.arg === m10) continue;
                    return { value: u11.arg, done: n12.done };
                  }
                  "throw" === u11.type && (r12 = v10, n12.method = "throw", n12.arg = u11.arg);
                }
              };
            }(e12, n11, o11), i11;
          }
          function h10(e12, t12, n11) {
            try {
              return { type: "normal", arg: e12.call(t12, n11) };
            } catch (e13) {
              return { type: "throw", arg: e13 };
            }
          }
          e11.wrap = l10;
          var p10 = "suspendedStart", f10 = "suspendedYield", d10 = "executing", v10 = "completed", m10 = {};
          function g10() {
          }
          function y10() {
          }
          function b10() {
          }
          var x10 = {};
          x10[i10] = function() {
            return this;
          };
          var k10 = Object.getPrototypeOf, w10 = k10 && k10(k10(R10([])));
          w10 && w10 !== n10 && r10.call(w10, i10) && (x10 = w10);
          var I10 = b10.prototype = g10.prototype = Object.create(x10);
          function N10(e12) {
            ["next", "throw", "return"].forEach(function(t12) {
              c10(e12, t12, function(e13) {
                return this._invoke(t12, e13);
              });
            });
          }
          function S10(e12, t12) {
            function n11(a12, i11, o11, u11) {
              var c11 = h10(e12[a12], e12, i11);
              if ("throw" !== c11.type) {
                var l11 = c11.arg, p11 = l11.value;
                return p11 && "object" === s(p11) && r10.call(p11, "__await") ? t12.resolve(p11.__await).then(function(e13) {
                  n11("next", e13, o11, u11);
                }, function(e13) {
                  n11("throw", e13, o11, u11);
                }) : t12.resolve(p11).then(function(e13) {
                  l11.value = e13, o11(l11);
                }, function(e13) {
                  return n11("throw", e13, o11, u11);
                });
              }
              u11(c11.arg);
            }
            var a11;
            this._invoke = function(e13, r11) {
              function i11() {
                return new t12(function(t13, a12) {
                  n11(e13, r11, t13, a12);
                });
              }
              return a11 = a11 ? a11.then(i11, i11) : i11();
            };
          }
          function T10(e12, n11) {
            var r11 = e12.iterator[n11.method];
            if (r11 === t11) {
              if (n11.delegate = null, "throw" === n11.method) {
                if (e12.iterator.return && (n11.method = "return", n11.arg = t11, T10(e12, n11), "throw" === n11.method)) return m10;
                n11.method = "throw", n11.arg = new TypeError("The iterator does not provide a 'throw' method");
              }
              return m10;
            }
            var a11 = h10(r11, e12.iterator, n11.arg);
            if ("throw" === a11.type) return n11.method = "throw", n11.arg = a11.arg, n11.delegate = null, m10;
            var i11 = a11.arg;
            return i11 ? i11.done ? (n11[e12.resultName] = i11.value, n11.next = e12.nextLoc, "return" !== n11.method && (n11.method = "next", n11.arg = t11), n11.delegate = null, m10) : i11 : (n11.method = "throw", n11.arg = new TypeError("iterator result is not an object"), n11.delegate = null, m10);
          }
          function E10(e12) {
            var t12 = { tryLoc: e12[0] };
            1 in e12 && (t12.catchLoc = e12[1]), 2 in e12 && (t12.finallyLoc = e12[2], t12.afterLoc = e12[3]), this.tryEntries.push(t12);
          }
          function C10(e12) {
            var t12 = e12.completion || {};
            t12.type = "normal", delete t12.arg, e12.completion = t12;
          }
          function A10(e12) {
            this.tryEntries = [{ tryLoc: "root" }], e12.forEach(E10, this), this.reset(true);
          }
          function R10(e12) {
            if (e12) {
              var n11 = e12[i10];
              if (n11) return n11.call(e12);
              if ("function" == typeof e12.next) return e12;
              if (!isNaN(e12.length)) {
                var a11 = -1, o11 = function n12() {
                  for (; ++a11 < e12.length; ) if (r10.call(e12, a11)) return n12.value = e12[a11], n12.done = false, n12;
                  return n12.value = t11, n12.done = true, n12;
                };
                return o11.next = o11;
              }
            }
            return { next: _10 };
          }
          function _10() {
            return { value: t11, done: true };
          }
          return y10.prototype = I10.constructor = b10, b10.constructor = y10, y10.displayName = c10(b10, u10, "GeneratorFunction"), e11.isGeneratorFunction = function(e12) {
            var t12 = "function" == typeof e12 && e12.constructor;
            return !!t12 && (t12 === y10 || "GeneratorFunction" === (t12.displayName || t12.name));
          }, e11.mark = function(e12) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e12, b10) : (e12.__proto__ = b10, c10(e12, u10, "GeneratorFunction")), e12.prototype = Object.create(I10), e12;
          }, e11.awrap = function(e12) {
            return { __await: e12 };
          }, N10(S10.prototype), S10.prototype[o10] = function() {
            return this;
          }, e11.AsyncIterator = S10, e11.async = function(t12, n11, r11, a11, i11) {
            void 0 === i11 && (i11 = Promise);
            var o11 = new S10(l10(t12, n11, r11, a11), i11);
            return e11.isGeneratorFunction(n11) ? o11 : o11.next().then(function(e12) {
              return e12.done ? e12.value : o11.next();
            });
          }, N10(I10), c10(I10, u10, "Generator"), I10[i10] = function() {
            return this;
          }, I10.toString = function() {
            return "[object Generator]";
          }, e11.keys = function(e12) {
            var t12 = [];
            for (var n11 in e12) t12.push(n11);
            return t12.reverse(), function n12() {
              for (; t12.length; ) {
                var r11 = t12.pop();
                if (r11 in e12) return n12.value = r11, n12.done = false, n12;
              }
              return n12.done = true, n12;
            };
          }, e11.values = R10, A10.prototype = { constructor: A10, reset: function(e12) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = t11, this.done = false, this.delegate = null, this.method = "next", this.arg = t11, this.tryEntries.forEach(C10), !e12) for (var n11 in this) "t" === n11.charAt(0) && r10.call(this, n11) && !isNaN(+n11.slice(1)) && (this[n11] = t11);
          }, stop: function() {
            this.done = true;
            var e12 = this.tryEntries[0].completion;
            if ("throw" === e12.type) throw e12.arg;
            return this.rval;
          }, dispatchException: function(e12) {
            if (this.done) throw e12;
            var n11 = this;
            function a11(r11, a12) {
              return s10.type = "throw", s10.arg = e12, n11.next = r11, a12 && (n11.method = "next", n11.arg = t11), !!a12;
            }
            for (var i11 = this.tryEntries.length - 1; i11 >= 0; --i11) {
              var o11 = this.tryEntries[i11], s10 = o11.completion;
              if ("root" === o11.tryLoc) return a11("end");
              if (o11.tryLoc <= this.prev) {
                var u11 = r10.call(o11, "catchLoc"), c11 = r10.call(o11, "finallyLoc");
                if (u11 && c11) {
                  if (this.prev < o11.catchLoc) return a11(o11.catchLoc, true);
                  if (this.prev < o11.finallyLoc) return a11(o11.finallyLoc);
                } else if (u11) {
                  if (this.prev < o11.catchLoc) return a11(o11.catchLoc, true);
                } else {
                  if (!c11) throw new Error("try statement without catch or finally");
                  if (this.prev < o11.finallyLoc) return a11(o11.finallyLoc);
                }
              }
            }
          }, abrupt: function(e12, t12) {
            for (var n11 = this.tryEntries.length - 1; n11 >= 0; --n11) {
              var a11 = this.tryEntries[n11];
              if (a11.tryLoc <= this.prev && r10.call(a11, "finallyLoc") && this.prev < a11.finallyLoc) {
                var i11 = a11;
                break;
              }
            }
            i11 && ("break" === e12 || "continue" === e12) && i11.tryLoc <= t12 && t12 <= i11.finallyLoc && (i11 = null);
            var o11 = i11 ? i11.completion : {};
            return o11.type = e12, o11.arg = t12, i11 ? (this.method = "next", this.next = i11.finallyLoc, m10) : this.complete(o11);
          }, complete: function(e12, t12) {
            if ("throw" === e12.type) throw e12.arg;
            return "break" === e12.type || "continue" === e12.type ? this.next = e12.arg : "return" === e12.type ? (this.rval = this.arg = e12.arg, this.method = "return", this.next = "end") : "normal" === e12.type && t12 && (this.next = t12), m10;
          }, finish: function(e12) {
            for (var t12 = this.tryEntries.length - 1; t12 >= 0; --t12) {
              var n11 = this.tryEntries[t12];
              if (n11.finallyLoc === e12) return this.complete(n11.completion, n11.afterLoc), C10(n11), m10;
            }
          }, catch: function(e12) {
            for (var t12 = this.tryEntries.length - 1; t12 >= 0; --t12) {
              var n11 = this.tryEntries[t12];
              if (n11.tryLoc === e12) {
                var r11 = n11.completion;
                if ("throw" === r11.type) {
                  var a11 = r11.arg;
                  C10(n11);
                }
                return a11;
              }
            }
            throw new Error("illegal catch attempt");
          }, delegateYield: function(e12, n11, r11) {
            return this.delegate = { iterator: R10(e12), resultName: n11, nextLoc: r11 }, "next" === this.method && (this.arg = t11), m10;
          } }, e11;
        }(e10.exports);
        try {
          regeneratorRuntime = t10;
        } catch (e11) {
          Function("r", "regeneratorRuntime = r")(t10);
        }
      }(N$);
      var S$ = function() {
        function e10(t10, n10) {
          l(this, e10), this.backend = t10, this.dataMover = n10, this.data = /* @__PURE__ */ new WeakMap(), this.dataIdsCount = 0;
        }
        return p(e10, [{ key: "get", value: function(e11) {
          return this.data.has(e11) || this.dataMover.moveData(this.backend, e11), this.data.get(e11);
        } }, { key: "set", value: function(e11, t10) {
          this.dataIdsCount++, this.data.set(e11, t10);
        } }, { key: "has", value: function(e11) {
          return this.data.has(e11);
        } }, { key: "delete", value: function(e11) {
          return this.dataIdsCount--, this.data.delete(e11);
        } }, { key: "numDataIds", value: function() {
          return this.dataIdsCount;
        } }]), e10;
      }(), T$ = function() {
        function e10() {
          l(this, e10);
        }
        return p(e10, [{ key: "refCount", value: function(e11) {
          return E$("refCount");
        } }, { key: "incRef", value: function(e11) {
          return E$("incRef");
        } }, { key: "timerAvailable", value: function() {
          return true;
        } }, { key: "time", value: function(e11) {
          return E$("time");
        } }, { key: "read", value: function(e11) {
          return E$("read");
        } }, { key: "readSync", value: function(e11) {
          return E$("readSync");
        } }, { key: "readToGPU", value: function(e11, t10) {
          return E$("readToGPU");
        } }, { key: "numDataIds", value: function() {
          return E$("numDataIds");
        } }, { key: "disposeData", value: function(e11, t10) {
          return E$("disposeData");
        } }, { key: "write", value: function(e11, t10, n10) {
          return E$("write");
        } }, { key: "move", value: function(e11, t10, n10, r10, a10) {
          return E$("move");
        } }, { key: "createTensorFromGPUData", value: function(e11, t10, n10) {
          return E$("createTensorFromGPUData");
        } }, { key: "memory", value: function() {
          return E$("memory");
        } }, { key: "floatPrecision", value: function() {
          return E$("floatPrecision");
        } }, { key: "epsilon", value: function() {
          return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
        } }, { key: "dispose", value: function() {
          return E$("dispose");
        } }]), e10;
      }();
      function E$(e10) {
        throw new Error("'".concat(e10, "' not yet implemented or not found in the registry. ") + "This kernel may not be supported by the tfjs backend you have chosen");
      }
      function C$(e10) {
        for (var t10 = e10.length, n10 = 0; t10 > 0; ) n10 = Math.random() * t10 | 0, _$(e10, --t10, n10);
      }
      function A$(e10, t10, n10) {
        return Math.max(e10, Math.min(t10, n10));
      }
      function R$(e10) {
        return e10 % 2 == 0 ? e10 : e10 + 1;
      }
      function _$(e10, t10, n10) {
        var r10 = e10[t10];
        e10[t10] = e10[n10], e10[n10] = r10;
      }
      function O$(e10) {
        for (var t10 = 0, n10 = 0; n10 < e10.length; n10++) t10 += e10[n10];
        return t10;
      }
      function F$(e10, t10) {
        if (!e10) throw new Error("string" == typeof t10 ? t10 : t10());
      }
      function D$(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
        F$(P$(e10, t10), function() {
          return n10 + " Shapes ".concat(e10, " and ").concat(t10, " must match");
        });
      }
      function M$(e10) {
        F$(null != e10, function() {
          return "The input to the tensor constructor must be a non-null value.";
        });
      }
      function L$(e10) {
        if (0 === e10.length) return 1;
        for (var t10 = e10[0], n10 = 1; n10 < e10.length; n10++) t10 *= e10[n10];
        return t10;
      }
      function z$(e10, t10) {
        if (e10 === t10) return true;
        if (null == e10 || null == t10) return false;
        if (e10.length !== t10.length) return false;
        for (var n10 = 0; n10 < e10.length; n10++) if (null !== e10[n10] && null !== t10[n10] && e10[n10] !== t10[n10]) return false;
        return true;
      }
      function P$(e10, t10) {
        if (e10 === t10) return true;
        if (null == e10 || null == t10) return false;
        if (e10.length !== t10.length) return false;
        for (var n10 = 0; n10 < e10.length; n10++) if (e10[n10] !== t10[n10]) return false;
        return true;
      }
      function B$(e10) {
        return e10 % 1 == 0;
      }
      function W$(e10) {
        var t10 = Math.ceil(Math.sqrt(e10));
        return [t10, Math.ceil(e10 / t10)];
      }
      function U$(e10, t10) {
        return t10 <= e10.length ? e10 : e10 + " ".repeat(t10 - e10.length);
      }
      function V$(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function(e11) {
          return 0;
        }, n10 = arguments.length > 2 ? arguments[2] : void 0, r10 = arguments.length > 3 ? arguments[3] : void 0;
        return new Promise(function(a10, i10) {
          var o10 = 0;
          !function s10() {
            if (e10()) a10();
            else {
              o10++;
              var u10 = t10(o10);
              null != n10 && o10 >= n10 ? i10() : null != r10 ? r10(s10, u10) : setTimeout(s10, u10);
            }
          }();
        });
      }
      function G$(e10, t10) {
        for (var n10 = 1, r10 = -1, a10 = 0; a10 < e10.length; ++a10) if (e10[a10] >= 0) n10 *= e10[a10];
        else if (-1 === e10[a10]) {
          if (-1 !== r10) throw Error("Shapes can only have 1 implicit size. " + "Found -1 at dim ".concat(r10, " and dim ").concat(a10));
          r10 = a10;
        } else if (e10[a10] < 0) throw Error("Shapes can not be < 0. Found ".concat(e10[a10], " at dim ").concat(a10));
        if (-1 === r10) {
          if (t10 > 0 && t10 !== n10) throw Error("Size(".concat(t10, ") must match the product of shape ").concat(e10));
          return e10;
        }
        if (0 === n10) throw Error("Cannot infer the missing size in [".concat(e10, "] when ") + "there are 0 elements");
        if (t10 % n10 != 0) throw Error("The implicit shape can't be a fractional number. " + "Got ".concat(t10, " / ").concat(n10));
        var i10 = e10.slice();
        return i10[r10] = t10 / n10, i10;
      }
      function j$(e10, t10) {
        var n10 = t10.length;
        return F$((e10 = null == e10 ? t10.map(function(e11, t11) {
          return t11;
        }) : [].concat(e10)).every(function(e11) {
          return e11 >= -n10 && e11 < n10;
        }), function() {
          return "All values in axis param must be in range [-".concat(n10, ", ").concat(n10, ") but ") + "got axis ".concat(e10);
        }), F$(e10.every(function(e11) {
          return B$(e11);
        }), function() {
          return "All values in axis param must be integers but " + "got axis ".concat(e10);
        }), e10.map(function(e11) {
          return e11 < 0 ? n10 + e11 : e11;
        });
      }
      function H$(e10, t10) {
        for (var n10 = [], r10 = [], a10 = null != t10 && Array.isArray(t10) && 0 === t10.length, i10 = null == t10 || a10 ? null : j$(t10, e10).sort(), o10 = 0, s10 = 0; s10 < e10.length; ++s10) {
          if (null != i10) {
            if (i10[o10] === s10 && 1 !== e10[s10]) throw new Error("Can't squeeze axis ".concat(s10, " since its dim '").concat(e10[s10], "' is not 1"));
            (null == i10[o10] || i10[o10] > s10) && 1 === e10[s10] && (n10.push(e10[s10]), r10.push(s10)), i10[o10] <= s10 && o10++;
          }
          1 !== e10[s10] && (n10.push(e10[s10]), r10.push(s10));
        }
        return { newShape: n10, keptDims: r10 };
      }
      function q$(e10, t10) {
        return K$(e10, t10);
      }
      function K$(e10, t10) {
        var n10 = null;
        if (null == e10 || "float32" === e10) n10 = new Float32Array(t10);
        else if ("int32" === e10) n10 = new Int32Array(t10);
        else if ("bool" === e10) n10 = new Uint8Array(t10);
        else {
          if ("string" !== e10) throw new Error("Unknown data type ".concat(e10));
          n10 = new Array(t10);
        }
        return n10;
      }
      function X$(e10, t10) {
        for (var n10 = 0; n10 < e10.length; n10++) {
          var r10 = e10[n10];
          if (isNaN(r10) || !isFinite(r10)) throw Error("A tensor of type ".concat(t10, " being uploaded contains ").concat(r10, "."));
        }
      }
      function Y$(e10) {
        return "bool" === e10 || "complex64" === e10 || "float32" === e10 || "int32" === e10 || "string" === e10;
      }
      function J$(e10, t10) {
        return "complex64" !== t10 && (("float32" !== t10 || "complex64" === e10) && (("int32" !== t10 || "float32" === e10 || "complex64" === e10) && ("bool" !== t10 || "bool" !== e10)));
      }
      function Z$(e10) {
        if ("float32" === e10 || "int32" === e10) return 4;
        if ("complex64" === e10) return 8;
        if ("bool" === e10) return 1;
        throw new Error("Unknown dtype ".concat(e10));
      }
      function Q$(e10) {
        if (null == e10) return 0;
        var t10 = 0;
        return e10.forEach(function(e11) {
          return t10 += e11.length;
        }), t10;
      }
      function $$(e10) {
        return "string" == typeof e10 || e10 instanceof String;
      }
      function e0(e10) {
        return "boolean" == typeof e10;
      }
      function t0(e10) {
        return "number" == typeof e10;
      }
      function n0(e10) {
        return Array.isArray(e10) ? n0(e10[0]) : e10 instanceof Float32Array ? "float32" : e10 instanceof Int32Array || e10 instanceof Uint8Array || e10 instanceof Uint8ClampedArray ? "int32" : t0(e10) ? "float32" : $$(e10) ? "string" : e0(e10) ? "bool" : "float32";
      }
      function r0(e10) {
        return !!(e10 && e10.constructor && e10.call && e10.apply);
      }
      function a0(e10, t10) {
        for (var n10 = t10; n10 < e10; ++n10) if (e10 % n10 == 0) return n10;
        return e10;
      }
      function i0(e10) {
        var t10 = e10.length;
        if (t10 < 2) return [];
        var n10 = new Array(t10 - 1);
        n10[t10 - 2] = e10[t10 - 1];
        for (var r10 = t10 - 3; r10 >= 0; --r10) n10[r10] = n10[r10 + 1] * e10[r10 + 1];
        return n10;
      }
      function o0(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a10 = new Array();
        if (1 === t10.length) for (var i10 = t10[0] * (r10 ? 2 : 1), o10 = 0; o10 < i10; o10++) a10[o10] = n10[e10 + o10];
        else for (var s10 = t10[0], u10 = t10.slice(1), c10 = u10.reduce(function(e11, t11) {
          return e11 * t11;
        }) * (r10 ? 2 : 1), l10 = 0; l10 < s10; l10++) a10[l10] = o0(e10 + l10 * c10, u10, n10, r10);
        return a10;
      }
      function s0(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if (0 === e10.length) return t10[0];
        var r10 = e10.reduce(function(e11, t11) {
          return e11 * t11;
        }) * (n10 ? 2 : 1);
        if (0 === r10) return [];
        if (r10 !== t10.length) throw new Error("[".concat(e10, "] does not match the input size ").concat(t10.length).concat(n10 ? " for a complex tensor" : "", "."));
        return o0(0, e10, t10, n10);
      }
      function u0(e10, t10) {
        if (Array.isArray(e10)) return e10;
        if ("float32" === t10) return e10 instanceof Float32Array ? e10 : new Float32Array(e10);
        if ("int32" === t10) return e10 instanceof Int32Array ? e10 : new Int32Array(e10);
        if ("bool" === t10 || "string" === t10) return Uint8Array.from(new Int32Array(e10));
        throw new Error("Unknown dtype ".concat(t10));
      }
      function c0(e10, t10) {
        for (var n10 = l0(e10, t10), r10 = 0; r10 < n10.length; r10++) n10[r10] = 1;
        return n10;
      }
      function l0(e10, t10) {
        if (null == t10 || "float32" === t10 || "complex64" === t10) return new Float32Array(e10);
        if ("int32" === t10) return new Int32Array(e10);
        if ("bool" === t10) return new Uint8Array(e10);
        throw new Error("Unknown data type ".concat(t10));
      }
      function h0(e10, t10) {
        var n10 = e10.reduce(function(e11, t11) {
          return e11 * t11;
        }, 1);
        if (null == t10 || "float32" === t10) return s0(e10, new Float32Array(n10));
        if ("int32" === t10) return s0(e10, new Int32Array(n10));
        if ("bool" === t10) return s0(e10, new Uint8Array(n10));
        throw new Error("Unknown data type ".concat(t10));
      }
      function p0(e10) {
        e10.forEach(function(t10) {
          F$(Number.isInteger(t10) && t10 >= 0, function() {
            return "Tensor must have a shape comprised of positive integers but got " + "shape [".concat(e10, "].");
          });
        });
      }
      function f0(e10, t10, n10) {
        if (0 === t10) return 0;
        if (1 === t10) return e10[0];
        for (var r10 = e10[e10.length - 1], a10 = 0; a10 < e10.length - 1; ++a10) r10 += n10[a10] * e10[a10];
        return r10;
      }
      function d0(e10, t10, n10) {
        if (0 === t10) return [];
        if (1 === t10) return [e10];
        for (var r10 = new Array(t10), a10 = 0; a10 < r10.length - 1; ++a10) r10[a10] = Math.floor(e10 / n10[a10]), e10 -= r10[a10] * n10[a10];
        return r10[r10.length - 1] = e10, r10;
      }
      function v0(e10) {
        return e10 && e10.then && "function" == typeof e10.then;
      }
      var m0, g0 = "tfjsflags", y0 = function() {
        function e10(t11) {
          l(this, e10), this.global = t11, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = b0, this.populateURLFlags();
        }
        var t10;
        return p(e10, [{ key: "setPlatform", value: function(e11, t11) {
          null != this.platform && (k0().getBool("IS_TEST") || k0().getBool("PROD") || console.warn("Platform ".concat(this.platformName, " has already been set. ") + "Overwriting the platform with ".concat(e11, "."))), this.platformName = e11, this.platform = t11;
        } }, { key: "registerFlag", value: function(e11, t11, n10) {
          if (this.flagRegistry[e11] = { evaluationFn: t11, setHook: n10 }, null != this.urlFlags[e11]) {
            var r10 = this.urlFlags[e11];
            k0().getBool("IS_TEST") || k0().getBool("PROD") || console.warn("Setting feature override from URL ".concat(e11, ": ").concat(r10, ".")), this.set(e11, r10);
          }
        } }, { key: "getAsync", value: (t10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!(t11 in this.flags)) {
                  e12.next = 2;
                  break;
                }
                return e12.abrupt("return", this.flags[t11]);
              case 2:
                return e12.next = 4, this.evaluateFlag(t11);
              case 4:
                return this.flags[t11] = e12.sent, e12.abrupt("return", this.flags[t11]);
              case 6:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "get", value: function(e11) {
          if (e11 in this.flags) return this.flags[e11];
          var t11 = this.evaluateFlag(e11);
          if (v0(t11)) throw new Error("Flag ".concat(e11, " cannot be synchronously evaluated. ") + "Please use getAsync() instead.");
          return this.flags[e11] = t11, this.flags[e11];
        } }, { key: "getNumber", value: function(e11) {
          return this.get(e11);
        } }, { key: "getBool", value: function(e11) {
          return this.get(e11);
        } }, { key: "getString", value: function(e11) {
          return this.get(e11);
        } }, { key: "getFlags", value: function() {
          return this.flags;
        } }, { key: "features", get: function() {
          return this.flags;
        } }, { key: "set", value: function(e11, t11) {
          if (null == this.flagRegistry[e11]) throw new Error("Cannot set flag ".concat(e11, " as it has not been registered."));
          this.flags[e11] = t11, null != this.flagRegistry[e11].setHook && this.flagRegistry[e11].setHook(t11);
        } }, { key: "evaluateFlag", value: function(e11) {
          if (null == this.flagRegistry[e11]) throw new Error("Cannot evaluate flag '".concat(e11, "': no evaluation function found."));
          return this.flagRegistry[e11].evaluationFn();
        } }, { key: "setFlags", value: function(e11) {
          this.flags = Object.assign({}, e11);
        } }, { key: "reset", value: function() {
          this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
        } }, { key: "populateURLFlags", value: function() {
          var e11 = this;
          if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {
            var t11 = this.getQueryParams(this.global.location.search);
            if (g0 in t11) t11.tfjsflags.split(",").forEach(function(t12) {
              var n10 = S(t12.split(":"), 2), r10 = n10[0], a10 = n10[1];
              e11.urlFlags[r10] = function(e12, t13) {
                var n11 = t13.toLowerCase();
                return "true" === n11 || "false" === n11 ? "true" === n11 : "".concat(+n11) === n11 ? +n11 : t13;
              }(0, a10);
            });
          }
        } }]), e10;
      }();
      function b0(e10) {
        var t10 = {};
        return e10.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function(e11) {
          for (var n10 = arguments.length, r10 = new Array(n10 > 1 ? n10 - 1 : 0), a10 = 1; a10 < n10; a10++) r10[a10 - 1] = arguments[a10];
          return x0(t10, r10[0], r10[1]), r10.join("=");
        }), t10;
      }
      function x0(e10, t10, n10) {
        e10[decodeURIComponent(t10)] = decodeURIComponent(n10 || "");
      }
      function k0() {
        return e.ENV;
      }
      function w0() {
        if (null == m0) {
          var e10;
          if ("undefined" != typeof window) e10 = window;
          else if ("undefined" != typeof global) e10 = global;
          else if ("undefined" != typeof process) e10 = process;
          else {
            if ("undefined" == typeof self) throw new Error("Could not find a global object");
            e10 = self;
          }
          m0 = e10;
        }
        return m0;
      }
      function I0(e10, t10) {
        var n10, r10 = (null == (n10 = w0())._tfGlobals && (n10._tfGlobals = /* @__PURE__ */ new Map()), n10._tfGlobals);
        if (r10.has(e10)) return r10.get(e10);
        var a10 = t10();
        return r10.set(e10, a10), r10.get(e10);
      }
      e.ENV = null;
      var N0 = "Abs", S0 = "Acos", T0 = "Acosh", E0 = "Add", C0 = "AddN", A0 = "All", R0 = "Any", _0 = "ArgMax", O0 = "ArgMin", F0 = "Asin", D0 = "Asinh", M0 = "Atan", L0 = "Atanh", z0 = "Atan2", P0 = "AvgPool", B0 = "AvgPoolGrad", W0 = "AvgPool3D", U0 = "AvgPool3DGrad", V0 = "BatchMatMul", G0 = "BatchToSpaceND", j0 = "Bincount", H0 = "BitwiseAnd", q0 = "BroadcastTo", K0 = "BroadcastArgs", X0 = "Cast", Y0 = "Ceil", J0 = "ClipByValue", Z0 = "Complex", Q0 = "ComplexAbs", $0 = "Concat", e1 = "Conv2D", t1 = "Conv2DBackpropFilter", n1 = "Conv2DBackpropInput", r1 = "Conv3D", a1 = "Conv3DBackpropFilterV2", i1 = "Conv3DBackpropInputV2", o1 = "Cos", s1 = "Cosh", u1 = "Cumprod", c1 = "Cumsum", l1 = "CropAndResize", h1 = "DenseBincount", p1 = "DepthToSpace", f1 = "DepthwiseConv2dNative", d1 = "DepthwiseConv2dNativeBackpropFilter", v1 = "DepthwiseConv2dNativeBackpropInput", m1 = "Diag", g1 = "Dilation2D", y1 = "Dilation2DBackpropInput", b1 = "Dilation2DBackpropFilter", x1 = "Draw", k1 = "RealDiv", w1 = "Einsum", I1 = "Elu", N1 = "EluGrad", S1 = "Erf", T1 = "Equal", E1 = "Exp", C1 = "ExpandDims", A1 = "Expm1", R1 = "FFT", _1 = "Fill", O1 = "FlipLeftRight", F1 = "Floor", D1 = "FloorDiv", M1 = "FusedBatchNorm", L1 = "GatherV2", z1 = "GatherNd", P1 = "Greater", B1 = "GreaterEqual", W1 = "Identity", U1 = "IFFT", V1 = "Imag", G1 = "IsFinite", j1 = "IsInf", H1 = "IsNan", q1 = "LeakyRelu", K1 = "Less", X1 = "LessEqual", Y1 = "LinSpace", J1 = "Log", Z1 = "Log1p", Q1 = "LogicalAnd", $1 = "LogicalNot", e2 = "LogicalOr", t2 = "LogSoftmax", n2 = "LRN", r2 = "LRNGrad", a2 = "Max", i2 = "Maximum", o2 = "MaxPool", s2 = "MaxPoolGrad", u2 = "MaxPool3D", c2 = "MaxPool3DGrad", l2 = "MaxPoolWithArgmax", h2 = "Mean", p2 = "Min", f2 = "Minimum", d2 = "MirrorPad", v2 = "Mod", m2 = "Multinomial", g2 = "Multiply", y2 = "Neg", b2 = "NotEqual", x2 = "NonMaxSuppressionV3", k2 = "NonMaxSuppressionV4", w2 = "NonMaxSuppressionV5", I2 = "OnesLike", N2 = "OneHot", S2 = "Pack", T2 = "PadV2", E2 = "Pow", C2 = "Prelu", A2 = "Prod", R2 = "RaggedGather", _2 = "RaggedRange", O2 = "RaggedTensorToTensor", F2 = "Range", D2 = "Real", M2 = "Reciprocal", L2 = "Relu", z2 = "Reshape", P2 = "ResizeNearestNeighbor", B2 = "ResizeNearestNeighborGrad", W2 = "ResizeBilinear", U2 = "ResizeBilinearGrad", V2 = "Relu6", G2 = "Reverse", j2 = "Round", H2 = "Rsqrt", q2 = "ScatterNd", K2 = "TensorScatterUpdate", X2 = "SearchSorted", Y2 = "Select", J2 = "Selu", Z2 = "Slice", Q2 = "Sin", $2 = "Sinh", e3 = "Sign", t3 = "Sigmoid", n3 = "Softplus", r3 = "Sqrt", a3 = "Sum", i3 = "SpaceToBatchND", o3 = "SplitV", s3 = "Softmax", u3 = "SparseFillEmptyRows", c3 = "SparseReshape", l3 = "SparseSegmentMean", h3 = "SparseSegmentSum", p3 = "SparseToDense", f3 = "SquaredDifference", d3 = "Square", v3 = "StaticRegexReplace", m3 = "StridedSlice", g3 = "StringNGrams", y3 = "StringSplit", b3 = "StringToHashBucketFast", x3 = "Sub", k3 = "Tan", w3 = "Tanh", I3 = "Tile", N3 = "TopK", S3 = "Transform", T3 = "Transpose", E3 = "Unique", C3 = "Unpack", A3 = "UnsortedSegmentSum", R3 = "ZerosLike", _3 = "Step", O3 = "FromPixels", F3 = "RotateWithOffset", D3 = "_FusedMatMul", M3 = "FusedConv2D", L3 = "FusedDepthwiseConv2D";
      function z3() {
        var e10;
        k0().getBool("IS_TEST") || k0().getBool("PROD") || (e10 = console).warn.apply(e10, arguments);
      }
      var P3 = I0("kernelRegistry", function() {
        return /* @__PURE__ */ new Map();
      }), B3 = I0("gradRegistry", function() {
        return /* @__PURE__ */ new Map();
      });
      function W3(e10, t10) {
        var n10 = H3(e10, t10);
        return P3.get(n10);
      }
      function U3(e10) {
        return B3.get(e10);
      }
      function V3(e10) {
        for (var t10 = P3.entries(), n10 = []; ; ) {
          var r10 = t10.next(), a10 = r10.done, i10 = r10.value;
          if (a10) break;
          var o10 = S(i10, 2), s10 = o10[0], u10 = o10[1];
          S(s10.split("_"), 1)[0] === e10 && n10.push(u10);
        }
        return n10;
      }
      function G3(e10) {
        var t10 = e10.kernelName, n10 = e10.backendName, r10 = H3(t10, n10);
        P3.has(r10) && z3("The kernel '".concat(t10, "' for backend ") + "'".concat(n10, "' is already registered")), P3.set(r10, e10);
      }
      function j3(e10) {
        var t10 = e10.kernelName;
        B3.has(t10) && k0().getBool("DEBUG") && z3("Overriding the gradient for '".concat(t10, "'")), B3.set(t10, e10);
      }
      function H3(e10, t10) {
        return "".concat(t10, "_").concat(e10);
      }
      function q3(e10) {
        return e10 instanceof Float32Array || e10 instanceof Int32Array || e10 instanceof Uint8Array || e10 instanceof Uint8ClampedArray;
      }
      var K3 = Y3, X3 = null;
      try {
        X3 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
      } catch (e10) {
      }
      function Y3(e10, t10, n10) {
        this.low = 0 | e10, this.high = 0 | t10, this.unsigned = !!n10;
      }
      function J3(e10) {
        return true === (e10 && e10.__isLong__);
      }
      Y3.prototype.__isLong__, Object.defineProperty(Y3.prototype, "__isLong__", { value: true }), Y3.isLong = J3;
      var Z3 = {}, Q3 = {};
      function $3(e10, t10) {
        var n10, r10, a10;
        return t10 ? (a10 = 0 <= (e10 >>>= 0) && e10 < 256) && (r10 = Q3[e10]) ? r10 : (n10 = t4(e10, (0 | e10) < 0 ? -1 : 0, true), a10 && (Q3[e10] = n10), n10) : (a10 = -128 <= (e10 |= 0) && e10 < 128) && (r10 = Z3[e10]) ? r10 : (n10 = t4(e10, e10 < 0 ? -1 : 0, false), a10 && (Z3[e10] = n10), n10);
      }
      function e4(e10, t10) {
        if (isNaN(e10)) return t10 ? l4 : c4;
        if (t10) {
          if (e10 < 0) return l4;
          if (e10 >= o4) return v4;
        } else {
          if (e10 <= -s4) return m4;
          if (e10 + 1 >= s4) return d4;
        }
        return e10 < 0 ? e4(-e10, t10).neg() : t4(e10 % i4 | 0, e10 / i4 | 0, t10);
      }
      function t4(e10, t10, n10) {
        return new Y3(e10, t10, n10);
      }
      Y3.fromInt = $3, Y3.fromNumber = e4, Y3.fromBits = t4;
      var n4 = Math.pow;
      function r4(e10, t10, n10) {
        if (0 === e10.length) throw Error("empty string");
        if ("NaN" === e10 || "Infinity" === e10 || "+Infinity" === e10 || "-Infinity" === e10) return c4;
        if ("number" == typeof t10 ? (n10 = t10, t10 = false) : t10 = !!t10, (n10 = n10 || 10) < 2 || 36 < n10) throw RangeError("radix");
        var r10;
        if ((r10 = e10.indexOf("-")) > 0) throw Error("interior hyphen");
        if (0 === r10) return r4(e10.substring(1), t10, n10).neg();
        for (var a10 = e4(n4(n10, 8)), i10 = c4, o10 = 0; o10 < e10.length; o10 += 8) {
          var s10 = Math.min(8, e10.length - o10), u10 = parseInt(e10.substring(o10, o10 + s10), n10);
          if (s10 < 8) {
            var c10 = e4(n4(n10, s10));
            i10 = i10.mul(c10).add(e4(u10));
          } else i10 = (i10 = i10.mul(a10)).add(e4(u10));
        }
        return i10.unsigned = t10, i10;
      }
      function a4(e10, t10) {
        return "number" == typeof e10 ? e4(e10, t10) : "string" == typeof e10 ? r4(e10, t10) : t4(e10.low, e10.high, "boolean" == typeof t10 ? t10 : e10.unsigned);
      }
      Y3.fromString = r4, Y3.fromValue = a4;
      var i4 = 4294967296, o4 = i4 * i4, s4 = o4 / 2, u4 = $3(1 << 24), c4 = $3(0);
      Y3.ZERO = c4;
      var l4 = $3(0, true);
      Y3.UZERO = l4;
      var h4 = $3(1);
      Y3.ONE = h4;
      var p4 = $3(1, true);
      Y3.UONE = p4;
      var f4 = $3(-1);
      Y3.NEG_ONE = f4;
      var d4 = t4(-1, 2147483647, false);
      Y3.MAX_VALUE = d4;
      var v4 = t4(-1, -1, true);
      Y3.MAX_UNSIGNED_VALUE = v4;
      var m4 = t4(0, -2147483648, false);
      Y3.MIN_VALUE = m4;
      var g4 = Y3.prototype;
      g4.toInt = function() {
        return this.unsigned ? this.low >>> 0 : this.low;
      }, g4.toNumber = function() {
        return this.unsigned ? (this.high >>> 0) * i4 + (this.low >>> 0) : this.high * i4 + (this.low >>> 0);
      }, g4.toString = function(e10) {
        if ((e10 = e10 || 10) < 2 || 36 < e10) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative()) {
          if (this.eq(m4)) {
            var t10 = e4(e10), n10 = this.div(t10), r10 = n10.mul(t10).sub(this);
            return n10.toString(e10) + r10.toInt().toString(e10);
          }
          return "-" + this.neg().toString(e10);
        }
        for (var a10 = e4(n4(e10, 6), this.unsigned), i10 = this, o10 = ""; ; ) {
          var s10 = i10.div(a10), u10 = (i10.sub(s10.mul(a10)).toInt() >>> 0).toString(e10);
          if ((i10 = s10).isZero()) return u10 + o10;
          for (; u10.length < 6; ) u10 = "0" + u10;
          o10 = "" + u10 + o10;
        }
      }, g4.getHighBits = function() {
        return this.high;
      }, g4.getHighBitsUnsigned = function() {
        return this.high >>> 0;
      }, g4.getLowBits = function() {
        return this.low;
      }, g4.getLowBitsUnsigned = function() {
        return this.low >>> 0;
      }, g4.getNumBitsAbs = function() {
        if (this.isNegative()) return this.eq(m4) ? 64 : this.neg().getNumBitsAbs();
        for (var e10 = 0 != this.high ? this.high : this.low, t10 = 31; t10 > 0 && 0 == (e10 & 1 << t10); t10--) ;
        return 0 != this.high ? t10 + 33 : t10 + 1;
      }, g4.isZero = function() {
        return 0 === this.high && 0 === this.low;
      }, g4.eqz = g4.isZero, g4.isNegative = function() {
        return !this.unsigned && this.high < 0;
      }, g4.isPositive = function() {
        return this.unsigned || this.high >= 0;
      }, g4.isOdd = function() {
        return 1 == (1 & this.low);
      }, g4.isEven = function() {
        return 0 == (1 & this.low);
      }, g4.equals = function(e10) {
        return J3(e10) || (e10 = a4(e10)), (this.unsigned === e10.unsigned || this.high >>> 31 != 1 || e10.high >>> 31 != 1) && (this.high === e10.high && this.low === e10.low);
      }, g4.eq = g4.equals, g4.notEquals = function(e10) {
        return !this.eq(e10);
      }, g4.neq = g4.notEquals, g4.ne = g4.notEquals, g4.lessThan = function(e10) {
        return this.comp(e10) < 0;
      }, g4.lt = g4.lessThan, g4.lessThanOrEqual = function(e10) {
        return this.comp(e10) <= 0;
      }, g4.lte = g4.lessThanOrEqual, g4.le = g4.lessThanOrEqual, g4.greaterThan = function(e10) {
        return this.comp(e10) > 0;
      }, g4.gt = g4.greaterThan, g4.greaterThanOrEqual = function(e10) {
        return this.comp(e10) >= 0;
      }, g4.gte = g4.greaterThanOrEqual, g4.ge = g4.greaterThanOrEqual, g4.compare = function(e10) {
        if (J3(e10) || (e10 = a4(e10)), this.eq(e10)) return 0;
        var t10 = this.isNegative(), n10 = e10.isNegative();
        return t10 && !n10 ? -1 : !t10 && n10 ? 1 : this.unsigned ? e10.high >>> 0 > this.high >>> 0 || e10.high === this.high && e10.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e10).isNegative() ? -1 : 1;
      }, g4.comp = g4.compare, g4.negate = function() {
        return !this.unsigned && this.eq(m4) ? m4 : this.not().add(h4);
      }, g4.neg = g4.negate, g4.add = function(e10) {
        J3(e10) || (e10 = a4(e10));
        var t10 = this.high >>> 16, n10 = 65535 & this.high, r10 = this.low >>> 16, a10 = 65535 & this.low, i10 = e10.high >>> 16, o10 = 65535 & e10.high, s10 = e10.low >>> 16, u10 = 0, c10 = 0, l10 = 0, h10 = 0;
        return l10 += (h10 += a10 + (65535 & e10.low)) >>> 16, c10 += (l10 += r10 + s10) >>> 16, u10 += (c10 += n10 + o10) >>> 16, u10 += t10 + i10, t4((l10 &= 65535) << 16 | (h10 &= 65535), (u10 &= 65535) << 16 | (c10 &= 65535), this.unsigned);
      }, g4.subtract = function(e10) {
        return J3(e10) || (e10 = a4(e10)), this.add(e10.neg());
      }, g4.sub = g4.subtract, g4.multiply = function(e10) {
        if (this.isZero()) return c4;
        if (J3(e10) || (e10 = a4(e10)), X3) return t4(X3.mul(this.low, this.high, e10.low, e10.high), X3.get_high(), this.unsigned);
        if (e10.isZero()) return c4;
        if (this.eq(m4)) return e10.isOdd() ? m4 : c4;
        if (e10.eq(m4)) return this.isOdd() ? m4 : c4;
        if (this.isNegative()) return e10.isNegative() ? this.neg().mul(e10.neg()) : this.neg().mul(e10).neg();
        if (e10.isNegative()) return this.mul(e10.neg()).neg();
        if (this.lt(u4) && e10.lt(u4)) return e4(this.toNumber() * e10.toNumber(), this.unsigned);
        var t10 = this.high >>> 16, n10 = 65535 & this.high, r10 = this.low >>> 16, a10 = 65535 & this.low, i10 = e10.high >>> 16, o10 = 65535 & e10.high, s10 = e10.low >>> 16, u10 = 65535 & e10.low, c10 = 0, l10 = 0, h10 = 0, p10 = 0;
        return h10 += (p10 += a10 * u10) >>> 16, l10 += (h10 += r10 * u10) >>> 16, h10 &= 65535, l10 += (h10 += a10 * s10) >>> 16, c10 += (l10 += n10 * u10) >>> 16, l10 &= 65535, c10 += (l10 += r10 * s10) >>> 16, l10 &= 65535, c10 += (l10 += a10 * o10) >>> 16, c10 += t10 * u10 + n10 * s10 + r10 * o10 + a10 * i10, t4((h10 &= 65535) << 16 | (p10 &= 65535), (c10 &= 65535) << 16 | (l10 &= 65535), this.unsigned);
      }, g4.mul = g4.multiply, g4.divide = function(e10) {
        if (J3(e10) || (e10 = a4(e10)), e10.isZero()) throw Error("division by zero");
        var t10, n10, r10;
        if (X3) return this.unsigned || -2147483648 !== this.high || -1 !== e10.low || -1 !== e10.high ? t4((this.unsigned ? X3.div_u : X3.div_s)(this.low, this.high, e10.low, e10.high), X3.get_high(), this.unsigned) : this;
        if (this.isZero()) return this.unsigned ? l4 : c4;
        if (this.unsigned) {
          if (e10.unsigned || (e10 = e10.toUnsigned()), e10.gt(this)) return l4;
          if (e10.gt(this.shru(1))) return p4;
          r10 = l4;
        } else {
          if (this.eq(m4)) return e10.eq(h4) || e10.eq(f4) ? m4 : e10.eq(m4) ? h4 : (t10 = this.shr(1).div(e10).shl(1)).eq(c4) ? e10.isNegative() ? h4 : f4 : (n10 = this.sub(e10.mul(t10)), r10 = t10.add(n10.div(e10)));
          if (e10.eq(m4)) return this.unsigned ? l4 : c4;
          if (this.isNegative()) return e10.isNegative() ? this.neg().div(e10.neg()) : this.neg().div(e10).neg();
          if (e10.isNegative()) return this.div(e10.neg()).neg();
          r10 = c4;
        }
        for (n10 = this; n10.gte(e10); ) {
          t10 = Math.max(1, Math.floor(n10.toNumber() / e10.toNumber()));
          for (var a10 = Math.ceil(Math.log(t10) / Math.LN2), i10 = a10 <= 48 ? 1 : n4(2, a10 - 48), o10 = e4(t10), s10 = o10.mul(e10); s10.isNegative() || s10.gt(n10); ) s10 = (o10 = e4(t10 -= i10, this.unsigned)).mul(e10);
          o10.isZero() && (o10 = h4), r10 = r10.add(o10), n10 = n10.sub(s10);
        }
        return r10;
      }, g4.div = g4.divide, g4.modulo = function(e10) {
        return J3(e10) || (e10 = a4(e10)), X3 ? t4((this.unsigned ? X3.rem_u : X3.rem_s)(this.low, this.high, e10.low, e10.high), X3.get_high(), this.unsigned) : this.sub(this.div(e10).mul(e10));
      }, g4.mod = g4.modulo, g4.rem = g4.modulo, g4.not = function() {
        return t4(~this.low, ~this.high, this.unsigned);
      }, g4.and = function(e10) {
        return J3(e10) || (e10 = a4(e10)), t4(this.low & e10.low, this.high & e10.high, this.unsigned);
      }, g4.or = function(e10) {
        return J3(e10) || (e10 = a4(e10)), t4(this.low | e10.low, this.high | e10.high, this.unsigned);
      }, g4.xor = function(e10) {
        return J3(e10) || (e10 = a4(e10)), t4(this.low ^ e10.low, this.high ^ e10.high, this.unsigned);
      }, g4.shiftLeft = function(e10) {
        return J3(e10) && (e10 = e10.toInt()), 0 == (e10 &= 63) ? this : e10 < 32 ? t4(this.low << e10, this.high << e10 | this.low >>> 32 - e10, this.unsigned) : t4(0, this.low << e10 - 32, this.unsigned);
      }, g4.shl = g4.shiftLeft, g4.shiftRight = function(e10) {
        return J3(e10) && (e10 = e10.toInt()), 0 == (e10 &= 63) ? this : e10 < 32 ? t4(this.low >>> e10 | this.high << 32 - e10, this.high >> e10, this.unsigned) : t4(this.high >> e10 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      }, g4.shr = g4.shiftRight, g4.shiftRightUnsigned = function(e10) {
        if (J3(e10) && (e10 = e10.toInt()), 0 === (e10 &= 63)) return this;
        var t10 = this.high;
        return e10 < 32 ? t4(this.low >>> e10 | t10 << 32 - e10, t10 >>> e10, this.unsigned) : t4(32 === e10 ? t10 : t10 >>> e10 - 32, 0, this.unsigned);
      }, g4.shru = g4.shiftRightUnsigned, g4.shr_u = g4.shiftRightUnsigned, g4.toSigned = function() {
        return this.unsigned ? t4(this.low, this.high, false) : this;
      }, g4.toUnsigned = function() {
        return this.unsigned ? this : t4(this.low, this.high, true);
      }, g4.toBytes = function(e10) {
        return e10 ? this.toBytesLE() : this.toBytesBE();
      }, g4.toBytesLE = function() {
        var e10 = this.high, t10 = this.low;
        return [255 & t10, t10 >>> 8 & 255, t10 >>> 16 & 255, t10 >>> 24, 255 & e10, e10 >>> 8 & 255, e10 >>> 16 & 255, e10 >>> 24];
      }, g4.toBytesBE = function() {
        var e10 = this.high, t10 = this.low;
        return [e10 >>> 24, e10 >>> 16 & 255, e10 >>> 8 & 255, 255 & e10, t10 >>> 24, t10 >>> 16 & 255, t10 >>> 8 & 255, 255 & t10];
      }, Y3.fromBytes = function(e10, t10, n10) {
        return n10 ? Y3.fromBytesLE(e10, t10) : Y3.fromBytesBE(e10, t10);
      }, Y3.fromBytesLE = function(e10, t10) {
        return new Y3(e10[0] | e10[1] << 8 | e10[2] << 16 | e10[3] << 24, e10[4] | e10[5] << 8 | e10[6] << 16 | e10[7] << 24, t10);
      }, Y3.fromBytesBE = function(e10, t10) {
        return new Y3(e10[4] << 24 | e10[5] << 16 | e10[6] << 8 | e10[7], e10[0] << 24 | e10[1] << 16 | e10[2] << 8 | e10[3], t10);
      };
      var y4 = r(K3), b4 = y4 || t({ __proto__: null, default: y4 }, [K3]);
      function x4(e10) {
        return b4.fromString(e10, true, 16);
      }
      var k4 = x4("c3a5c85c97cb3127"), w4 = x4("b492b66fbe98f273"), I4 = x4("9ae16a3b2f90404f");
      function N4(e10) {
        return e10.xor(e10.shru(47));
      }
      function S4(e10, t10, n10) {
        var r10 = e10.slice(t10, t10 + n10);
        return b4.fromBytes(Array.from(r10), true, true);
      }
      function T4(e10, t10) {
        return S4(e10, t10, 8);
      }
      function E4(e10, t10) {
        return S4(e10, t10, 4);
      }
      function C4(e10, t10) {
        return 0 === t10 ? e10 : e10.shru(t10).or(e10.shl(64 - t10));
      }
      function A4(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : x4("9ddfea08eb382d69"), r10 = e10.xor(t10).mul(n10);
        r10 = r10.xor(r10.shru(47));
        var a10 = t10.xor(r10).mul(n10);
        return a10 = (a10 = a10.xor(a10.shru(47))).mul(n10);
      }
      function R4(e10, t10, n10, r10) {
        return function(e11, t11, n11, r11, a10, i10) {
          a10 = a10.add(e11), i10 = C4(i10.add(a10).add(r11), 21);
          var o10 = a10;
          return a10 = (a10 = a10.add(t11)).add(n11), i10 = i10.add(C4(a10, 44)), [a10.add(r11), i10.add(o10)];
        }(T4(e10, t10), T4(e10, t10 + 8), T4(e10, t10 + 16), T4(e10, t10 + 24), n10, r10);
      }
      function _4(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e10.length;
        if (t10 >= 8) {
          var n10 = I4.add(2 * t10), r10 = T4(e10, 0).add(I4), a10 = T4(e10, t10 - 8), i10 = C4(a10, 37).mul(n10).add(r10), o10 = C4(r10, 25).add(a10).mul(n10);
          return A4(i10, o10, n10);
        }
        if (t10 >= 4) {
          var s10 = I4.add(2 * t10), u10 = E4(e10, 0);
          return A4(u10.shl(3).add(t10), E4(e10, t10 - 4), s10);
        }
        if (t10 > 0) {
          var c10 = e10[0], l10 = e10[t10 >> 1], h10 = e10[t10 - 1], p10 = c10 + (l10 << 8), f10 = t10 + (h10 << 2);
          return N4(I4.mul(p10).xor(k4.mul(f10))).mul(I4);
        }
        return I4;
      }
      function O4(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e10.length, n10 = I4.add(2 * t10), r10 = T4(e10, 0).mul(w4), a10 = T4(e10, 8), i10 = T4(e10, t10 - 8).mul(n10), o10 = T4(e10, t10 - 16).mul(I4);
        return A4(C4(r10.add(a10), 43).add(C4(i10, 30)).add(o10), r10.add(C4(a10.add(I4), 18)).add(i10), n10);
      }
      function F4(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e10.length, n10 = I4.add(2 * t10), r10 = T4(e10, 0).mul(I4), a10 = T4(e10, 8), i10 = T4(e10, t10 - 8).mul(n10), o10 = T4(e10, t10 - 16).mul(I4), s10 = C4(r10.add(a10), 43).add(C4(i10, 30)).add(o10), u10 = A4(s10, r10.add(C4(a10.add(I4), 18)).add(i10), n10), c10 = T4(e10, 16).mul(n10), l10 = T4(e10, 24), h10 = s10.add(T4(e10, t10 - 32)).mul(n10), p10 = u10.add(T4(e10, t10 - 24)).mul(n10);
        return A4(C4(c10.add(l10), 43).add(C4(h10, 30)).add(p10), c10.add(C4(l10.add(r10), 18)).add(h10), n10);
      }
      function D4(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e10.length, n10 = b4.fromNumber(81, true);
        if (t10 <= 32) return t10 <= 16 ? _4(e10, t10) : O4(e10, t10);
        if (t10 <= 64) return F4(e10, t10);
        var r10 = n10, a10 = n10.mul(w4).add(113), i10 = N4(a10.mul(I4).add(113)).mul(I4), o10 = [b4.UZERO, b4.UZERO], s10 = [b4.UZERO, b4.UZERO];
        r10 = r10.mul(I4).add(T4(e10, 0));
        var u10 = 0, c10 = 64 * (t10 - 1 >> 6), l10 = c10 + (t10 - 1 & 63) - 63;
        do {
          r10 = C4(r10.add(a10).add(o10[0]).add(T4(e10, u10 + 8)), 37).mul(w4), a10 = C4(a10.add(o10[1]).add(T4(e10, u10 + 48)), 42).mul(w4), r10 = r10.xor(s10[1]), a10 = a10.add(o10[0]).add(T4(e10, u10 + 40)), i10 = C4(i10.add(s10[0]), 33).mul(w4), o10 = R4(e10, u10, o10[1].mul(w4), r10.add(s10[0])), s10 = R4(e10, u10 + 32, i10.add(s10[1]), a10.add(T4(e10, u10 + 16)));
          var h10 = [r10, i10];
          i10 = h10[0], r10 = h10[1], u10 += 64;
        } while (u10 !== c10);
        var p10 = w4.add(i10.and(255).shl(1));
        u10 = l10, s10[0] = s10[0].add(t10 - 1 & 63), o10[0] = o10[0].add(s10[0]), s10[0] = s10[0].add(o10[0]), r10 = C4(r10.add(a10).add(o10[0]).add(T4(e10, u10 + 8)), 37).mul(p10), a10 = C4(a10.add(o10[1]).add(T4(e10, u10 + 48)), 42).mul(p10), r10 = r10.xor(s10[1].mul(9)), a10 = a10.add(o10[0].mul(9).add(T4(e10, u10 + 40))), i10 = C4(i10.add(s10[0]), 33).mul(p10), o10 = R4(e10, u10, o10[1].mul(p10), r10.add(s10[0])), s10 = R4(e10, u10 + 32, i10.add(s10[1]), a10.add(T4(e10, u10 + 16)));
        var f10 = [r10, i10];
        return i10 = f10[0], r10 = f10[1], A4(A4(o10[0], s10[0], p10).add(N4(a10).mul(k4)).add(i10), A4(o10[1], s10[1], p10).add(r10), p10);
      }
      function M4(e10, t10) {
        return "string" === t10 ? B4(e10) : L4([e10], t10);
      }
      function L4(e10, t10) {
        if ("string" === t10) throw new Error("Cannot convert a string[] to a TypedArray");
        if (Array.isArray(e10) && (e10 = V4(e10)), k0().getBool("DEBUG") && X$(e10, t10), function(e11, t11) {
          return e11 instanceof Float32Array && "float32" === t11 || e11 instanceof Int32Array && "int32" === t11 || e11 instanceof Uint8Array && "bool" === t11;
        }(e10, t10)) return e10;
        if (null == t10 || "float32" === t10 || "complex64" === t10) return new Float32Array(e10);
        if ("int32" === t10) return new Int32Array(e10);
        if ("bool" === t10) {
          for (var n10 = new Uint8Array(e10.length), r10 = 0; r10 < n10.length; ++r10) 0 !== Math.round(e10[r10]) && (n10[r10] = 1);
          return n10;
        }
        throw new Error("Unknown data type ".concat(t10));
      }
      function z4() {
        return k0().platform.now();
      }
      function P4(e10, t10) {
        return k0().platform.fetch(e10, t10);
      }
      function B4(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "utf-8";
        return t10 = t10 || "utf-8", k0().platform.encode(e10, t10);
      }
      function W4(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "utf-8";
        return t10 = t10 || "utf-8", k0().platform.decode(e10, t10);
      }
      function U4(e10) {
        return null != k0().platform.isTypedArray ? k0().platform.isTypedArray(e10) : q3(e10);
      }
      function V4(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if (null == t10 && (t10 = []), "boolean" == typeof e10 || "number" == typeof e10 || "string" == typeof e10 || v0(e10) || null == e10 || U4(e10) && n10) t10.push(e10);
        else if (Array.isArray(e10) || U4(e10)) for (var r10 = 0; r10 < e10.length; ++r10) V4(e10[r10], t10, n10);
        else {
          for (var a10 = -1, i10 = 0, o10 = Object.keys(e10); i10 < o10.length; i10++) {
            var s10 = o10[i10];
            /^([1-9]+[0-9]*|0)$/.test(s10) && (a10 = Math.max(a10, Number(s10)));
          }
          for (var u10 = 0; u10 <= a10; u10++) V4(e10[u10], t10, n10);
        }
        return t10;
      }
      var G4 = { __proto__: null, arraysEqual: P$, arraysEqualWithNull: z$, assert: F$, assertNonNegativeIntegerDimensions: p0, assertNonNull: M$, assertShapesMatch: D$, bytesFromStringArray: Q$, bytesPerElement: Z$, checkConversionForErrors: X$, clamp: A$, computeStrides: i0, convertBackendValuesAndArrayBuffer: u0, createScalarValue: M4, createShuffledIndices: function(e10) {
        for (var t10 = new Uint32Array(e10), n10 = 0; n10 < e10; ++n10) t10[n10] = n10;
        return C$(t10), t10;
      }, decodeString: W4, distSquared: function(e10, t10) {
        for (var n10 = 0, r10 = 0; r10 < e10.length; r10++) {
          var a10 = Number(e10[r10]) - Number(t10[r10]);
          n10 += a10 * a10;
        }
        return n10;
      }, encodeString: B4, fetch: P4, fingerPrint64: D4, flatten: V4, getArrayFromDType: K$, getTypedArrayFromDType: q$, hasEncodingLoss: J$, hexToLong: x4, indexToLoc: d0, inferDtype: n0, inferFromImplicitShape: G$, isBoolean: e0, isFunction: r0, isInt: B$, isNumber: t0, isPromise: v0, isScalarShape: function(e10) {
        return 0 === e10.length;
      }, isString: $$, isTypedArray: U4, isValidDtype: Y$, locToIndex: f0, makeOnesTypedArray: c0, makeZerosNestedTypedArray: h0, makeZerosTypedArray: l0, nearestDivisor: a0, nearestLargerEven: R$, now: z4, parseAxisParam: j$, randUniform: function(e10, t10) {
        var n10 = Math.random();
        return t10 * n10 + (1 - n10) * e10;
      }, repeatedTry: V$, rightPad: U$, shuffle: C$, shuffleCombo: function(e10, t10) {
        if (e10.length !== t10.length) throw new Error("Array sizes must match to be shuffled together " + "First array length was ".concat(e10.length) + "Second array length was ".concat(t10.length));
        for (var n10 = e10.length, r10 = 0; n10 > 0; ) r10 = Math.random() * n10 | 0, _$(e10, --n10, r10), _$(t10, n10, r10);
      }, sizeFromShape: L$, sizeToSquarishShape: W$, squeezeShape: H$, sum: O$, swap: _$, tanh: function(e10) {
        if (null != Math.tanh) return Math.tanh(e10);
        if (e10 === 1 / 0) return 1;
        if (e10 === -1 / 0) return -1;
        var t10 = Math.exp(2 * e10);
        return (t10 - 1) / (t10 + 1);
      }, toNestedArray: s0, toTypedArray: L4 }, j4 = function() {
        function e10(t10, n10) {
          l(this, e10), this.backendTimer = t10, this.logger = n10, null == n10 && (this.logger = new H4());
        }
        return p(e10, [{ key: "profileKernel", value: function(e11, t10, n10) {
          var r10, a10, i10 = function() {
            r10 = n10();
          }, o10 = z4();
          if (this.backendTimer.timerAvailable()) a10 = this.backendTimer.time(i10);
          else {
            i10();
            var s10, u10 = O(r10);
            try {
              for (u10.s(); !(s10 = u10.n()).done; ) {
                s10.value.dataSync();
              }
            } catch (e12) {
              u10.e(e12);
            } finally {
              u10.f();
            }
            a10 = Promise.resolve({ kernelMs: z4() - o10 });
          }
          if (k0().getBool("CHECK_COMPUTATION_FOR_ERRORS")) for (var c10 = function() {
            var t11 = r10[l10];
            t11.data().then(function(n11) {
              !function(e12, t12, n12) {
                if ("float32" !== t12) return false;
                for (var r11 = 0; r11 < e12.length; r11++) {
                  var a11 = e12[r11];
                  if (isNaN(a11) || !isFinite(a11)) return console.warn("Found ".concat(a11, " in the result of '").concat(n12, "'")), true;
                }
              }(n11, t11.dtype, e11);
            });
          }, l10 = 0; l10 < r10.length; l10++) c10();
          return { kernelName: e11, outputs: r10, inputs: t10, timeMs: a10.then(function(e12) {
            return e12.kernelMs;
          }), extraInfo: a10.then(function(e12) {
            return null != e12.getExtraProfileInfo ? e12.getExtraProfileInfo() : "";
          }) };
        } }, { key: "logKernelProfile", value: function(e11) {
          var t10 = this, n10 = e11.kernelName, r10 = e11.outputs, a10 = e11.timeMs, i10 = e11.inputs, o10 = e11.extraInfo;
          r10.forEach(function(e12) {
            Promise.all([e12.data(), a10, o10]).then(function(r11) {
              t10.logger.logKernelProfile(n10, e12, r11[0], r11[1], i10, r11[2]);
            });
          });
        } }]), e10;
      }();
      var H4 = function() {
        function e10() {
          l(this, e10);
        }
        return p(e10, [{ key: "logKernelProfile", value: function(e11, t10, n10, r10, a10, i10) {
          var o10 = "number" == typeof r10 ? U$("".concat(r10, "ms"), 9) : r10.error, s10 = U$(e11, 25), u10 = t10.rank, c10 = t10.size, l10 = U$(t10.shape.toString(), 14), h10 = "";
          for (var p10 in a10) {
            var f10 = a10[p10];
            if (null != f10) {
              var d10 = f10.shape || t10.shape, v10 = d10.length;
              h10 += "".concat(p10, ": ").concat(v10, "D ").concat(v10 > 0 ? d10 : "", " ");
            }
          }
          console.log("%c".concat(s10, "	%c").concat(o10, "	%c").concat(u10, "D ").concat(l10, "	%c").concat(c10, "	%c").concat(h10, "	%c").concat(i10), "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
        } }]), e10;
      }();
      function q4(e10, t10, n10) {
        for (var r10 = {}, a10 = {}, i10 = 0; i10 < t10.length; i10++) r10[t10[i10].id] = true;
        for (var o10 = 0; o10 < e10.length; o10++) {
          var s10 = e10[o10], u10 = s10.inputs;
          for (var c10 in u10) {
            for (var l10 = u10[c10], h10 = false, p10 = 0; p10 < t10.length; p10++) if (r10[l10.id]) {
              s10.outputs.forEach(function(e11) {
                return r10[e11.id] = true;
              }), h10 = true, a10[s10.id] = true;
              break;
            }
            if (h10) break;
          }
        }
        var f10 = {};
        f10[n10.id] = true;
        for (var d10 = {}, v10 = e10.length - 1; v10 >= 0; v10--) for (var m10 = e10[v10], g10 = m10.inputs, y10 = 0; y10 < m10.outputs.length; y10++) if (f10[m10.outputs[y10].id]) {
          for (var b10 in g10) f10[g10[b10].id] = true, d10[m10.id] = true;
          break;
        }
        for (var x10 = [], k10 = 0; k10 < e10.length; k10++) {
          var w10 = e10[k10];
          if (a10[w10.id] && d10[w10.id]) {
            var I10 = {};
            for (var N10 in w10.inputs) {
              var S10 = w10.inputs[N10];
              r10[S10.id] && (I10[N10] = S10);
            }
            var T10 = Object.assign({}, w10);
            T10.inputs = I10, T10.outputs = w10.outputs, x10.push(T10);
          }
        }
        return x10;
      }
      function K4(e10, t10, n10, r10) {
        for (var a10 = function() {
          var a11 = t10[i10], o10 = [];
          if (a11.outputs.forEach(function(t11) {
            var n11 = e10[t11.id];
            null != n11 ? o10.push(n11) : o10.push(null);
          }), null == a11.gradient) throw new Error("Cannot compute gradient: gradient function not found " + "for ".concat(a11.kernelName, "."));
          var s10 = a11.gradient(o10), u10 = function(t11) {
            if (!(t11 in s10)) throw new Error("Cannot backprop through input ".concat(t11, ". ") + "Available gradients found: ".concat(Object.keys(s10), "."));
            var i11 = n10(function() {
              return s10[t11]();
            });
            if ("float32" !== i11.dtype) throw new Error("Error in gradient for op ".concat(a11.kernelName, ". The gradient of input ") + "".concat(t11, " must have 'float32' dtype, but has '").concat(i11.dtype, "'"));
            var o11 = a11.inputs[t11];
            if (!P$(i11.shape, o11.shape)) throw new Error("Error in gradient for op ".concat(a11.kernelName, ". The gradient of input ") + "'".concat(t11, "' has shape '").concat(i11.shape, "', which does not match ") + "the shape of the input '".concat(o11.shape, "'"));
            if (null == e10[o11.id]) e10[o11.id] = i11;
            else {
              var u11 = e10[o11.id];
              e10[o11.id] = r10(u11, i11), u11.dispose();
            }
          };
          for (var c10 in a11.inputs) u10(c10);
        }, i10 = t10.length - 1; i10 >= 0; i10--) a10();
      }
      function X4(e10, t10, n10, r10) {
        var a10 = i0(t10), i10 = function(e11, t11, n11, r11) {
          var a11 = L$(t11), i11 = r11[r11.length - 1], o11 = new Array(i11).fill(0), s11 = t11.length, u11 = "complex64" === n11 ? Q4(e11) : e11;
          if (s11 > 1) for (var c10 = 0; c10 < a11 / i11; c10++) for (var l10 = c10 * i11, h10 = 0; h10 < i11; h10++) o11[h10] = Math.max(o11[h10], Y4(u11[l10 + h10], 0, n11).length);
          return o11;
        }(e10, t10, n10, a10), o10 = t10.length, s10 = Z4(e10, t10, n10, a10, i10), u10 = ["Tensor"];
        return r10 && (u10.push("  dtype: ".concat(n10)), u10.push("  rank: ".concat(o10)), u10.push("  shape: [".concat(t10, "]")), u10.push("  values:")), u10.push(s10.map(function(e11) {
          return "    " + e11;
        }).join("\n")), u10.join("\n");
      }
      function Y4(e10, t10, n10) {
        return U$(Array.isArray(e10) ? "".concat(parseFloat(e10[0].toFixed(7)), " + ") + "".concat(parseFloat(e10[1].toFixed(7)), "j") : $$(e10) ? "'".concat(e10, "'") : "bool" === n10 ? J4(e10) : parseFloat(e10.toFixed(7)).toString(), t10);
      }
      function J4(e10) {
        return 0 === e10 ? "false" : "true";
      }
      function Z4(e10, t10, n10, r10, a10) {
        var i10 = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5], o10 = "complex64" === n10 ? 2 : 1, s10 = t10[0], u10 = t10.length;
        if (0 === u10) {
          if ("complex64" === n10) {
            var c10 = Q4(e10);
            return [Y4(c10[0], 0, n10)];
          }
          return "bool" === n10 ? [J4(e10[0])] : [e10[0].toString()];
        }
        if (1 === u10) {
          if (s10 > 20) {
            var l10 = 3 * o10, h10 = Array.from(e10.slice(0, l10)), p10 = Array.from(e10.slice((s10 - 3) * o10, s10 * o10));
            return "complex64" === n10 && (h10 = Q4(h10), p10 = Q4(p10)), ["[" + h10.map(function(e11, t11) {
              return Y4(e11, a10[t11], n10);
            }).join(", ") + ", ..., " + p10.map(function(e11, t11) {
              return Y4(e11, a10[s10 - 3 + t11], n10);
            }).join(", ") + "]"];
          }
          var f10 = "complex64" === n10 ? Q4(e10) : Array.from(e10);
          return ["[" + f10.map(function(e11, t11) {
            return Y4(e11, a10[t11], n10);
          }).join(", ") + "]"];
        }
        var d10 = t10.slice(1), v10 = r10.slice(1), m10 = r10[0] * o10, g10 = [];
        if (s10 > 20) {
          for (var y10 = 0; y10 < 3; y10++) {
            var b10 = y10 * m10, x10 = b10 + m10;
            g10.push.apply(g10, T(Z4(e10.slice(b10, x10), d10, n10, v10, a10, false)));
          }
          g10.push("...");
          for (var k10 = s10 - 3; k10 < s10; k10++) {
            var w10 = k10 * m10, I10 = w10 + m10;
            g10.push.apply(g10, T(Z4(e10.slice(w10, I10), d10, n10, v10, a10, k10 === s10 - 1)));
          }
        } else for (var N10 = 0; N10 < s10; N10++) {
          var S10 = N10 * m10, E10 = S10 + m10;
          g10.push.apply(g10, T(Z4(e10.slice(S10, E10), d10, n10, v10, a10, N10 === s10 - 1)));
        }
        var C10 = 2 === u10 ? "," : "";
        g10[0] = "[" + (s10 > 0 ? g10[0] + C10 : "");
        for (var A10 = 1; A10 < g10.length - 1; A10++) g10[A10] = " " + g10[A10] + C10;
        for (var R10 = ",\n", _10 = 2; _10 < u10; _10++) R10 += "\n";
        return g10[g10.length - 1] = " " + g10[g10.length - 1] + "]" + (i10 ? "" : R10), g10;
      }
      function Q4(e10) {
        for (var t10 = [], n10 = 0; n10 < e10.length; n10 += 2) t10.push([e10[n10], e10[n10 + 1]]);
        return t10;
      }
      var $4 = function() {
        function e10(t10, n10, r10) {
          var a10 = this;
          if (l(this, e10), this.dtype = n10, this.shape = t10.slice(), this.size = L$(t10), null != r10) {
            var i10 = r10.length;
            F$(i10 === this.size, function() {
              return "Length of values '".concat(i10, "' does not match the size ") + "inferred by the shape '".concat(a10.size, "'.");
            });
          }
          if ("complex64" === n10) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
          this.values = r10 || K$(n10, this.size), this.strides = i0(t10);
        }
        return p(e10, [{ key: "set", value: function(e11) {
          for (var t10 = this, n10 = arguments.length, r10 = new Array(n10 > 1 ? n10 - 1 : 0), a10 = 1; a10 < n10; a10++) r10[a10 - 1] = arguments[a10];
          0 === r10.length && (r10 = [0]), F$(r10.length === this.rank, function() {
            return "The number of provided coordinates (".concat(r10.length, ") must ") + "match the rank (".concat(t10.rank, ")");
          });
          var i10 = this.locToIndex(r10);
          this.values[i10] = e11;
        } }, { key: "get", value: function() {
          for (var e11 = arguments.length, t10 = new Array(e11), n10 = 0; n10 < e11; n10++) t10[n10] = arguments[n10];
          0 === t10.length && (t10 = [0]);
          for (var r10 = 0, a10 = 0, i10 = t10; a10 < i10.length; a10++) {
            var o10 = i10[a10];
            if (o10 < 0 || o10 >= this.shape[r10]) {
              var s10 = "Requested out of range element at ".concat(t10, ". ") + "  Buffer shape=".concat(this.shape);
              throw new Error(s10);
            }
            r10++;
          }
          for (var u10 = t10[t10.length - 1], c10 = 0; c10 < t10.length - 1; ++c10) u10 += this.strides[c10] * t10[c10];
          return this.values[u10];
        } }, { key: "locToIndex", value: function(e11) {
          if (0 === this.rank) return 0;
          if (1 === this.rank) return e11[0];
          for (var t10 = e11[e11.length - 1], n10 = 0; n10 < e11.length - 1; ++n10) t10 += this.strides[n10] * e11[n10];
          return t10;
        } }, { key: "indexToLoc", value: function(e11) {
          if (0 === this.rank) return [];
          if (1 === this.rank) return [e11];
          for (var t10 = new Array(this.shape.length), n10 = 0; n10 < t10.length - 1; ++n10) t10[n10] = Math.floor(e11 / this.strides[n10]), e11 -= t10[n10] * this.strides[n10];
          return t10[t10.length - 1] = e11, t10;
        } }, { key: "rank", get: function() {
          return this.shape.length;
        } }, { key: "toTensor", value: function() {
          return e5().makeTensor(this.values, this.shape, this.dtype);
        } }]), e10;
      }(), e5 = null, t5 = null;
      var n5 = function() {
        function e10(t11, n11, r11, a11) {
          l(this, e10), this.kept = false, this.isDisposedInternal = false, this.shape = t11.slice(), this.dtype = n11 || "float32", this.size = L$(t11), this.strides = i0(t11), this.dataId = r11, this.id = a11, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
        }
        var t10, n10, r10, a10;
        return p(e10, [{ key: "rank", get: function() {
          return this.shape.length;
        } }, { key: "buffer", value: (a10 = c(o().mark(function e11() {
          var t11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.data();
              case 2:
                return t11 = e12.sent, e12.abrupt("return", t5.buffer(this.shape, this.dtype, t11));
              case 4:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return a10.apply(this, arguments);
        }) }, { key: "bufferSync", value: function() {
          return t5.buffer(this.shape, this.dtype, this.dataSync());
        } }, { key: "array", value: (r10 = c(o().mark(function e11() {
          var t11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.data();
              case 2:
                return t11 = e12.sent, e12.abrupt("return", s0(this.shape, t11, "complex64" === this.dtype));
              case 4:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return r10.apply(this, arguments);
        }) }, { key: "arraySync", value: function() {
          return s0(this.shape, this.dataSync(), "complex64" === this.dtype);
        } }, { key: "data", value: (n10 = c(o().mark(function e11() {
          var t11, n11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (this.throwIfDisposed(), t11 = e5().read(this.dataId), "string" !== this.dtype) {
                  e12.next = 13;
                  break;
                }
                return e12.next = 5, t11;
              case 5:
                return n11 = e12.sent, e12.prev = 6, e12.abrupt("return", n11.map(function(e13) {
                  return W4(e13);
                }));
              case 10:
                throw e12.prev = 10, e12.t0 = e12.catch(6), new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
              case 13:
                return e12.abrupt("return", t11);
              case 14:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[6, 10]]);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "dataToGPU", value: function(e11) {
          return this.throwIfDisposed(), e5().readToGPU(this.dataId, e11);
        } }, { key: "dataSync", value: function() {
          this.throwIfDisposed();
          var e11 = e5().readSync(this.dataId);
          if ("string" === this.dtype) try {
            return e11.map(function(e12) {
              return W4(e12);
            });
          } catch (e12) {
            throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
          }
          return e11;
        } }, { key: "bytes", value: (t10 = c(o().mark(function e11() {
          var t11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.throwIfDisposed(), e12.next = 3, e5().read(this.dataId);
              case 3:
                if (t11 = e12.sent, "string" !== this.dtype) {
                  e12.next = 8;
                  break;
                }
                return e12.abrupt("return", t11);
              case 8:
                return e12.abrupt("return", new Uint8Array(t11.buffer));
              case 9:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }, { key: "dispose", value: function() {
          this.isDisposed || (this.kerasMask && this.kerasMask.dispose(), e5().disposeTensor(this), this.isDisposedInternal = true);
        } }, { key: "isDisposed", get: function() {
          return this.isDisposedInternal;
        } }, { key: "throwIfDisposed", value: function() {
          if (this.isDisposed) throw new Error("Tensor is disposed.");
        } }, { key: "print", value: function() {
          var e11 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return t5.print(this, e11);
        } }, { key: "clone", value: function() {
          return this.throwIfDisposed(), t5.clone(this);
        } }, { key: "toString", value: function() {
          var e11 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t11 = this.dataSync();
          return X4(t11, this.shape, this.dtype, e11);
        } }, { key: "cast", value: function(e11) {
          return this.throwIfDisposed(), t5.cast(this, e11);
        } }, { key: "variable", value: function() {
          var e11 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], t11 = arguments.length > 1 ? arguments[1] : void 0, n11 = arguments.length > 2 ? arguments[2] : void 0;
          return this.throwIfDisposed(), e5().makeVariable(this, e11, t11, n11);
        } }]), e10;
      }();
      function r5() {
        return I0("Tensor", function() {
          return n5;
        });
      }
      Object.defineProperty(n5, Symbol.hasInstance, { value: function(e10) {
        return !!e10 && null != e10.data && null != e10.dataSync && null != e10.throwIfDisposed;
      } }), r5();
      var a5, i5, o5, s5, u5, c5 = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11, r10, a10, i10) {
          var o10;
          return l(this, n10), (o10 = t10.call(this, e11.shape, e11.dtype, e11.dataId, i10)).trainable = r10, o10.name = a10, o10;
        }
        return p(n10, [{ key: "assign", value: function(e11) {
          if (e11.dtype !== this.dtype) throw new Error("dtype of the new value (".concat(e11.dtype, ") and ") + "previous value (".concat(this.dtype, ") must match"));
          if (!P$(e11.shape, this.shape)) throw new Error("shape of the new value (".concat(e11.shape, ") and ") + "previous value (".concat(this.shape, ") must match"));
          e5().disposeTensor(this), this.dataId = e11.dataId, e5().incRef(this, null);
        } }, { key: "dispose", value: function() {
          e5().disposeVariable(this), this.isDisposedInternal = true;
        } }]), n10;
      }(n5);
      Object.defineProperty(c5, Symbol.hasInstance, { value: function(e10) {
        return e10 instanceof n5 && null != e10.assign && e10.assign instanceof Function;
      } }), e.Rank = void 0, (a5 = e.Rank || (e.Rank = {})).R0 = "R0", a5.R1 = "R1", a5.R2 = "R2", a5.R3 = "R3", a5.R4 = "R4", a5.R5 = "R5", a5.R6 = "R6", function(e10) {
        e10.float32 = "float32", e10.int32 = "int32", e10.bool = "int32", e10.complex64 = "complex64";
      }(i5 || (i5 = {})), function(e10) {
        e10.float32 = "float32", e10.int32 = "int32", e10.bool = "bool", e10.complex64 = "complex64";
      }(o5 || (o5 = {})), function(e10) {
        e10.float32 = "float32", e10.int32 = "float32", e10.bool = "float32", e10.complex64 = "complex64";
      }(s5 || (s5 = {})), function(e10) {
        e10.float32 = "complex64", e10.int32 = "complex64", e10.bool = "complex64", e10.complex64 = "complex64";
      }(u5 || (u5 = {}));
      var l5 = { float32: s5, int32: i5, bool: o5, complex64: u5 };
      function h5(e10, t10) {
        if ("string" === e10 || "string" === t10) {
          if ("string" === e10 && "string" === t10) return "string";
          throw new Error("Can not upcast ".concat(e10, " with ").concat(t10));
        }
        return l5[e10][t10];
      }
      function p5(e10) {
        return h5(e10, "int32");
      }
      function f5(e10) {
        return null != e10 && "object" === s(e10) && "texture" in e10 && e10.texture instanceof WebGLTexture;
      }
      function d5(e10) {
        return "undefined" != typeof GPUBuffer && null != e10 && "object" === s(e10) && "buffer" in e10 && e10.buffer instanceof GPUBuffer;
      }
      function v5(e10, t10) {
        if (e10.dtype === t10.dtype) return [e10, t10];
        var n10 = h5(e10.dtype, t10.dtype);
        return [e10.cast(n10), t10.cast(n10)];
      }
      function m5(e10, t10) {
        F$(e10.dtype === t10.dtype, function() {
          return "The dtypes of the first(".concat(e10.dtype, ") and") + " second(".concat(t10.dtype, ") input must match");
        });
      }
      function g5(e10, t10) {
        return t10.some(function(t11) {
          return t11.id === e10.id;
        });
      }
      function y5(e10) {
        var t10 = [];
        return b5(e10, t10, /* @__PURE__ */ new Set()), t10;
      }
      function b5(e10, t10, n10) {
        if (null != e10) {
          if (e10 instanceof n5) t10.push(e10);
          else if (r10 = e10, Array.isArray(r10) || "object" === s(r10)) {
            var r10, a10 = e10;
            for (var i10 in a10) {
              var o10 = a10[i10];
              n10.has(o10) || (n10.add(o10), b5(o10, t10, n10));
            }
          }
        }
      }
      var x5 = { __proto__: null, assertTypesMatch: m5, getTensorsInContainer: y5, isTensorInList: g5, makeTypesMatch: v5 };
      function k5(e10) {
        return null != e10.kernelName;
      }
      var w5 = function() {
        function e10() {
          l(this, e10), this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = /* @__PURE__ */ new WeakMap(), this.profiling = false, this.activeProfile = { newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null, get kernelNames() {
            return Array.from(new Set(this.kernels.map(function(e11) {
              return e11.name;
            })));
          } };
        }
        return p(e10, [{ key: "dispose", value: function() {
          for (var e11 in this.registeredVariables) this.registeredVariables[e11].dispose();
        } }]), e10;
      }(), I5 = function() {
        function e10(t11) {
          l(this, e10), this.ENV = t11, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new w5();
        }
        var t10, n10, r10, a10;
        return p(e10, [{ key: "ready", value: (a10 = c(o().mark(function e11() {
          var t11, n11, r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (null == this.pendingBackendInit) {
                  e12.next = 2;
                  break;
                }
                return e12.abrupt("return", this.pendingBackendInit.then(function() {
                }));
              case 2:
                if (null == this.backendInstance) {
                  e12.next = 4;
                  break;
                }
                return e12.abrupt("return");
              case 4:
                t11 = this.getSortedBackends(), n11 = 0;
              case 6:
                if (!(n11 < t11.length)) {
                  e12.next = 18;
                  break;
                }
                return r11 = t11[n11], e12.next = 10, this.initializeBackend(r11).success;
              case 10:
                if (!e12.sent) {
                  e12.next = 15;
                  break;
                }
                return e12.next = 14, this.setBackend(r11);
              case 14:
                return e12.abrupt("return");
              case 15:
                n11++, e12.next = 6;
                break;
              case 18:
                throw new Error("Could not initialize any backends, all backend initializations failed.");
              case 19:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return a10.apply(this, arguments);
        }) }, { key: "backend", get: function() {
          if (null != this.pendingBackendInit) throw new Error("Backend '".concat(this.backendName, "' has not yet been initialized. Make ") + "sure to await tf.ready() or await tf.setBackend() before calling other methods");
          if (null == this.backendInstance) {
            var e11 = this.initializeBackendsAndReturnBest(), t11 = e11.name;
            if (e11.asyncInit) throw new Error("The highest priority backend '".concat(t11, "' has not yet been ") + "initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
            this.setBackend(t11);
          }
          return this.backendInstance;
        } }, { key: "backendNames", value: function() {
          return Object.keys(this.registryFactory);
        } }, { key: "findBackend", value: function(e11) {
          if (!(e11 in this.registry)) {
            if (!(e11 in this.registryFactory)) return null;
            if (this.initializeBackend(e11).asyncInit) return null;
          }
          return this.registry[e11];
        } }, { key: "findBackendFactory", value: function(e11) {
          return e11 in this.registryFactory ? this.registryFactory[e11].factory : null;
        } }, { key: "registerBackend", value: function(e11, t11) {
          var n11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
          return e11 in this.registryFactory ? (z3("".concat(e11, " backend was already registered. ") + "Reusing existing backend factory."), false) : (this.registryFactory[e11] = { factory: t11, priority: n11 }, true);
        } }, { key: "setBackend", value: (r10 = c(o().mark(function e11(t11) {
          var n11, r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (null != this.registryFactory[t11]) {
                  e12.next = 2;
                  break;
                }
                throw new Error("Backend name '".concat(t11, "' not found in registry"));
              case 2:
                if (this.backendName = t11, null != this.registry[t11]) {
                  e12.next = 16;
                  break;
                }
                if (this.backendInstance = null, n11 = this.initializeBackend(t11), r11 = n11.success, !n11.asyncInit) {
                  e12.next = 12;
                  break;
                }
                return e12.next = 9, r11;
              case 9:
                e12.t0 = e12.sent, e12.next = 13;
                break;
              case 12:
                e12.t0 = r11;
              case 13:
                if (e12.t0) {
                  e12.next = 16;
                  break;
                }
                return e12.abrupt("return", false);
              case 16:
                return this.backendInstance = this.registry[t11], this.setupRegisteredKernels(), this.profiler = new j4(this.backendInstance), e12.abrupt("return", true);
              case 20:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return r10.apply(this, arguments);
        }) }, { key: "setupRegisteredKernels", value: function() {
          var e11 = this;
          V3(this.backendName).forEach(function(t11) {
            null != t11.setupFunc && t11.setupFunc(e11.backendInstance);
          });
        } }, { key: "disposeRegisteredKernels", value: function(e11) {
          var t11 = this;
          V3(e11).forEach(function(n11) {
            null != n11.disposeFunc && n11.disposeFunc(t11.registry[e11]);
          });
        } }, { key: "initializeBackend", value: function(e11) {
          var t11 = this, n11 = this.registryFactory[e11];
          if (null == n11) throw new Error("Cannot initialize backend ".concat(e11, ", no registration found."));
          try {
            var r11 = n11.factory();
            if (!r11 || r11 instanceof T$ || "function" != typeof r11.then) return this.registry[e11] = r11, { success: true, asyncInit: false };
            var a11 = ++this.pendingBackendInitId, i10 = r11.then(function(n12) {
              return !(a11 < t11.pendingBackendInitId) && (t11.registry[e11] = n12, t11.pendingBackendInit = null, true);
            }).catch(function(n12) {
              return a11 < t11.pendingBackendInitId || (t11.pendingBackendInit = null, z3("Initialization of backend ".concat(e11, " failed")), z3(n12.stack || n12.message)), false;
            });
            return this.pendingBackendInit = i10, { success: i10, asyncInit: true };
          } catch (t12) {
            return z3("Initialization of backend ".concat(e11, " failed")), z3(t12.stack || t12.message), { success: false, asyncInit: false };
          }
        } }, { key: "removeBackend", value: function(e11) {
          if (!(e11 in this.registryFactory)) throw new Error("".concat(e11, " backend not found in registry"));
          this.backendName === e11 && null != this.pendingBackendInit && this.pendingBackendInitId++, e11 in this.registry && (this.disposeRegisteredKernels(e11), this.registry[e11].dispose(), delete this.registry[e11]), delete this.registryFactory[e11], this.backendName === e11 && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
        } }, { key: "getSortedBackends", value: function() {
          var e11 = this;
          if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
          return Object.keys(this.registryFactory).sort(function(t11, n11) {
            return e11.registryFactory[n11].priority - e11.registryFactory[t11].priority;
          });
        } }, { key: "initializeBackendsAndReturnBest", value: function() {
          for (var e11 = this.getSortedBackends(), t11 = 0; t11 < e11.length; t11++) {
            var n11 = e11[t11], r11 = this.initializeBackend(n11), a11 = r11.success, i10 = r11.asyncInit;
            if (i10 || a11) return { name: n11, asyncInit: i10 };
          }
          throw new Error("Could not initialize any backends, all backend initializations failed.");
        } }, { key: "moveData", value: function(e11, t11) {
          var n11 = this.state.tensorInfo.get(t11), r11 = n11.backend, a11 = this.readSync(t11), i10 = r11.refCount(t11);
          r11.disposeData(t11, true), n11.backend = e11, e11.move(t11, a11, n11.shape, n11.dtype, i10), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
        } }, { key: "tidy", value: function(e11, t11) {
          var n11, r11 = this, a11 = null;
          if (null == t11) {
            if ("function" != typeof e11) throw new Error("Please provide a function to tidy()");
            t11 = e11;
          } else {
            if ("string" != typeof e11 && !(e11 instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
            if ("function" != typeof t11) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
            a11 = e11;
          }
          return this.scopedRun(function() {
            return r11.startScope(a11);
          }, function() {
            return r11.endScope(n11);
          }, function() {
            return (n11 = t11()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n11;
          });
        } }, { key: "scopedRun", value: function(e11, t11, n11) {
          e11();
          try {
            var r11 = n11();
            return t11(), r11;
          } catch (e12) {
            throw t11(), e12;
          }
        } }, { key: "nextTensorId", value: function() {
          return e10.nextTensorId++;
        } }, { key: "nextVariableId", value: function() {
          return e10.nextVariableId++;
        } }, { key: "clone", value: function(e11) {
          var t11 = E5.runKernel(W1, { x: e11 }), n11 = { x: e11 };
          return this.addTapeNode(this.state.activeScope.name, n11, [t11], function(e12) {
            return { x: function() {
              var t12 = { x: e12 }, n12 = { dtype: "float32" };
              return E5.runKernel(X0, t12, n12);
            } };
          }, [], {}), t11;
        } }, { key: "runKernel", value: function(e11, t11, n11) {
          if (null == this.backendName && this.backend, !(null != W3(e11, this.backendName))) throw new Error("Kernel '".concat(e11, "' not registered for backend '").concat(this.backendName, "'"));
          return this.runKernelFunc({ kernelName: e11, inputs: t11, attrs: n11 });
        } }, { key: "shouldCheckForMemLeaks", value: function() {
          return this.ENV.getBool("IS_TEST");
        } }, { key: "checkKernelForMemLeak", value: function(e11, t11, n11) {
          var r11 = this.backend.numDataIds(), a11 = 0;
          n11.forEach(function(e12) {
            a11 += "complex64" === e12.dtype ? 3 : 1;
          });
          var i10 = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], o10 = r11 - t11 - a11 - i10;
          if (o10 > 0) throw new Error("Backend '".concat(this.backendName, "' has an internal memory leak ") + "(".concat(o10, " data ids) after running '").concat(e11, "'"));
        } }, { key: "runKernelFunc", value: function(e11) {
          var t11, n11, r11, a11 = this, i10 = [], o10 = this.isTapeOn(), s10 = this.state.numBytes, u10 = this.state.numTensors;
          this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0), null == this.backendName && this.backend;
          var c10 = k5(e11) ? e11.kernelName : null != this.state.activeScope ? this.state.activeScope.name : "";
          if (k5(e11)) {
            var l10 = e11.kernelName, h10 = e11.inputs, p10 = e11.attrs;
            null == this.backendName && this.backend;
            var f10 = W3(l10, this.backendName);
            F$(null != f10, function() {
              return "Cannot find registered kernel '".concat(l10, "' for backend '").concat(a11.backendName, "'");
            }), n11 = function() {
              var e12 = a11.backend.numDataIds();
              r11 = f10.kernelFunc({ inputs: h10, attrs: p10, backend: a11.backend });
              var t12 = Array.isArray(r11) ? r11 : [r11];
              a11.shouldCheckForMemLeaks() && a11.checkKernelForMemLeak(l10, e12, t12);
              var n12 = t12.map(function(e13) {
                return null != e13.rank ? e13 : a11.makeTensorFromTensorInfo(e13);
              });
              if (o10) {
                var s11 = a11.getTensorsForGradient(l10, h10, n12);
                i10 = a11.saveTensorsForBackwardMode(s11);
              }
              return n12;
            };
          } else {
            var d10 = e11.forwardFunc, v10 = function(e12) {
              o10 && (i10 = e12.map(function(e13) {
                return a11.keep(a11.clone(e13));
              }));
            };
            n11 = function() {
              var e12 = a11.backend.numDataIds();
              r11 = a11.tidy(function() {
                return d10(a11.backend, v10);
              });
              var t12 = Array.isArray(r11) ? r11 : [r11];
              return a11.shouldCheckForMemLeaks() && a11.checkKernelForMemLeak(c10, e12, t12), t12;
            };
          }
          var m10, g10 = e11.inputs, y10 = e11.attrs, b10 = k5(e11) ? null : e11.backwardsFunc;
          return this.scopedRun(function() {
            return a11.state.kernelDepth++;
          }, function() {
            return a11.state.kernelDepth--;
          }, function() {
            a11.ENV.getBool("DEBUG") || a11.state.profiling ? (m10 = a11.profiler.profileKernel(c10, g10, function() {
              return n11();
            }), a11.ENV.getBool("DEBUG") && a11.profiler.logKernelProfile(m10), t11 = m10.outputs) : t11 = n11();
          }), o10 && this.addTapeNode(c10, g10, t11, b10, i10, y10), this.state.profiling && this.state.activeProfile.kernels.push({ name: c10, bytesAdded: this.state.numBytes - s10, totalBytesSnapshot: this.state.numBytes, tensorsAdded: this.state.numTensors - u10, totalTensorsSnapshot: this.state.numTensors, inputShapes: Object.keys(g10).map(function(e12) {
            return null != g10[e12] ? g10[e12].shape : null;
          }), outputShapes: t11.map(function(e12) {
            return e12.shape;
          }), kernelTimeMs: m10.timeMs, extraInfo: m10.extraInfo }), Array.isArray(r11) ? t11 : t11[0];
        } }, { key: "saveTensorsForBackwardMode", value: function(e11) {
          var t11 = this, n11 = e11.map(function(e12) {
            return t11.keep(t11.clone(e12));
          });
          return n11;
        } }, { key: "getTensorsForGradient", value: function(e11, t11, n11) {
          var r11 = U3(e11);
          if (null != r11) {
            var a11, i10 = r11.inputsToSave || [], o10 = r11.outputsToSave || [];
            r11.saveAllInputs ? (F$(Array.isArray(t11), function() {
              return "saveAllInputs is true, expected inputs to be an array.";
            }), a11 = Object.keys(t11).map(function(e12) {
              return t11[e12];
            })) : a11 = i10.map(function(e12) {
              return t11[e12];
            });
            var s10 = n11.filter(function(e12, t12) {
              return o10[t12];
            });
            return a11.concat(s10);
          }
          return [];
        } }, { key: "makeTensor", value: function(e11, t11, n11, r11) {
          if (null == e11) throw new Error("Values passed to engine.makeTensor() are null");
          n11 = n11 || "float32", r11 = r11 || this.backend;
          var a11 = e11;
          "string" === n11 && $$(e11[0]) && (a11 = e11.map(function(e12) {
            return B4(e12);
          }));
          var i10 = r11.write(a11, t11, n11), o10 = new n5(t11, n11, i10, this.nextTensorId());
          if (this.trackTensor(o10, r11), "string" === n11) {
            var s10 = this.state.tensorInfo.get(i10), u10 = Q$(a11);
            this.state.numBytes += u10 - s10.bytes, s10.bytes = u10;
          }
          return o10;
        } }, { key: "makeTensorFromDataId", value: function(e11, t11, n11, r11) {
          var a11 = { dataId: e11, shape: t11, dtype: n11 = n11 || "float32" };
          return this.makeTensorFromTensorInfo(a11, r11);
        } }, { key: "makeTensorFromTensorInfo", value: function(e11, t11) {
          var n11 = e11.dataId, r11 = e11.shape, a11 = e11.dtype, i10 = new n5(r11, a11, n11, this.nextTensorId());
          return this.trackTensor(i10, t11), i10;
        } }, { key: "makeVariable", value: function(e11) {
          var t11 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n11 = arguments.length > 2 ? arguments[2] : void 0, r11 = arguments.length > 3 ? arguments[3] : void 0;
          n11 = n11 || this.nextVariableId().toString(), null != r11 && r11 !== e11.dtype && (e11 = e11.cast(r11));
          var a11 = new c5(e11, t11, n11, this.nextTensorId());
          if (null != this.state.registeredVariables[a11.name]) throw new Error("Variable with name ".concat(a11.name, " was already registered"));
          return this.state.registeredVariables[a11.name] = a11, this.incRef(a11, this.backend), a11;
        } }, { key: "trackTensor", value: function(e11, t11) {
          this.state.numTensors++, "string" === e11.dtype && this.state.numStringTensors++;
          var n11 = 0;
          "complex64" !== e11.dtype && "string" !== e11.dtype && (n11 = e11.size * Z$(e11.dtype)), this.state.numBytes += n11, this.state.tensorInfo.has(e11.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(e11.dataId, { backend: t11 || this.backend, dtype: e11.dtype, shape: e11.shape, bytes: n11 })), e11 instanceof c5 || this.track(e11);
        } }, { key: "incRef", value: function(e11, t11) {
          this.trackTensor(e11, t11), this.backend.incRef(e11.dataId);
        } }, { key: "removeDataId", value: function(e11, t11) {
          this.state.tensorInfo.has(e11) && this.state.tensorInfo.get(e11).backend === t11 && (this.state.tensorInfo.delete(e11), this.state.numDataBuffers--);
        } }, { key: "disposeTensor", value: function(e11) {
          if (this.state.tensorInfo.has(e11.dataId)) {
            var t11 = this.state.tensorInfo.get(e11.dataId);
            if (this.state.numTensors--, "string" === e11.dtype && (this.state.numStringTensors--, this.state.numBytes -= t11.bytes), "complex64" !== e11.dtype && "string" !== e11.dtype) {
              var n11 = e11.size * Z$(e11.dtype);
              this.state.numBytes -= n11;
            }
            t11.backend.disposeData(e11.dataId) && this.removeDataId(e11.dataId, t11.backend);
          }
        } }, { key: "disposeVariables", value: function() {
          for (var e11 in this.state.registeredVariables) {
            var t11 = this.state.registeredVariables[e11];
            this.disposeVariable(t11);
          }
        } }, { key: "disposeVariable", value: function(e11) {
          this.disposeTensor(e11), null != this.state.registeredVariables[e11.name] && delete this.state.registeredVariables[e11.name];
        } }, { key: "memory", value: function() {
          var e11 = this.backend.memory();
          return e11.numTensors = this.state.numTensors, e11.numDataBuffers = this.state.numDataBuffers, e11.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e11.unreliable = true, null == e11.reasons && (e11.reasons = []), e11.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e11;
        } }, { key: "profile", value: (n10 = c(o().mark(function e11(t11) {
          var n11, r11, a11, i10, s10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.state.profiling = true, n11 = this.state.numBytes, r11 = this.state.numTensors, this.state.activeProfile.kernels = [], e12.next = 6, t11();
              case 6:
                this.state.activeProfile.result = e12.sent, this.state.profiling = false, this.state.activeProfile.peakBytes = Math.max.apply(Math, T(this.state.activeProfile.kernels.map(function(e13) {
                  return e13.totalBytesSnapshot;
                }))), this.state.activeProfile.newBytes = this.state.numBytes - n11, this.state.activeProfile.newTensors = this.state.numTensors - r11, a11 = O(this.state.activeProfile.kernels), e12.prev = 12, a11.s();
              case 14:
                if ((i10 = a11.n()).done) {
                  e12.next = 24;
                  break;
                }
                return s10 = i10.value, e12.next = 18, s10.kernelTimeMs;
              case 18:
                return s10.kernelTimeMs = e12.sent, e12.next = 21, s10.extraInfo;
              case 21:
                s10.extraInfo = e12.sent;
              case 22:
                e12.next = 14;
                break;
              case 24:
                e12.next = 29;
                break;
              case 26:
                e12.prev = 26, e12.t0 = e12.catch(12), a11.e(e12.t0);
              case 29:
                return e12.prev = 29, a11.f(), e12.finish(29);
              case 32:
                return e12.abrupt("return", this.state.activeProfile);
              case 33:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[12, 26, 29, 32]]);
        })), function(e11) {
          return n10.apply(this, arguments);
        }) }, { key: "isTapeOn", value: function() {
          return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
        } }, { key: "addTapeNode", value: function(e11, t11, n11, r11, a11, i10) {
          var o10 = this, s10 = { id: this.state.nextTapeNodeId++, kernelName: e11, inputs: t11, outputs: n11, saved: a11 }, u10 = U3(e11);
          null != u10 && (r11 = u10.gradFunc), null != r11 && (s10.gradient = function(e12) {
            return e12 = e12.map(function(e13, t12) {
              if (null == e13) {
                var r12 = n11[t12], a12 = l0(r12.size, r12.dtype);
                return o10.makeTensor(a12, r12.shape, r12.dtype);
              }
              return e13;
            }), r11(e12.length > 1 ? e12 : e12[0], a11, i10);
          }), this.state.activeTape.push(s10);
        } }, { key: "keep", value: function(e11) {
          return e11.kept = true, e11;
        } }, { key: "startTape", value: function() {
          0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
        } }, { key: "endTape", value: function() {
          this.state.gradientDepth--;
        } }, { key: "startScope", value: function(e11) {
          var t11 = { track: [], name: "unnamed scope", id: this.state.nextScopeId++ };
          e11 && (t11.name = e11), this.state.scopeStack.push(t11), this.state.activeScope = t11;
        } }, { key: "endScope", value: function(e11) {
          for (var t11 = this, n11 = y5(e11), r11 = new Set(n11.map(function(e12) {
            return e12.id;
          })), a11 = 0; a11 < this.state.activeScope.track.length; a11++) {
            var i10 = this.state.activeScope.track[a11];
            i10.kept || r11.has(i10.id) || i10.dispose();
          }
          var o10 = this.state.scopeStack.pop();
          this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n11.forEach(function(e12) {
            e12.kept || e12.scopeId !== o10.id || t11.track(e12);
          });
        } }, { key: "gradients", value: function(e11, t11, n11) {
          var r11 = this, a11 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
          if (F$(t11.length > 0, function() {
            return "gradients() received an empty list of xs.";
          }), null != n11 && "float32" !== n11.dtype) throw new Error("dy must have 'float32' dtype, but has '".concat(n11.dtype, "'"));
          var i10 = this.scopedRun(function() {
            return r11.startTape();
          }, function() {
            return r11.endTape();
          }, function() {
            return r11.tidy("forward", e11);
          });
          F$(i10 instanceof n5, function() {
            return "The result y returned by f() must be a tensor.";
          });
          var o10 = q4(this.state.activeTape, t11, i10);
          if (!a11 && 0 === o10.length && t11.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
          return this.tidy("backward", function() {
            var e12 = {};
            e12[i10.id] = null == n11 ? N5(i10.shape) : n11, K4(e12, o10, function(e13) {
              return r11.tidy(e13);
            }, C5);
            var a12 = t11.map(function(t12) {
              return e12[t12.id];
            });
            return 0 === r11.state.gradientDepth && (r11.state.activeTape.forEach(function(e13) {
              var t12, n12 = O(e13.saved);
              try {
                for (n12.s(); !(t12 = n12.n()).done; ) {
                  t12.value.dispose();
                }
              } catch (e14) {
                n12.e(e14);
              } finally {
                n12.f();
              }
            }), r11.state.activeTape = null), { value: i10, grads: a12 };
          });
        } }, { key: "customGrad", value: function(e11) {
          var t11 = this;
          return F$(r0(e11), function() {
            return "The f passed in customGrad(f) must be a function.";
          }), function() {
            for (var n11 = arguments.length, r11 = new Array(n11), a11 = 0; a11 < n11; a11++) r11[a11] = arguments[a11];
            var i10;
            F$(r11.every(function(e12) {
              return e12 instanceof n5;
            }), function() {
              return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
            });
            var o10 = {};
            r11.forEach(function(e12, t12) {
              o10[t12] = e12;
            });
            var s10 = function(t12, n12) {
              return F$((i10 = e11.apply(void 0, [].concat(r11, [n12]))).value instanceof n5, function() {
                return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
              }), F$(r0(i10.gradFunc), function() {
                return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
              }), i10.value;
            }, u10 = function(e12, t12) {
              var n12 = i10.gradFunc(e12, t12), a12 = Array.isArray(n12) ? n12 : [n12];
              F$(a12.length === r11.length, function() {
                return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
              }), F$(a12.every(function(e13) {
                return e13 instanceof n5;
              }), function() {
                return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
              });
              var o11 = {};
              return a12.forEach(function(e13, t13) {
                o11[t13] = function() {
                  return e13;
                };
              }), o11;
            };
            return t11.runKernelFunc({ forwardFunc: s10, backwardsFunc: u10, inputs: o10 });
          };
        } }, { key: "readSync", value: function(e11) {
          return this.state.tensorInfo.get(e11).backend.readSync(e11);
        } }, { key: "read", value: function(e11) {
          return this.state.tensorInfo.get(e11).backend.read(e11);
        } }, { key: "readToGPU", value: function(e11, t11) {
          return this.state.tensorInfo.get(e11).backend.readToGPU(e11, t11);
        } }, { key: "time", value: (t10 = c(o().mark(function e11(t11) {
          var n11, r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return n11 = z4(), e12.next = 3, this.backend.time(t11);
              case 3:
                return (r11 = e12.sent).wallMs = z4() - n11, e12.abrupt("return", r11);
              case 6:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "track", value: function(e11) {
          return null != this.state.activeScope && (e11.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e11)), e11;
        } }, { key: "registeredVariables", get: function() {
          return this.state.registeredVariables;
        } }, { key: "reset", value: function() {
          for (var e11 in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new w5(), this.registry) this.disposeRegisteredKernels(e11), this.registry[e11].dispose(), delete this.registry[e11];
          this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
        } }]), e10;
      }();
      function N5(e10) {
        var t10 = c0(L$(e10), "float32");
        return E5.makeTensor(t10, e10, "float32");
      }
      function S5() {
        var t10 = w0();
        if (null == t10._tfengine) {
          var n10 = new y0(t10);
          t10._tfengine = new I5(n10);
        }
        return function(t11) {
          e.ENV = t11;
        }(t10._tfengine.ENV), e5 = function() {
          return t10._tfengine;
        }, t10._tfengine;
      }
      I5.nextTensorId = 0, I5.nextVariableId = 0;
      var T5, E5 = S5();
      function C5(e10, t10) {
        var n10 = { a: e10, b: t10 };
        return E5.runKernel(E0, n10);
      }
      function A5(e10) {
        if (void 0 !== T5) return T5;
        if (e10 || "undefined" != typeof navigator && null != navigator) {
          if (e10 || (e10 = navigator), "ReactNative" === e10.product) return true;
          var t10 = e10.userAgent || e10.vendor || ("undefined" != typeof window ? window.opera : "");
          if (!t10) {
            var n10 = e10;
            return n10.userAgentData && n10.userAgentData.mobile;
          }
          return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t10) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t10.substr(0, 4));
        }
        return false;
      }
      function R5() {
        return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope;
      }
      var _5 = { __proto__: null, isBrowser: R5, isMobile: A5, mockIsMobile: function(e10) {
        T5 = e10;
      } }, O5 = k0();
      function F5(e10, t10) {
        var n10 = e10;
        if (U4(e10)) return "string" === t10 ? [] : [e10.length];
        if (f5(e10)) {
          var r10 = e10.channels || "RGBA";
          return [e10.height, e10.width * r10.length];
        }
        if (d5(e10)) return [e10.buffer.size / (null == t10 ? 4 : Z$(t10))];
        if (!Array.isArray(e10)) return [];
        for (var a10 = []; Array.isArray(n10) || U4(n10) && "string" !== t10; ) a10.push(n10.length), n10 = n10[0];
        return Array.isArray(e10) && k0().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && D5(e10, a10, []), a10;
      }
      function D5(e10, t10, n10) {
        if (n10 = n10 || [], Array.isArray(e10) || U4(e10)) {
          F$(t10.length > 0, function() {
            return "Element arr[".concat(n10.join("]["), "] should be a primitive, ") + "but is an array of ".concat(e10.length, " elements");
          }), F$(e10.length === t10[0], function() {
            return "Element arr[".concat(n10.join("]["), "] should have ").concat(t10[0], " ") + "elements, but has ".concat(e10.length, " elements");
          });
          for (var r10 = t10.slice(1), a10 = 0; a10 < e10.length; ++a10) D5(e10[a10], r10, n10.concat(a10));
        } else F$(0 === t10.length, function() {
          return "Element arr[".concat(n10.join("]["), "] is a primitive, ") + "but should be an array/TypedArray of ".concat(t10[0], " elements");
        });
      }
      function M5(e10, t10, n10, r10) {
        if ("string_or_numeric" !== e10) {
          if (null == e10) throw new Error("Expected dtype cannot be null.");
          if ("numeric" !== e10 && e10 !== t10 || "numeric" === e10 && "string" === t10) throw new Error("Argument '".concat(n10, "' passed to '").concat(r10, "' must ") + "be ".concat(e10, " tensor, but got ").concat(t10, " tensor"));
        }
      }
      function L5(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "numeric";
        if (e10 instanceof r5()) return M5(r10, e10.dtype, t10, n10), e10;
        var a10 = n0(e10);
        if ("string" !== a10 && ["bool", "int32", "float32"].indexOf(r10) >= 0 && (a10 = r10), M5(r10, a10, t10, n10), null == e10 || !U4(e10) && !Array.isArray(e10) && "number" != typeof e10 && "boolean" != typeof e10 && "string" != typeof e10) {
          var i10 = null == e10 ? "null" : e10.constructor.name;
          throw new Error("Argument '".concat(t10, "' passed to '").concat(n10, "' must be a ") + "Tensor or TensorLike, but got '".concat(i10, "'"));
        }
        var o10 = F5(e10, a10);
        U4(e10) || Array.isArray(e10) || (e10 = [e10]);
        var s10 = true, u10 = "string" !== a10 ? L4(e10, a10) : V4(e10, [], s10);
        return E5.makeTensor(u10, o10, a10);
      }
      function z5(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "numeric";
        if (!Array.isArray(e10)) throw new Error("Argument ".concat(t10, " passed to ").concat(n10, " must be a ") + "`Tensor[]` or `TensorLike[]`");
        var a10 = e10;
        return a10.map(function(e11, a11) {
          return L5(e11, "".concat(t10, "[").concat(a11, "]"), n10, r10);
        });
      }
      O5.registerFlag("DEBUG", function() {
        return false;
      }, function(e10) {
        e10 && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
      }), O5.registerFlag("IS_BROWSER", function() {
        return R5();
      }), O5.registerFlag("IS_NODE", function() {
        return "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node;
      }), O5.registerFlag("IS_CHROME", function() {
        return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
      }), O5.registerFlag("IS_SAFARI", function() {
        return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor);
      }), O5.registerFlag("PROD", function() {
        return false;
      }), O5.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function() {
        return O5.getBool("DEBUG");
      }), O5.registerFlag("DEPRECATION_WARNINGS_ENABLED", function() {
        return true;
      }), O5.registerFlag("IS_TEST", function() {
        return false;
      }), O5.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", function() {
        return O5.getBool("DEBUG");
      }), O5.registerFlag("WRAP_TO_IMAGEBITMAP", function() {
        return false;
      }), O5.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", function() {
        return false;
      }), O5.registerFlag("USE_SETTIMEOUTCUSTOM", function() {
        return false;
      });
      var P5 = "__op";
      function B5(e10) {
        var t10 = Object.keys(e10);
        if (1 !== t10.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + "".concat(t10.length, " keys."));
        var n10 = t10[0], r10 = e10[n10];
        n10.endsWith("_") && (n10 = n10.substring(0, n10.length - 1)), n10 += P5;
        var a10 = function() {
          E5.startScope(n10);
          try {
            var e11 = r10.apply(void 0, arguments);
            return v0(e11) && console.error("Cannot return a Promise inside of tidy."), E5.endScope(e11), e11;
          } catch (e12) {
            throw E5.endScope(null), e12;
          }
        };
        return Object.defineProperty(a10, "name", { value: n10, configurable: true }), a10;
      }
      var W5 = B5({ complex_: function(e10, t10) {
        var n10 = L5(e10, "real", "complex"), r10 = L5(t10, "imag", "complex");
        D$(n10.shape, r10.shape, "real and imag shapes, ".concat(n10.shape, " and ").concat(r10.shape, ", ") + "must match in call to tf.complex().");
        var a10 = { real: n10, imag: r10 };
        return E5.runKernel(Z0, a10);
      } });
      function U5(e10, t10, n10, r10) {
        if (null == r10) r10 = n0(e10);
        else if ("complex64" === r10) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
        if (d5(e10) || f5(e10)) {
          if ("float32" !== r10 && "int32" !== r10) throw new Error("Creating tensor from GPU data only supports " + "'float32'|'int32' dtype, while the dtype is ".concat(r10, "."));
          return E5.backend.createTensorFromGPUData(e10, t10 || n10, r10);
        }
        if (!U4(e10) && !Array.isArray(e10) && "number" != typeof e10 && "boolean" != typeof e10 && "string" != typeof e10) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
        if (null != t10) {
          p0(t10);
          var a10 = L$(t10), i10 = L$(n10);
          F$(a10 === i10, function() {
            return "Based on the provided shape, [".concat(t10, "], the tensor should have ") + "".concat(a10, " values but has ").concat(i10);
          });
          for (var o10 = 0; o10 < n10.length; ++o10) {
            var s10 = n10[o10], u10 = o10 !== n10.length - 1 || s10 !== L$(t10.slice(o10));
            F$(n10[o10] === t10[o10] || !u10, function() {
              return "Error creating a new Tensor. Inferred shape " + "(".concat(n10, ") does not match the provided ") + "shape (".concat(t10, "). ");
            });
          }
        }
        return U4(e10) || Array.isArray(e10) || (e10 = [e10]), t10 = t10 || n10, e10 = "string" !== r10 ? L4(e10, r10) : V4(e10, [], true), E5.makeTensor(e10, t10, r10);
      }
      function V5(e10, t10, n10) {
        return U5(e10, t10, F5(e10, n10), n10);
      }
      var G5 = { float32: 4, float16: 2, int32: 4, uint16: 2, uint8: 1, bool: 1, complex64: 8 }, j5 = function() {
        function e10(t10) {
          if (l(this, e10), this.shards = [], this.previousShardIndex = 0, null != t10 && (t10 instanceof Array || (t10 = [t10]), 0 !== (t10 = t10.map(function(e11) {
            return U4(e11) ? e11.buffer : e11;
          })).length)) {
            this.bufferUniformSize = t10[0].byteLength;
            for (var n10 = 0, r10 = 0; r10 < t10.length; r10++) {
              var a10 = t10[r10];
              r10 !== t10.length - 1 && a10.byteLength !== this.bufferUniformSize && (this.bufferUniformSize = void 0);
              var i10 = n10 + a10.byteLength;
              this.shards.push({ buffer: a10, start: n10, end: i10 }), n10 = i10;
            }
            0 === this.shards.length && (this.byteLength = 0), this.byteLength = this.shards[this.shards.length - 1].end;
          }
        }
        return p(e10, [{ key: "slice", value: function() {
          var e11 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.byteLength;
          if (0 === this.shards.length) return new ArrayBuffer(0);
          if (e11 = isNaN(Number(e11)) ? 0 : e11, t10 = isNaN(Number(t10)) ? 0 : t10, e11 = Math.max(0, e11), (t10 = Math.min(this.byteLength, t10)) <= e11) return new ArrayBuffer(0);
          var n10 = this.findShardForByte(e11);
          if (-1 === n10) throw new Error("Could not find start shard for byte ".concat(e11));
          for (var r10 = t10 - e11, a10 = new ArrayBuffer(r10), i10 = new Uint8Array(a10), o10 = 0, s10 = n10; s10 < this.shards.length; s10++) {
            var u10 = this.shards[s10], c10 = e11 + o10, l10 = c10 - u10.start, h10 = o10, p10 = Math.min(t10, u10.end), f10 = p10 - u10.start, d10 = new Uint8Array(u10.buffer, l10, f10 - l10);
            if (i10.set(d10, h10), o10 += d10.length, t10 < u10.end) break;
          }
          return a10;
        } }, { key: "findShardForByte", value: function(e11) {
          if (0 === this.shards.length || e11 < 0 || e11 >= this.byteLength) return -1;
          if (null != this.bufferUniformSize) return this.previousShardIndex = Math.floor(e11 / this.bufferUniformSize), this.previousShardIndex;
          function t10(t11) {
            return e11 < t11.start ? -1 : e11 >= t11.end ? 1 : 0;
          }
          if (0 === t10(this.shards[this.previousShardIndex])) return this.previousShardIndex;
          var n10 = function(e12, t11) {
            var n11 = 0, r10 = e12.length;
            for (; n11 <= r10; ) {
              var a10 = Math.floor((r10 - n11) / 2) + n11, i10 = t11(e12[a10]);
              if (0 === i10) return a10;
              i10 < 0 ? r10 = a10 : n11 = a10 + 1;
            }
            return -1;
          }(this.shards, t10);
          return -1 === n10 ? -1 : (this.previousShardIndex = n10, this.previousShardIndex);
        } }], [{ key: "join", value: function(t10) {
          return new e10(t10).slice();
        } }]), e10;
      }();
      function H5(e10) {
        k0().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(e10 + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
      }
      function q5() {
        return E5;
      }
      function K5() {
        return E5.memory();
      }
      function X5(e10, t10) {
        return E5.tidy(e10, t10);
      }
      function Y5(e10) {
        y5(e10).forEach(function(e11) {
          return e11.dispose();
        });
      }
      function J5(e10) {
        return E5.keep(e10);
      }
      function Z5(e10) {
        return E5.setBackend(e10);
      }
      function Q5() {
        return E5.backendName;
      }
      function $5(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
        return E5.registerBackend(e10, t10, n10);
      }
      function e6() {
        return E5.backend;
      }
      function t6(e10, t10) {
        return n6.apply(this, arguments);
      }
      function n6() {
        return n6 = c(o().mark(function e10(t10, n10) {
          var r10, a10, i10, s10, u10, l10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                r10 = [], a10 = [], i10 = Array.isArray(t10) ? t10.map(function(e12) {
                  return e12.name;
                }) : Object.keys(t10), s10 = o().mark(function e12() {
                  var s11, l11, h10, p10;
                  return o().wrap(function(e13) {
                    for (; ; ) switch (e13.prev = e13.next) {
                      case 0:
                        if (s11 = i10[u10], "float32" === (l11 = Array.isArray(t10) ? t10[u10].tensor : t10[s11]).dtype || "int32" === l11.dtype || "bool" === l11.dtype || "string" === l11.dtype || "complex64" === l11.dtype) {
                          e13.next = 4;
                          break;
                        }
                        throw new Error("Unsupported dtype in weight '".concat(s11, "': ").concat(l11.dtype));
                      case 4:
                        h10 = { name: s11, shape: l11.shape, dtype: l11.dtype }, "string" === l11.dtype ? (p10 = new Promise(function() {
                          var e14 = c(o().mark(function e15(t11) {
                            var n11, r11, a11, i11, s12, u11, c10;
                            return o().wrap(function(e16) {
                              for (; ; ) switch (e16.prev = e16.next) {
                                case 0:
                                  return e16.next = 2, l11.bytes();
                                case 2:
                                  for (n11 = e16.sent, r11 = n11.reduce(function(e17, t12) {
                                    return e17 + t12.length;
                                  }, 0) + 4 * n11.length, a11 = new Uint8Array(r11), i11 = 0, s12 = 0; s12 < n11.length; s12++) u11 = n11[s12], c10 = new Uint8Array(new Uint32Array([u11.length]).buffer), a11.set(c10, i11), i11 += 4, a11.set(u11, i11), i11 += u11.length;
                                  t11(a11);
                                case 8:
                                case "end":
                                  return e16.stop();
                              }
                            }, e15);
                          }));
                          return function(t11) {
                            return e14.apply(this, arguments);
                          };
                        }()), a10.push(p10)) : a10.push(l11.data()), null != n10 && (h10.group = n10), r10.push(h10);
                      case 8:
                      case "end":
                        return e13.stop();
                    }
                  }, e12);
                }), u10 = 0;
              case 5:
                if (!(u10 < i10.length)) {
                  e11.next = 10;
                  break;
                }
                return e11.delegateYield(s10(), "t0", 7);
              case 7:
                ++u10, e11.next = 5;
                break;
              case 10:
                return e11.next = 12, Promise.all(a10);
              case 12:
                return l10 = e11.sent, e11.abrupt("return", { data: p6(l10), specs: r10 });
              case 14:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), n6.apply(this, arguments);
      }
      function r6(e10, t10) {
        var n10, r10 = new j5(e10), a10 = {}, i10 = 0, o10 = O(t10);
        try {
          for (o10.s(); !(n10 = o10.n()).done; ) {
            var s10 = n10.value, u10 = a6(s10, function(e11, t11) {
              return r10.slice(i10 + e11, i10 + t11);
            });
            a10[s10.name] = s6(s10, r10.slice(i10, i10 + u10)), i10 += u10;
          }
        } catch (e11) {
          o10.e(e11);
        } finally {
          o10.f();
        }
        return a10;
      }
      function a6(e10, t10) {
        var n10, r10 = L$(e10.shape);
        if ("quantization" in e10) {
          var a10 = e10.quantization;
          n10 = G5[a10.dtype];
        } else {
          if ("string" === e10.dtype) {
            for (var i10 = 0, o10 = 0; o10 < r10; o10++) i10 += 4 + new Uint32Array(t10(i10, i10 + 4))[0];
            return i10;
          }
          n10 = G5[e10.dtype];
        }
        return r10 * n10;
      }
      function i6(e10, t10) {
        return o6.apply(this, arguments);
      }
      function o6() {
        return o6 = c(o().mark(function e10(t10, n10) {
          var r10, a10, i10, s10, u10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                if (r10 = L$(t10.shape), !("quantization" in t10)) {
                  e11.next = 6;
                  break;
                }
                i10 = t10.quantization, a10 = G5[i10.dtype], e11.next = 25;
                break;
              case 6:
                if ("string" !== t10.dtype) {
                  e11.next = 24;
                  break;
                }
                s10 = 0, u10 = 0;
              case 9:
                if (!(u10 < r10)) {
                  e11.next = 21;
                  break;
                }
                return e11.t0 = s10, e11.t1 = 4, e11.t2 = Uint32Array, e11.next = 15, n10(s10, s10 + 4);
              case 15:
                e11.t3 = e11.sent, e11.t4 = new e11.t2(e11.t3)[0], s10 = e11.t0 += e11.t1 + e11.t4;
              case 18:
                u10++, e11.next = 9;
                break;
              case 21:
                return e11.abrupt("return", s10);
              case 24:
                a10 = G5[t10.dtype];
              case 25:
                return e11.abrupt("return", r10 * a10);
              case 26:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), o6.apply(this, arguments);
      }
      function s6(e10, t10) {
        var n10, r10, a10, i10, o10 = e10.name, s10 = e10.dtype, u10 = e10.shape, c10 = L$(u10), l10 = 0;
        if ("quantization" in e10) {
          var h10 = e10.quantization;
          if ("uint8" === h10.dtype || "uint16" === h10.dtype) {
            if (!("min" in h10) || !("scale" in h10)) throw new Error("Weight ".concat(e10.name, " with quantization ").concat(h10.dtype, " ") + "doesn't have corresponding metadata min and scale.");
          } else {
            if ("float16" !== h10.dtype) throw new Error("Weight ".concat(e10.name, " has unknown ") + "quantization dtype ".concat(h10.dtype, ". ") + "Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");
            if ("float32" !== s10) throw new Error("Weight ".concat(e10.name, " is quantized with ").concat(h10.dtype, " ") + "which only supports weights of type float32 not ".concat(s10, "."));
          }
          var p10 = G5[h10.dtype], f10 = "uint8" === h10.dtype ? new Uint8Array(t10) : new Uint16Array(t10);
          if ("float32" === s10) if ("uint8" === h10.dtype || "uint16" === h10.dtype) {
            n10 = new Float32Array(f10.length);
            for (var d10 = 0; d10 < f10.length; d10++) {
              var v10 = f10[d10];
              n10[d10] = v10 * h10.scale + h10.min;
            }
          } else {
            if ("float16" !== h10.dtype) throw new Error("Unsupported quantization type ".concat(h10.dtype, " ") + "for weight type float32.");
            var m10 = (r10 = function() {
              var e11 = function(e12) {
                for (var t12 = e12 << 13, n12 = 0; 0 == (8388608 & t12); ) n12 -= 8388608, t12 <<= 1;
                return (t12 &= -8388609) | (n12 += 947912704);
              }, t11 = new Uint32Array(2048);
              t11[0] = 0;
              for (var n11 = 1; n11 < 1024; n11++) t11[n11] = e11(n11);
              for (var r11 = 1024; r11 < 2048; r11++) t11[r11] = 939524096 + (r11 - 1024 << 13);
              return t11;
            }(), a10 = function() {
              var e11 = new Uint32Array(64);
              e11[0] = 0, e11[31] = 1199570944, e11[32] = 2147483648, e11[63] = 3347054592;
              for (var t11 = 1; t11 < 31; t11++) e11[t11] = t11 << 23;
              for (var n11 = 33; n11 < 63; n11++) e11[n11] = 2147483648 + (n11 - 32 << 23);
              return e11;
            }(), i10 = function() {
              for (var e11 = new Uint32Array(64), t11 = 0; t11 < 64; t11++) e11[t11] = 1024;
              return e11[0] = e11[32] = 0, e11;
            }(), function(e11) {
              for (var t11 = new ArrayBuffer(4 * e11.length), n11 = new Uint32Array(t11), o11 = 0; o11 < e11.length; o11++) {
                var s11 = e11[o11], u11 = r10[i10[s11 >> 10] + (1023 & s11)] + a10[s11 >> 10];
                n11[o11] = u11;
              }
              return new Float32Array(t11);
            });
            n10 = m10(f10);
          }
          else {
            if ("int32" !== s10) throw new Error("Unsupported dtype in weight '".concat(o10, "': ").concat(s10));
            if ("uint8" !== h10.dtype && "uint16" !== h10.dtype) throw new Error("Unsupported quantization type ".concat(h10.dtype, " ") + "for weight type int32.");
            n10 = new Int32Array(f10.length);
            for (var g10 = 0; g10 < f10.length; g10++) {
              var y10 = f10[g10];
              n10[g10] = Math.round(y10 * h10.scale + h10.min);
            }
          }
          l10 += c10 * p10;
        } else if ("string" === s10) {
          var b10 = L$(e10.shape);
          n10 = [];
          for (var x10 = 0; x10 < b10; x10++) {
            var k10 = new Uint32Array(t10.slice(l10, l10 + 4))[0];
            l10 += 4;
            var w10 = new Uint8Array(t10.slice(l10, l10 + k10));
            n10.push(w10), l10 += k10;
          }
        } else {
          var I10 = G5[s10];
          if ("float32" === s10) n10 = new Float32Array(t10);
          else if ("int32" === s10) n10 = new Int32Array(t10);
          else {
            if ("bool" !== s10) {
              if ("complex64" === s10) {
                n10 = new Float32Array(t10);
                for (var N10 = new Float32Array(n10.length / 2), S10 = new Float32Array(n10.length / 2), T10 = 0; T10 < N10.length; T10++) N10[T10] = n10[2 * T10], S10[T10] = n10[2 * T10 + 1];
                var E10 = V5(N10, u10, "float32"), C10 = V5(S10, u10, "float32"), A10 = W5(E10, C10);
                return E10.dispose(), C10.dispose(), A10;
              }
              throw new Error("Unsupported dtype in weight '".concat(o10, "': ").concat(s10));
            }
            n10 = new Uint8Array(t10);
          }
          l10 += c10 * I10;
        }
        return V5(n10, u10, s10);
      }
      function u6(e10, t10, n10) {
        return c6.apply(this, arguments);
      }
      function c6() {
        return c6 = c(o().mark(function e10(t10, n10, r10) {
          var a10, i10, s10, u10, c10, l10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                a10 = new Uint8Array(n10);
              case 1:
                if (!(a10.byteLength < r10)) {
                  e11.next = 16;
                  break;
                }
                return e11.next = 4, t10.read();
              case 4:
                if (i10 = e11.sent, s10 = i10.done, u10 = i10.value, !s10 || null != u10) {
                  e11.next = 10;
                  break;
                }
                throw c10 = r10 - a10.byteLength, new Error("Reader is done but ".concat(c10, " bytes are still expected"));
              case 10:
                (l10 = new Uint8Array(a10.length + u10.byteLength)).set(a10, 0), l10.set(new Uint8Array(u10), a10.length), a10 = l10, e11.next = 1;
                break;
              case 16:
                return e11.abrupt("return", a10.buffer);
              case 17:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), c6.apply(this, arguments);
      }
      function l6(e10, t10) {
        return h6.apply(this, arguments);
      }
      function h6() {
        return h6 = c(o().mark(function e10(t10, n10) {
          var r10, a10, i10, s10, u10, l10, h10, p10, f10, d10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                r10 = {}, a10 = t10.getReader(), i10 = new ArrayBuffer(0), s10 = O(n10), e11.prev = 4, s10.s();
              case 6:
                if ((u10 = s10.n()).done) {
                  e11.next = 21;
                  break;
                }
                return l10 = u10.value, e11.next = 10, i6(l10, function() {
                  var e12 = c(o().mark(function e13(t11, n11) {
                    return o().wrap(function(e14) {
                      for (; ; ) switch (e14.prev = e14.next) {
                        case 0:
                          return e14.next = 2, u6(a10, i10, n11);
                        case 2:
                          return i10 = e14.sent, e14.abrupt("return", i10.slice(t11, n11));
                        case 4:
                        case "end":
                          return e14.stop();
                      }
                    }, e13);
                  }));
                  return function(t11, n11) {
                    return e12.apply(this, arguments);
                  };
                }());
              case 10:
                return h10 = e11.sent, e11.next = 13, u6(a10, i10, h10);
              case 13:
                i10 = e11.sent, p10 = i10.slice(0, h10), i10 = i10.slice(h10), f10 = s6(l10, p10), r10[l10.name] = f10, "webgpu" === Q5() && "uploadToGPU" in (d10 = e6()) && L$(f10.shape) >= k0().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD") && d10.uploadToGPU(f10.dataId);
              case 19:
                e11.next = 6;
                break;
              case 21:
                e11.next = 26;
                break;
              case 23:
                e11.prev = 23, e11.t0 = e11.catch(4), s10.e(e11.t0);
              case 26:
                return e11.prev = 26, s10.f(), e11.finish(26);
              case 29:
                return e11.abrupt("return", r10);
              case 30:
              case "end":
                return e11.stop();
            }
          }, e10, null, [[4, 23, 26, 29]]);
        })), h6.apply(this, arguments);
      }
      function p6(e10) {
        if (null === e10) throw new Error("Invalid input value: ".concat(JSON.stringify(e10)));
        var t10 = 0, n10 = [];
        e10.forEach(function(e11) {
          if (t10 += e11.byteLength, n10.push(e11.byteLength === e11.buffer.byteLength ? e11 : new e11.constructor(e11)), !(e11 instanceof Float32Array || e11 instanceof Int32Array || e11 instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: ".concat(e11.constructor.name));
        });
        var r10 = new Uint8Array(t10), a10 = 0;
        return n10.forEach(function(e11) {
          r10.set(new Uint8Array(e11.buffer), a10), a10 += e11.byteLength;
        }), r10.buffer;
      }
      var f6 = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);
      function d6(e10) {
        return f6 ? Buffer.byteLength(e10, "utf8") : new Blob([e10]).size;
      }
      function v6(e10) {
        if (f6) return Buffer.from(e10).toString("base64");
        for (var t10 = new Uint8Array(e10), n10 = "", r10 = 0, a10 = t10.length; r10 < a10; r10++) n10 += String.fromCharCode(t10[r10]);
        return btoa(n10);
      }
      function m6(e10) {
        if (f6) {
          var t10 = Buffer.from(e10, "base64");
          return t10.buffer.slice(t10.byteOffset, t10.byteOffset + t10.byteLength);
        }
        for (var n10 = atob(e10), r10 = new Uint8Array(n10.length), a10 = 0; a10 < n10.length; ++a10) r10.set([n10.charCodeAt(a10)], a10);
        return r10.buffer;
      }
      function g6(e10) {
        return j5.join(e10);
      }
      function y6(e10) {
        for (e10 = e10.trim(); e10.endsWith("/"); ) e10 = e10.slice(0, e10.length - 1);
        var t10 = e10.split("/");
        return t10[t10.length - 1];
      }
      function b6(e10, t10) {
        var n10 = { modelTopology: e10.modelTopology, format: e10.format, generatedBy: e10.generatedBy, convertedBy: e10.convertedBy, weightsManifest: t10 };
        return null != e10.signature && (n10.signature = e10.signature), null != e10.userDefinedMetadata && (n10.userDefinedMetadata = e10.userDefinedMetadata), null != e10.modelInitializer && (n10.modelInitializer = e10.modelInitializer), null != e10.initializerSignature && (n10.initializerSignature = e10.initializerSignature), null != e10.trainingConfig && (n10.trainingConfig = e10.trainingConfig), n10;
      }
      function x6(e10, t10, n10) {
        var r10 = { modelTopology: e10.modelTopology, format: e10.format, generatedBy: e10.generatedBy, convertedBy: e10.convertedBy };
        if (null != e10.trainingConfig && (r10.trainingConfig = e10.trainingConfig), null != e10.weightsManifest) {
          if (!t10) throw new Error("modelJSON has weightsManifest but weightSpecs is null");
          if (!n10) throw new Error("modelJSON has weightsManifest but weightData is null");
          r10.weightSpecs = t10, r10.weightData = n10;
        }
        return null != e10.signature && (r10.signature = e10.signature), null != e10.userDefinedMetadata && (r10.userDefinedMetadata = e10.userDefinedMetadata), null != e10.modelInitializer && (r10.modelInitializer = e10.modelInitializer), null != e10.initializerSignature && (r10.initializerSignature = e10.initializerSignature), r10;
      }
      function k6(e10, t10) {
        return w6.apply(this, arguments);
      }
      function w6() {
        return w6 = c(o().mark(function e10(t10, n10) {
          var r10, a10, i10, s10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                if (null == t10.weightsManifest) {
                  e11.next = 7;
                  break;
                }
                return e11.next = 3, n10(t10.weightsManifest);
              case 3:
                i10 = e11.sent, s10 = S(i10, 2), r10 = s10[0], a10 = s10[1];
              case 7:
                return e11.abrupt("return", x6(t10, r10, a10));
              case 8:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), w6.apply(this, arguments);
      }
      function I6(e10) {
        if (e10.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
        return { dateSaved: /* @__PURE__ */ new Date(), modelTopologyType: "JSON", modelTopologyBytes: null == e10.modelTopology ? 0 : d6(JSON.stringify(e10.modelTopology)), weightSpecsBytes: null == e10.weightSpecs ? 0 : d6(JSON.stringify(e10.weightSpecs)), weightDataBytes: null == e10.weightData ? 0 : new j5(e10.weightData).byteLength };
      }
      function N6(e10) {
        var t10, n10 = [], r10 = O(e10);
        try {
          for (r10.s(); !(t10 = r10.n()).done; ) {
            var a10 = t10.value;
            n10.push.apply(n10, T(a10.weights));
          }
        } catch (e11) {
          r10.e(e11);
        } finally {
          r10.f();
        }
        return n10;
      }
      var S6 = function() {
        function e10() {
          l(this, e10), this.saveRouters = [], this.loadRouters = [];
        }
        return p(e10, null, [{ key: "getInstance", value: function() {
          return null == e10.instance && (e10.instance = new e10()), e10.instance;
        } }, { key: "registerSaveRouter", value: function(t10) {
          e10.getInstance().saveRouters.push(t10);
        } }, { key: "registerLoadRouter", value: function(t10) {
          e10.getInstance().loadRouters.push(t10);
        } }, { key: "getSaveHandlers", value: function(t10) {
          return e10.getHandlers(t10, "save");
        } }, { key: "getLoadHandlers", value: function(t10, n10) {
          return e10.getHandlers(t10, "load", n10);
        } }, { key: "getHandlers", value: function(t10, n10, r10) {
          var a10 = [];
          return ("load" === n10 ? e10.getInstance().loadRouters : e10.getInstance().saveRouters).forEach(function(e11) {
            var n11 = e11(t10, r10);
            null !== n11 && a10.push(n11);
          }), a10;
        } }]), e10;
      }(), T6 = function(e10) {
        return S6.getSaveHandlers(e10);
      }, E6 = function(e10, t10) {
        return S6.getLoadHandlers(e10, t10);
      }, C6 = "tensorflowjs", A6 = "models_store", R6 = "model_info_store";
      function _6() {
        if (!k0().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
        var e10 = "undefined" == typeof window ? self : window, t10 = e10.indexedDB || e10.mozIndexedDB || e10.webkitIndexedDB || e10.msIndexedDB || e10.shimIndexedDB;
        if (null == t10) throw new Error("The current browser does not appear to support IndexedDB.");
        return t10;
      }
      function O6(e10) {
        var t10 = e10.result;
        t10.createObjectStore(A6, { keyPath: "modelPath" }), t10.createObjectStore(R6, { keyPath: "modelPath" });
      }
      var F6 = function() {
        function e10(t11) {
          if (l(this, e10), this.indexedDB = _6(), null == t11 || !t11) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
          this.modelPath = t11;
        }
        var t10, n10;
        return p(e10, [{ key: "save", value: (n10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!(t11.modelTopology instanceof ArrayBuffer)) {
                  e12.next = 2;
                  break;
                }
                throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
              case 2:
                return e12.abrupt("return", this.databaseAction(this.modelPath, t11));
              case 3:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return n10.apply(this, arguments);
        }) }, { key: "load", value: (t10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.abrupt("return", this.databaseAction(this.modelPath));
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }, { key: "databaseAction", value: function(e11, t11) {
          var n11 = this;
          return new Promise(function(e12, r10) {
            var a10 = n11.indexedDB.open(C6, 1);
            a10.onupgradeneeded = function() {
              return O6(a10);
            }, a10.onsuccess = function() {
              var i10 = a10.result;
              if (null == t11) {
                var o10 = i10.transaction(A6, "readonly"), s10 = o10.objectStore(A6).get(n11.modelPath);
                s10.onsuccess = function() {
                  if (null == s10.result) return i10.close(), r10(new Error("Cannot find model with path '".concat(n11.modelPath, "' ") + "in IndexedDB."));
                  e12(s10.result.modelArtifacts);
                }, s10.onerror = function(e13) {
                  return i10.close(), r10(s10.error);
                }, o10.oncomplete = function() {
                  return i10.close();
                };
              } else {
                t11.weightData = j5.join(t11.weightData);
                var u10, c10, l10 = I6(t11), h10 = i10.transaction(R6, "readwrite"), p10 = h10.objectStore(R6);
                try {
                  u10 = p10.put({ modelPath: n11.modelPath, modelArtifactsInfo: l10 });
                } catch (e13) {
                  return r10(e13);
                }
                u10.onsuccess = function() {
                  var a11, o11 = (c10 = i10.transaction(A6, "readwrite")).objectStore(A6);
                  try {
                    a11 = o11.put({ modelPath: n11.modelPath, modelArtifacts: t11, modelArtifactsInfo: l10 });
                  } catch (e13) {
                    return r10(e13);
                  }
                  a11.onsuccess = function() {
                    return e12({ modelArtifactsInfo: l10 });
                  }, a11.onerror = function(e13) {
                    var t12 = (p10 = h10.objectStore(R6)).delete(n11.modelPath);
                    t12.onsuccess = function() {
                      return i10.close(), r10(a11.error);
                    }, t12.onerror = function(e14) {
                      return i10.close(), r10(a11.error);
                    };
                  };
                }, u10.onerror = function(e13) {
                  return i10.close(), r10(u10.error);
                }, h10.oncomplete = function() {
                  null == c10 ? i10.close() : c10.oncomplete = function() {
                    return i10.close();
                  };
                };
              }
            }, a10.onerror = function(e13) {
              return r10(a10.error);
            };
          });
        } }]), e10;
      }();
      F6.URL_SCHEME = "indexeddb://";
      var D6 = function(e10) {
        return k0().getBool("IS_BROWSER") && !Array.isArray(e10) && e10.startsWith(F6.URL_SCHEME) ? (t10 = e10.slice(F6.URL_SCHEME.length), new F6(t10)) : null;
        var t10;
      };
      function M6(e10) {
        return e10.startsWith(F6.URL_SCHEME) ? e10.slice(F6.URL_SCHEME.length) : e10;
      }
      S6.registerSaveRouter(D6), S6.registerLoadRouter(D6);
      var L6 = function() {
        function e10() {
          l(this, e10), this.indexedDB = _6();
        }
        return p(e10, [{ key: "listModels", value: function() {
          var e11 = c(o().mark(function e12() {
            var t10 = this;
            return o().wrap(function(e13) {
              for (; ; ) switch (e13.prev = e13.next) {
                case 0:
                  return e13.abrupt("return", new Promise(function(e14, n10) {
                    var r10 = t10.indexedDB.open(C6, 1);
                    r10.onupgradeneeded = function() {
                      return O6(r10);
                    }, r10.onsuccess = function() {
                      var t11 = r10.result, a10 = t11.transaction(R6, "readonly"), i10 = a10.objectStore(R6).getAll();
                      i10.onsuccess = function() {
                        var t12, n11 = {}, r11 = O(i10.result);
                        try {
                          for (r11.s(); !(t12 = r11.n()).done; ) {
                            var a11 = t12.value;
                            n11[a11.modelPath] = a11.modelArtifactsInfo;
                          }
                        } catch (e15) {
                          r11.e(e15);
                        } finally {
                          r11.f();
                        }
                        e14(n11);
                      }, i10.onerror = function(e15) {
                        return t11.close(), n10(i10.error);
                      }, a10.oncomplete = function() {
                        return t11.close();
                      };
                    }, r10.onerror = function(e15) {
                      return n10(r10.error);
                    };
                  }));
                case 1:
                case "end":
                  return e13.stop();
              }
            }, e12);
          }));
          return function() {
            return e11.apply(this, arguments);
          };
        }() }, { key: "removeModel", value: function() {
          var e11 = c(o().mark(function e12(t10) {
            var n10 = this;
            return o().wrap(function(e13) {
              for (; ; ) switch (e13.prev = e13.next) {
                case 0:
                  return t10 = M6(t10), e13.abrupt("return", new Promise(function(e14, r10) {
                    var a10 = n10.indexedDB.open(C6, 1);
                    a10.onupgradeneeded = function() {
                      return O6(a10);
                    }, a10.onsuccess = function() {
                      var n11, i10 = a10.result, o10 = i10.transaction(R6, "readwrite"), s10 = o10.objectStore(R6), u10 = s10.get(t10);
                      u10.onsuccess = function() {
                        if (null == u10.result) return i10.close(), r10(new Error("Cannot find model with path '".concat(t10, "' ") + "in IndexedDB."));
                        var a11 = s10.delete(t10), o11 = function() {
                          var a12 = (n11 = i10.transaction(A6, "readwrite")).objectStore(A6).delete(t10);
                          a12.onsuccess = function() {
                            return e14(u10.result.modelArtifactsInfo);
                          }, a12.onerror = function(e15) {
                            return r10(u10.error);
                          };
                        };
                        a11.onsuccess = o11, a11.onerror = function(e15) {
                          return o11(), i10.close(), r10(u10.error);
                        };
                      }, u10.onerror = function(e15) {
                        return i10.close(), r10(u10.error);
                      }, o10.oncomplete = function() {
                        null == n11 ? i10.close() : n11.oncomplete = function() {
                          return i10.close();
                        };
                      };
                    }, a10.onerror = function(e15) {
                      return r10(a10.error);
                    };
                  }));
                case 2:
                case "end":
                  return e13.stop();
              }
            }, e12);
          }));
          return function(t10) {
            return e11.apply(this, arguments);
          };
        }() }]), e10;
      }(), z6 = "/", P6 = "tensorflowjs_models", B6 = "info", W6 = "model_topology", U6 = "weight_specs", V6 = "weight_data", G6 = "model_metadata";
      function j6(e10) {
        return { info: [P6, e10, B6].join(z6), topology: [P6, e10, W6].join(z6), weightSpecs: [P6, e10, U6].join(z6), weightData: [P6, e10, V6].join(z6), modelMetadata: [P6, e10, G6].join(z6) };
      }
      function H6(e10) {
        for (var t10 = 0, n10 = Object.values(e10); t10 < n10.length; t10++) {
          var r10 = n10[t10];
          window.localStorage.removeItem(r10);
        }
      }
      function q6(e10) {
        var t10 = e10.split(z6);
        if (t10.length < 3) throw new Error("Invalid key format: ".concat(e10));
        return t10.slice(1, t10.length - 1).join(z6);
      }
      function K6(e10) {
        return e10.startsWith(X6.URL_SCHEME) ? e10.slice(X6.URL_SCHEME.length) : e10;
      }
      var X6 = function() {
        function e10(t11) {
          if (l(this, e10), !k0().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
          if (this.LS = window.localStorage, null == t11 || !t11) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
          this.modelPath = t11, this.keys = j6(this.modelPath);
        }
        var t10, n10;
        return p(e10, [{ key: "save", value: (n10 = c(o().mark(function e11(t11) {
          var n11, r10, a10, i10, s10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!(t11.modelTopology instanceof ArrayBuffer)) {
                  e12.next = 4;
                  break;
                }
                throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
              case 4:
                return n11 = JSON.stringify(t11.modelTopology), r10 = JSON.stringify(t11.weightSpecs), a10 = I6(t11), i10 = j5.join(t11.weightData), e12.prev = 8, this.LS.setItem(this.keys.info, JSON.stringify(a10)), this.LS.setItem(this.keys.topology, n11), this.LS.setItem(this.keys.weightSpecs, r10), this.LS.setItem(this.keys.weightData, v6(i10)), s10 = { format: t11.format, generatedBy: t11.generatedBy, convertedBy: t11.convertedBy, signature: null != t11.signature ? t11.signature : void 0, userDefinedMetadata: null != t11.userDefinedMetadata ? t11.userDefinedMetadata : void 0, modelInitializer: null != t11.modelInitializer ? t11.modelInitializer : void 0, initializerSignature: null != t11.initializerSignature ? t11.initializerSignature : void 0, trainingConfig: null != t11.trainingConfig ? t11.trainingConfig : void 0 }, this.LS.setItem(this.keys.modelMetadata, JSON.stringify(s10)), e12.abrupt("return", { modelArtifactsInfo: a10 });
              case 18:
                throw e12.prev = 18, e12.t0 = e12.catch(8), H6(this.keys), new Error("Failed to save model '".concat(this.modelPath, "' to local storage: ") + "size quota being exceeded is a possible cause of this failure: " + "modelTopologyBytes=".concat(a10.modelTopologyBytes, ", ") + "weightSpecsBytes=".concat(a10.weightSpecsBytes, ", ") + "weightDataBytes=".concat(a10.weightDataBytes, "."));
              case 22:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[8, 18]]);
        })), function(e11) {
          return n10.apply(this, arguments);
        }) }, { key: "load", value: (t10 = c(o().mark(function e11() {
          var t11, n11, r10, a10, i10, s10, u10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (null != (t11 = JSON.parse(this.LS.getItem(this.keys.info)))) {
                  e12.next = 3;
                  break;
                }
                throw new Error("In local storage, there is no model with name '".concat(this.modelPath, "'"));
              case 3:
                if ("JSON" === t11.modelTopologyType) {
                  e12.next = 5;
                  break;
                }
                throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
              case 5:
                if (n11 = {}, null != (r10 = JSON.parse(this.LS.getItem(this.keys.topology)))) {
                  e12.next = 9;
                  break;
                }
                throw new Error("In local storage, the topology of model '".concat(this.modelPath, "' ") + "is missing.");
              case 9:
                if (n11.modelTopology = r10, null != (a10 = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) {
                  e12.next = 13;
                  break;
                }
                throw new Error("In local storage, the weight specs of model '".concat(this.modelPath, "' ") + "are missing.");
              case 13:
                if (n11.weightSpecs = a10, null != (i10 = this.LS.getItem(this.keys.modelMetadata)) && (s10 = JSON.parse(i10), n11.format = s10.format, n11.generatedBy = s10.generatedBy, n11.convertedBy = s10.convertedBy, null != s10.signature && (n11.signature = s10.signature), null != s10.userDefinedMetadata && (n11.userDefinedMetadata = s10.userDefinedMetadata), null != s10.modelInitializer && (n11.modelInitializer = s10.modelInitializer), null != s10.initializerSignature && (n11.initializerSignature = s10.initializerSignature), null != s10.trainingConfig && (n11.trainingConfig = s10.trainingConfig)), null != (u10 = this.LS.getItem(this.keys.weightData))) {
                  e12.next = 19;
                  break;
                }
                throw new Error("In local storage, the binary weight values of model " + "'".concat(this.modelPath, "' are missing."));
              case 19:
                return n11.weightData = m6(u10), e12.abrupt("return", n11);
              case 21:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), e10;
      }();
      X6.URL_SCHEME = "localstorage://";
      var Y6 = function(e10) {
        return k0().getBool("IS_BROWSER") && !Array.isArray(e10) && e10.startsWith(X6.URL_SCHEME) ? (t10 = e10.slice(X6.URL_SCHEME.length), new X6(t10)) : null;
        var t10;
      };
      S6.registerSaveRouter(Y6), S6.registerLoadRouter(Y6);
      var J6 = function() {
        function e10() {
          l(this, e10), F$(k0().getBool("IS_BROWSER"), function() {
            return "Current environment is not a web browser";
          }), F$("undefined" == typeof window || void 0 !== window.localStorage, function() {
            return "Current browser does not appear to support localStorage";
          }), this.LS = window.localStorage;
        }
        return p(e10, [{ key: "listModels", value: function() {
          var e11 = c(o().mark(function e12() {
            var t10, n10, r10, a10, i10, s10;
            return o().wrap(function(e13) {
              for (; ; ) switch (e13.prev = e13.next) {
                case 0:
                  for (t10 = {}, n10 = P6 + z6, r10 = z6 + B6, a10 = 0; a10 < this.LS.length; ++a10) (i10 = this.LS.key(a10)).startsWith(n10) && i10.endsWith(r10) && (s10 = q6(i10), t10[s10] = JSON.parse(this.LS.getItem(i10)));
                  return e13.abrupt("return", t10);
                case 5:
                case "end":
                  return e13.stop();
              }
            }, e12, this);
          }));
          return function() {
            return e11.apply(this, arguments);
          };
        }() }, { key: "removeModel", value: function() {
          var e11 = c(o().mark(function e12(t10) {
            var n10, r10;
            return o().wrap(function(e13) {
              for (; ; ) switch (e13.prev = e13.next) {
                case 0:
                  if (t10 = K6(t10), n10 = j6(t10), null != this.LS.getItem(n10.info)) {
                    e13.next = 4;
                    break;
                  }
                  throw new Error("Cannot find model at path '".concat(t10, "'"));
                case 4:
                  return r10 = JSON.parse(this.LS.getItem(n10.info)), H6(n10), e13.abrupt("return", r10);
                case 7:
                case "end":
                  return e13.stop();
              }
            }, e12, this);
          }));
          return function(t10) {
            return e11.apply(this, arguments);
          };
        }() }]), e10;
      }(), Z6 = "://", Q6 = function() {
        function e10() {
          l(this, e10), this.managers = {};
        }
        return p(e10, null, [{ key: "getInstance", value: function() {
          return null == e10.instance && (e10.instance = new e10()), e10.instance;
        } }, { key: "registerManager", value: function(t10, n10) {
          F$(null != t10, function() {
            return "scheme must not be undefined or null.";
          }), t10.endsWith(Z6) && (t10 = t10.slice(0, t10.indexOf(Z6))), F$(t10.length > 0, function() {
            return "scheme must not be an empty string.";
          });
          var r10 = e10.getInstance();
          F$(null == r10.managers[t10], function() {
            return "A model store manager is already registered for scheme '".concat(t10, "'.");
          }), r10.managers[t10] = n10;
        } }, { key: "getManager", value: function(t10) {
          var n10 = e10.getInstance().managers[t10];
          if (null == n10) throw new Error("Cannot find model manager for scheme '".concat(t10, "'"));
          return n10;
        } }, { key: "getSchemes", value: function() {
          return Object.keys(e10.getInstance().managers);
        } }]), e10;
      }();
      function $6(e10) {
        if (-1 === e10.indexOf(Z6)) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + "".concat(Q6.getSchemes().join(",")));
        return { scheme: e10.split(Z6)[0], path: e10.split(Z6)[1] };
      }
      function e8(e10, t10) {
        return t8.apply(this, arguments);
      }
      function t8() {
        return t8 = c(o().mark(function e10(t10, n10) {
          var r10, a10, i10, s10, u10, c10, l10, h10, p10, f10, d10 = arguments;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return r10 = d10.length > 2 && void 0 !== d10[2] && d10[2], F$(t10 !== n10, function() {
                  return "Old path and new path are the same: '".concat(t10, "'");
                }), F$((a10 = S6.getLoadHandlers(t10)).length > 0, function() {
                  return "Copying failed because no load handler is found for source URL ".concat(t10, ".");
                }), F$(a10.length < 2, function() {
                  return "Copying failed because more than one (".concat(a10.length, ") ") + "load handlers for source URL ".concat(t10, ".");
                }), i10 = a10[0], F$((s10 = S6.getSaveHandlers(n10)).length > 0, function() {
                  return "Copying failed because no save handler is found for destination " + "URL ".concat(n10, ".");
                }), F$(s10.length < 2, function() {
                  return "Copying failed because more than one (".concat(a10.length, ") ") + "save handlers for destination URL ".concat(n10, ".");
                }), u10 = s10[0], c10 = $6(t10).scheme, l10 = $6(t10).path, h10 = c10 === $6(t10).scheme, e11.next = 15, i10.load();
              case 15:
                if (p10 = e11.sent, !r10 || !h10) {
                  e11.next = 19;
                  break;
                }
                return e11.next = 19, Q6.getManager(c10).removeModel(l10);
              case 19:
                return e11.next = 21, u10.save(p10);
              case 21:
                if (f10 = e11.sent, !r10 || h10) {
                  e11.next = 25;
                  break;
                }
                return e11.next = 25, Q6.getManager(c10).removeModel(l10);
              case 25:
                return e11.abrupt("return", f10.modelArtifactsInfo);
              case 26:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), t8.apply(this, arguments);
      }
      function n8() {
        return n8 = c(o().mark(function e10() {
          var t10, n10, r10, a10, i10, s10, u10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                t10 = Q6.getSchemes(), n10 = {}, r10 = O(t10), e11.prev = 3, r10.s();
              case 5:
                if ((a10 = r10.n()).done) {
                  e11.next = 13;
                  break;
                }
                return i10 = a10.value, e11.next = 9, Q6.getManager(i10).listModels();
              case 9:
                for (u10 in s10 = e11.sent) n10[i10 + Z6 + u10] = s10[u10];
              case 11:
                e11.next = 5;
                break;
              case 13:
                e11.next = 18;
                break;
              case 15:
                e11.prev = 15, e11.t0 = e11.catch(3), r10.e(e11.t0);
              case 18:
                return e11.prev = 18, r10.f(), e11.finish(18);
              case 21:
                return e11.abrupt("return", n10);
              case 22:
              case "end":
                return e11.stop();
            }
          }, e10, null, [[3, 15, 18, 21]]);
        })), n8.apply(this, arguments);
      }
      function r8() {
        return (r8 = c(o().mark(function e10(t10) {
          var n10, r10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return n10 = $6(t10), r10 = Q6.getManager(n10.scheme), e11.abrupt("return", r10.removeModel(n10.path));
              case 3:
              case "end":
                return e11.stop();
            }
          }, e10);
        }))).apply(this, arguments);
      }
      function a8() {
        return (a8 = c(o().mark(function e10(t10, n10) {
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return false, e11.abrupt("return", e8(t10, n10, false));
              case 2:
              case "end":
                return e11.stop();
            }
          }, e10);
        }))).apply(this, arguments);
      }
      function i8() {
        return (i8 = c(o().mark(function e10(t10, n10) {
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return true, e11.abrupt("return", e8(t10, n10, true));
              case 2:
              case "end":
                return e11.stop();
            }
          }, e10);
        }))).apply(this, arguments);
      }
      var o8 = function() {
        function e10() {
          l(this, e10), this.messageName = "setTimeoutCustom", this.functionRefs = [], this.handledMessageCount = 0, this.hasEventListener = false;
        }
        return p(e10, [{ key: "fetch", value: function(e11) {
          function t10(t11, n10) {
            return e11.apply(this, arguments);
          }
          return t10.toString = function() {
            return e11.toString();
          }, t10;
        }(function(e11, t10) {
          return fetch(e11, t10);
        }) }, { key: "now", value: function() {
          return performance.now();
        } }, { key: "encode", value: function(e11, t10) {
          if ("utf-8" !== t10 && "utf8" !== t10) throw new Error("Browser's encoder only supports utf-8, but got ".concat(t10));
          return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(e11);
        } }, { key: "decode", value: function(e11, t10) {
          return new TextDecoder(t10).decode(e11);
        } }, { key: "setTimeoutCustom", value: function(e11, t10) {
          var n10 = this;
          "undefined" != typeof window && k0().getBool("USE_SETTIMEOUTCUSTOM") ? (this.functionRefs.push(e11), setTimeout(function() {
            window.postMessage({ name: n10.messageName, index: n10.functionRefs.length - 1 }, "*");
          }, t10), this.hasEventListener || (this.hasEventListener = true, window.addEventListener("message", function(e12) {
            e12.source === window && e12.data.name === n10.messageName && (e12.stopPropagation(), (0, n10.functionRefs[e12.data.index])(), n10.handledMessageCount++, n10.handledMessageCount === n10.functionRefs.length && (n10.functionRefs = [], n10.handledMessageCount = 0));
          }, true))) : setTimeout(e11, t10);
        } }, { key: "isTypedArray", value: function(e11) {
          return q3(e11);
        } }]), e10;
      }();
      if (k0().get("IS_BROWSER")) {
        k0().setPlatform("browser", new o8());
        try {
          Q6.registerManager(X6.URL_SCHEME, new J6());
        } catch (e10) {
        }
        try {
          Q6.registerManager(F6.URL_SCHEME, new L6());
        } catch (e10) {
        }
      }
      var s8, u8 = function() {
        return require_node_fetch();
      };
      var c8 = function() {
        function e10() {
          l(this, e10), this.util = require_util(), this.textEncoder = new this.util.TextEncoder();
        }
        return p(e10, [{ key: "fetch", value: function(e11, t10) {
          return null != k0().global.fetch ? k0().global.fetch(e11, t10) : (null == s8 && (s8 = u8()), s8(e11, t10));
        } }, { key: "now", value: function() {
          var e11 = process.hrtime();
          return 1e3 * e11[0] + e11[1] / 1e6;
        } }, { key: "encode", value: function(e11, t10) {
          if ("utf-8" !== t10 && "utf8" !== t10) throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t10));
          return this.textEncoder.encode(e11);
        } }, { key: "decode", value: function(e11, t10) {
          return 0 === e11.length ? "" : new this.util.TextDecoder(t10).decode(e11);
        } }, { key: "isTypedArray", value: function(e11) {
          return this.util.types.isFloat32Array(e11) || this.util.types.isInt32Array(e11) || this.util.types.isUint8Array(e11) || this.util.types.isUint8ClampedArray(e11);
        } }]), e10;
      }();
      function l8(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "float32", n10 = arguments.length > 2 ? arguments[2] : void 0;
        return t10 = t10 || "float32", p0(e10), new $4(e10, t10, n10);
      }
      k0().get("IS_NODE") && !k0().get("IS_BROWSER") && k0().setPlatform("node", new c8());
      var h8 = B5({ cast_: function(e10, t10) {
        var n10 = L5(e10, "x", "cast");
        if (!Y$(t10)) throw new Error("Failed to cast to unknown dtype ".concat(t10));
        if ("string" === t10 && "string" !== n10.dtype || "string" !== t10 && "string" === n10.dtype) throw new Error("Only strings can be casted to strings");
        var r10 = { x: n10 }, a10 = { dtype: t10 };
        return E5.runKernel(X0, r10, a10);
      } });
      var p8 = B5({ clone_: function(e10) {
        var t10 = { x: L5(e10, "x", "clone", "string_or_numeric") };
        return E5.runKernel(W1, t10);
      } });
      function f8(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        console.log(e10.toString(t10));
      }
      S5(), t5 = { buffer: l8, cast: h8, clone: p8, print: f8 };
      var d8 = B5({ add_: function(e10, t10) {
        var n10 = L5(e10, "a", "add"), r10 = L5(t10, "b", "add"), a10 = S(v5(n10, r10), 2), i10 = { a: n10 = a10[0], b: r10 = a10[1] };
        return E5.runKernel(E0, i10);
      } });
      var v8 = B5({ floorDiv_: function(e10, t10) {
        var n10 = L5(e10, "a", "floorDiv"), r10 = L5(t10, "b", "floorDiv"), a10 = S(v5(n10, r10), 2), i10 = { a: n10 = a10[0], b: r10 = a10[1] };
        return E5.runKernel(D1, i10);
      } });
      var m8 = B5({ div_: function(e10, t10) {
        var n10 = L5(e10, "a", "div"), r10 = L5(t10, "b", "div"), a10 = S(v5(n10, r10), 2);
        if (n10 = a10[0], r10 = a10[1], "int32" === n10.dtype && "int32" === r10.dtype) return v8(n10, r10);
        var i10 = { a: n10, b: r10 };
        return E5.runKernel(k1, i10, {});
      } });
      var g8 = B5({ mul_: function(e10, t10) {
        var n10 = L5(e10, "a", "mul"), r10 = L5(t10, "b", "mul"), a10 = S(v5(n10, r10), 2), i10 = { a: n10 = a10[0], b: r10 = a10[1] };
        return E5.runKernel(g2, i10);
      } });
      var y8 = B5({ abs_: function(e10) {
        var t10 = L5(e10, "x", "abs");
        if ("complex64" === t10.dtype) {
          var n10 = { x: t10 };
          return E5.runKernel(Q0, n10);
        }
        var r10 = { x: t10 };
        return E5.runKernel(N0, r10);
      } });
      var b8 = B5({ acos_: function(e10) {
        var t10 = { x: L5(e10, "x", "acos") };
        return E5.runKernel(S0, t10);
      } });
      var x8 = B5({ acosh_: function(e10) {
        var t10 = { x: L5(e10, "x", "acosh") };
        return E5.runKernel(T0, t10);
      } });
      var k8 = B5({ addN_: function(e10) {
        F$(Array.isArray(e10), function() {
          return "The argument passed to tf.addN() must be a list of tensors";
        }), F$(e10.length >= 1, function() {
          return "Must pass at least one tensor to tf.addN(), but got " + "".concat(e10.length);
        });
        var t10 = e10.map(function(e11, t11) {
          return L5(e11, "tensors".concat(t11), "addN");
        }), n10 = t10[0];
        t10.forEach(function(e11) {
          if (e11.dtype !== n10.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype");
        }), t10.forEach(function(e11) {
          if (!P$(e11.shape, n10.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape");
        });
        var r10 = t10;
        return E5.runKernel(C0, r10);
      } });
      var w8 = B5({ all_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r10 = L5(e10, "x", "all", "bool"), a10 = { x: r10 }, i10 = { axis: t10, keepDims: n10 };
        return E5.runKernel(A0, a10, i10);
      } });
      var I8 = B5({ any_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r10 = L5(e10, "x", "any", "bool"), a10 = { x: r10 }, i10 = { axis: t10, keepDims: n10 };
        return E5.runKernel(R0, a10, i10);
      } });
      var N8 = B5({ argMax_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n10 = L5(e10, "x", "argMax"), r10 = { x: n10 }, a10 = { axis: t10 };
        return E5.runKernel(_0, r10, a10);
      } });
      var S8 = B5({ argMin_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n10 = L5(e10, "x", "argMin"), r10 = { x: n10 }, a10 = { axis: t10 };
        return E5.runKernel(O0, r10, a10);
      } });
      var T8 = B5({ asin_: function(e10) {
        var t10 = { x: L5(e10, "x", "asin") };
        return E5.runKernel(F0, t10);
      } });
      var E8 = B5({ asinh_: function(e10) {
        var t10 = { x: L5(e10, "x", "asinh") };
        return E5.runKernel(D0, t10);
      } });
      var C8 = B5({ atan_: function(e10) {
        var t10 = { x: L5(e10, "x", "atan") };
        return E5.runKernel(M0, t10);
      } });
      var A8 = B5({ atan2_: function(e10, t10) {
        var n10 = L5(e10, "a", "atan2"), r10 = L5(t10, "b", "atan2"), a10 = S(v5(n10, r10), 2), i10 = { a: n10 = a10[0], b: r10 = a10[1] };
        return E5.runKernel(z0, i10);
      } });
      var R8 = B5({ atanh_: function(e10) {
        var t10 = { x: L5(e10, "x", "atanh") };
        return E5.runKernel(L0, t10);
      } });
      function _8(e10, t10, n10, r10) {
        var a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "NHWC", i10 = arguments.length > 5 ? arguments[5] : void 0, o10 = e10[3], s10 = [].concat(T(t10), [o10]), u10 = q8(a10);
        return D8(e10, s10, n10, i10, r10, null, null, u10);
      }
      function O8(e10, t10, n10, r10, a10, i10) {
        var o10, s10 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : "channelsLast", u10 = z8(t10), c10 = S(u10, 2), l10 = c10[0], h10 = c10[1];
        if ("channelsLast" === s10) o10 = [l10, h10, e10[3], e10[3]];
        else {
          if ("channelsFirst" !== s10) throw new Error("Unknown dataFormat ".concat(s10));
          o10 = [l10, h10, e10[1], e10[1]];
        }
        return D8(e10, o10, n10, r10, a10, i10, false, s10);
      }
      function F8(e10, t10, n10, r10, a10, i10) {
        var o10, s10, u10 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : "NDHWC", c10 = P8(t10), l10 = S(c10, 3), h10 = l10[0], p10 = l10[1], f10 = l10[2];
        if ("NDHWC" === u10) s10 = "channelsLast", o10 = [h10, p10, f10, e10[4], e10[4]];
        else {
          if ("NCDHW" !== u10) throw new Error("Unknown dataFormat ".concat(u10));
          s10 = "channelsFirst", o10 = [h10, p10, f10, e10[1], e10[1]];
        }
        return M8(e10, o10, n10, r10, a10, false, s10, i10);
      }
      function D8(e10, t10, n10, r10, a10, i10) {
        var o10 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6], s10 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "channelsLast", u10 = -1, c10 = -1, l10 = -1, h10 = -1;
        if ("channelsLast" === s10) {
          var p10 = S(e10, 4);
          u10 = p10[0], c10 = p10[1], l10 = p10[2], h10 = p10[3];
        } else {
          if ("channelsFirst" !== s10) throw new Error("Unknown dataFormat ".concat(s10));
          var f10 = S(e10, 4);
          u10 = f10[0], h10 = f10[1], c10 = f10[2], l10 = f10[3];
        }
        var d10, v10 = S(t10, 4), m10 = v10[0], g10 = v10[1], y10 = v10[3], b10 = z8(n10), x10 = S(b10, 2), k10 = x10[0], w10 = x10[1], I10 = z8(r10), N10 = S(I10, 2), T10 = N10[0], E10 = N10[1], C10 = B8(m10, T10), A10 = B8(g10, E10), R10 = W8(a10, c10, l10, k10, w10, C10, A10, i10, s10), _10 = R10.padInfo, O10 = R10.outHeight, F10 = R10.outWidth, D10 = o10 ? y10 * h10 : y10;
        return "channelsFirst" === s10 ? d10 = [u10, D10, O10, F10] : "channelsLast" === s10 && (d10 = [u10, O10, F10, D10]), { batchSize: u10, dataFormat: s10, inHeight: c10, inWidth: l10, inChannels: h10, outHeight: O10, outWidth: F10, outChannels: D10, padInfo: _10, strideHeight: k10, strideWidth: w10, filterHeight: m10, filterWidth: g10, effectiveFilterHeight: C10, effectiveFilterWidth: A10, dilationHeight: T10, dilationWidth: E10, inShape: e10, outShape: d10, filterShape: t10 };
      }
      function M8(e10, t10, n10, r10, a10) {
        var i10 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5], o10 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : "channelsLast", s10 = arguments.length > 7 ? arguments[7] : void 0, u10 = -1, c10 = -1, l10 = -1, h10 = -1, p10 = -1;
        if ("channelsLast" === o10) {
          var f10 = S(e10, 5);
          u10 = f10[0], c10 = f10[1], l10 = f10[2], h10 = f10[3], p10 = f10[4];
        } else {
          if ("channelsFirst" !== o10) throw new Error("Unknown dataFormat ".concat(o10));
          var d10 = S(e10, 5);
          u10 = d10[0], p10 = d10[1], c10 = d10[2], l10 = d10[3], h10 = d10[4];
        }
        var v10, m10 = S(t10, 5), g10 = m10[0], y10 = m10[1], b10 = m10[2], x10 = m10[4], k10 = P8(n10), w10 = S(k10, 3), I10 = w10[0], N10 = w10[1], T10 = w10[2], E10 = P8(r10), C10 = S(E10, 3), A10 = C10[0], R10 = C10[1], _10 = C10[2], O10 = B8(g10, A10), F10 = B8(y10, R10), D10 = B8(b10, _10), M10 = U8(a10, c10, l10, h10, I10, N10, T10, O10, F10, D10, s10), L10 = M10.padInfo, z10 = M10.outDepth, P10 = M10.outHeight, B10 = M10.outWidth, W10 = i10 ? x10 * p10 : x10;
        return "channelsFirst" === o10 ? v10 = [u10, W10, z10, P10, B10] : "channelsLast" === o10 && (v10 = [u10, z10, P10, B10, W10]), { batchSize: u10, dataFormat: o10, inDepth: c10, inHeight: l10, inWidth: h10, inChannels: p10, outDepth: z10, outHeight: P10, outWidth: B10, outChannels: W10, padInfo: L10, strideDepth: I10, strideHeight: N10, strideWidth: T10, filterDepth: g10, filterHeight: y10, filterWidth: b10, effectiveFilterDepth: O10, effectiveFilterHeight: F10, effectiveFilterWidth: D10, dilationDepth: A10, dilationHeight: R10, dilationWidth: _10, inShape: e10, outShape: v10, filterShape: t10 };
      }
      function L8(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, a10 = B8(t10, r10);
        return Math.floor((e10[0] * (n10 - 1) - n10 + a10) / 2);
      }
      function z8(e10) {
        return "number" == typeof e10 ? [e10, e10, e10] : 2 === e10.length ? [e10[0], e10[1], 1] : e10;
      }
      function P8(e10) {
        return "number" == typeof e10 ? [e10, e10, e10] : e10;
      }
      function B8(e10, t10) {
        return t10 <= 1 ? e10 : e10 + (e10 - 1) * (t10 - 1);
      }
      function W8(e10, t10, n10, r10, a10, i10, o10, u10, c10) {
        var l10, h10, p10;
        if ("number" == typeof e10) {
          l10 = { top: e10, bottom: e10, left: e10, right: e10, type: 0 === e10 ? "VALID" : "NUMBER" };
          var f10 = function(e11, t11, n11, r11, a11) {
            null == r11 && (r11 = L8(e11, t11, n11));
            var i11 = e11[0], o11 = e11[1];
            return [V8((i11 - t11 + 2 * r11) / n11 + 1, a11), V8((o11 - t11 + 2 * r11) / n11 + 1, a11)];
          }([t10, n10], i10, r10, e10, u10);
          h10 = f10[0], p10 = f10[1];
        } else if ("same" === e10) {
          h10 = Math.ceil(t10 / r10), p10 = Math.ceil(n10 / a10);
          var d10 = Math.max(0, (h10 - 1) * r10 + i10 - t10), v10 = Math.max(0, (p10 - 1) * a10 + o10 - n10), m10 = Math.floor(d10 / 2), g10 = d10 - m10, y10 = Math.floor(v10 / 2);
          l10 = { top: m10, bottom: g10, left: y10, right: v10 - y10, type: "SAME" };
        } else if ("valid" === e10) l10 = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" }, h10 = Math.ceil((t10 - i10 + 1) / r10), p10 = Math.ceil((n10 - o10 + 1) / a10);
        else {
          if ("object" !== s(e10)) throw Error("Unknown padding parameter: ".concat(e10));
          var b10 = "channelsLast" === c10 ? e10[1][0] : e10[2][0], x10 = "channelsLast" === c10 ? e10[1][1] : e10[2][1], k10 = "channelsLast" === c10 ? e10[2][0] : e10[3][0], w10 = "channelsLast" === c10 ? e10[2][1] : e10[3][1];
          l10 = { top: b10, bottom: x10, left: k10, right: w10, type: 0 === b10 && 0 === x10 && 0 === k10 && 0 === w10 ? "VALID" : "EXPLICIT" }, h10 = V8((t10 - i10 + b10 + x10) / r10 + 1, u10), p10 = V8((n10 - o10 + k10 + w10) / a10 + 1, u10);
        }
        return { padInfo: l10, outHeight: h10, outWidth: p10 };
      }
      function U8(e10, t10, n10, r10, a10, i10, o10, s10, u10, c10, l10) {
        var h10, p10, f10, d10;
        if ("valid" === e10 && (e10 = 0), "number" == typeof e10) {
          h10 = { top: e10, bottom: e10, left: e10, right: e10, front: e10, back: e10, type: 0 === e10 ? "VALID" : "NUMBER" };
          var v10 = function(e11, t11, n11, r11, a11, i11) {
            null == a11 && (a11 = L8(e11, t11[0], r11[0]));
            for (var o11 = [0, 0, 0, n11], s11 = 0; s11 < 3; s11++) e11[s11] + 2 * a11 >= t11[s11] && (o11[s11] = V8((e11[s11] - t11[s11] + 2 * a11) / r11[s11] + 1, i11));
            return o11;
          }([t10, n10, r10, 1], [s10, u10, c10], 1, [a10, i10, o10], e10, l10);
          p10 = v10[0], f10 = v10[1], d10 = v10[2];
        } else {
          if ("same" !== e10) throw Error("Unknown padding parameter: ".concat(e10));
          var m10 = ((p10 = Math.ceil(t10 / a10)) - 1) * a10 + s10 - t10, g10 = ((f10 = Math.ceil(n10 / i10)) - 1) * i10 + u10 - n10, y10 = ((d10 = Math.ceil(r10 / o10)) - 1) * o10 + c10 - r10, b10 = Math.floor(m10 / 2), x10 = m10 - b10, k10 = Math.floor(g10 / 2), w10 = g10 - k10, I10 = Math.floor(y10 / 2);
          h10 = { top: k10, bottom: w10, left: I10, right: y10 - I10, front: b10, back: x10, type: "SAME" };
        }
        return { padInfo: h10, outDepth: p10, outHeight: f10, outWidth: d10 };
      }
      function V8(e10, t10) {
        if (!t10) return Math.trunc(e10);
        switch (t10) {
          case "round":
            return Math.round(e10);
          case "ceil":
            return Math.ceil(e10);
          case "floor":
            return Math.floor(e10);
          default:
            throw new Error("Unknown roundingMode ".concat(t10));
        }
      }
      function G8(e10) {
        var t10 = S(z8(e10), 3), n10 = t10[0], r10 = t10[1], a10 = t10[2];
        return 1 === n10 && 1 === r10 && 1 === a10;
      }
      function j8(e10, t10) {
        return G8(e10) || G8(t10);
      }
      function H8(e10) {
        return z8(e10).every(function(e11) {
          return e11 > 0;
        });
      }
      function q8(e10) {
        if ("NHWC" === e10) return "channelsLast";
        if ("NCHW" === e10) return "channelsFirst";
        throw new Error("Unknown dataFormat ".concat(e10));
      }
      function K8(e10, t10, n10) {
        if (null != n10) {
          if ("string" == typeof t10) throw Error("Error in ".concat(e10, ": pad must be an integer when using ") + "dimRoundingMode ".concat(n10, " but got pad ").concat(t10, "."));
          if ("number" == typeof t10) F$(B$(t10), function() {
            return "Error in ".concat(e10, ": pad must be an integer when using ") + "dimRoundingMode ".concat(n10, " but got pad ").concat(t10, ".");
          });
          else {
            if ("object" !== s(t10)) throw Error("Error in ".concat(e10, ": Unknown padding parameter: ").concat(t10));
            t10.forEach(function(t11) {
              t11.forEach(function(t12) {
                F$(B$(t12), function() {
                  return "Error in ".concat(e10, ": pad must be an integer when using ") + "dimRoundingMode ".concat(n10, " but got pad ").concat(t12, ".");
                });
              });
            });
          }
        }
      }
      var X8 = B5({ reshape_: function(e10, t10) {
        var n10 = { x: L5(e10, "x", "reshape", "string_or_numeric") }, r10 = { shape: t10 };
        return E5.runKernel(z2, n10, r10);
      } });
      var Y8 = B5({ avgPool_: function(e10, t10, n10, r10, a10) {
        var i10 = L5(e10, "x", "avgPool", "float32");
        F$(j8(n10, 1), function() {
          return "Error in avgPool: Either strides or dilations must be 1. " + "Got strides ".concat(n10, " and dilations '").concat(1, "'");
        });
        var o10 = i10, s10 = false;
        3 === i10.rank && (s10 = true, o10 = X8(i10, [1, i10.shape[0], i10.shape[1], i10.shape[2]])), F$(4 === o10.rank, function() {
          return "Error in avgPool: x must be rank 4 but got rank ".concat(o10.rank, ".");
        }), K8("avgPool", r10, a10);
        var u10 = { x: o10 }, c10 = { filterSize: t10, strides: n10, pad: r10, dimRoundingMode: a10 }, l10 = E5.runKernel(P0, u10, c10);
        return l10 = h8(l10, i10.dtype), s10 ? X8(l10, [l10.shape[1], l10.shape[2], l10.shape[3]]) : l10;
      } });
      var J8 = B5({ avgPool3d_: function(e10, t10, n10, r10, a10) {
        var i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "NDHWC", o10 = L5(e10, "x", "avgPool3d", "float32"), s10 = o10, u10 = false;
        4 === o10.rank && (u10 = true, s10 = X8(o10, [1, o10.shape[0], o10.shape[1], o10.shape[2], o10.shape[3]])), F$(5 === s10.rank, function() {
          return "Error in avgPool3d: x must be rank 5 but got rank ".concat(s10.rank, ".");
        }), F$("NDHWC" === i10, function() {
          return "Error in avgPool3d: Only NDHWC is currently supported, " + "but got dataFormat of ".concat(i10);
        }), F$("number" == typeof n10 && n10 > 0 || Array.isArray(n10) && n10[0] > 0 && n10[1] > 0 && n10[2] > 0, function() {
          return "Error in avgPool3d: Stride must be > 0, but got '".concat(n10, "'");
        }), K8("avgPool3d", r10, a10);
        var c10 = { x: s10 }, l10 = { filterSize: t10, strides: n10, pad: r10, dimRoundingMode: a10, dataFormat: i10 }, h10 = E5.runKernel(W0, c10, l10);
        return h10 = h8(h10, s10.dtype), u10 ? X8(h10, [h10.shape[1], h10.shape[2], h10.shape[3], h10.shape[4]]) : h10;
      } });
      var Z8 = B5({ concat_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        F$(e10.length >= 1, function() {
          return "Pass at least one tensor to concat";
        });
        var n10 = z5(e10, "tensors", "concat", "string_or_numeric");
        if ("complex64" === n10[0].dtype && n10.forEach(function(e11) {
          if ("complex64" !== e11.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e11.dtype, ". "));
        }), 1 === n10.length) return p8(n10[0]);
        var r10 = n10, a10 = { axis: t10 };
        return E5.runKernel($0, r10, a10);
      } });
      var Q8 = B5({ matMul_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a10 = L5(e10, "a", "matMul"), i10 = L5(t10, "b", "matMul"), o10 = v5(a10, i10), s10 = S(o10, 2), u10 = { a: a10 = s10[0], b: i10 = s10[1] }, c10 = { transposeA: n10, transposeB: r10 };
        return E5.runKernel(V0, u10, c10);
      } });
      var $8 = B5({ sigmoid_: function(e10) {
        var t10 = { x: L5(e10, "x", "sigmoid", "float32") };
        return E5.runKernel(t3, t10);
      } });
      var e7 = B5({ slice_: function(e10, t10, n10) {
        var r10 = L5(e10, "x", "slice", "string_or_numeric");
        if (0 === r10.rank) throw new Error("Slicing scalar is not possible");
        var a10 = { x: r10 }, i10 = { begin: t10, size: n10 };
        return E5.runKernel(Z2, a10, i10);
      } });
      var t7 = B5({ tanh_: function(e10) {
        var t10 = { x: L5(e10, "x", "tanh", "float32") };
        return E5.runKernel(w3, t10);
      } });
      var n7 = B5({ basicLSTMCell_: function(e10, t10, n10, r10, a10, i10) {
        var o10 = L5(e10, "forgetBias", "basicLSTMCell"), s10 = L5(t10, "lstmKernel", "basicLSTMCell"), u10 = L5(n10, "lstmBias", "basicLSTMCell"), c10 = L5(r10, "data", "basicLSTMCell"), l10 = L5(a10, "c", "basicLSTMCell"), h10 = L5(i10, "h", "basicLSTMCell"), p10 = Z8([c10, h10], 1), f10 = Q8(p10, s10), d10 = d8(f10, u10), v10 = d10.shape[0], m10 = d10.shape[1] / 4, g10 = [v10, m10], y10 = e7(d10, [0, 0], g10), b10 = e7(d10, [0, m10], g10), x10 = e7(d10, [0, 2 * m10], g10), k10 = e7(d10, [0, 3 * m10], g10), w10 = d8(g8($8(y10), t7(b10)), g8(l10, $8(d8(o10, x10))));
        return [w10, g8(t7(w10), $8(k10))];
      } });
      var r7 = B5({ batchToSpaceND_: function(e10, t10, n10) {
        var r10 = L5(e10, "x", "batchToSpaceND"), a10 = t10.reduce(function(e11, t11) {
          return e11 * t11;
        });
        F$(r10.rank >= 1 + t10.length, function() {
          return "input rank is ".concat(r10.rank, " but should be > than blockShape.length ").concat(t10.length);
        }), F$(n10.length === t10.length, function() {
          return "crops.length is ".concat(n10.length, " but should be equal to blockShape.length  ").concat(t10.length);
        }), F$(r10.shape[0] % a10 == 0, function() {
          return "input tensor batch is ".concat(r10.shape[0], " but is not divisible by the product of ") + "the elements of blockShape ".concat(t10.join(" * "), " === ").concat(a10);
        });
        var i10 = { x: r10 }, o10 = { blockShape: t10, crops: n10 };
        return E5.runKernel(G0, i10, o10);
      } });
      var a7 = B5({ batchNorm_: function(e10, t10, n10, r10, a10, i10) {
        null == i10 && (i10 = 1e-3);
        var o10, s10, u10 = L5(e10, "x", "batchNorm"), c10 = L5(t10, "mean", "batchNorm"), l10 = L5(n10, "variance", "batchNorm");
        null != a10 && (o10 = L5(a10, "scale", "batchNorm")), null != r10 && (s10 = L5(r10, "offset", "batchNorm")), F$(c10.rank === l10.rank, function() {
          return "Batch normalization gradient requires mean and variance to have equal ranks.";
        }), F$(null == s10 || c10.rank === s10.rank, function() {
          return "Batch normalization gradient requires mean and offset to have equal ranks.";
        }), F$(null == o10 || c10.rank === o10.rank, function() {
          return "Batch normalization gradient requires mean and scale to have equal ranks.";
        });
        var h10 = function(e11) {
          return 0 === e11.rank || 1 === e11.rank ? X8(e11, [1, 1, 1, e11.size]) : 2 === e11.rank ? X8(e11, [1, 1, e11.shape[0], e11.shape[1]]) : 3 === e11.rank ? X8(e11, [1, e11.shape[0], e11.shape[1], e11.shape[2]]) : e11;
        }(u10), p10 = { x: h10, scale: o10, offset: s10, mean: c10, variance: l10 }, f10 = { varianceEpsilon: i10 }, d10 = E5.runKernel(M1, p10, f10);
        return X8(d10, u10.shape);
      } });
      var i7 = B5({ batchNorm2d_: function(e10, t10, n10, r10, a10, i10) {
        var o10, s10, u10 = L5(e10, "x", "batchNorm"), c10 = L5(t10, "mean", "batchNorm"), l10 = L5(n10, "variance", "batchNorm");
        return null != a10 && (o10 = L5(a10, "scale", "batchNorm")), null != r10 && (s10 = L5(r10, "offset", "batchNorm")), F$(2 === u10.rank, function() {
          return "Error in batchNorm2D: x must be rank 2 but got rank " + "".concat(u10.rank, ".");
        }), F$(2 === c10.rank || 1 === c10.rank, function() {
          return "Error in batchNorm2D: mean must be rank 2 or rank 1 but " + "got rank ".concat(c10.rank, ".");
        }), F$(2 === l10.rank || 1 === l10.rank, function() {
          return "Error in batchNorm2D: variance must be rank 2 or rank 1 " + "but got rank ".concat(l10.rank, ".");
        }), null != o10 && F$(2 === o10.rank || 1 === o10.rank, function() {
          return "Error in batchNorm2D: scale must be rank 2 or rank 1 " + "but got rank ".concat(o10.rank, ".");
        }), null != s10 && F$(2 === s10.rank || 1 === s10.rank, function() {
          return "Error in batchNorm2D: offset must be rank 2 or rank 1 " + "but got rank ".concat(s10.rank, ".");
        }), a7(u10, c10, l10, s10, o10, i10);
      } });
      var o7 = B5({ batchNorm3d_: function(e10, t10, n10, r10, a10, i10) {
        var o10, s10, u10 = L5(e10, "x", "batchNorm"), c10 = L5(t10, "mean", "batchNorm"), l10 = L5(n10, "variance", "batchNorm");
        return null != a10 && (o10 = L5(a10, "scale", "batchNorm")), null != r10 && (s10 = L5(r10, "offset", "batchNorm")), F$(3 === u10.rank, function() {
          return "Error in batchNorm3D: x must be rank 3 but got rank " + "".concat(u10.rank, ".");
        }), F$(3 === c10.rank || 1 === c10.rank, function() {
          return "Error in batchNorm3D: mean must be rank 3 or rank 1 but " + "got rank ".concat(c10.rank, ".");
        }), F$(3 === l10.rank || 1 === l10.rank, function() {
          return "Error in batchNorm3D: variance must be rank 3 or rank 1 " + "but got rank ".concat(l10.rank, ".");
        }), null != o10 && F$(3 === o10.rank || 1 === o10.rank, function() {
          return "Error in batchNorm3D: scale must be rank 3 or rank 1 " + "but got rank ".concat(o10.rank, ".");
        }), null != s10 && F$(3 === s10.rank || 1 === s10.rank, function() {
          return "Error in batchNorm3D: offset must be rank 3 or rank 1 " + "but got rank ".concat(s10.rank, ".");
        }), a7(u10, c10, l10, s10, o10, i10);
      } });
      var s7 = B5({ batchNorm4d_: function(e10, t10, n10, r10, a10, i10) {
        var o10, s10, u10 = L5(e10, "x", "batchNorm"), c10 = L5(t10, "mean", "batchNorm"), l10 = L5(n10, "variance", "batchNorm");
        return null != a10 && (o10 = L5(a10, "scale", "batchNorm")), null != r10 && (s10 = L5(r10, "offset", "batchNorm")), F$(4 === u10.rank, function() {
          return "Error in batchNorm4D: x must be rank 4 but got rank " + "".concat(u10.rank, ".");
        }), F$(4 === c10.rank || 1 === c10.rank, function() {
          return "Error in batchNorm4D: mean must be rank 4 or rank 1 but " + "got rank ".concat(c10.rank, ".");
        }), F$(4 === l10.rank || 1 === l10.rank, function() {
          return "Error in batchNorm4D: variance must be rank 4 or rank 1 " + "but got rank ".concat(l10.rank, ".");
        }), null != o10 && F$(4 === o10.rank || 1 === o10.rank, function() {
          return "Error in batchNorm4D: scale must be rank 4 or rank 1 " + "but got rank ".concat(o10.rank, ".");
        }), null != s10 && F$(4 === s10.rank || 1 === s10.rank, function() {
          return "Error in batchNorm4D: offset must be rank 4 or rank 1 " + "but got rank ".concat(s10.rank, ".");
        }), a7(u10, c10, l10, s10, o10, i10);
      } });
      var u7 = B5({ bincount_: function(e10, t10, n10) {
        var r10 = L5(e10, "x", "bincount"), a10 = L5(t10, "weights", "bincount");
        F$("int32" === r10.dtype, function() {
          return "Error in bincount: input " + "dtype must be int32, but got ".concat(r10.dtype);
        }), F$(n10 >= 0, function() {
          return "size must be non-negative, but got ".concat(n10, ".");
        }), F$(a10.size === r10.size || 0 === a10.size, function() {
          return "Error in bincount: weights must have the same size as input or" + "0-length, but got input shape: ".concat(r10.shape, ", weights shape: ") + "".concat(a10.shape, ".");
        });
        var i10 = { x: r10, weights: a10 }, o10 = { size: n10 };
        return E5.runKernel(j0, i10, o10);
      } });
      var c7 = B5({ bitwiseAnd_: function(e10, t10) {
        var n10 = L5(e10, "x", "bitwiseAnd"), r10 = L5(t10, "y", "bitwiseAnd");
        if (!P$(n10.shape, r10.shape)) throw new Error("BitwiseAnd: Tensors must have the same shape. x: ".concat(n10.shape, ", y: ").concat(r10.shape));
        if ("int32" !== n10.dtype || "int32" !== r10.dtype) throw new Error("BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ".concat(n10.dtype, " and type of y: ").concat(r10.dtype));
        var a10 = { a: n10, b: r10 };
        return E5.runKernel(H0, a10);
      } });
      var l7 = B5({ broadcastArgs_: function(e10, t10) {
        var n10 = L5(e10, "s0", "broadcastArgs", "int32"), r10 = L5(t10, "s1", "broadcastArgs", "int32");
        if (1 !== n10.rank) throw new Error("broadcastArgs(): first input must be a vector (rank=1). " + "Has rank ".concat(n10.rank));
        if (1 !== r10.rank) throw new Error("broadcastArgs(): second input must be a vector (rank=1). " + "Has rank ".concat(r10.rank));
        var a10 = { s0: n10, s1: r10 };
        return E5.runKernel(K0, a10);
      } });
      var h7 = B5({ broadcastTo_: function(e10, t10) {
        var n10 = L5(e10, "broadcastTo", "x"), r10 = n10.shape;
        if (p0(t10), t10.length < n10.rank) throw new Error("broadcastTo(): shape.length=".concat(t10.length, " < input.rank=").concat(n10.rank, "."));
        if (t10.length > n10.rank) {
          for (var a10 = n10.shape.slice(); a10.length < t10.length; ) a10.unshift(1);
          n10 = X8(n10, a10);
        }
        for (var i10 = n10.shape, o10 = Array.from(t10), s10 = t10.length - 1; s10 >= 0; s10--) if (i10[s10] === t10[s10]) o10[s10] = 1;
        else if (1 !== n10.shape[s10]) throw new Error("broadcastTo(): [".concat(r10, "] cannot be broadcast to [").concat(t10, "]."));
        var u10 = o10.map(function(e11, t11) {
          return e11 > 1 ? t11 : -1;
        }).filter(function(e11) {
          return e11 >= 0;
        });
        if (0 === u10.length) return p8(n10);
        var c10 = { x: n10 }, l10 = { reps: o10 };
        return E5.runKernel(I3, c10, l10);
      } });
      var p7 = B5({ ceil_: function(e10) {
        var t10 = { x: L5(e10, "x", "ceil", "float32") };
        return E5.runKernel(Y0, t10);
      } });
      function f7(e10, t10, n10) {
        p0(e10);
        var r10 = { shape: e10, value: t10, dtype: n10 = n10 || n0(t10) };
        return E5.runKernel(_1, {}, r10);
      }
      var d7 = B5({ clipByValue_: function(e10, t10, n10) {
        var r10 = L5(e10, "x", "clipByValue");
        if (F$(t10 <= n10, function() {
          return "Error in clip: min (".concat(t10, ") must be ") + "less than or equal to max (".concat(n10, ").");
        }), t10 === n10) return f7(r10.shape, t10, r10.dtype);
        var a10 = { x: r10 }, i10 = { clipValueMin: t10, clipValueMax: n10 };
        return E5.runKernel(J0, a10, i10);
      } });
      var v7 = B5({ concat1d_: function(e10) {
        return Z8(e10, 0);
      } });
      var m7 = B5({ concat2d_: function(e10, t10) {
        return Z8(e10, t10);
      } });
      var g7 = B5({ concat3d_: function(e10, t10) {
        return Z8(e10, t10);
      } });
      var y7 = B5({ concat4d_: function(e10, t10) {
        return Z8(e10, t10);
      } });
      var b7 = B5({ conv2d_: function(e10, t10, n10, r10) {
        var a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "NHWC", i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [1, 1], o10 = arguments.length > 6 ? arguments[6] : void 0, s10 = L5(e10, "x", "conv2d", "float32"), u10 = L5(t10, "filter", "conv2d", "float32"), c10 = s10, l10 = false;
        3 === s10.rank && (l10 = true, c10 = X8(s10, [1, s10.shape[0], s10.shape[1], s10.shape[2]])), F$(4 === c10.rank, function() {
          return "Error in conv2d: input must be rank 4, but got rank ".concat(c10.rank, ".");
        }), F$(4 === u10.rank, function() {
          return "Error in conv2d: filter must be rank 4, but got rank " + "".concat(u10.rank, ".");
        }), K8("conv2d", r10, o10);
        var h10 = "NHWC" === a10 ? c10.shape[3] : c10.shape[1];
        F$(h10 === u10.shape[2], function() {
          return "Error in conv2d: depth of input (".concat(h10, ") must match ") + "input depth for filter ".concat(u10.shape[2], ".");
        }), F$(j8(n10, i10), function() {
          return "Error in conv2D: Either strides or dilations must be 1. " + "Got strides ".concat(n10, " and dilations '").concat(i10, "'");
        }), F$(H8(i10), function() {
          return "Error in conv2D: Dilated rates should be larger than 0.";
        }), F$(H8(n10), function() {
          return "Error in conv2D: Strides should be larger than 0.";
        });
        var p10 = { x: c10, filter: u10 }, f10 = { strides: n10, pad: r10, dataFormat: a10, dilations: i10, dimRoundingMode: o10 }, d10 = E5.runKernel(e1, p10, f10);
        return l10 ? X8(d10, [d10.shape[1], d10.shape[2], d10.shape[3]]) : d10;
      } });
      var x7 = B5({ conv1d_: function(e10, t10, n10, r10) {
        var a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "NWC", i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1, o10 = arguments.length > 6 ? arguments[6] : void 0, s10 = L5(e10, "x", "conv1d"), u10 = L5(t10, "filter", "conv1d"), c10 = s10, l10 = false;
        2 === s10.rank && (l10 = true, c10 = X8(s10, [1, s10.shape[0], s10.shape[1]])), F$(3 === c10.rank, function() {
          return "Error in conv1d: input must be rank 3, but got rank ".concat(c10.rank, ".");
        }), F$(3 === u10.rank, function() {
          return "Error in conv1d: filter must be rank 3, but got rank " + "".concat(u10.rank, ".");
        }), K8("conv1d", r10, o10), F$(c10.shape[2] === u10.shape[1], function() {
          return "Error in conv1d: depth of input (".concat(c10.shape[2], ") must match ") + "input depth for filter ".concat(u10.shape[1], ".");
        }), F$(j8(n10, i10), function() {
          return "Error in conv1D: Either stride or dilation must be 1. " + "Got stride ".concat(n10, " and dilation '").concat(i10, "'");
        }), F$(H8(i10), function() {
          return "Error in conv1D: Dilated rates should be larger than 0.";
        }), F$(H8(n10), function() {
          return "Error in conv1D: Stride should be larger than 0.";
        }), F$("NWC" === a10, function() {
          return "Error in conv1d: got dataFormat of ".concat(a10, " but only NWC is currently supported.");
        });
        var h10 = X8(u10, [1, u10.shape[0], u10.shape[1], u10.shape[2]]), p10 = X8(c10, [c10.shape[0], 1, c10.shape[1], c10.shape[2]]), f10 = [1, n10], d10 = [1, i10], v10 = "NHWC", m10 = b7(p10, h10, f10, r10, v10, d10, o10);
        return X8(m10, l10 ? [m10.shape[2], m10.shape[3]] : [m10.shape[0], m10.shape[2], m10.shape[3]]);
      } });
      var k7 = B5({ conv2DBackpropInput_: function(e10, t10, n10, r10, a10) {
        var i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "NHWC", o10 = arguments.length > 6 ? arguments[6] : void 0;
        F$(e10.length === t10.rank, function() {
          return "Length of inShape " + "(".concat(e10.length, ") and rank of dy (").concat(t10.rank, ") must match");
        });
        var s10 = e10, u10 = t10, c10 = false;
        3 === t10.rank && (c10 = true, u10 = X8(t10, [1, t10.shape[0], t10.shape[1], t10.shape[2]]), s10 = [1, e10[0], e10[1], e10[2]]), F$(4 === s10.length, function() {
          return "Error in conv2dDerInput: inShape must be length 4, but got length " + "".concat(s10.length, ".");
        }), F$(4 === u10.rank, function() {
          return "Error in conv2dDerInput: dy must be rank 4, but got " + "rank ".concat(u10.rank);
        }), F$(4 === n10.rank, function() {
          return "Error in conv2dDerInput: filter must be rank 4, but got " + "rank ".concat(n10.rank);
        });
        var l10 = "NHWC" === i10 ? s10[3] : s10[1], h10 = "NHWC" === i10 ? u10.shape[3] : u10.shape[1];
        F$(l10 === n10.shape[2], function() {
          return "Error in conv2dDerInput: depth of input (".concat(l10, ") must ") + "match input depth for filter ".concat(n10.shape[2], ".");
        }), F$(h10 === n10.shape[3], function() {
          return "Error in conv2dDerInput: depth of output (".concat(h10, ") must ") + "match output depth for filter ".concat(n10.shape[3], ".");
        }), K8("conv2dDerInput", a10, o10);
        var p10 = { dy: u10, filter: n10 }, f10 = { strides: r10, pad: a10, dataFormat: i10, dimRoundingMode: o10, inputShape: s10 }, d10 = E5.runKernel(n1, p10, f10);
        return c10 ? X8(d10, [d10.shape[1], d10.shape[2], d10.shape[3]]) : d10;
      } });
      var w7 = B5({ conv2dTranspose_: function(e10, t10, n10, r10, a10, i10) {
        var o10 = L5(e10, "x", "conv2dTranspose"), s10 = L5(t10, "filter", "conv2dTranspose");
        return k7(n10, o10, s10, r10, a10, "NHWC", i10);
      } });
      var I7 = B5({ conv3d_: function(e10, t10, n10, r10) {
        var a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "NDHWC", i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [1, 1, 1], o10 = L5(e10, "x", "conv3d"), s10 = L5(t10, "filter", "conv3d"), u10 = o10, c10 = false;
        4 === o10.rank && (c10 = true, u10 = X8(o10, [1, o10.shape[0], o10.shape[1], o10.shape[2], o10.shape[3]])), F$(5 === u10.rank, function() {
          return "Error in conv3d: input must be rank 5, but got rank ".concat(u10.rank, ".");
        }), F$(5 === s10.rank, function() {
          return "Error in conv3d: filter must be rank 5, but got rank " + "".concat(s10.rank, ".");
        }), F$(u10.shape[4] === s10.shape[3], function() {
          return "Error in conv3d: depth of input (".concat(u10.shape[4], ") must match ") + "input depth for filter ".concat(s10.shape[3], ".");
        }), F$(j8(n10, i10), function() {
          return "Error in conv3D: Either strides or dilations must be 1. " + "Got strides ".concat(n10, " and dilations '").concat(i10, "'");
        }), F$("NDHWC" === a10, function() {
          return "Error in conv3d: got dataFormat of ".concat(a10, " but only NDHWC is currently supported.");
        }), F$(H8(i10), function() {
          return "Error in conv3D: Dilated rates should be larger than 0.";
        }), F$(H8(n10), function() {
          return "Error in conv3D: Strides should be larger than 0.";
        });
        var l10 = { x: u10, filter: s10 }, h10 = { strides: n10, pad: r10, dataFormat: a10, dilations: i10 }, p10 = E5.runKernel(r1, l10, h10);
        return c10 ? X8(p10, [p10.shape[1], p10.shape[2], p10.shape[3], p10.shape[4]]) : p10;
      } });
      var N7 = B5({ conv3DBackpropInput_: function(e10, t10, n10, r10, a10) {
        F$(e10.length === t10.rank, function() {
          return "Length of inShape " + "(".concat(e10.length, ") and rank of dy (").concat(t10.rank, ") must match");
        });
        var i10 = e10, o10 = t10, s10 = false;
        4 === t10.rank && (s10 = true, o10 = X8(t10, [1, t10.shape[0], t10.shape[1], t10.shape[2], t10.shape[3]]), i10 = [1, e10[0], e10[1], e10[2], e10[3]]);
        var u10 = i10[4], c10 = o10.shape[4];
        F$(5 === i10.length, function() {
          return "Error in conv3dDerInput: inShape must be length 5, but got length " + "".concat(i10.length, ".");
        }), F$(5 === o10.rank, function() {
          return "Error in conv3dDerInput: dy must be rank 5, but got " + "rank ".concat(o10.rank);
        }), F$(5 === n10.rank, function() {
          return "Error in conv3dDerInput: filter must be rank 5, but got " + "rank ".concat(n10.rank);
        }), F$(u10 === n10.shape[3], function() {
          return "Error in conv3dDerInput: depth of input (".concat(u10, ") must ") + "match input depth for filter ".concat(n10.shape[3], ".");
        }), F$(c10 === n10.shape[4], function() {
          return "Error in conv3dDerInput: depth of output (".concat(c10, ") must ") + "match output depth for filter ".concat(n10.shape[4], ".");
        });
        var l10 = { dy: o10, filter: n10 }, h10 = { pad: a10, strides: r10, inputShape: i10 }, p10 = E5.runKernel(i1, l10, h10);
        return s10 ? X8(p10, [p10.shape[1], p10.shape[2], p10.shape[3], p10.shape[4]]) : p10;
      } });
      var S7 = B5({ conv3dTranspose_: function(e10, t10, n10, r10, a10) {
        var i10 = L5(e10, "x", "conv3dTranspose"), o10 = L5(t10, "filter", "conv3dTranspose");
        return N7(n10, i10, o10, r10, a10);
      } });
      var T7 = B5({ cos_: function(e10) {
        var t10 = { x: L5(e10, "x", "cos", "float32") };
        return E5.runKernel(o1, t10);
      } });
      var E7 = B5({ cosh_: function(e10) {
        var t10 = { x: L5(e10, "x", "cosh", "float32") };
        return E5.runKernel(s1, t10);
      } });
      var C7 = B5({ cumprod_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a10 = L5(e10, "x", "cumprod"), i10 = { x: a10 }, o10 = { axis: t10, exclusive: n10, reverse: r10 };
        return E5.runKernel(u1, i10, o10);
      } });
      var A7 = B5({ cumsum_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a10 = L5(e10, "x", "cumsum"), i10 = { x: a10 }, o10 = { axis: t10, exclusive: n10, reverse: r10 };
        return E5.runKernel(c1, i10, o10);
      } });
      var R7 = B5({ denseBincount_: function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a10 = L5(e10, "x", "denseBincount"), i10 = L5(t10, "weights", "denseBincount");
        F$("int32" === a10.dtype, function() {
          return "Error in denseBincount: input " + "dtype must be int32, but got ".concat(a10.dtype);
        }), F$(a10.rank <= 2, function() {
          return "Error in denseBincount: input must be at most rank 2, but got " + "rank ".concat(a10.rank, ".");
        }), F$(n10 >= 0, function() {
          return "size must be non-negative, but got ".concat(n10, ".");
        }), F$(i10.size === a10.size || 0 === i10.size, function() {
          return "Error in denseBincount: weights must have the same shape as x or " + "0-length, but got x shape: ".concat(a10.shape, ", weights shape: ") + "".concat(i10.shape, ".");
        });
        var o10 = { x: a10, weights: i10 }, s10 = { size: n10, binaryOutput: r10 };
        return E5.runKernel(h1, o10, s10);
      } });
      var _7 = B5({ depthToSpace_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "NHWC", r10 = L5(e10, "x", "depthToSpace", "float32"), a10 = "NHWC" === n10 ? r10.shape[1] : r10.shape[2], i10 = "NHWC" === n10 ? r10.shape[2] : r10.shape[3], o10 = "NHWC" === n10 ? r10.shape[3] : r10.shape[1];
        F$(t10 > 1, function() {
          return "blockSize should be > 1 for depthToSpace, but was: ".concat(t10);
        }), F$(a10 * t10 >= 0, function() {
          return "Negative dimension size caused by overflow when multiplying\n    ".concat(a10, " and ").concat(t10, "  for depthToSpace with input shape\n    ").concat(r10.shape);
        }), F$(i10 * t10 >= 0, function() {
          return "Negative dimension size caused by overflow when multiplying\n    ".concat(i10, " and ").concat(t10, " for depthToSpace with input shape\n        ").concat(r10.shape);
        }), F$(o10 % (t10 * t10) == 0, function() {
          return "Dimension size must be evenly divisible by ".concat(t10 * t10, " but is ").concat(o10, " for depthToSpace with input shape ").concat(r10.shape);
        });
        var s10 = { x: r10 }, u10 = { blockSize: t10, dataFormat: n10 };
        return E5.runKernel(p1, s10, u10);
      } });
      var O7 = B5({ depthwiseConv2d_: function(e10, t10, n10, r10) {
        var a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "NHWC", i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [1, 1], o10 = arguments.length > 6 ? arguments[6] : void 0, s10 = L5(e10, "x", "depthwiseConv2d", "float32"), u10 = L5(t10, "filter", "depthwiseConv2d", "float32"), c10 = s10, l10 = false;
        3 === s10.rank && (l10 = true, c10 = X8(s10, [1, s10.shape[0], s10.shape[1], s10.shape[2]])), F$(4 === c10.rank, function() {
          return "Error in depthwiseConv2d: input must be rank 4, but got " + "rank ".concat(c10.rank, ".");
        }), F$(4 === u10.rank, function() {
          return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + "".concat(u10.rank, ".");
        });
        var h10 = "NHWC" === a10 ? c10.shape[3] : c10.shape[1];
        F$(h10 === u10.shape[2], function() {
          return "Error in depthwiseConv2d: number of input channels " + "(".concat(h10, ") must match the inChannels dimension in ") + "filter ".concat(u10.shape[2], ".");
        }), K8("depthwiseConv2d", r10, o10);
        var p10 = { x: c10, filter: u10 }, f10 = { strides: n10, pad: r10, dataFormat: a10, dilations: i10, dimRoundingMode: o10 }, d10 = E5.runKernel(f1, p10, f10);
        return l10 ? X8(d10, [d10.shape[1], d10.shape[2], d10.shape[3]]) : d10;
      } });
      var F7 = B5({ diag_: function(e10) {
        var t10 = { x: L5(e10, "x", "diag") };
        return E5.runKernel(m1, t10);
      } });
      var D7 = B5({ dilation2d_: function(e10, t10, n10, r10) {
        var a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [1, 1], i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "NHWC", o10 = L5(e10, "x", "dilation2d"), s10 = L5(t10, "filter", "dilation2d");
        F$(3 === o10.rank || 4 === o10.rank, function() {
          return "Error in dilation2d: input must be rank 3 or 4, but got rank " + "".concat(o10.rank, ".");
        }), F$(3 === s10.rank, function() {
          return "Error in dilation2d: filter must be rank 3, but got rank " + "".concat(s10.rank, ".");
        }), F$("NHWC" === i10, function() {
          return "Error in dilation2d: Only NHWC is currently supported, " + "but got dataFormat of ".concat(i10);
        });
        var u10 = o10, c10 = false;
        3 === o10.rank && (u10 = X8(o10, [1, o10.shape[0], o10.shape[1], o10.shape[2]]), c10 = true), F$(u10.shape[3] === s10.shape[2], function() {
          return "Error in dilation2d:  input and filter must have the same depth: ".concat(u10.shape[3], " vs ").concat(s10.shape[2]);
        });
        var l10 = { x: u10, filter: s10 }, h10 = { strides: n10, pad: r10, dilations: a10 }, p10 = E5.runKernel(g1, l10, h10);
        return c10 ? X8(p10, [p10.shape[1], p10.shape[2], p10.shape[3]]) : p10;
      } });
      function M7(e10, t10) {
        for (var n10 = e10.length, r10 = [], a10 = 0; a10 < n10; a10++) {
          var i10 = n10 - 1 - a10, o10 = e10[i10] || 1;
          (t10[t10.length - 1 - a10] || 1) > 1 && 1 === o10 && r10.unshift(i10);
        }
        return r10;
      }
      function L7(e10, t10) {
        for (var n10 = [], r10 = 0; r10 < t10.length; r10++) {
          var a10 = e10[e10.length - r10 - 1], i10 = t10.length - r10 - 1, o10 = t10[i10];
          (null == a10 || 1 === a10 && o10 > 1) && n10.unshift(i10);
        }
        return n10;
      }
      function z7(e10, t10) {
        for (var n10 = Math.max(e10.length, t10.length), r10 = new Array(n10), a10 = 0; a10 < n10; a10++) {
          var i10 = e10[e10.length - a10 - 1];
          null == i10 && (i10 = 1);
          var o10 = t10[t10.length - a10 - 1];
          if (null == o10 && (o10 = 1), 1 === i10) r10[n10 - a10 - 1] = o10;
          else if (1 === o10) r10[n10 - a10 - 1] = i10;
          else {
            if (i10 !== o10) {
              var s10 = "Operands could not be broadcast together with shapes " + "".concat(e10, " and ").concat(t10, ".");
              throw Error(s10);
            }
            r10[n10 - a10 - 1] = i10;
          }
        }
        return r10;
      }
      var P7 = { __proto__: null, assertAndGetBroadcastShape: z7, getBroadcastDims: M7, getReductionAxes: L7 };
      var B7 = B5({ equal_: function(e10, t10) {
        var n10 = L5(e10, "a", "equal", "string_or_numeric"), r10 = L5(t10, "b", "equal", "string_or_numeric"), a10 = S(v5(n10, r10), 2);
        n10 = a10[0], r10 = a10[1], z7(n10.shape, r10.shape);
        var i10 = { a: n10, b: r10 };
        return E5.runKernel(T1, i10);
      } });
      var W7 = B5({ where_: function(e10, t10, n10) {
        var r10 = L5(t10, "a", "where"), a10 = L5(n10, "b", "where"), i10 = L5(e10, "condition", "where", "bool"), o10 = z7(z7(i10.shape, r10.shape), a10.shape), s10 = { condition: h7(i10, o10), t: h7(r10, o10), e: h7(a10, o10) };
        return E5.runKernel(Y2, s10);
      } });
      var U7 = B5({ zerosLike_: function(e10) {
        var t10 = { x: L5(e10, "x", "zerosLike") };
        return E5.runKernel(R3, t10);
      } });
      var V7 = B5({ divNoNan_: function(e10, t10) {
        var n10 = L5(e10, "a", "div"), r10 = L5(t10, "b", "div"), a10 = S(v5(n10, r10), 2);
        n10 = a10[0], r10 = a10[1];
        var i10 = m8(n10, r10), o10 = U7(i10), s10 = B7(r10, o10);
        return W7(s10, o10, i10);
      } });
      var G7 = B5({ dot_: function(e10, t10) {
        var n10 = L5(e10, "t1", "dot"), r10 = L5(t10, "t2", "dot");
        F$(!(1 !== n10.rank && 2 !== n10.rank || 1 !== r10.rank && 2 !== r10.rank), function() {
          return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + "".concat(n10.rank, " and ").concat(r10.rank, ".");
        });
        var a10 = 1 === n10.rank ? n10.size : n10.shape[1], i10 = 1 === r10.rank ? r10.size : r10.shape[0];
        if (F$(a10 === i10, function() {
          return "Error in dot: inner dimensions of inputs must match, but got " + "".concat(a10, " and ").concat(i10, ".");
        }), 1 === n10.rank && 1 === r10.rank) {
          var o10 = X8(n10, [1, -1]), s10 = X8(r10, [-1, 1]), u10 = Q8(o10, s10);
          return X8(u10, []);
        }
        if (1 === n10.rank && 2 === r10.rank) {
          var c10 = X8(n10, [1, -1]), l10 = X8(r10, [r10.shape[0], r10.shape[1]]), h10 = Q8(c10, l10);
          return X8(h10, [h10.size]);
        }
        if (2 === n10.rank && 1 === r10.rank) {
          var p10 = X8(r10, [-1, 1]), f10 = Q8(n10, p10);
          return X8(f10, [f10.size]);
        }
        var d10 = X8(r10, [r10.shape[0], r10.shape[1]]);
        return Q8(n10, d10);
      } });
      var j7 = B5({ einsum_: function(e10) {
        for (var t10 = arguments.length, n10 = new Array(t10 > 1 ? t10 - 1 : 0), r10 = 1; r10 < t10; r10++) n10[r10 - 1] = arguments[r10];
        var a10 = n10.map(function(e11, t11) {
          return L5(e11, "tensors".concat(t11), "einsum");
        }), i10 = { equation: e10 };
        return E5.runKernel(w1, a10, i10);
      } });
      var H7 = B5({ elu_: function(e10) {
        var t10 = { x: L5(e10, "x", "elu", "float32") };
        return E5.runKernel(I1, t10);
      } });
      var q7 = B5({ ensureShape_: function(e10, t10) {
        var n10 = L5(e10, "x", "ensureShape", "string_or_numeric");
        if (!z$(n10.shape, t10)) throw new Error("EnsureShape: Shape of tensor ".concat(n10.shape, " is not compatible with expected shape ").concat(t10));
        return e10;
      } });
      var K7 = B5({ erf_: function(e10) {
        var t10 = L5(e10, "x", "erf");
        F$("int32" === t10.dtype || "float32" === t10.dtype, function() {
          return "Input dtype must be `int32` or `float32`.";
        }), "int32" === t10.dtype && (t10 = h8(t10, "float32"));
        var n10 = { x: t10 };
        return E5.runKernel(S1, n10);
      } });
      function X7(e10, t10) {
        for (var n10 = 0; n10 < e10.length; ++n10) if (e10[e10.length - n10 - 1] !== t10 - 1 - n10) return false;
        return true;
      }
      function Y7(e10, t10, n10) {
        for (var r10 = e10.length + t10.length, a10 = [], i10 = 0, o10 = 0, s10 = 0; s10 < r10; s10++) -1 === n10.indexOf(s10) ? a10.push(e10[i10++]) : a10.push(t10[o10++]);
        return a10;
      }
      function J7(e10, t10) {
        for (var n10 = [], r10 = e10.length, a10 = 0; a10 < r10; a10++) -1 === t10.indexOf(a10) && n10.push(e10[a10]);
        var i10 = t10.map(function(t11) {
          return e10[t11];
        });
        return [n10, i10];
      }
      function Z7(e10, t10) {
        return Y7(e10, t10.map(function(e11) {
          return 1;
        }), t10);
      }
      function Q7(e10, t10, n10) {
        F$(X7(t10, n10), function() {
          return "".concat(e10, " supports only inner-most axes for now. ") + "Got axes ".concat(t10, " and rank-").concat(n10, " input.");
        });
      }
      function $7(e10, t10) {
        if (X7(e10, t10)) return null;
        for (var n10 = [], r10 = 0; r10 < t10; ++r10) -1 === e10.indexOf(r10) && n10.push(r10);
        return e10.forEach(function(e11) {
          return n10.push(e11);
        }), n10;
      }
      function e9(e10) {
        return e10.map(function(e11, t10) {
          return [t10, e11];
        }).sort(function(e11, t10) {
          return e11[1] - t10[1];
        }).map(function(e11) {
          return e11[0];
        });
      }
      function t9(e10, t10) {
        for (var n10 = [], r10 = t10 - e10; r10 < t10; ++r10) n10.push(r10);
        return n10;
      }
      var n9 = B5({ max_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r10 = L5(e10, "x", "max"), a10 = { x: r10 }, i10 = { reductionIndices: t10, keepDims: n10 };
        return E5.runKernel(a2, a10, i10);
      } });
      var r9 = B5({ min_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r10 = L5(e10, "x", "min"), a10 = { x: r10 }, i10 = { axis: t10, keepDims: n10 };
        return E5.runKernel(p2, a10, i10);
      } });
      var a9 = B5({ pow_: function(e10, t10) {
        var n10 = L5(e10, "base", "pow"), r10 = L5(t10, "exp", "pow"), a10 = S(v5(n10, r10), 2), i10 = { a: n10 = a10[0], b: r10 = a10[1] };
        return E5.runKernel(E2, i10);
      } });
      function i9(e10, t10) {
        if ((U4(e10) && "string" !== t10 || Array.isArray(e10)) && "complex64" !== t10) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
        if ("string" === t10 && U4(e10) && !(e10 instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
        return U5(e10, [], [], t10);
      }
      var o9 = B5({ sqrt_: function(e10) {
        var t10 = { x: L5(e10, "x", "sqrt", "float32") };
        return E5.runKernel(r3, t10);
      } });
      var s9 = B5({ square_: function(e10) {
        var t10 = L5(e10, "x", "square");
        return E5.runKernel("Square", { x: t10 }, {});
      } });
      var u9 = B5({ sum_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r10 = L5(e10, "x", "sum");
        "bool" === r10.dtype && (r10 = h8(r10, "int32"));
        var a10 = { x: r10 }, i10 = { axis: t10, keepDims: n10 };
        return E5.runKernel(a3, a10, i10);
      } });
      function c9(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
        if (0 === e10.rank) return y8(e10);
        if (1 !== e10.rank && null === n10) return c9(X8(e10, [-1]), t10, n10);
        if (1 === e10.rank || "number" == typeof n10 || Array.isArray(n10) && 1 === n10.length) {
          if (1 === t10) return u9(y8(e10), n10);
          if (t10 === 1 / 0) return n9(y8(e10), n10);
          if (t10 === -1 / 0) return r9(y8(e10), n10);
          if ("euclidean" === t10 || 2 === t10) return o9(u9(a9(y8(e10), i9(2, "int32")), n10));
          throw new Error("Error in norm: invalid ord value: ".concat(t10));
        }
        if (Array.isArray(n10) && 2 === n10.length) {
          if (1 === t10) return n9(u9(y8(e10), n10[0]), n10[1] - 1);
          if (t10 === 1 / 0) return n9(u9(y8(e10), n10[1]), n10[0]);
          if (t10 === -1 / 0) return r9(u9(y8(e10), n10[1]), n10[0]);
          if ("fro" === t10 || "euclidean" === t10) return o9(u9(s9(e10), n10));
          throw new Error("Error in norm: invalid ord value: ".concat(t10));
        }
        throw new Error("Error in norm: invalid axis: ".concat(n10));
      }
      var l9 = B5({ norm_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "euclidean", n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a10 = c9(e10 = L5(e10, "x", "norm"), t10, n10), i10 = a10.shape;
        if (r10) {
          var o10 = j$(n10, e10.shape);
          i10 = Z7(a10.shape, o10);
        }
        return X8(a10, i10);
      } });
      var h9 = B5({ euclideanNorm_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return l9(e10, "euclidean", t10, n10);
      } });
      var p9 = B5({ exp_: function(e10) {
        var t10 = { x: L5(e10, "x", "exp") };
        return E5.runKernel(E1, t10);
      } });
      var f9 = B5({ expandDims_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n10 = L5(e10, "x", "expandDims", "string_or_numeric");
        F$(t10 <= n10.rank, function() {
          return "Axis must be <= rank of the tensor";
        });
        var r10 = { input: n10 }, a10 = { dim: t10 };
        return E5.runKernel(C1, r10, a10);
      } });
      var d9 = B5({ expm1_: function(e10) {
        var t10 = { x: L5(e10, "x", "expm1") };
        return E5.runKernel(A1, t10);
      } });
      var v9 = B5({ tile_: function(e10, t10) {
        var n10 = L5(e10, "x", "tile", "string_or_numeric");
        F$(n10.rank === t10.length, function() {
          return "Error in transpose: rank of input ".concat(n10.rank, " ") + "must match length of reps ".concat(t10, ".");
        });
        var r10 = { x: n10 }, a10 = { reps: t10 };
        return E5.runKernel(I3, r10, a10);
      } });
      var m9 = B5({ eye_: function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "float32";
        null == t10 && (t10 = e10);
        for (var a10 = l8([e10, t10], r10), i10 = e10 <= t10 ? e10 : t10, o10 = 0; o10 < i10; ++o10) a10.set(1, o10, o10);
        var s10 = X8(a10.toTensor(), [e10, t10]);
        if (null == n10) return s10;
        if (1 === n10.length) return v9(f9(s10, 0), [n10[0], 1, 1]);
        if (2 === n10.length) return v9(f9(f9(s10, 0), 0), [n10[0], n10[1], 1, 1]);
        if (3 === n10.length) return v9(f9(f9(f9(s10, 0), 0), 0), [n10[0], n10[1], n10[2], 1, 1]);
        throw new Error("eye() currently supports only 1D and 2D " + "batchShapes, but received ".concat(n10.length, "D."));
      } });
      var g9 = B5({ floor_: function(e10) {
        var t10 = { x: L5(e10, "x", "floor", "float32") };
        return E5.runKernel(F1, t10);
      } });
      var y9 = B5({ gather_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, a10 = L5(e10, "x", "gather"), i10 = L5(t10, "indices", "gather", "int32"), o10 = { x: a10, indices: i10 }, s10 = { axis: n10, batchDims: r10 };
        return E5.runKernel(L1, o10, s10);
      } });
      var b9 = B5({ greater_: function(e10, t10) {
        var n10 = L5(e10, "a", "greater", "string_or_numeric"), r10 = L5(t10, "b", "greater", "string_or_numeric"), a10 = S(v5(n10, r10), 2);
        n10 = a10[0], r10 = a10[1], z7(n10.shape, r10.shape);
        var i10 = { a: n10, b: r10 };
        return E5.runKernel(P1, i10);
      } });
      var x9 = B5({ greaterEqual_: function(e10, t10) {
        var n10 = L5(e10, "a", "greaterEqual", "string_or_numeric"), r10 = L5(t10, "b", "greaterEqual", "string_or_numeric"), a10 = S(v5(n10, r10), 2);
        n10 = a10[0], r10 = a10[1], z7(n10.shape, r10.shape);
        var i10 = { a: n10, b: r10 };
        return E5.runKernel(B1, i10);
      } });
      var k9 = B5({ imag_: function(e10) {
        var t10 = { input: L5(e10, "input", "imag") };
        return E5.runKernel(V1, t10);
      } });
      var w9 = B5({ isFinite_: function(e10) {
        var t10 = { x: L5(e10, "x", "isFinite") };
        return E5.runKernel(G1, t10);
      } });
      var I9 = B5({ isInf_: function(e10) {
        var t10 = { x: L5(e10, "x", "isInf") };
        return E5.runKernel(j1, t10);
      } });
      var N9 = B5({ isNaN_: function(e10) {
        var t10 = { x: L5(e10, "x", "isNaN") };
        return E5.runKernel(H1, t10);
      } });
      var S9 = B5({ leakyRelu_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.2, n10 = L5(e10, "x", "leakyRelu"), r10 = { x: n10 }, a10 = { alpha: t10 };
        return E5.runKernel(q1, r10, a10);
      } });
      var T9 = B5({ less_: function(e10, t10) {
        var n10 = L5(e10, "a", "less", "string_or_numeric"), r10 = L5(t10, "b", "less", "string_or_numeric"), a10 = S(v5(n10, r10), 2);
        n10 = a10[0], r10 = a10[1], z7(n10.shape, r10.shape);
        var i10 = { a: n10, b: r10 };
        return E5.runKernel(K1, i10);
      } });
      var E9 = B5({ lessEqual_: function(e10, t10) {
        var n10 = L5(e10, "a", "lessEqual", "string_or_numeric"), r10 = L5(t10, "b", "lessEqual", "string_or_numeric"), a10 = S(v5(n10, r10), 2);
        n10 = a10[0], r10 = a10[1], z7(n10.shape, r10.shape);
        var i10 = { a: n10, b: r10 };
        return E5.runKernel(X1, i10);
      } });
      function C9(e10, t10, n10) {
        if (n10 <= 0) throw new Error("The number of values should be positive.");
        var r10 = { start: e10, stop: t10, num: n10 };
        return E5.runKernel(Y1, {}, r10);
      }
      var A9 = B5({ localResponseNormalization_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5, n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0.5, i10 = L5(e10, "x", "localResponseNormalization");
        F$(4 === i10.rank || 3 === i10.rank, function() {
          return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(i10.rank, ".");
        }), F$(B$(t10), function() {
          return "Error in localResponseNormalization: depthRadius must be an " + "integer but got depthRadius ".concat(t10, ".");
        });
        var o10 = i10, s10 = false;
        3 === i10.rank && (s10 = true, o10 = X8(i10, [1, i10.shape[0], i10.shape[1], i10.shape[2]]));
        var u10 = { x: o10 }, c10 = { depthRadius: t10, bias: n10, alpha: r10, beta: a10 }, l10 = E5.runKernel(n2, u10, c10);
        return s10 ? X8(l10, [l10.shape[1], l10.shape[2], l10.shape[3]]) : l10;
      } });
      var R9 = B5({ log_: function(e10) {
        var t10 = { x: L5(e10, "x", "log", "float32") };
        return E5.runKernel(J1, t10);
      } });
      var _9 = B5({ log1p_: function(e10) {
        var t10 = { x: L5(e10, "x", "log1p") };
        return E5.runKernel(Z1, t10);
      } });
      function O9(e10, t10) {
        F$(r0(e10), function() {
          return "The f passed in variableGrads(f) must be a function";
        }), F$(null == t10 || Array.isArray(t10) && t10.every(function(e11) {
          return e11 instanceof c5;
        }), function() {
          return "The varList passed in variableGrads(f, varList) must be an array of variables";
        });
        var n10 = null != t10;
        if (!n10) for (var r10 in t10 = [], E5.registeredVariables) t10.push(E5.registeredVariables[r10]);
        var a10 = n10 ? t10.filter(function(e11) {
          return !e11.trainable;
        }) : null, i10 = t10.length;
        t10 = t10.filter(function(e11) {
          return e11.trainable;
        }), F$(t10.length > 0, function() {
          return "variableGrads() expects at least one of the input variables to " + "be trainable, but none of the ".concat(i10, " variables is ") + "trainable.";
        });
        var o10 = E5.gradients(e10, t10, null, true), s10 = o10.value, u10 = o10.grads;
        F$(u10.some(function(e11) {
          return null != e11;
        }), function() {
          return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
        }), F$(0 === s10.rank, function() {
          return "The f passed in variableGrads(f) must return a scalar, but it " + "returned a rank-".concat(s10.rank, " tensor");
        });
        var c10 = {};
        return t10.forEach(function(e11, t11) {
          null != u10[t11] && (c10[e11.name] = u10[t11]);
        }), null != a10 && a10.forEach(function(e11) {
          return c10[e11.name] = null;
        }), { value: s10, grads: c10 };
      }
      function F9(e10) {
        return E5.customGrad(e10);
      }
      function D9(e10) {
        if (e10.filter(function(e11) {
          return null == e11;
        }).length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
      }
      var M9 = B5({ neg_: function(e10) {
        var t10 = { x: L5(e10, "x", "neg") };
        return E5.runKernel(y2, t10);
      } });
      var L9 = B5({ softplus_: function(e10) {
        var t10 = { x: L5(e10, "x", "softplus") };
        return E5.runKernel(n3, t10);
      } });
      var z9 = B5({ logSigmoid_: function(e10) {
        var t10 = L5(e10, "x", "logSigmoid"), n10 = F9(function(e11) {
          return { value: M9(L9(M9(e11))), gradFunc: function(t11) {
            return g8(t11, $8(M9(e11)));
          } };
        });
        return n10(t10);
      } });
      var P9 = B5({ sub_: function(e10, t10) {
        var n10 = L5(e10, "a", "sub"), r10 = L5(t10, "b", "sub"), a10 = S(v5(n10, r10), 2), i10 = { a: n10 = a10[0], b: r10 = a10[1] };
        return E5.runKernel(x3, i10);
      } });
      var B9 = B5({ logSoftmax_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1, n10 = L5(e10, "logits", "logSoftmax");
        if (-1 === t10 && (t10 = n10.rank - 1), t10 !== n10.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. " + "Logits was rank ".concat(n10.rank, " and axis was ").concat(t10));
        var r10 = F9(function(e11, n11) {
          var r11 = n9(e11, t10, true), a10 = P9(e11, r11), i10 = P9(h8(a10, "float32"), R9(u9(p9(a10), t10, true)));
          n11([i10]);
          return { value: i10, gradFunc: function(e12, n12) {
            var r12 = S(n12, 1)[0], a11 = p9(r12);
            return P9(e12, g8(u9(e12, t10, true), a11));
          } };
        });
        return r10(n10);
      } });
      var W9 = B5({ logSumExp_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r10 = L5(e10, "x", "logSumExp"), a10 = j$(t10, r10.shape), i10 = n9(r10, a10, true), o10 = P9(r10, i10), s10 = p9(o10), u10 = u9(s10, a10), c10 = R9(u10), l10 = d8(X8(i10, c10.shape), c10);
        if (n10) {
          var h10 = Z7(l10.shape, a10);
          return X8(l10, h10);
        }
        return l10;
      } });
      var U9 = B5({ logicalAnd_: function(e10, t10) {
        var n10 = L5(e10, "a", "logicalAnd", "bool"), r10 = L5(t10, "b", "logicalAnd", "bool");
        z7(n10.shape, r10.shape);
        var a10 = { a: n10, b: r10 };
        return E5.runKernel(Q1, a10);
      } });
      var V9 = B5({ logicalNot_: function(e10) {
        var t10 = { x: L5(e10, "x", "logicalNot", "bool") };
        return E5.runKernel($1, t10);
      } });
      var G9 = B5({ logicalOr_: function(e10, t10) {
        var n10 = L5(e10, "a", "logicalOr", "bool"), r10 = L5(t10, "b", "logicalOr", "bool");
        z7(n10.shape, r10.shape);
        var a10 = { a: n10, b: r10 };
        return E5.runKernel(e2, a10);
      } });
      var j9 = B5({ logicalXor_: function(e10, t10) {
        var n10 = L5(e10, "a", "logicalXor", "bool"), r10 = L5(t10, "b", "logicalXor", "bool");
        return z7(n10.shape, r10.shape), U9(G9(e10, t10), V9(U9(e10, t10)));
      } }), H9 = 2147483648;
      var q9 = B5({ searchSorted_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "left", r10 = L5(e10, "sortedSequence", "searchSorted"), a10 = L5(t10, "values", "searchSorted"), i10 = r10.shape[r10.shape.length - 1], o10 = a10.shape[a10.shape.length - 1], s10 = X8(r10, [-1, i10]), u10 = X8(a10, [-1, o10]);
        if (s10.rank < 2) throw new Error("Sorted input argument must be at least 2-dimensional");
        if (s10.shape[0] !== u10.shape[0]) throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");
        if (L$(u10.shape) >= H9) throw new Error("values tensor size must less than ".concat(H9));
        if (s10.shape[1] >= H9) throw new Error("trailing dim_size must less than ".concat(H9, " for int32 output type, was ").concat(s10.shape[1]));
        var c10 = { sortedSequence: s10, values: u10 }, l10 = { side: n10 };
        return E5.runKernel(X2, c10, l10);
      } });
      function K9(e10, t10) {
        return q9(e10, t10, "left");
      }
      var X9 = B5({ maxPool_: function(e10, t10, n10, r10, a10) {
        var i10 = L5(e10, "x", "maxPool"), o10 = i10, s10 = false;
        3 === i10.rank && (s10 = true, o10 = X8(i10, [1, i10.shape[0], i10.shape[1], i10.shape[2]])), F$(4 === o10.rank, function() {
          return "Error in maxPool: input must be rank 4 but got rank ".concat(o10.rank, ".");
        }), F$(j8(n10, 1), function() {
          return "Error in maxPool: Either strides or dilations must be 1. " + "Got strides ".concat(n10, " and dilations '").concat(1, "'");
        }), K8("maxPool", r10, a10);
        var u10 = { x: o10 }, c10 = { filterSize: t10, strides: n10, pad: r10, dimRoundingMode: a10 }, l10 = E5.runKernel(o2, u10, c10);
        return s10 ? X8(l10, [l10.shape[1], l10.shape[2], l10.shape[3]]) : l10;
      } });
      var Y9 = B5({ maxPool3d_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [1, 1, 1], n10 = arguments.length > 2 ? arguments[2] : void 0, r10 = arguments.length > 3 ? arguments[3] : void 0, a10 = arguments.length > 4 ? arguments[4] : void 0, i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "NDHWC", o10 = L5(e10, "x", "maxPool3d"), s10 = o10, u10 = false;
        4 === o10.rank && (u10 = true, s10 = X8(o10, [1, o10.shape[0], o10.shape[1], o10.shape[2], o10.shape[3]])), F$(5 === s10.rank, function() {
          return "Error in maxPool3d: x must be rank 5 but got rank ".concat(s10.rank, ".");
        }), F$("NDHWC" === i10, function() {
          return "Error in maxPool3d: Only NDHWC is currently supported, " + "but got dataFormat of ".concat(i10);
        }), K8("maxPool3d", r10, a10);
        var c10 = { x: s10 }, l10 = { filterSize: t10, strides: n10, pad: r10, dimRoundingMode: a10, dataFormat: i10 }, h10 = E5.runKernel(u2, c10, l10);
        return u10 ? X8(h10, [h10.shape[1], h10.shape[2], h10.shape[3], h10.shape[4]]) : h10;
      } });
      var J9 = B5({ maxPoolWithArgmax_: function(e10, t10, n10, r10) {
        var a10 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], i10 = L5(e10, "x", "maxPoolWithArgmax"), o10 = { x: i10 }, s10 = { filterSize: t10, strides: n10, pad: r10, includeBatchInIndex: a10 }, u10 = E5.runKernel(l2, o10, s10);
        return { result: u10[0], indexes: u10[1] };
      } });
      var Z9 = B5({ maximum_: function(e10, t10) {
        var n10 = L5(e10, "a", "maximum"), r10 = L5(t10, "b", "maximum"), a10 = S(v5(n10, r10), 2);
        n10 = a10[0], r10 = a10[1], "bool" === n10.dtype && (n10 = h8(n10, "int32"), r10 = h8(r10, "int32")), z7(n10.shape, r10.shape);
        var i10 = { a: n10, b: r10 };
        return E5.runKernel(i2, i10);
      } });
      var Q9 = B5({ mean_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r10 = L5(e10, "x", "mean"), a10 = { x: r10 }, i10 = { axis: t10, keepDims: n10 };
        return E5.runKernel(h2, a10, i10);
      } });
      function $9(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "float32";
        if (p0(e10), "complex64" === t10) {
          var n10 = $9(e10, "float32"), r10 = $9(e10, "float32");
          return W5(n10, r10);
        }
        var a10 = l0(L$(e10), t10);
        return E5.makeTensor(a10, e10, t10);
      }
      function eee(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "float32";
        if (p0(e10), "complex64" === t10) {
          var n10 = eee(e10, "float32"), r10 = $9(e10, "float32");
          return W5(n10, r10);
        }
        var a10 = c0(L$(e10), t10);
        return E5.makeTensor(a10, e10, t10);
      }
      function tee(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r10 = n10.indexing, a10 = void 0 === r10 ? "xy" : r10;
        if ("xy" !== a10 && "ij" !== a10) throw new TypeError("".concat(a10, " is not a valid third argument to meshgrid"));
        if (void 0 === e10) return [];
        var i10 = L5(e10, "x", "meshgrid", e10 instanceof n5 ? e10.dtype : "float32");
        if (void 0 === t10) return [i10];
        var o10 = L5(t10, "y", "meshgrid", t10 instanceof n5 ? t10.dtype : "float32"), s10 = L$(i10.shape), u10 = L$(o10.shape);
        return "xy" === a10 ? (i10 = X8(i10, [1, -1]), o10 = X8(o10, [-1, 1]), [Q8(eee([u10, 1], i10.dtype), i10), Q8(o10, eee([1, s10], o10.dtype))]) : (i10 = X8(i10, [-1, 1]), o10 = X8(o10, [1, -1]), [Q8(i10, eee([1, u10], i10.dtype)), Q8(eee([s10, 1], o10.dtype), o10)]);
      }
      var nee = B5({ minimum_: function(e10, t10) {
        var n10 = L5(e10, "a", "minimum"), r10 = L5(t10, "b", "minimum"), a10 = S(v5(n10, r10), 2);
        n10 = a10[0], r10 = a10[1], "bool" === n10.dtype && (n10 = h8(n10, "int32"), r10 = h8(r10, "int32")), z7(n10.shape, r10.shape);
        var i10 = { a: n10, b: r10 };
        return E5.runKernel(f2, i10);
      } });
      var ree = B5({ mirrorPad_: function(e10, t10, n10) {
        F$("reflect" === n10 || "symmetric" === n10, function() {
          return "Invalid mode. Mode must be either reflect or symmetric. " + "Got ".concat(n10, ".");
        });
        var r10 = L5(e10, "x", "mirrorPad");
        if (0 === r10.rank) throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
        F$(t10.length === r10.rank, function() {
          return "Padding doesn't match input. Must be ".concat(r10.rank, ". ") + "Got ".concat(t10.length, ".");
        });
        for (var a10 = "reflect" === n10 ? 1 : 0, i10 = function(e11) {
          F$(2 === t10[e11].length, function() {
            return "Invalid number of paddings. Must be length of 2 each.";
          }), F$(t10[e11][0] >= 0 && t10[e11][0] <= r10.shape[e11] - a10 && t10[e11][1] >= 0 && t10[e11][1] <= r10.shape[e11] - a10, function() {
            return "Padding in dimension ".concat(e11, " cannot be greater than or equal ") + "to ".concat(r10.shape[e11] - a10, " or less than 0 for input of ") + "shape ".concat(r10.shape);
          });
        }, o10 = 0; o10 < r10.rank; o10++) i10(o10);
        var s10 = { paddings: t10, mode: n10 }, u10 = { x: r10 };
        return E5.runKernel(d2, u10, s10);
      } });
      var aee = B5({ mod_: function(e10, t10) {
        var n10 = L5(e10, "a", "mod"), r10 = L5(t10, "b", "mod"), a10 = S(v5(n10, r10), 2), i10 = { a: n10 = a10[0], b: r10 = a10[1] };
        return E5.runKernel(v2, i10);
      } });
      var iee = B5({ moments_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r10 = j$(t10, (e10 = L5(e10, "x", "moments")).shape), a10 = Q9(e10, r10, n10), i10 = a10.shape;
        n10 || (i10 = Z7(a10.shape, r10));
        var o10 = s9(P9(h8(e10, "float32"), X8(a10, i10))), s10 = Q9(o10, r10, n10);
        return { mean: a10, variance: s10 };
      } });
      var oee = B5({ multiRNNCell_: function(e10, t10, n10, r10) {
        for (var a10 = L5(t10, "data", "multiRNNCell"), i10 = z5(n10, "c", "multiRNNCell"), o10 = z5(r10, "h", "multiRNNCell"), s10 = a10, u10 = [], c10 = 0; c10 < e10.length; c10++) {
          var l10 = e10[c10](s10, i10[c10], o10[c10]);
          u10.push(l10[0]), u10.push(l10[1]), s10 = l10[1];
        }
        for (var h10 = [], p10 = [], f10 = 0; f10 < u10.length; f10 += 2) h10.push(u10[f10]), p10.push(u10[f10 + 1]);
        return [h10, p10];
      } });
      var see = B5({ multinomial_: function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a10 = L5(e10, "logits", "multinomial"), i10 = a10.size, o10 = a10.rank;
        if (i10 < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + "".concat(i10, "."));
        if (o10 > 2) throw new Error("Rank of probabilities must be 1 or 2, but is ".concat(o10));
        n10 = n10 || Math.random();
        var s10 = 1 === o10 ? X8(a10, [1, -1]) : a10, u10 = { logits: s10 }, c10 = { numSamples: t10, seed: n10, normalized: r10 }, l10 = E5.runKernel(m2, u10, c10);
        return 1 === o10 ? X8(l10, [l10.size]) : l10;
      } });
      var uee = B5({ notEqual_: function(e10, t10) {
        var n10 = L5(e10, "a", "notEqual", "string_or_numeric"), r10 = L5(t10, "b", "notEqual", "string_or_numeric"), a10 = S(v5(n10, r10), 2);
        n10 = a10[0], r10 = a10[1], z7(n10.shape, r10.shape);
        var i10 = { a: n10, b: r10 };
        return E5.runKernel(b2, i10);
      } });
      var cee = B5({ oneHot_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "int32";
        if (t10 < 2) throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t10));
        var i10 = L5(e10, "indices", "oneHot", "int32"), o10 = { indices: i10 }, s10 = { dtype: a10, depth: t10, onValue: n10, offValue: r10 };
        return E5.runKernel(N2, o10, s10);
      } });
      var lee = B5({ onesLike_: function(e10) {
        var t10 = { x: L5(e10, "x", "onesLike") };
        return E5.runKernel(I2, t10);
      } });
      var hee = B5({ outerProduct_: function(e10, t10) {
        var n10 = L5(e10, "v1", "outerProduct"), r10 = L5(t10, "v2", "outerProduct");
        F$(1 === n10.rank && 1 === r10.rank, function() {
          return "Error in outerProduct: inputs must be rank 1, but got ranks " + "".concat(n10.rank, " and ").concat(r10.rank, ".");
        });
        var a10 = X8(n10, [-1, 1]), i10 = X8(r10, [1, -1]);
        return Q8(a10, i10);
      } });
      var pee = B5({ pad_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r10 = L5(e10, "x", "pad");
        if (0 === r10.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
        var a10 = { paddings: t10, constantValue: n10 }, i10 = { x: r10 };
        return E5.runKernel(T2, i10, a10);
      } });
      var fee = B5({ pad1d_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return F$(2 === t10.length, function() {
          return "Invalid number of paddings. Must be length of 2.";
        }), pee(e10, [t10], n10);
      } });
      var dee = B5({ pad2d_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return F$(2 === t10.length && 2 === t10[0].length && 2 === t10[1].length, function() {
          return "Invalid number of paddings. Must be length of 2 each.";
        }), pee(e10, t10, n10);
      } });
      var vee = B5({ pad3d_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return F$(3 === t10.length && 2 === t10[0].length && 2 === t10[1].length && 2 === t10[2].length, function() {
          return "Invalid number of paddings. Must be length of 2 each.";
        }), pee(e10, t10, n10);
      } });
      var mee = B5({ pad4d_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return F$(4 === t10.length && 2 === t10[0].length && 2 === t10[1].length && 2 === t10[2].length && 2 === t10[3].length, function() {
          return "Invalid number of paddings. Must be length of 2 each.";
        }), pee(e10, t10, n10);
      } });
      var gee = B5({ spaceToBatchND_: function(e10, t10, n10) {
        var r10 = L5(e10, "x", "spaceToBatchND");
        F$(r10.rank >= 1 + t10.length, function() {
          return "input rank ".concat(r10.rank, " should be > than [blockShape] ").concat(t10.length);
        }), F$(n10.length === t10.length, function() {
          return "paddings.shape[0] ".concat(n10.length, " must be equal to [blockShape] ").concat(t10.length);
        }), F$(r10.shape.reduce(function(e11, r11, a11) {
          return a11 > 0 && a11 <= t10.length ? e11 && (r11 + n10[a11 - 1][0] + n10[a11 - 1][1]) % t10[a11 - 1] == 0 : e11;
        }, true), function() {
          return "input spatial dimensions ".concat(r10.shape.slice(1), " with paddings ").concat(n10.toString(), " must be divisible by blockShapes ").concat(t10.toString());
        });
        var a10 = { x: r10 }, i10 = { blockShape: t10, paddings: n10 };
        return E5.runKernel(i3, a10, i10);
      } });
      var yee = B5({ pool_: function(e10, t10, n10, r10, a10, i10, o10) {
        null == a10 && (a10 = [1, 1]), null == i10 && (i10 = 1), 0 === r10 && (r10 = "valid");
        var s10 = L5(e10, "x", "maxPool"), u10 = s10, c10 = false;
        3 === s10.rank && (c10 = true, u10 = X8(s10, [1, s10.shape[0], s10.shape[1], s10.shape[2]])), F$(j8(i10, a10), function() {
          return "Error in pool: Either strides or dilations must be 1. " + "Got strides ".concat(i10, " and dilations '").concat(a10, "'");
        });
        var l10, h10 = O8(u10.shape, t10, i10, a10, r10), p10 = [h10.dilationHeight, h10.dilationWidth];
        l10 = "same" === r10 ? function(e11, t11) {
          var n11 = e11.map(function(e12, n12) {
            return e12 + (e12 - 1) * (t11[n12] - 1);
          }).map(function(e12) {
            return e12 - 1;
          }), r11 = n11.map(function(e12) {
            return Math.floor(e12 / 2);
          }), a11 = n11.map(function(e12, t12) {
            return e12 - r11[t12];
          });
          return n11.map(function(e12, t12) {
            return [r11[t12], a11[t12]];
          });
        }([h10.filterHeight, h10.filterWidth], p10) : [[0, 0], [0, 0]];
        var f10 = 1 === p10[0] && 1 === p10[1], d10 = function(e11, t11, n11) {
          var r11 = n11.map(function(e12) {
            return e12[0];
          }), a11 = n11.map(function(e12) {
            return e12[1];
          }), i11 = e11.concat(r11, a11), o11 = t11.map(function(e12, t12) {
            return (e12 - i11[t12] % e12) % e12;
          }), s11 = a11.map(function(e12, t12) {
            return e12 + o11[t12];
          }), u11 = t11.map(function(e12, t12) {
            return [r11[t12], s11[t12]];
          }), c11 = t11.map(function(e12, t12) {
            return [0, o11[t12]];
          });
          return [u11, c11];
        }([h10.inHeight, h10.inWidth], p10, l10), v10 = S(d10, 2), m10 = v10[0], g10 = v10[1], y10 = f10 ? r10 : "valid", b10 = f10 ? u10 : gee(u10, p10, m10), x10 = ("avg" === n10 ? function() {
          return Y8(b10, t10, i10, y10, o10);
        } : function() {
          return X9(b10, t10, i10, y10, o10);
        })(), k10 = f10 ? x10 : r7(x10, p10, g10);
        return c10 ? X8(k10, [k10.shape[1], k10.shape[2], k10.shape[3]]) : k10;
      } });
      var bee = B5({ prelu_: function(e10, t10) {
        var n10 = { x: L5(e10, "x", "prelu"), alpha: L5(t10, "alpha", "prelu") };
        return E5.runKernel(C2, n10);
      } });
      var xee = B5({ prod_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r10 = L5(e10, "x", "prod");
        "bool" === r10.dtype && (r10 = h8(r10, "int32"));
        var a10 = { x: r10 }, i10 = { axis: t10, keepDims: n10 };
        return E5.runKernel(A2, a10, i10);
      } });
      var kee = B5({ raggedGather_: function(e10, t10, n10, r10) {
        var a10 = { paramsNestedSplits: e10.map(function(e11, t11) {
          return L5(e11, "tensors".concat(t11), "raggedGather", "int32");
        }), paramsDenseValues: L5(t10, "paramsDenseValues", "raggedGather"), indices: L5(n10, "indices", "raggedGather", "int32") }, i10 = { outputRaggedRank: r10 }, o10 = E5.runKernel(R2, a10, i10);
        return { outputNestedSplits: o10.slice(0, o10.length - 1), outputDenseValues: o10[o10.length - 1] };
      } });
      var wee = B5({ raggedRange_: function(e10, t10, n10) {
        var r10 = L5(e10, "starts", "raggedRange"), a10 = { starts: r10, limits: L5(t10, "limits", "raggedRange", r10.dtype), deltas: L5(n10, "deltas", "raggedRange", r10.dtype) }, i10 = E5.runKernel(_2, a10);
        return { rtNestedSplits: i10[0], rtDenseValues: i10[1] };
      } });
      var Iee = B5({ raggedTensorToTensor_: function(e10, t10, n10, r10, a10) {
        var i10 = L5(e10, "shape", "raggedTensorToTensor", "int32"), o10 = L5(t10, "values", "raggedTensorToTensor"), s10 = { shape: i10, values: o10, defaultValue: L5(n10, "defaultValue", "raggedTensorToTensor", o10.dtype), rowPartitionTensors: r10.map(function(e11, t11) {
          return L5(e11, "tensors".concat(t11), "raggedTensorToTensor", "int32");
        }) }, u10 = { rowPartitionTypes: a10 };
        return E5.runKernel(O2, s10, u10);
      } });
      var Nee = B5({ rand_: function(e10, t10, n10) {
        p0(e10);
        var r10 = L$(e10), a10 = null;
        if (null == n10 || "float32" === n10) a10 = new Float32Array(r10);
        else if ("int32" === n10) a10 = new Int32Array(r10);
        else {
          if ("bool" !== n10) throw new Error("Unknown data type ".concat(n10));
          a10 = new Uint8Array(r10);
        }
        for (var i10 = 0; i10 < r10; i10++) a10[i10] = t10();
        return E5.makeTensor(a10, e10, n10);
      } }), See = { exports: {} };
      !function(e10) {
        !function(e11, t10, n10) {
          function r10(e12) {
            var t11 = this, n11 = /* @__PURE__ */ function() {
              var e13 = 4022871197, t12 = function(t13) {
                t13 = String(t13);
                for (var n12 = 0; n12 < t13.length; n12++) {
                  var r11 = 0.02519603282416938 * (e13 += t13.charCodeAt(n12));
                  r11 -= e13 = r11 >>> 0, e13 = (r11 *= e13) >>> 0, e13 += 4294967296 * (r11 -= e13);
                }
                return 23283064365386963e-26 * (e13 >>> 0);
              };
              return t12;
            }();
            t11.next = function() {
              var e13 = 2091639 * t11.s0 + 23283064365386963e-26 * t11.c;
              return t11.s0 = t11.s1, t11.s1 = t11.s2, t11.s2 = e13 - (t11.c = 0 | e13);
            }, t11.c = 1, t11.s0 = n11(" "), t11.s1 = n11(" "), t11.s2 = n11(" "), t11.s0 -= n11(e12), t11.s0 < 0 && (t11.s0 += 1), t11.s1 -= n11(e12), t11.s1 < 0 && (t11.s1 += 1), t11.s2 -= n11(e12), t11.s2 < 0 && (t11.s2 += 1), n11 = null;
          }
          function a10(e12, t11) {
            return t11.c = e12.c, t11.s0 = e12.s0, t11.s1 = e12.s1, t11.s2 = e12.s2, t11;
          }
          function i10(e12, t11) {
            var n11 = new r10(e12), i11 = t11 && t11.state, o10 = n11.next;
            return o10.int32 = function() {
              return 4294967296 * n11.next() | 0;
            }, o10.double = function() {
              return o10() + 11102230246251565e-32 * (2097152 * o10() | 0);
            }, o10.quick = o10, i11 && ("object" == s(i11) && a10(i11, n11), o10.state = function() {
              return a10(n11, {});
            }), o10;
          }
          t10 && t10.exports ? t10.exports = i10 : n10 && n10.amd ? n10(function() {
            return i10;
          }) : this.alea = i10;
        }(0, e10, false);
      }(See);
      var Tee = See.exports, Eee = { exports: {} };
      !function(e10) {
        !function(e11, t10, n10) {
          function r10(e12) {
            var t11 = this, n11 = "";
            t11.x = 0, t11.y = 0, t11.z = 0, t11.w = 0, t11.next = function() {
              var e13 = t11.x ^ t11.x << 11;
              return t11.x = t11.y, t11.y = t11.z, t11.z = t11.w, t11.w ^= t11.w >>> 19 ^ e13 ^ e13 >>> 8;
            }, e12 === (0 | e12) ? t11.x = e12 : n11 += e12;
            for (var r11 = 0; r11 < n11.length + 64; r11++) t11.x ^= 0 | n11.charCodeAt(r11), t11.next();
          }
          function a10(e12, t11) {
            return t11.x = e12.x, t11.y = e12.y, t11.z = e12.z, t11.w = e12.w, t11;
          }
          function i10(e12, t11) {
            var n11 = new r10(e12), i11 = t11 && t11.state, o10 = function() {
              return (n11.next() >>> 0) / 4294967296;
            };
            return o10.double = function() {
              do {
                var e13 = ((n11.next() >>> 11) + (n11.next() >>> 0) / 4294967296) / (1 << 21);
              } while (0 === e13);
              return e13;
            }, o10.int32 = n11.next, o10.quick = o10, i11 && ("object" == s(i11) && a10(i11, n11), o10.state = function() {
              return a10(n11, {});
            }), o10;
          }
          t10 && t10.exports ? t10.exports = i10 : n10 && n10.amd ? n10(function() {
            return i10;
          }) : this.xor128 = i10;
        }(0, e10, false);
      }(Eee);
      var Cee = Eee.exports, Aee = { exports: {} };
      !function(e10) {
        !function(e11, t10, n10) {
          function r10(e12) {
            var t11 = this, n11 = "";
            t11.next = function() {
              var e13 = t11.x ^ t11.x >>> 2;
              return t11.x = t11.y, t11.y = t11.z, t11.z = t11.w, t11.w = t11.v, (t11.d = t11.d + 362437 | 0) + (t11.v = t11.v ^ t11.v << 4 ^ e13 ^ e13 << 1) | 0;
            }, t11.x = 0, t11.y = 0, t11.z = 0, t11.w = 0, t11.v = 0, e12 === (0 | e12) ? t11.x = e12 : n11 += e12;
            for (var r11 = 0; r11 < n11.length + 64; r11++) t11.x ^= 0 | n11.charCodeAt(r11), r11 == n11.length && (t11.d = t11.x << 10 ^ t11.x >>> 4), t11.next();
          }
          function a10(e12, t11) {
            return t11.x = e12.x, t11.y = e12.y, t11.z = e12.z, t11.w = e12.w, t11.v = e12.v, t11.d = e12.d, t11;
          }
          function i10(e12, t11) {
            var n11 = new r10(e12), i11 = t11 && t11.state, o10 = function() {
              return (n11.next() >>> 0) / 4294967296;
            };
            return o10.double = function() {
              do {
                var e13 = ((n11.next() >>> 11) + (n11.next() >>> 0) / 4294967296) / (1 << 21);
              } while (0 === e13);
              return e13;
            }, o10.int32 = n11.next, o10.quick = o10, i11 && ("object" == s(i11) && a10(i11, n11), o10.state = function() {
              return a10(n11, {});
            }), o10;
          }
          t10 && t10.exports ? t10.exports = i10 : n10 && n10.amd ? n10(function() {
            return i10;
          }) : this.xorwow = i10;
        }(0, e10, false);
      }(Aee);
      var Ree = Aee.exports, _ee = { exports: {} };
      !function(e10) {
        !function(e11, t10, n10) {
          function r10(e12) {
            var t11 = this;
            t11.next = function() {
              var e13, n11, r11 = t11.x, a11 = t11.i;
              return e13 = r11[a11], n11 = (e13 ^= e13 >>> 7) ^ e13 << 24, n11 ^= (e13 = r11[a11 + 1 & 7]) ^ e13 >>> 10, n11 ^= (e13 = r11[a11 + 3 & 7]) ^ e13 >>> 3, n11 ^= (e13 = r11[a11 + 4 & 7]) ^ e13 << 7, e13 = r11[a11 + 7 & 7], n11 ^= (e13 ^= e13 << 13) ^ e13 << 9, r11[a11] = n11, t11.i = a11 + 1 & 7, n11;
            }, function(e13, t12) {
              var n11, r11 = [];
              if (t12 === (0 | t12)) r11[0] = t12;
              else for (t12 = "" + t12, n11 = 0; n11 < t12.length; ++n11) r11[7 & n11] = r11[7 & n11] << 15 ^ t12.charCodeAt(n11) + r11[n11 + 1 & 7] << 13;
              for (; r11.length < 8; ) r11.push(0);
              for (n11 = 0; n11 < 8 && 0 === r11[n11]; ++n11) ;
              for (8 == n11 ? r11[7] = -1 : r11[n11], e13.x = r11, e13.i = 0, n11 = 256; n11 > 0; --n11) e13.next();
            }(t11, e12);
          }
          function a10(e12, t11) {
            return t11.x = e12.x.slice(), t11.i = e12.i, t11;
          }
          function i10(e12, t11) {
            null == e12 && (e12 = +/* @__PURE__ */ new Date());
            var n11 = new r10(e12), i11 = t11 && t11.state, o10 = function() {
              return (n11.next() >>> 0) / 4294967296;
            };
            return o10.double = function() {
              do {
                var e13 = ((n11.next() >>> 11) + (n11.next() >>> 0) / 4294967296) / (1 << 21);
              } while (0 === e13);
              return e13;
            }, o10.int32 = n11.next, o10.quick = o10, i11 && (i11.x && a10(i11, n11), o10.state = function() {
              return a10(n11, {});
            }), o10;
          }
          t10 && t10.exports ? t10.exports = i10 : n10 && n10.amd ? n10(function() {
            return i10;
          }) : this.xorshift7 = i10;
        }(0, e10, false);
      }(_ee);
      var Oee = _ee.exports, Fee = { exports: {} };
      !function(e10) {
        !function(e11, t10, n10) {
          function r10(e12) {
            var t11 = this;
            t11.next = function() {
              var e13, n11, r11 = t11.w, a11 = t11.X, i11 = t11.i;
              return t11.w = r11 = r11 + 1640531527 | 0, n11 = a11[i11 + 34 & 127], e13 = a11[i11 = i11 + 1 & 127], n11 ^= n11 << 13, e13 ^= e13 << 17, n11 ^= n11 >>> 15, e13 ^= e13 >>> 12, n11 = a11[i11] = n11 ^ e13, t11.i = i11, n11 + (r11 ^ r11 >>> 16) | 0;
            }, function(e13, t12) {
              var n11, r11, a11, i11, o10, s10 = [], u10 = 128;
              for (t12 === (0 | t12) ? (r11 = t12, t12 = null) : (t12 += "\0", r11 = 0, u10 = Math.max(u10, t12.length)), a11 = 0, i11 = -32; i11 < u10; ++i11) t12 && (r11 ^= t12.charCodeAt((i11 + 32) % t12.length)), 0 === i11 && (o10 = r11), r11 ^= r11 << 10, r11 ^= r11 >>> 15, r11 ^= r11 << 4, r11 ^= r11 >>> 13, i11 >= 0 && (o10 = o10 + 1640531527 | 0, a11 = 0 == (n11 = s10[127 & i11] ^= r11 + o10) ? a11 + 1 : 0);
              for (a11 >= 128 && (s10[127 & (t12 && t12.length || 0)] = -1), a11 = 127, i11 = 512; i11 > 0; --i11) r11 = s10[a11 + 34 & 127], n11 = s10[a11 = a11 + 1 & 127], r11 ^= r11 << 13, n11 ^= n11 << 17, r11 ^= r11 >>> 15, n11 ^= n11 >>> 12, s10[a11] = r11 ^ n11;
              e13.w = o10, e13.X = s10, e13.i = a11;
            }(t11, e12);
          }
          function a10(e12, t11) {
            return t11.i = e12.i, t11.w = e12.w, t11.X = e12.X.slice(), t11;
          }
          function i10(e12, t11) {
            null == e12 && (e12 = +/* @__PURE__ */ new Date());
            var n11 = new r10(e12), i11 = t11 && t11.state, o10 = function() {
              return (n11.next() >>> 0) / 4294967296;
            };
            return o10.double = function() {
              do {
                var e13 = ((n11.next() >>> 11) + (n11.next() >>> 0) / 4294967296) / (1 << 21);
              } while (0 === e13);
              return e13;
            }, o10.int32 = n11.next, o10.quick = o10, i11 && (i11.X && a10(i11, n11), o10.state = function() {
              return a10(n11, {});
            }), o10;
          }
          t10 && t10.exports ? t10.exports = i10 : n10 && n10.amd ? n10(function() {
            return i10;
          }) : this.xor4096 = i10;
        }(0, e10, false);
      }(Fee);
      var Dee = Fee.exports, Mee = { exports: {} };
      !function(e10) {
        !function(e11, t10, n10) {
          function r10(e12) {
            var t11 = this, n11 = "";
            t11.next = function() {
              var e13 = t11.b, n12 = t11.c, r12 = t11.d, a11 = t11.a;
              return e13 = e13 << 25 ^ e13 >>> 7 ^ n12, n12 = n12 - r12 | 0, r12 = r12 << 24 ^ r12 >>> 8 ^ a11, a11 = a11 - e13 | 0, t11.b = e13 = e13 << 20 ^ e13 >>> 12 ^ n12, t11.c = n12 = n12 - r12 | 0, t11.d = r12 << 16 ^ n12 >>> 16 ^ a11, t11.a = a11 - e13 | 0;
            }, t11.a = 0, t11.b = 0, t11.c = -1640531527, t11.d = 1367130551, e12 === Math.floor(e12) ? (t11.a = e12 / 4294967296 | 0, t11.b = 0 | e12) : n11 += e12;
            for (var r11 = 0; r11 < n11.length + 20; r11++) t11.b ^= 0 | n11.charCodeAt(r11), t11.next();
          }
          function a10(e12, t11) {
            return t11.a = e12.a, t11.b = e12.b, t11.c = e12.c, t11.d = e12.d, t11;
          }
          function i10(e12, t11) {
            var n11 = new r10(e12), i11 = t11 && t11.state, o10 = function() {
              return (n11.next() >>> 0) / 4294967296;
            };
            return o10.double = function() {
              do {
                var e13 = ((n11.next() >>> 11) + (n11.next() >>> 0) / 4294967296) / (1 << 21);
              } while (0 === e13);
              return e13;
            }, o10.int32 = n11.next, o10.quick = o10, i11 && ("object" == s(i11) && a10(i11, n11), o10.state = function() {
              return a10(n11, {});
            }), o10;
          }
          t10 && t10.exports ? t10.exports = i10 : n10 && n10.amd ? n10(function() {
            return i10;
          }) : this.tychei = i10;
        }(0, e10, false);
      }(Mee);
      var Lee = Mee.exports, zee = { exports: {} };
      !function(e10) {
        !function(t10, n10, r10) {
          var a10, i10 = 256, o10 = r10.pow(i10, 6), u10 = r10.pow(2, 52), c10 = 2 * u10, l10 = 255;
          function h10(e11, s10, l11) {
            var h11 = [], g10 = v10(d10((s10 = 1 == s10 ? { entropy: true } : s10 || {}).entropy ? [e11, m10(n10)] : null == e11 ? function() {
              try {
                var e12;
                return a10 && (e12 = a10.randomBytes) ? e12 = e12(i10) : (e12 = new Uint8Array(i10), (t10.crypto || t10.msCrypto).getRandomValues(e12)), m10(e12);
              } catch (e13) {
                var r11 = t10.navigator, o11 = r11 && r11.plugins;
                return [+/* @__PURE__ */ new Date(), t10, o11, t10.screen, m10(n10)];
              }
            }() : e11, 3), h11), y10 = new p10(h11), b10 = function() {
              for (var e12 = y10.g(6), t11 = o10, n11 = 0; e12 < u10; ) e12 = (e12 + n11) * i10, t11 *= i10, n11 = y10.g(1);
              for (; e12 >= c10; ) e12 /= 2, t11 /= 2, n11 >>>= 1;
              return (e12 + n11) / t11;
            };
            return b10.int32 = function() {
              return 0 | y10.g(4);
            }, b10.quick = function() {
              return y10.g(4) / 4294967296;
            }, b10.double = b10, v10(m10(y10.S), n10), (s10.pass || l11 || function(e12, t11, n11, a11) {
              return a11 && (a11.S && f10(a11, y10), e12.state = function() {
                return f10(y10, {});
              }), n11 ? (r10.random = e12, t11) : e12;
            })(b10, g10, "global" in s10 ? s10.global : this == r10, s10.state);
          }
          function p10(e11) {
            var t11, n11 = e11.length, r11 = this, a11 = 0, o11 = r11.i = r11.j = 0, s10 = r11.S = [];
            for (n11 || (e11 = [n11++]); a11 < i10; ) s10[a11] = a11++;
            for (a11 = 0; a11 < i10; a11++) s10[a11] = s10[o11 = l10 & o11 + e11[a11 % n11] + (t11 = s10[a11])], s10[o11] = t11;
            (r11.g = function(e12) {
              for (var t12, n12 = 0, a12 = r11.i, o12 = r11.j, s11 = r11.S; e12--; ) t12 = s11[a12 = l10 & a12 + 1], n12 = n12 * i10 + s11[l10 & (s11[a12] = s11[o12 = l10 & o12 + t12]) + (s11[o12] = t12)];
              return r11.i = a12, r11.j = o12, n12;
            })(i10);
          }
          function f10(e11, t11) {
            return t11.i = e11.i, t11.j = e11.j, t11.S = e11.S.slice(), t11;
          }
          function d10(e11, t11) {
            var n11, r11 = [], a11 = s(e11);
            if (t11 && "object" == a11) for (n11 in e11) try {
              r11.push(d10(e11[n11], t11 - 1));
            } catch (e12) {
            }
            return r11.length ? r11 : "string" == a11 ? e11 : e11 + "\0";
          }
          function v10(e11, t11) {
            for (var n11, r11 = e11 + "", a11 = 0; a11 < r11.length; ) t11[l10 & a11] = l10 & (n11 ^= 19 * t11[l10 & a11]) + r11.charCodeAt(a11++);
            return m10(t11);
          }
          function m10(e11) {
            return String.fromCharCode.apply(0, e11);
          }
          if (v10(r10.random(), n10), e10.exports) {
            e10.exports = h10;
            try {
              a10 = require_crypto();
            } catch (e11) {
            }
          } else r10.seedrandom = h10;
        }("undefined" != typeof self ? self : n, [], Math);
      }(zee);
      var Pee = zee.exports, Bee = Tee, Wee = Cee, Uee = Ree, Vee = Oee, Gee = Dee, jee = Lee, Hee = Pee;
      Hee.alea = Bee, Hee.xor128 = Wee, Hee.xorwow = Uee, Hee.xorshift7 = Vee, Hee.xor4096 = Gee, Hee.tychei = jee;
      var qee = Hee;
      function Kee() {
        return 32 === E5.backend.floatPrecision() ? 1e-3 : 0.1;
      }
      function Xee(e10, t10, n10) {
        var r10 = true;
        if ((U4(e10) || U4(t10)) && (r10 = false), U4(e10) && U4(t10) && (r10 = true), r10) {
          var a10 = e10.constructor.name, i10 = t10.constructor.name;
          if (a10 !== i10) throw new Error("Arrays are of different type. Actual: ".concat(a10, ". ") + "Expected: ".concat(i10));
        }
        if (Array.isArray(e10) && Array.isArray(t10)) {
          var o10 = F5(e10), s10 = F5(t10);
          if (!P$(o10, s10)) throw new Error("Arrays have different shapes. " + "Actual: [".concat(o10, "]. Expected: [").concat(s10, "]"));
        }
        var u10 = U4(e10) ? e10 : V4(e10), c10 = U4(t10) ? t10 : V4(t10);
        if (u10.length !== c10.length) throw new Error("Arrays have different lengths actual: ".concat(u10.length, " vs ") + "expected: ".concat(c10.length, ".\n") + "Actual:   ".concat(u10, ".\n") + "Expected: ".concat(c10, "."));
        for (var l10 = 0; l10 < c10.length; ++l10) {
          var h10 = u10[l10], p10 = c10[l10];
          if (!n10(h10, p10)) throw new Error("Arrays differ: actual[".concat(l10, "] = ").concat(h10, ", expected[").concat(l10, "] = ").concat(p10, ".\n") + "Actual:   ".concat(u10, ".\n") + "Expected: ".concat(c10, "."));
        }
        "undefined" != typeof expect && expect().nothing();
      }
      function Yee(e10, t10, n10) {
        if (null == n10 && (n10 = Kee()), !Jee(e10, t10, n10)) throw new Error("Numbers differ: actual === ".concat(e10, ", expected === ").concat(t10));
        "undefined" != typeof expect && expect().nothing();
      }
      function Jee(e10, t10, n10) {
        return !isFinite(e10) && !isFinite(t10) || !(isNaN(e10) || isNaN(t10) || Math.abs(e10 - t10) > n10);
      }
      function Zee() {
        return (Zee = c(o().mark(function e10(t10) {
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return e11.next = 2, t10.play();
              case 2:
                if (!("requestVideoFrameCallback" in t10)) {
                  e11.next = 5;
                  break;
                }
                return e11.next = 5, new Promise(function(e12) {
                  t10.requestVideoFrameCallback(e12);
                });
              case 5:
              case "end":
                return e11.stop();
            }
          }, e10);
        }))).apply(this, arguments);
      }
      var Qee = { __proto__: null, TEST_EPSILON_FLOAT16: 0.1, createVideoElement: function(e10) {
        var t10 = document.createElement("video");
        return "playsInline" in t10 && (t10.playsInline = true), t10.muted = true, t10.loop = true, t10.style.position = "fixed", t10.style.left = "0px", t10.style.top = "0px", t10.preload = "auto", t10.appendChild(e10), new Promise(function(e11) {
          t10.addEventListener("loadeddata", function(n10) {
            return e11(t10);
          }), t10.load();
        });
      }, encodeStrings: function e10(t10) {
        for (var n10 = 0; n10 < t10.length; n10++) {
          var r10 = t10[n10];
          Array.isArray(r10) ? e10(r10) : t10[n10] = B4(r10);
        }
        return t10;
      }, expectArrayBuffersEqual: function(e10, t10) {
        var n10 = new Float32Array(e10), r10 = new Float32Array(t10);
        if (n10.length !== r10.length) throw new Error("Expected ArrayBuffer to be of length " + "".concat(r10.length, ", but it was ").concat(n10.length));
        for (var a10 = 0; a10 < r10.length; a10++) if (n10[a10] !== r10[a10]) throw new Error("Expected ArrayBuffer value at ".concat(a10, " to be ") + "".concat(r10[a10], " but got ").concat(n10[a10], " instead"));
      }, expectArraysClose: function(e10, t10, n10) {
        return null == n10 && (n10 = Kee()), Xee(e10, t10, function(e11, t11) {
          return Jee(e11, t11, n10);
        });
      }, expectArraysEqual: function(e10, t10) {
        var n10 = "string" == typeof t10 || "number" == typeof t10 || "boolean" == typeof t10 ? [t10] : t10;
        return $$(e10) || $$(e10[0]) || $$(t10) || $$(t10[0]) ? Xee(e10, n10, function(e11, t11) {
          return e11 == t11;
        }) : Xee(e10, t10, function(e11, t11) {
          return Jee(e11, t11, 0);
        });
      }, expectNumbersClose: Yee, expectPromiseToFail: function(e10, t10) {
        e10().then(function() {
          return t10.fail();
        }, function() {
          return t10();
        }), "undefined" != typeof expect && expect().nothing();
      }, expectValuesInRange: function(e10, t10, n10) {
        for (var r10 = 0; r10 < e10.length; r10++) if (e10[r10] < t10 || e10[r10] > n10) throw new Error("Value out of range:".concat(e10[r10], " low: ").concat(t10, ", high: ").concat(n10));
      }, play: function(e10) {
        return Zee.apply(this, arguments);
      }, testEpsilon: Kee }, $ee = function() {
        function e10(t10, n10, r10, a10, i10) {
          l(this, e10), this.mean = t10, this.stdDev = n10, this.dtype = r10, this.nextVal = NaN, this.truncated = a10, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
          var o10 = i10 || Math.random();
          this.random = qee.alea(o10.toString());
        }
        return p(e10, [{ key: "nextValue", value: function() {
          if (!isNaN(this.nextVal)) {
            var e11 = this.nextVal;
            return this.nextVal = NaN, e11;
          }
          for (var t10, n10, r10 = false; !r10; ) {
            var a10 = void 0, i10 = void 0, o10 = void 0;
            do {
              o10 = (a10 = 2 * this.random() - 1) * a10 + (i10 = 2 * this.random() - 1) * i10;
            } while (o10 >= 1 || 0 === o10);
            var s10 = Math.sqrt(-2 * Math.log(o10) / o10);
            t10 = this.mean + this.stdDev * a10 * s10, n10 = this.mean + this.stdDev * i10 * s10, this.truncated && !this.isValidTruncated(t10) || (r10 = true);
          }
          return this.truncated && !this.isValidTruncated(n10) || (this.nextVal = this.convertValue(n10)), this.convertValue(t10);
        } }, { key: "convertValue", value: function(e11) {
          return null == this.dtype || "float32" === this.dtype ? e11 : Math.round(e11);
        } }, { key: "isValidTruncated", value: function(e11) {
          return e11 <= this.upper && e11 >= this.lower;
        } }]), e10;
      }(), ete = function() {
        function e10(t10, n10, r10, a10) {
          l(this, e10), this.alpha = t10, this.beta = 1 / n10, this.dtype = r10;
          var i10 = a10 || Math.random();
          this.randu = qee.alea(i10.toString()), this.randn = new $ee(0, 1, r10, false, this.randu()), this.d = t10 < 1 ? t10 + 2 / 3 : t10 - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
        }
        return p(e10, [{ key: "nextValue", value: function() {
          for (var e11, t10, n10, r10, a10, i10; ; ) {
            do {
              r10 = this.randn.nextValue(), i10 = 1 + this.c * r10;
            } while (i10 <= 0);
            if (i10 *= i10 * i10, t10 = 1 - 0.331 * (e11 = r10 * r10) * e11, n10 = 0.5 * e11 + this.d * (1 - i10 + Math.log(i10)), (a10 = this.randu()) < t10 || Math.log(a10) < n10) break;
          }
          return i10 = 1 / this.beta * this.d * i10, this.alpha < 1 && (i10 *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(i10);
        } }, { key: "convertValue", value: function(e11) {
          return "float32" === this.dtype ? e11 : Math.round(e11);
        } }]), e10;
      }(), tte = function() {
        function e10() {
          var t10 = this, n10 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, r10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, a10 = arguments.length > 2 ? arguments[2] : void 0, i10 = arguments.length > 3 ? arguments[3] : void 0;
          if (l(this, e10), this.canReturnFloat = function() {
            return null == t10.dtype || "float32" === t10.dtype;
          }, this.min = n10, this.range = r10 - n10, this.dtype = a10, null == i10 && (i10 = Math.random()), "number" == typeof i10 && (i10 = i10.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between ".concat(n10, " - ").concat(r10, " <= 1 and dtype is not float"));
          this.random = qee.alea(i10);
        }
        return p(e10, [{ key: "convertValue", value: function(e11) {
          return this.canReturnFloat() ? e11 : Math.round(e11);
        } }, { key: "nextValue", value: function() {
          return this.convertValue(this.min + this.range * this.random());
        } }]), e10;
      }();
      var nte = B5({ randomGamma_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "float32", a10 = arguments.length > 4 ? arguments[4] : void 0;
        if (p0(e10), null == n10 && (n10 = 1), null == r10 && (r10 = "float32"), "float32" !== r10 && "int32" !== r10) throw new Error("Unsupported data type ".concat(r10));
        for (var i10 = new ete(t10, n10, r10, a10), o10 = l8(e10, r10), s10 = 0; s10 < o10.values.length; s10++) o10.values[s10] = i10.nextValue();
        return o10.toTensor();
      } });
      var rte = B5({ randomNormal_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r10 = arguments.length > 3 ? arguments[3] : void 0, a10 = arguments.length > 4 ? arguments[4] : void 0;
        if (p0(e10), null != r10 && "bool" === r10) throw new Error("Unsupported data type ".concat(r10));
        for (var i10 = new $ee(t10, n10, r10, false, a10), o10 = l8(e10, r10), s10 = 0; s10 < o10.values.length; s10++) o10.values[s10] = i10.nextValue();
        return o10.toTensor();
      } });
      var ate = B5({ randomStandardNormal_: function(e10, t10, n10) {
        if (null != t10 && "bool" === t10) throw new Error("Unsupported data type ".concat(t10));
        return rte(e10, 0, 1, t10, n10);
      } });
      var ite = B5({ randomUniform_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "float32", a10 = arguments.length > 4 ? arguments[4] : void 0;
        p0(e10);
        for (var i10 = l8(e10, r10), o10 = new tte(t10, n10, null, a10), s10 = 0; s10 < i10.values.length; s10++) i10.values[s10] = o10.nextValue();
        return i10.toTensor();
      } });
      var ote = B5({ randomUniformInt_: function(e10, t10, n10, r10) {
        return ite(e10, t10, n10, "int32", r10);
      } });
      function ste(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "float32";
        if (0 === n10) throw new Error("Cannot have a step of zero");
        var a10 = { start: e10, stop: t10, step: n10, dtype: r10 };
        return E5.runKernel(F2, {}, a10);
      }
      var ute = B5({ real_: function(e10) {
        var t10 = { input: L5(e10, "input", "real") };
        return E5.runKernel(D2, t10);
      } });
      var cte = B5({ reciprocal_: function(e10) {
        var t10 = { x: L5(e10, "x", "reciprocal") };
        return E5.runKernel(M2, t10);
      } });
      var lte = B5({ relu_: function(e10) {
        var t10 = { x: L5(e10, "x", "relu") };
        return E5.runKernel(L2, t10);
      } });
      var hte = B5({ relu6_: function(e10) {
        var t10 = { x: L5(e10, "x", "relu6") };
        return E5.runKernel(V2, t10);
      } });
      var pte = B5({ reverse_: function(e10, t10) {
        var n10 = { x: L5(e10, "x", "reverse") }, r10 = { dims: t10 };
        return E5.runKernel(G2, n10, r10);
      } });
      var fte = B5({ reverse1d_: function(e10) {
        var t10 = L5(e10, "x", "reverse");
        return F$(1 === t10.rank, function() {
          return "Error in reverse1D: x must be rank 1 but got rank ".concat(t10.rank, ".");
        }), pte(t10, 0);
      } });
      var dte = B5({ reverse2d_: function(e10, t10) {
        var n10 = L5(e10, "x", "reverse");
        return F$(2 === n10.rank, function() {
          return "Error in reverse2D: x must be rank 2 but got rank ".concat(n10.rank, ".");
        }), pte(n10, t10);
      } });
      var vte = B5({ reverse3d_: function(e10, t10) {
        var n10 = L5(e10, "x", "reverse");
        return F$(3 === n10.rank, function() {
          return "Error in reverse3D: x must be rank 3 but got rank ".concat(n10.rank, ".");
        }), pte(n10, t10);
      } });
      var mte = B5({ reverse4d_: function(e10, t10) {
        var n10 = L5(e10, "x", "reverse");
        return F$(4 === n10.rank, function() {
          return "Error in reverse4D: x must be rank 4 but got rank ".concat(n10.rank, ".");
        }), pte(n10, t10);
      } });
      var gte = B5({ round_: function(e10) {
        var t10 = { x: L5(e10, "x", "round") };
        return E5.runKernel(j2, t10);
      } });
      var yte = B5({ rsqrt_: function(e10) {
        var t10 = { x: L5(e10, "x", "rsqrt", "float32") };
        return E5.runKernel(H2, t10);
      } });
      var bte = B5({ selu_: function(e10) {
        var t10 = { x: L5(e10, "x", "selu") };
        return E5.runKernel(J2, t10);
      } });
      var xte = B5({ separableConv2d_: function(e10, t10, n10, r10, a10) {
        var i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [1, 1], o10 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : "NHWC", s10 = L5(e10, "x", "separableConv2d"), u10 = L5(t10, "depthwiseFilter", "separableConv2d"), c10 = L5(n10, "pointwiseFilter", "separableConv2d"), l10 = s10, h10 = false;
        if (3 === s10.rank && (h10 = true, l10 = X8(s10, [1, s10.shape[0], s10.shape[1], s10.shape[2]])), "NCHW" === o10) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
        F$(4 === l10.rank, function() {
          return "Error in separableConv2d: input must be rank 4, but got " + "rank ".concat(l10.rank, ".");
        }), F$(4 === u10.rank, function() {
          return "Error in separableConv2d: depthwise filter must be rank 4, but " + "got rank ".concat(u10.rank, ".");
        }), F$(4 === c10.rank, function() {
          return "Error in separableConv2d: pointwise filter must be rank 4, but " + "got rank ".concat(u10.rank, ".");
        }), F$(1 === c10.shape[0], function() {
          return "Error in separableConv2d: the first dimension of pointwise filter " + " must be 1, but got ".concat(c10.shape[0], ".");
        }), F$(1 === c10.shape[1], function() {
          return "Error in separableConv2d: the second dimension of pointwise " + "filter must be 1, but got ".concat(c10.shape[1], ".");
        });
        var p10 = u10.shape[2], f10 = u10.shape[3];
        F$(c10.shape[2] === p10 * f10, function() {
          return "Error in separableConv2d: the third dimension of pointwise filter " + "must be ".concat(p10 * f10, ", ") + "but got ".concat(c10.shape[2], ".");
        });
        var d10 = O7(l10, u10, r10, a10, o10, i10), v10 = 1, m10 = b7(d10, c10, v10, "valid", o10);
        return h10 ? X8(m10, [m10.shape[1], m10.shape[2], m10.shape[3]]) : m10;
      } });
      function kte() {
        return kte = c(o().mark(function e10(t10, n10) {
          var r10, a10, i10, s10, u10, c10, l10, h10, p10, f10, d10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return r10 = L5(t10, "x", "setdiff1d"), a10 = L5(n10, "y", "setdiff1d"), F$(r10.dtype === a10.dtype, function() {
                  return "x and y should have the same dtype, but got x (".concat(r10.dtype, ") and y (").concat(a10.dtype, ").");
                }), F$(1 === r10.rank, function() {
                  return "x should be 1D tensor, but got x (".concat(r10.shape, ").");
                }), F$(1 === a10.rank, function() {
                  return "y should be 1D tensor, but got y (".concat(a10.shape, ").");
                }), e11.next = 7, r10.data();
              case 7:
                return i10 = e11.sent, e11.next = 10, a10.data();
              case 10:
                for (s10 = e11.sent, u10 = new Set(s10), c10 = 0, l10 = 0; l10 < i10.length; l10++) u10.has(i10[l10]) || c10++;
                for (h10 = new $4([c10], r10.dtype), p10 = new $4([c10], "int32"), f10 = 0, d10 = 0; f10 < i10.length; f10++) u10.has(i10[f10]) || (h10.values[d10] = i10[f10], p10.values[d10] = f10, d10++);
                return e11.abrupt("return", [h10.toTensor(), p10.toTensor()]);
              case 18:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), kte.apply(this, arguments);
      }
      var wte = function(e10, t10) {
        return kte.apply(this, arguments);
      };
      var Ite = B5({ sign_: function(e10) {
        var t10 = { x: L5(e10, "x", "sign") };
        return E5.runKernel(e3, t10);
      } });
      var Nte = B5({ sin_: function(e10) {
        var t10 = { x: L5(e10, "x", "sin", "float32") };
        return E5.runKernel(Q2, t10);
      } });
      var Ste = B5({ sinh_: function(e10) {
        var t10 = { x: L5(e10, "x", "sinh") };
        return E5.runKernel($2, t10);
      } });
      var Tte = B5({ slice1d_: function(e10, t10, n10) {
        var r10 = L5(e10, "x", "slice1d");
        return F$(1 === r10.rank, function() {
          return "slice1d expects a rank-1 tensor, but got a rank-".concat(r10.rank, " tensor");
        }), e7(r10, [t10], [n10]);
      } });
      var Ete = B5({ slice2d_: function(e10, t10, n10) {
        var r10 = L5(e10, "x", "slice2d");
        return F$(2 === r10.rank, function() {
          return "slice2d expects a rank-2 tensor, but got a rank-".concat(r10.rank, " tensor");
        }), e7(r10, t10, n10);
      } });
      var Cte = B5({ slice3d_: function(e10, t10, n10) {
        var r10 = L5(e10, "x", "slice3d");
        return F$(3 === r10.rank, function() {
          return "slice3d expects a rank-3 tensor, but got a rank-".concat(r10.rank, " tensor");
        }), e7(r10, t10, n10);
      } });
      var Ate = B5({ slice4d_: function(e10, t10, n10) {
        var r10 = L5(e10, "x", "slice4d");
        return F$(4 === r10.rank, function() {
          return "slice4d expects a rank-4 tensor, but got a rank-".concat(r10.rank, " tensor");
        }), e7(r10, t10, n10);
      } });
      var Rte = B5({ softmax_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1, n10 = L5(e10, "logits", "softmax", "float32");
        if (-1 === t10 && (t10 = n10.rank - 1), t10 !== n10.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. " + "Logits was rank ".concat(n10.rank, " and dim was ").concat(t10));
        var r10 = { logits: n10 }, a10 = { dim: t10 };
        return E5.runKernel(s3, r10, a10);
      } });
      var _te = B5({ fft_: function(e10) {
        F$("complex64" === e10.dtype, function() {
          return "The dtype for tf.spectral.fft() must be complex64 " + "but got ".concat(e10.dtype, ".");
        });
        var t10 = { input: e10 };
        return E5.runKernel(R1, t10);
      } });
      var Ote = B5({ ifft_: function(e10) {
        F$("complex64" === e10.dtype, function() {
          return "The dtype for tf.spectral.ifft() must be complex64 " + "but got ".concat(e10.dtype, ".");
        });
        var t10 = { input: e10 };
        return E5.runKernel(U1, t10);
      } });
      var Fte = B5({ irfft_: function(e10) {
        var t10, n10 = e10.shape[e10.shape.length - 1], r10 = e10.size / n10;
        if (n10 <= 2) {
          var a10 = X8(e10, [r10, n10]);
          t10 = Ote(a10);
        } else {
          var i10 = [r10, 2 * (n10 - 1)], o10 = X8(ute(e10), [r10, n10]), s10 = X8(k9(e10), [r10, n10]), u10 = pte(e7(o10, [0, 1], [r10, n10 - 2]), 1), c10 = g8(pte(e7(s10, [0, 1], [r10, n10 - 2]), 1), i9(-1)), l10 = Z8([o10, u10], 1), h10 = Z8([s10, c10], 1), p10 = X8(W5(l10, h10), [i10[0], i10[1]]);
          t10 = Ote(p10);
        }
        if (t10 = ute(t10), 3 === e10.rank && 0 !== e10.shape[0]) {
          var f10 = t10, d10 = e10.shape[0];
          t10 = X8(t10, [d10, t10.shape[0] / d10, t10.shape[1]]), f10.dispose();
        }
        return t10;
      } });
      var Dte = B5({ split_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r10 = L5(e10, "x", "split"), a10 = { x: r10 }, i10 = { numOrSizeSplits: t10, axis: n10 };
        return E5.runKernel(o3, a10, i10);
      } });
      var Mte = B5({ rfft_: function(e10, t10) {
        F$("float32" === e10.dtype, function() {
          return "The dtype for rfft() must be real value but got ".concat(e10.dtype);
        });
        var n10, r10 = e10.shape[e10.shape.length - 1], a10 = e10.size / r10;
        if (null != t10 && t10 < r10) {
          var i10 = e10.shape.map(function(e11) {
            return 0;
          }), o10 = e10.shape.map(function(e11) {
            return e11;
          });
          o10[e10.shape.length - 1] = t10, n10 = e7(e10, i10, o10), r10 = t10;
        } else if (null != t10 && t10 > r10) {
          var s10 = e10.shape.map(function(e11) {
            return e11;
          });
          s10[e10.shape.length - 1] = t10 - r10, n10 = Z8([e10, $9(s10)], e10.shape.length - 1), r10 = t10;
        } else n10 = e10;
        var u10 = U7(n10), c10 = X8(W5(n10, u10), [a10, r10]), l10 = _te(c10), h10 = Math.floor(r10 / 2) + 1, p10 = ute(l10), f10 = k9(l10), d10 = Dte(p10, [h10, r10 - h10], p10.shape.length - 1), v10 = Dte(f10, [h10, r10 - h10], f10.shape.length - 1), m10 = n10.shape.slice();
        return m10[n10.shape.length - 1] = h10, X8(W5(d10[0], v10[0]), m10);
      } });
      var Lte = B5({ squaredDifference_: function(e10, t10) {
        var n10 = L5(e10, "a", "squaredDifference"), r10 = L5(t10, "b", "squaredDifference"), a10 = S(v5(n10, r10), 2);
        n10 = a10[0], r10 = a10[1], z7(n10.shape, r10.shape);
        var i10 = { a: n10, b: r10 };
        return E5.runKernel(f3, i10, {});
      } });
      var zte = B5({ squeeze_: function(e10, t10) {
        var n10 = L5(e10, "x", "squeeze", "string_or_numeric");
        return X8(n10, H$(n10.shape, t10).newShape);
      } });
      var Pte = B5({ stack_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n10 = z5(e10, "tensors", "stack", "string_or_numeric");
        F$(n10.length >= 1, function() {
          return "Pass at least one tensor to tf.stack";
        }), n10.length > 0 && F$(t10 <= n10[0].rank, function() {
          return "Axis must be <= rank of the tensor";
        });
        var r10 = n10, a10 = { axis: t10 };
        return E5.runKernel(S2, r10, a10);
      } });
      var Bte = B5({ step_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n10 = L5(e10, "x", "step"), r10 = { x: n10 }, a10 = { alpha: t10 };
        return E5.runKernel(_3, r10, a10);
      } });
      var Wte = B5({ stridedSlice_: function(e10, t10, n10, r10) {
        var a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, o10 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, s10 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, u10 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, c10 = L5(e10, "x", "stridedSlice", "string_or_numeric"), l10 = { x: c10 }, h10 = { begin: t10, end: n10, strides: r10, beginMask: a10, endMask: i10, ellipsisMask: o10, newAxisMask: s10, shrinkAxisMask: u10 };
        return E5.runKernel(m3, l10, h10);
      } });
      var Ute = B5({ tan_: function(e10) {
        var t10 = { x: L5(e10, "x", "tan", "float32") };
        return E5.runKernel(k3, t10);
      } });
      function Vte(e10, t10) {
        M$(e10);
        var n10 = F5(e10, t10);
        if (1 !== n10.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
        return U5(e10, null, n10, t10);
      }
      function Gte(e10, t10, n10) {
        if (M$(e10), null != t10 && 2 !== t10.length) throw new Error("tensor2d() requires shape to have two numbers");
        var r10 = F5(e10, n10);
        if (2 !== r10.length && 1 !== r10.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
        if (1 === r10.length && null == t10) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
        return U5(e10, t10, r10, n10);
      }
      function jte(e10, t10, n10) {
        if (M$(e10), null != t10 && 3 !== t10.length) throw new Error("tensor3d() requires shape to have three numbers");
        var r10 = F5(e10, n10);
        if (3 !== r10.length && 1 !== r10.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
        if (1 === r10.length && null == t10) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
        return U5(e10, t10, r10, n10);
      }
      function Hte(e10, t10, n10) {
        if (M$(e10), null != t10 && 4 !== t10.length) throw new Error("tensor4d() requires shape to have four numbers");
        var r10 = F5(e10, n10);
        if (4 !== r10.length && 1 !== r10.length) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
        if (1 === r10.length && null == t10) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
        return U5(e10, t10, r10, n10);
      }
      function qte(e10, t10, n10) {
        if (M$(e10), null != t10 && 5 !== t10.length) throw new Error("tensor5d() requires shape to have five numbers");
        var r10 = F5(e10, n10);
        if (5 !== r10.length && 1 !== r10.length) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
        if (1 === r10.length && null == t10) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
        return U5(e10, t10, r10, n10);
      }
      function Kte(e10, t10, n10) {
        if (M$(e10), null != t10 && 6 !== t10.length) throw new Error("tensor6d() requires shape to have six numbers");
        var r10 = F5(e10, n10);
        if (6 !== r10.length && 1 !== r10.length) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
        if (1 === r10.length && null == t10) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
        return U5(e10, t10 = t10 || r10, r10, n10);
      }
      function Xte(e10, t10, n10) {
        var r10 = t10.rank > 1 ? t10.shape[t10.rank - 1] : 1, a10 = t10.rank > 1 ? t10.rank - 1 : 1, i10 = "Must have updates.shape = indices.shape[:batchDim] + " + "shape[sliceDim:], got updates.shape: ".concat(n10.shape) + ", indices.shape: ".concat(t10.shape, ", shape: ").concat(e10) + ", sliceDim: ".concat(r10, ", and batchDim: ").concat(a10, ".");
        if (n10.rank < a10) throw new Error(i10 + " update.rank < ".concat(a10, ". "));
        if (e10.length < r10 + (n10.rank - a10)) throw new Error(i10 + " Output shape length < ".concat(r10 + (n10.rank - a10)));
        if (n10.rank !== a10 + e10.length - r10) throw new Error(i10 + " update.rank != ".concat(a10 + e10.length - r10));
        for (var o10 = 0; o10 < a10; ++o10) if (n10.shape[o10] !== t10.shape[o10]) throw new Error(i10 + " updates.shape[".concat(o10, "] (").concat(n10.shape[o10], ") != indices.shape[").concat(o10, "] (").concat(t10.shape[o10], ")."));
        for (var s10 = 0; s10 < n10.rank - a10; ++s10) if (n10.shape[s10 + a10] !== e10[s10 + r10]) throw new Error(i10 + " updates.shape[".concat(s10 + a10, "] (").concat(n10.shape[s10 + a10], ") != shape[").concat(s10 + a10, "] (").concat(e10[s10 + a10], ")"));
      }
      function Yte(e10, t10, n10) {
        if (t10.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher," + " but the rank was ".concat(t10.rank, "."));
        if (e10.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher," + " but the rank was ".concat(e10.rank, "."));
        if ("int32" !== t10.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t10.dtype));
        if (n10.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n10));
        if (0 === n10.length) {
          if (0 === t10.size) throw new Error("Indices specified for empty output. indices shape: ".concat(t10.shape));
          if (0 === e10.size) throw new Error("Updates specified for empty output. updates shape: ".concat(e10.shape));
        }
        Xte(n10, t10, e10);
      }
      function Jte(e10, t10, n10) {
        for (var r10 = t10.shape.length, a10 = r10 > 1 ? t10.shape[r10 - 1] : 1, i10 = n10.length, o10 = 1, s10 = a10; s10 < i10; ++s10) o10 *= n10[s10];
        var u10 = a10 < 1 ? 1 : a10;
        return { sliceRank: a10, numUpdates: L$(t10.shape) / u10, sliceSize: o10, strides: [].concat(T(i0(n10.slice(0, a10))), [1]), outputSize: L$(n10) };
      }
      var Zte = { __proto__: null, calculateShapes: Jte, validateInput: Yte, validateUpdateShape: Xte };
      var Qte = B5({ tensorScatterUpdate_: function(e10, t10, n10) {
        var r10 = L5(e10, "tensor", "tensorScatterupdate"), a10 = L5(t10, "indices", "tensorScatterupdate", "int32"), i10 = L5(n10, "updates", "tensorScatterupdate");
        if (Yte(i10, a10, r10.shape), r10.dtype !== i10.dtype) throw new Error("tensor and updates must have the same dtype, instead they are ".concat(r10.dtype, " and ").concat(i10.dtype, "."));
        var o10 = { tensor: r10, indices: a10, updates: i10 };
        return E5.runKernel(K2, o10, {});
      } });
      var $te = B5({ topk_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n10 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r10 = L5(e10, "x", "topk");
        if (0 === r10.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
        var a10 = r10.shape[r10.shape.length - 1];
        if (t10 < 0) throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t10));
        if (t10 > a10) throw new Error("'k' passed to topk() must be <= the last dimension (".concat(a10, ") ") + "but got ".concat(t10));
        var i10 = { x: r10 }, o10 = { k: t10, sorted: n10 }, s10 = E5.runKernel(N3, i10, o10), u10 = S(s10, 2), c10 = u10[0], l10 = u10[1];
        return { values: c10, indices: l10 };
      } });
      var ene = B5({ truncatedNormal_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r10 = arguments.length > 3 ? arguments[3] : void 0, a10 = arguments.length > 4 ? arguments[4] : void 0;
        if (p0(e10), null != r10 && "bool" === r10) throw new Error("Unsupported data type $ { dtype }");
        for (var i10 = new $ee(t10, n10, r10, true, a10), o10 = l8(e10, r10), s10 = 0; s10 < o10.values.length; s10++) o10.values[s10] = i10.nextValue();
        return o10.toTensor();
      } });
      var tne = B5({ unique_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n10 = L5(e10, "x", "unique", "string_or_numeric");
        F$(n10.rank > 0, function() {
          return "The input tensor must be at least 1D";
        });
        var r10 = { x: n10 }, a10 = { axis: t10 }, i10 = E5.runKernel(E3, r10, a10), o10 = S(i10, 2), s10 = o10[0], u10 = o10[1];
        return { values: s10, indices: u10 };
      } });
      var nne = B5({ unsortedSegmentSum_: function(e10, t10, n10) {
        var r10 = L5(e10, "x", "unsortedSegmentSum"), a10 = L5(t10, "segmentIds", "unsortedSegmentSum", "int32");
        F$(B$(n10), function() {
          return "numSegments must be of dtype int";
        });
        var i10 = { x: r10, segmentIds: a10 }, o10 = { numSegments: n10 };
        return E5.runKernel(A3, i10, o10);
      } });
      var rne = B5({ unstack_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n10 = L5(e10, "x", "unstack", "string_or_numeric");
        F$(t10 >= -n10.shape.length && t10 < n10.shape.length, function() {
          return "Axis = ".concat(t10, " is not in [-").concat(n10.shape.length, ", ").concat(n10.shape.length, ")");
        });
        var r10 = { value: n10 }, a10 = { axis: t10 };
        return E5.runKernel(C3, r10, a10);
      } });
      function ane(e10, t10) {
        return q9(e10, t10, "right");
      }
      function ine(e10) {
        var t10 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n10 = arguments.length > 2 ? arguments[2] : void 0, r10 = arguments.length > 3 ? arguments[3] : void 0;
        return E5.makeVariable(e10, t10, n10, r10);
      }
      function one(e10, t10) {
        for (var n10 = [], r10 = 0; r10 < t10.length; r10++) t10[r10] && n10.push(r10);
        for (var a10 = l8(e10, "int32"), i10 = l8([n10.length, e10.length], "int32"), o10 = 0; o10 < n10.length; o10++) {
          var s10 = a10.indexToLoc(n10[o10]), u10 = o10 * e10.length;
          i10.values.set(s10, u10);
        }
        return i10.toTensor();
      }
      function sne() {
        return (sne = c(o().mark(function e10(t10) {
          var n10, r10, a10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return n10 = L5(t10, "condition", "whereAsync", "bool"), e11.next = 3, n10.data();
              case 3:
                return r10 = e11.sent, a10 = one(n10.shape, r10), t10 !== n10 && n10.dispose(), e11.abrupt("return", a10);
              case 7:
              case "end":
                return e11.stop();
            }
          }, e10);
        }))).apply(this, arguments);
      }
      var une = function(e10) {
        return sne.apply(this, arguments);
      };
      function cne() {
        return cne = c(o().mark(function e10(t10, n10, r10) {
          var a10, i10, s10, u10, c10, l10, h10, p10, f10, d10, v10, m10, g10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                for (a10 = L5(t10, "tensor", "boolMask"), i10 = L5(n10, "mask", "boolMask", "bool"), s10 = null == r10 ? 0 : r10, u10 = i10.rank, c10 = a10.shape, F$(u10 > 0, function() {
                  return "mask cannot be scalar";
                }), D$(c10.slice(s10, s10 + u10), i10.shape, "mask's shape must match the first K dimensions of tensor's shape,"), l10 = 1, h10 = s10; h10 < s10 + u10; h10++) l10 *= c10[h10];
                return p10 = c10.slice(0, s10).concat([l10], c10.slice(s10 + u10)), f10 = X8(a10, p10), d10 = X8(i10, [-1]), e11.next = 14, une(d10);
              case 14:
                return v10 = e11.sent, m10 = zte(v10, [1]), g10 = y9(f10, m10, s10), t10 !== a10 && a10.dispose(), n10 !== i10 && i10.dispose(), m10.dispose(), f10.dispose(), d10.dispose(), v10.dispose(), e11.abrupt("return", g10);
              case 24:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), cne.apply(this, arguments);
      }
      var lne = function(e10, t10, n10) {
        return cne.apply(this, arguments);
      };
      var hne = B5({ transpose_: function(e10, t10, n10) {
        var r10 = L5(e10, "x", "transpose");
        if (null == t10 && (t10 = r10.shape.map(function(e11, t11) {
          return t11;
        }).reverse()), F$(r10.rank === t10.length, function() {
          return "Error in transpose: rank of input ".concat(r10.rank, " ") + "must match length of perm ".concat(t10, ".");
        }), t10.forEach(function(e11) {
          F$(e11 >= 0 && e11 < r10.rank, function() {
            return "All entries in 'perm' must be between 0 and ".concat(r10.rank - 1) + " but got ".concat(t10);
          });
        }), r10.rank <= 1) return r10.clone();
        var a10 = { x: r10 }, i10 = { perm: t10 };
        return "complex64" === r10.dtype ? X5(function() {
          var e11 = ute(r10), t11 = k9(r10);
          return e11 = E5.runKernel(T3, { x: e11 }, i10), t11 = E5.runKernel(T3, { x: t11 }, i10), n10 && (t11 = M9(t11)), W5(e11, t11);
        }) : E5.runKernel(T3, a10, i10);
      } });
      var pne = B5({ movingAverage_: function(e10, t10, n10, r10) {
        var a10 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], i10 = L5(e10, "v", "movingAverage"), o10 = L5(t10, "x", "movingAverage"), s10 = L5(n10, "decay", "movingAverage");
        m5(i10, o10), F$(P$(i10.shape, o10.shape), function() {
          return "Shape mismatch in v and x";
        });
        var u10 = i9(1), c10 = P9(u10, s10), l10 = g8(P9(o10, i10), c10);
        if (a10) {
          F$(null != r10, function() {
            return "When using zeroDebias: true, step is required.";
          });
          var h10 = L5(r10, "step", "movingAverage");
          l10 = m8(l10, P9(u10, a9(s10, h10)));
        }
        return d8(i10, l10);
      } });
      var fne = B5({ scatterND_: function(e10, t10, n10) {
        p0(n10);
        var r10 = L5(e10, "indices", "scatterND", "int32"), a10 = L5(t10, "updates", "scatterND");
        Yte(a10, r10, n10);
        var i10 = { indices: r10, updates: a10 }, o10 = { shape: n10 };
        return E5.runKernel(q2, i10, o10);
      } });
      function dne(e10, t10, n10, r10) {
        if ("int32" !== e10.dtype) throw new Error("tf.sparseToDense() expects the indices to be int32 type," + " but the dtype was ".concat(e10.dtype, "."));
        if (e10.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix," + " but got shape ".concat(e10.shape, "."));
        var a10 = e10.rank > 0 ? e10.shape[0] : 1, i10 = e10.rank > 1 ? e10.shape[1] : 1;
        if (n10.length !== i10) throw new Error("outputShape has incorrect number of elements:," + " ".concat(n10.length, ", should be: ").concat(i10, "."));
        var o10 = t10.size;
        if (0 !== t10.rank && (1 !== t10.rank || o10 !== a10)) throw new Error("sparseValues has incorrect shape " + "".concat(t10.shape, ", should be [] or [").concat(a10, "]"));
        if (t10.dtype !== r10.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype");
      }
      var vne = B5({ sparseToDense_: function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
        p0(n10);
        var a10 = L5(e10, "sparseIndices", "sparseToDense", "int32"), i10 = L5(t10, "sparseValues", "sparseToDense", "string_or_numeric"), o10 = L5(r10, "defaultValue", "sparseToDense", i10.dtype);
        dne(a10, i10, n10, o10);
        var s10 = { sparseIndices: a10, sparseValues: i10, defaultValue: o10 }, u10 = { outputShape: n10 };
        return E5.runKernel(p3, s10, u10);
      } });
      var mne = B5({ gatherND_: function(e10, t10) {
        var n10 = L5(t10, "indices", "gatherND", "int32"), r10 = { params: L5(e10, "x", "gatherND", "string_or_numeric"), indices: n10 };
        return E5.runKernel(z1, r10);
      } });
      var gne = B5({ dropout_: function(e10, t10, n10, r10) {
        var a10 = L5(e10, "x", "dropout");
        if (F$("float32" === a10.dtype, function() {
          return "x has to be a floating point tensor since it's going to be " + "scaled, but got a ".concat(a10.dtype, " tensor instead.");
        }), F$(t10 >= 0 && t10 < 1, function() {
          return "rate must be a float in the range [0, 1), but got ".concat(t10, ".");
        }), 0 === t10) return e10 instanceof n5 ? a10.clone() : a10;
        var i10 = function(e11, t11) {
          if (null == t11) return e11.shape.slice();
          if (P$(e11.shape, t11)) return t11;
          if (e11.shape.length === t11.length) {
            for (var n11 = [], r11 = 0; r11 < e11.shape.length; r11++) null == t11[r11] && null != e11.shape[r11] ? n11.push(e11.shape[r11]) : n11.push(t11[r11]);
            return n11;
          }
          return t11;
        }(a10, n10), o10 = 1 - t10, s10 = m8(g9(d8(ite(i10, 0, 1, "float32", r10), o10)), o10);
        return g8(a10, s10);
      } });
      function yne(e10) {
        return Math.floor(Math.pow(2, Math.ceil(Math.log(e10) / Math.log(2))));
      }
      function bne(e10, t10, n10) {
        for (var r10 = 1 - e10 % 2, a10 = new Float32Array(e10), i10 = 0; i10 < e10; ++i10) {
          var o10 = 2 * Math.PI * i10 / (e10 + r10 - 1);
          a10[i10] = t10 - n10 * Math.cos(o10);
        }
        return Vte(a10, "float32");
      }
      function xne() {
        return xne = c(o().mark(function e10(t10, n10) {
          var r10, a10, i10, s10, u10, c10, l10, h10, p10, f10, d10, v10, m10, g10, y10, b10 = arguments;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return r10 = b10.length > 2 && void 0 !== b10[2] ? b10[2] : 1, a10 = L5(t10, "predictions", "inTopK"), i10 = L5(n10, "targets", "inTopK"), F$(a10.rank > 1, function() {
                  return "inTopK() expects the predictions to be of rank 2 or higher, " + "but got ".concat(a10.rank);
                }), F$(a10.rank - 1 === i10.rank, function() {
                  return "predictions rank should be 1 larger than targets rank, but got predictions rank " + "".concat(a10.rank, " and targets rank ").concat(i10.rank);
                }), D$(a10.shape.slice(0, a10.shape.length - 1), i10.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), s10 = a10.shape[a10.shape.length - 1], F$(r10 > 0 && r10 <= s10, function() {
                  return "'k' passed to inTopK() must be > 0 && <= the predictions last " + "dimension (".concat(s10, "), but got ").concat(r10);
                }), e11.next = 10, a10.data();
              case 10:
                return u10 = e11.sent, e11.next = 13, i10.data();
              case 13:
                c10 = e11.sent, l10 = u10.length / s10, h10 = s10, p10 = q$("bool", l10), f10 = 0;
              case 17:
                if (!(f10 < l10)) {
                  e11.next = 35;
                  break;
                }
                for (d10 = f10 * h10, v10 = u10.subarray(d10, d10 + h10), m10 = [], g10 = 0; g10 < v10.length; g10++) m10.push({ value: v10[g10], index: g10 });
                m10.sort(function(e12, t11) {
                  return t11.value - e12.value;
                }), p10[f10] = 0, y10 = 0;
              case 25:
                if (!(y10 < r10)) {
                  e11.next = 32;
                  break;
                }
                if (m10[y10].index !== c10[f10]) {
                  e11.next = 29;
                  break;
                }
                return p10[f10] = 1, e11.abrupt("break", 32);
              case 29:
                y10++, e11.next = 25;
                break;
              case 32:
                f10++, e11.next = 17;
                break;
              case 35:
                return t10 !== a10 && a10.dispose(), n10 !== i10 && i10.dispose(), e11.abrupt("return", V5(p10, i10.shape, "bool"));
              case 38:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), xne.apply(this, arguments);
      }
      var kne = function(e10, t10) {
        return xne.apply(this, arguments);
      };
      var wne = B5({ conv2DBackpropFilter_: function(e10, t10, n10, r10, a10) {
        var i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "NHWC", o10 = arguments.length > 6 ? arguments[6] : void 0, s10 = e10;
        3 === e10.rank && (s10 = X8(e10, [1, e10.shape[0], e10.shape[1], e10.shape[2]]));
        var u10 = t10;
        3 === u10.rank && (u10 = X8(t10, [1, t10.shape[0], t10.shape[1], t10.shape[2]])), F$(4 === s10.rank, function() {
          return "Error in conv2dDerFilter: input must be rank 4, but got shape " + "".concat(s10.shape, ".");
        }), F$(4 === u10.rank, function() {
          return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + "".concat(u10.shape, ".");
        }), F$(4 === n10.length, function() {
          return "Error in conv2dDerFilter: filterShape must be length 4, but got " + "".concat(n10, ".");
        });
        var c10 = "NHWC" === i10 ? s10.shape[3] : s10.shape[1], l10 = "NHWC" === i10 ? u10.shape[3] : u10.shape[1];
        F$(c10 === n10[2], function() {
          return "Error in conv2dDerFilter: depth of input ".concat(c10, ") must ") + "match input depth in filter (".concat(n10[2], ".");
        }), F$(l10 === n10[3], function() {
          return "Error in conv2dDerFilter: depth of dy (".concat(l10, ") must ") + "match output depth for filter (".concat(n10[3], ").");
        }), K8("conv2dDerFilter", a10, o10);
        var h10 = { x: s10, dy: u10 }, p10 = { strides: r10, pad: a10, dataFormat: i10, dimRoundingMode: o10, filterShape: n10 };
        return E5.runKernel(t1, h10, p10);
      } });
      function Ine(e10, t10, n10) {
        if (null == n10 || "linear" === n10) return e10;
        if ("relu" === n10) return g8(e10, Bte(t10));
        throw new Error("Cannot compute gradient for fused activation ".concat(n10, "."));
      }
      function Nne(e10, t10) {
        var n10 = t10, r10 = L7(e10.shape, t10.shape);
        return r10.length > 0 && (n10 = u9(n10, r10)), X8(n10, e10.shape);
      }
      function Sne(e10, t10, n10, r10) {
        if ("linear" === t10) return e10;
        if ("relu" === t10) return lte(e10);
        if ("elu" === t10) return H7(e10);
        if ("relu6" === t10) return hte(e10);
        if ("prelu" === t10) return bee(e10, n10);
        if ("leakyrelu" === t10) return S9(e10, r10);
        if ("sigmoid" === t10) return $8(e10);
        throw new Error("Unknown fused activation ".concat(t10, "."));
      }
      var Tne = function(e10, t10) {
        return !(e10 > 0) || "linear" === t10;
      };
      var Ene = B5({ fusedConv2d_: function(e10) {
        var t10 = e10.x, n10 = e10.filter, r10 = e10.strides, a10 = e10.pad, i10 = e10.dataFormat, o10 = void 0 === i10 ? "NHWC" : i10, s10 = e10.dilations, u10 = void 0 === s10 ? [1, 1] : s10, c10 = e10.dimRoundingMode, l10 = e10.bias, h10 = e10.activation, p10 = void 0 === h10 ? "linear" : h10, f10 = e10.preluActivationWeights, d10 = e10.leakyreluAlpha;
        if (p10 = p10 || "linear", false === Tne(E5.state.gradientDepth, p10)) {
          F$("NHWC" === o10, function() {
            return "Error in fused conv2d: got dataFormat of ".concat(o10, " but ") + "only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.";
          });
          var v10 = b7(t10, n10, r10, a10, o10, u10, c10);
          return null != l10 && (v10 = d8(v10, l10)), Sne(v10, p10, f10, d10);
        }
        var m10 = L5(t10, "x", "conv2d", "float32"), g10 = L5(n10, "filter", "conv2d", "float32"), y10 = m10, b10 = false;
        3 === m10.rank && (b10 = true, y10 = X8(m10, [1, m10.shape[0], m10.shape[1], m10.shape[2]])), F$(4 === y10.rank, function() {
          return "Error in fused conv2d: input must be rank 4, but got rank " + "".concat(y10.rank, ".");
        }), F$(4 === g10.rank, function() {
          return "Error in fused conv2d: filter must be rank 4, but got rank " + "".concat(g10.rank, ".");
        }), K8("fused conv2d", a10, c10);
        var x10 = "NHWC" === o10 ? y10.shape[3] : y10.shape[1];
        F$(g10.shape[2] === x10, function() {
          return "Error in conv2d: depth of input (".concat(x10, ") must match ") + "input depth for filter ".concat(g10.shape[2], ".");
        }), F$(j8(r10, u10), function() {
          return "Error in conv2D: Either strides or dilations must be 1. " + "Got strides ".concat(r10, " and dilations '").concat(u10, "'");
        });
        var k10, w10, I10 = D8(y10.shape, g10.shape, r10, u10, a10, c10);
        if (null != l10) {
          var N10 = S(v5(k10 = L5(l10, "bias", "fused conv2d"), m10), 1);
          k10 = N10[0], "NHWC" === o10 ? z7(I10.outShape, k10.shape) : (F$(k10.shape.length <= 1, function() {
            return "Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of " + "rank-".concat(k10.shape.length, ".");
          }), F$(0 === k10.shape.length || k10.shape[0] === I10.outChannels || 1 === k10.shape[0], function() {
            return "Error in fused conv2d: bias shape (".concat(k10.shape, ") is not ") + "compatible with the number of output channels " + "(".concat(I10.outChannels, ")");
          }));
        }
        if (null != f10) {
          var T10 = f10.shape;
          if (F$(T10.length <= 1 || 3 === T10.length, function() {
            return "Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of " + "rank-".concat(T10.length, ".");
          }), 1 === T10.length) F$(1 === T10[0] || T10[0] === I10.outChannels, function() {
            return "Error in fused conv2d: PReLU activation weights " + "(".concat(T10, ") is not compatible with the number of output ") + "channels (".concat(I10.outChannels, ").");
          });
          else if (3 === T10.length) try {
            z7(T10, I10.outShape);
          } catch (e11) {
            var E10 = "Error in fused conv2d: PReLU activation weights (".concat(T10, ") ") + "is not compatible with the output shape of the conv2d " + "(".concat(I10.outShape, ").");
            throw Error(E10);
          }
          w10 = L5(f10, "prelu weights", "fused conv2d");
        }
        var C10 = function(e11, t11) {
          F$("NHWC" === o10, function() {
            return "Error in gradient of fused conv2D: got dataFormat of ".concat(o10, " but only NHWC is currently supported.");
          });
          var n11 = S(t11, 4), i11 = n11[0], s11 = n11[1], c11 = n11[2], l11 = n11[3], h11 = Ine(e11, c11, p10);
          F$(G8(u10), function() {
            return "Error in gradient of fused conv2D: dilation rates greater than 1 " + "are not yet supported in gradients. Got dilations '".concat(u10, "'");
          });
          var f11 = [k7(s11.shape, h11, i11, r10, a10), wne(s11, h11, i11.shape, r10, a10)];
          if (null != l11) {
            var d11 = Nne(l11, h11);
            f11.push(d11);
          }
          return f11;
        }, A10 = { x: y10, filter: g10, bias: k10, preluActivationWeights: w10 }, R10 = { strides: r10, pad: a10, dataFormat: o10, dilations: u10, dimRoundingMode: c10, activation: p10, leakyreluAlpha: d10 };
        if (null == l10) {
          var _10 = F9(function(e11, t11, n11) {
            var r11 = E5.runKernel(M3, A10, R10);
            return n11([t11, e11, r11]), b10 && (r11 = X8(r11, [r11.shape[1], r11.shape[2], r11.shape[3]])), { value: r11, gradFunc: C10 };
          });
          return _10(y10, g10);
        }
        var O10 = F9(function(e11, t11, n11, r11) {
          var a11 = E5.runKernel(M3, A10, R10);
          return r11([t11, e11, a11, n11]), b10 && (a11 = X8(a11, [a11.shape[1], a11.shape[2], a11.shape[3]])), { value: a11, gradFunc: C10 };
        });
        return O10(y10, g10, k10);
      } });
      var Cne = B5({ depthwiseConv2dNativeBackpropFilter_: function(e10, t10, n10, r10, a10) {
        var i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [1, 1], o10 = arguments.length > 6 ? arguments[6] : void 0, s10 = e10;
        3 === e10.rank && (s10 = X8(e10, [1, e10.shape[0], e10.shape[1], e10.shape[2]]));
        var u10 = t10;
        3 === u10.rank && (u10 = X8(t10, [1, t10.shape[0], t10.shape[1], t10.shape[2]]));
        var c10 = { x: s10, dy: u10 }, l10 = { strides: r10, pad: a10, dimRoundingMode: o10, dilations: i10, filterShape: n10 };
        return E5.runKernel(d1, c10, l10);
      } });
      var Ane = B5({ depthwiseConv2dNativeBackpropInput_: function(e10, t10, n10, r10, a10) {
        var i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [1, 1], o10 = arguments.length > 6 ? arguments[6] : void 0, s10 = t10, u10 = false;
        3 === t10.rank && (u10 = true, s10 = X8(t10, [1, t10.shape[0], t10.shape[1], t10.shape[2]]));
        var c10 = { dy: s10, filter: n10 }, l10 = { strides: r10, pad: a10, dimRoundingMode: o10, dilations: i10, inputShape: e10 }, h10 = E5.runKernel(v1, c10, l10);
        return u10 ? X8(h10, [h10.shape[1], h10.shape[2], h10.shape[3]]) : h10;
      } });
      var Rne = B5({ fusedDepthwiseConv2d_: function(e10) {
        var t10 = e10.x, n10 = e10.filter, r10 = e10.strides, a10 = e10.pad, i10 = e10.dataFormat, o10 = void 0 === i10 ? "NHWC" : i10, s10 = e10.dilations, u10 = void 0 === s10 ? [1, 1] : s10, c10 = e10.dimRoundingMode, l10 = e10.bias, h10 = e10.activation, p10 = void 0 === h10 ? "linear" : h10, f10 = e10.preluActivationWeights, d10 = e10.leakyreluAlpha;
        if (false === Tne(E5.state.gradientDepth, p10)) {
          var v10 = O7(t10, n10, r10, a10, o10, u10, c10);
          return null != l10 && (v10 = d8(v10, l10)), Sne(v10, p10, f10, d10);
        }
        var m10 = L5(t10, "x", "depthwiseConv2d", "float32"), g10 = L5(n10, "filter", "depthwiseConv2d", "float32"), y10 = m10, b10 = false;
        3 === m10.rank && (b10 = true, y10 = X8(m10, [1, m10.shape[0], m10.shape[1], m10.shape[2]])), F$(4 === y10.rank, function() {
          return "Error in fused depthwiseConv2d: input must be rank 4, but got " + "rank ".concat(y10.rank, ".");
        }), F$(4 === g10.rank, function() {
          return "Error in fused depthwiseConv2d: filter must be rank 4, " + "but got rank ".concat(g10.rank, ".");
        }), F$(y10.shape[3] === g10.shape[2], function() {
          return "Error in fused depthwiseConv2d: number of input channels " + "(".concat(y10.shape[3], ") must match the inChannels dimension in ") + "filter ".concat(g10.shape[2], ".");
        }), null == u10 && (u10 = [1, 1]), F$(j8(r10, u10), function() {
          return "Error in fused depthwiseConv2d: Either strides or dilations must " + "be 1. Got strides ".concat(r10, " and dilations '").concat(u10, "'");
        }), K8("fused depthwiseConv2d", a10, c10);
        var x10, k10, w10 = D8(y10.shape, g10.shape, r10, u10, a10, c10, true);
        if (null != l10) {
          var I10 = S(v5(x10 = L5(l10, "bias", "fused conv2d"), m10), 1);
          x10 = I10[0], z7(w10.outShape, x10.shape);
        }
        null != f10 && (k10 = L5(f10, "prelu weights", "fused depthwiseConv2d"));
        var N10 = function(e11, t11) {
          F$(G8(u10), function() {
            return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations " + "'".concat(u10, "'");
          });
          var n11 = S(t11, 4), i11 = n11[0], o11 = n11[1], s11 = n11[2], l11 = n11[3], h11 = Ine(e11, s11, p10), f11 = Ane(o11.shape, h11, i11, r10, a10, u10, c10), d11 = Cne(o11, h11, i11.shape, r10, a10, u10, c10);
          return null != l11 ? [f11, d11, Nne(x10, h11)] : [f11, d11];
        }, T10 = { x: y10, filter: g10, bias: x10, preluActivationWeights: k10 }, E10 = { strides: r10, pad: a10, dataFormat: o10, dilations: u10, dimRoundingMode: c10, activation: p10, leakyreluAlpha: d10 };
        if (null == l10) {
          var C10 = F9(function(e11, t11, n11) {
            var r11 = E5.runKernel(L3, T10, E10);
            return n11([t11, e11, r11]), b10 && (r11 = X8(r11, [r11.shape[1], r11.shape[2], r11.shape[3]])), { value: r11, gradFunc: N10 };
          });
          return C10(y10, g10);
        }
        var A10 = F9(function(e11, t11, n11, r11) {
          var a11 = E5.runKernel(L3, T10, E10);
          return r11([t11, e11, a11, n11]), b10 && (a11 = X8(a11, [a11.shape[1], a11.shape[2], a11.shape[3]])), { value: a11, gradFunc: N10 };
        });
        return A10(y10, g10, x10);
      } });
      var _ne = B5({ fusedMatMul_: function(e10) {
        var t10 = e10.a, n10 = e10.b, r10 = e10.transposeA, a10 = void 0 !== r10 && r10, i10 = e10.transposeB, o10 = void 0 !== i10 && i10, s10 = e10.bias, u10 = e10.activation, c10 = void 0 === u10 ? "linear" : u10, l10 = e10.preluActivationWeights, h10 = e10.leakyreluAlpha, p10 = void 0 === h10 ? 0.2 : h10;
        if (false === Tne(E5.state.gradientDepth, c10)) {
          var f10 = Q8(t10, n10, a10, o10);
          return null != s10 && (f10 = d8(f10, s10)), Sne(f10, c10, l10, p10);
        }
        var d10 = L5(t10, "a", "fused matMul"), v10 = L5(n10, "b", "fused matMul"), m10 = S(v5(d10, v10), 2);
        d10 = m10[0], v10 = m10[1];
        var g10 = a10 ? d10.shape[d10.rank - 2] : d10.shape[d10.rank - 1], y10 = o10 ? v10.shape[v10.rank - 1] : v10.shape[v10.rank - 2], b10 = a10 ? d10.shape[d10.rank - 1] : d10.shape[d10.rank - 2], x10 = o10 ? v10.shape[v10.rank - 2] : v10.shape[v10.rank - 1], k10 = d10.shape.slice(0, -2), w10 = v10.shape.slice(0, -2), I10 = L$(k10), N10 = L$(w10);
        F$(g10 === y10, function() {
          return "Error in fused matMul: inner shapes (".concat(g10, ") and (") + "".concat(y10, ") of Tensors with shapes ").concat(d10.shape, " and ") + "".concat(v10.shape, " and transposeA=").concat(a10) + " and transposeB=".concat(o10, " must match.");
        });
        var T10, E10, C10 = z7(d10.shape.slice(0, -2), v10.shape.slice(0, -2)).concat([b10, x10]), A10 = X8(d10, a10 ? [I10, g10, b10] : [I10, b10, g10]), R10 = X8(v10, o10 ? [N10, x10, y10] : [N10, y10, x10]);
        null != s10 && (T10 = S(v5(T10 = L5(s10, "bias", "fused matMul"), d10), 1)[0], z7(C10, T10.shape)), null != l10 && (E10 = L5(l10, "prelu weights", "fused matMul"));
        var _10 = function(e11, t11) {
          var n11, r11, i11 = S(t11, 4), u11 = i11[0], l11 = i11[1], h11 = i11[2], p11 = i11[3], f11 = Ine(X8(e11, h11.shape), h11, c10);
          return a10 || o10 ? !a10 && o10 ? (n11 = Q8(f11, l11, false, false), r11 = Q8(f11, u11, true, false)) : a10 && !o10 ? (n11 = Q8(l11, f11, false, true), r11 = Q8(u11, f11, false, false)) : (n11 = Q8(l11, f11, true, true), r11 = Q8(f11, u11, true, true)) : (n11 = Q8(f11, l11, false, true), r11 = Q8(u11, f11, true, false)), null != s10 ? [n11, r11, Nne(p11, f11)] : [n11, r11];
        }, O10 = { a: A10, b: R10, bias: T10, preluActivationWeights: E10 }, F10 = { transposeA: a10, transposeB: o10, activation: c10, leakyreluAlpha: p10 };
        if (null == s10) {
          var D10 = F9(function(e11, t11, n11) {
            var r11 = E5.runKernel(D3, O10, F10);
            return n11([e11, t11, r11]), { value: X8(r11, C10), gradFunc: _10 };
          });
          return D10(A10, R10);
        }
        var M10 = F9(function(e11, t11, n11, r11) {
          var a11 = E5.runKernel(D3, O10, F10);
          return r11([e11, t11, a11, n11]), { value: X8(a11, C10), gradFunc: _10 };
        });
        return M10(A10, R10, T10);
      } }), One = { __proto__: null, conv2d: Ene, depthwiseConv2d: Rne, matMul: _ne };
      var Fne = B5({ hammingWindow_: function(e10) {
        return bne(e10, 0.54, 0.46);
      } });
      var Dne = B5({ hannWindow_: function(e10) {
        return bne(e10, 0.5, 0.5);
      } });
      var Mne = B5({ frame_: function(e10, t10, n10) {
        for (var r10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, i10 = 0, o10 = []; i10 + t10 <= e10.size; ) o10.push(e7(e10, i10, t10)), i10 += n10;
        if (r10) for (; i10 < e10.size; ) {
          var s10 = i10 + t10 - e10.size, u10 = Z8([e7(e10, i10, t10 - s10), f7([s10], a10)]);
          o10.push(u10), i10 += n10;
        }
        return 0 === o10.length ? Gte([], [0, t10]) : X8(Z8(o10), [o10.length, t10]);
      } });
      var Lne = B5({ stft_: function(e10, t10, n10, r10) {
        var a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Dne;
        null == r10 && (r10 = yne(t10));
        var i10 = Mne(e10, t10, n10), o10 = g8(i10, a10(t10));
        return Mte(o10, r10);
      } });
      var zne = B5({ cropAndResize_: function(e10, t10, n10, r10) {
        var a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "bilinear", i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, o10 = L5(e10, "image", "cropAndResize"), s10 = L5(t10, "boxes", "cropAndResize", "float32"), u10 = L5(n10, "boxInd", "cropAndResize", "int32"), c10 = s10.shape[0];
        F$(4 === o10.rank, function() {
          return "Error in cropAndResize: image must be rank 4," + "but got rank ".concat(o10.rank, ".");
        }), F$(2 === s10.rank && 4 === s10.shape[1], function() {
          return "Error in cropAndResize: boxes must be have size [".concat(c10, ",4] ") + "but had shape ".concat(s10.shape, ".");
        }), F$(1 === u10.rank && u10.shape[0] === c10, function() {
          return "Error in cropAndResize: boxInd must be have size [".concat(c10, "] ") + "but had shape ".concat(s10.shape, ".");
        }), F$(2 === r10.length, function() {
          return "Error in cropAndResize: cropSize must be of length 2, but got " + "length ".concat(r10.length, ".");
        }), F$(r10[0] >= 1 && r10[1] >= 1, function() {
          return "cropSize must be atleast [1,1], but was ".concat(r10);
        }), F$("bilinear" === a10 || "nearest" === a10, function() {
          return "method must be bilinear or nearest, but was ".concat(a10);
        });
        var l10 = { image: o10, boxes: s10, boxInd: u10 }, h10 = { method: a10, extrapolationValue: i10, cropSize: r10 }, p10 = E5.runKernel(l1, l10, h10);
        return p10;
      } });
      var Pne = B5({ flipLeftRight_: function(e10) {
        var t10 = L5(e10, "image", "flipLeftRight", "float32");
        F$(4 === t10.rank, function() {
          return "Error in flipLeftRight: image must be rank 4," + "but got rank ".concat(t10.rank, ".");
        });
        var n10 = { image: t10 };
        return E5.runKernel(O1, n10, {});
      } });
      var Bne = B5({ grayscaleToRGB_: function(e10) {
        var t10 = L5(e10, "image", "grayscaleToRGB"), n10 = t10.rank - 1, r10 = t10.shape[n10];
        F$(t10.rank >= 2, function() {
          return "Error in grayscaleToRGB: images must be at least rank 2, " + "but got rank ".concat(t10.rank, ".");
        }), F$(1 === r10, function() {
          return "Error in grayscaleToRGB: last dimension of a grayscale image " + "should be size 1, but got size ".concat(r10, ".");
        });
        var a10 = new Array(t10.rank);
        return a10.fill(1, 0, n10), a10[n10] = 3, v9(t10, a10);
      } });
      var Wne = B5({ rgbToGrayscale_: function(e10) {
        var t10 = L5(e10, "image", "RGBToGrayscale"), n10 = t10.rank - 1, r10 = t10.shape[n10];
        F$(t10.rank >= 2, function() {
          return "Error in RGBToGrayscale: images must be at least rank 2, " + "but got rank ".concat(t10.rank, ".");
        }), F$(3 === r10, function() {
          return "Error in RGBToGrayscale: last dimension of an RGB image " + "should be size 3, but got size ".concat(r10, ".");
        });
        var a10, i10 = t10.dtype, o10 = h8(t10, "float32"), s10 = Vte([0.2989, 0.587, 0.114]);
        switch (t10.rank) {
          case 2:
            a10 = j7("ij,j->i", o10, s10);
            break;
          case 3:
            a10 = j7("ijk,k->ij", o10, s10);
            break;
          case 4:
            a10 = j7("ijkl,l->ijk", o10, s10);
            break;
          case 5:
            a10 = j7("ijklm,m->ijkl", o10, s10);
            break;
          case 6:
            a10 = j7("ijklmn,n->ijklm", o10, s10);
            break;
          default:
            throw new Error("Not a valid tensor rank.");
        }
        return a10 = f9(a10, -1), h8(a10, i10);
      } });
      var Une = B5({ rotateWithOffset_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.5, a10 = L5(e10, "image", "rotateWithOffset", "float32");
        F$(4 === a10.rank, function() {
          return "Error in rotateWithOffset: image must be rank 4," + "but got rank ".concat(a10.rank, ".");
        });
        var i10 = { image: a10 }, o10 = { radians: t10, fillValue: n10, center: r10 }, s10 = E5.runKernel(F3, i10, o10);
        return s10;
      } });
      function Vne(e10, t10, n10, r10, a10, i10) {
        null == r10 && (r10 = 0.5), null == a10 && (a10 = Number.NEGATIVE_INFINITY), null == i10 && (i10 = 0);
        var o10 = e10.shape[0];
        return n10 = Math.min(n10, o10), F$(0 <= r10 && r10 <= 1, function() {
          return "iouThreshold must be in [0, 1], but was '".concat(r10, "'");
        }), F$(2 === e10.rank, function() {
          return "boxes must be a 2D tensor, but was of rank '".concat(e10.rank, "'");
        }), F$(4 === e10.shape[1], function() {
          return "boxes must have 4 columns, but 2nd dimension was ".concat(e10.shape[1]);
        }), F$(1 === t10.rank, function() {
          return "scores must be a 1D tensor";
        }), F$(t10.shape[0] === o10, function() {
          return "scores has incompatible shape with boxes. Expected ".concat(o10, ", ") + "but was ".concat(t10.shape[0]);
        }), F$(0 <= i10 && i10 <= 1, function() {
          return "softNmsSigma must be in [0, 1], but was '".concat(i10, "'");
        }), { maxOutputSize: n10, iouThreshold: r10, scoreThreshold: a10, softNmsSigma: i10 };
      }
      var Gne = B5({ nonMaxSuppression_: function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.5, a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Number.NEGATIVE_INFINITY, i10 = L5(e10, "boxes", "nonMaxSuppression", "float32"), o10 = L5(t10, "scores", "nonMaxSuppression", "float32"), s10 = Vne(i10, o10, n10, r10, a10), u10 = { maxOutputSize: n10 = s10.maxOutputSize, iouThreshold: r10 = s10.iouThreshold, scoreThreshold: a10 = s10.scoreThreshold };
        return E5.runKernel(x2, { boxes: i10, scores: o10 }, u10);
      } });
      function jne(e10, t10, n10) {
        var r10 = function(e11, t11, n11) {
          return function(e12, t12, n12) {
            var r11 = 0, a11 = e12.length, i10 = 0, o10 = false;
            for (; r11 < a11; ) {
              var s10 = n12(t12, e12[i10 = r11 + (a11 - r11 >>> 1)]);
              s10 > 0 ? r11 = i10 + 1 : (a11 = i10, o10 = !s10);
            }
            return o10 ? r11 : -r11 - 1;
          }(e11, t11, n11 || Hne);
        }(e10, t10, n10), a10 = r10 < 0 ? -(r10 + 1) : r10;
        e10.splice(a10, 0, t10);
      }
      function Hne(e10, t10) {
        return e10 > t10 ? 1 : e10 < t10 ? -1 : 0;
      }
      function qne(e10, t10, n10, r10, a10) {
        return Yne(e10, t10, n10, r10, a10, 0);
      }
      function Kne(e10, t10, n10, r10, a10, i10) {
        return Yne(e10, t10, n10, r10, a10, 0, false, i10, true);
      }
      function Xne(e10, t10, n10, r10, a10, i10) {
        return Yne(e10, t10, n10, r10, a10, i10, true);
      }
      function Yne(e10, t10, n10, r10, a10, i10) {
        for (var o10 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6], s10 = arguments.length > 7 && void 0 !== arguments[7] && arguments[7], u10 = arguments.length > 8 && void 0 !== arguments[8] && arguments[8], c10 = [], l10 = 0; l10 < t10.length; l10++) t10[l10] > a10 && c10.push({ score: t10[l10], boxIndex: l10, suppressBeginIndex: 0 });
        c10.sort(Qne);
        for (var h10 = i10 > 0 ? -0.5 / i10 : 0, p10 = [], f10 = []; p10.length < n10 && c10.length > 0; ) {
          var d10 = c10.pop(), v10 = d10.score, m10 = d10.boxIndex, g10 = d10.suppressBeginIndex;
          if (v10 < a10) break;
          for (var y10 = false, b10 = p10.length - 1; b10 >= g10; --b10) {
            var x10 = Jne(e10, m10, p10[b10]);
            if (x10 >= r10) {
              y10 = true;
              break;
            }
            if (d10.score = d10.score * Zne(r10, h10, x10), d10.score <= a10) break;
          }
          d10.suppressBeginIndex = p10.length, y10 || (d10.score === v10 ? (p10.push(m10), f10.push(d10.score)) : d10.score > a10 && jne(c10, d10, Qne));
        }
        var k10 = p10.length, w10 = n10 - k10;
        s10 && w10 > 0 && (p10.push.apply(p10, T(new Array(w10).fill(0))), f10.push.apply(f10, T(new Array(w10).fill(0))));
        var I10 = { selectedIndices: p10 };
        return o10 && (I10.selectedScores = f10), u10 && (I10.validOutputs = k10), I10;
      }
      function Jne(e10, t10, n10) {
        var r10 = e10.subarray(4 * t10, 4 * t10 + 4), a10 = e10.subarray(4 * n10, 4 * n10 + 4), i10 = Math.min(r10[0], r10[2]), o10 = Math.min(r10[1], r10[3]), s10 = Math.max(r10[0], r10[2]), u10 = Math.max(r10[1], r10[3]), c10 = Math.min(a10[0], a10[2]), l10 = Math.min(a10[1], a10[3]), h10 = Math.max(a10[0], a10[2]), p10 = Math.max(a10[1], a10[3]), f10 = (s10 - i10) * (u10 - o10), d10 = (h10 - c10) * (p10 - l10);
        if (f10 <= 0 || d10 <= 0) return 0;
        var v10 = Math.max(i10, c10), m10 = Math.max(o10, l10), g10 = Math.min(s10, h10), y10 = Math.min(u10, p10), b10 = Math.max(g10 - v10, 0) * Math.max(y10 - m10, 0);
        return b10 / (f10 + d10 - b10);
      }
      function Zne(e10, t10, n10) {
        var r10 = Math.exp(t10 * n10 * n10);
        return n10 <= e10 ? r10 : 0;
      }
      function Qne(e10, t10) {
        return e10.score - t10.score || e10.score === t10.score && t10.boxIndex - e10.boxIndex;
      }
      function $ne() {
        return $ne = c(o().mark(function e10(t10, n10, r10) {
          var a10, i10, s10, u10, c10, l10, h10, p10, f10, d10, v10 = arguments;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return a10 = v10.length > 3 && void 0 !== v10[3] ? v10[3] : 0.5, i10 = v10.length > 4 && void 0 !== v10[4] ? v10[4] : Number.NEGATIVE_INFINITY, s10 = L5(t10, "boxes", "nonMaxSuppressionAsync"), u10 = L5(n10, "scores", "nonMaxSuppressionAsync"), c10 = Vne(s10, u10, r10, a10, i10), r10 = c10.maxOutputSize, a10 = c10.iouThreshold, i10 = c10.scoreThreshold, e11.next = 10, Promise.all([s10.data(), u10.data()]);
              case 10:
                return l10 = e11.sent, h10 = l10[0], p10 = l10[1], f10 = qne(h10, p10, r10, a10, i10), d10 = f10.selectedIndices, s10 !== t10 && s10.dispose(), u10 !== n10 && u10.dispose(), e11.abrupt("return", Vte(d10, "int32"));
              case 17:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), $ne.apply(this, arguments);
      }
      var ere = function(e10, t10, n10) {
        return $ne.apply(this, arguments);
      };
      var tre = B5({ nonMaxSuppressionWithScore_: function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.5, a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Number.NEGATIVE_INFINITY, i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, o10 = L5(e10, "boxes", "nonMaxSuppression"), s10 = L5(t10, "scores", "nonMaxSuppression"), u10 = Vne(o10, s10, n10, r10, a10, i10), c10 = { boxes: o10, scores: s10 }, l10 = { maxOutputSize: n10 = u10.maxOutputSize, iouThreshold: r10 = u10.iouThreshold, scoreThreshold: a10 = u10.scoreThreshold, softNmsSigma: i10 = u10.softNmsSigma }, h10 = E5.runKernel(w2, c10, l10);
        return { selectedIndices: h10[0], selectedScores: h10[1] };
      } });
      function nre() {
        return nre = c(o().mark(function e10(t10, n10, r10) {
          var a10, i10, s10, u10, c10, l10, h10, p10, f10, d10, v10, m10, g10 = arguments;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return a10 = g10.length > 3 && void 0 !== g10[3] ? g10[3] : 0.5, i10 = g10.length > 4 && void 0 !== g10[4] ? g10[4] : Number.NEGATIVE_INFINITY, s10 = g10.length > 5 && void 0 !== g10[5] ? g10[5] : 0, u10 = L5(t10, "boxes", "nonMaxSuppressionAsync"), c10 = L5(n10, "scores", "nonMaxSuppressionAsync"), l10 = Vne(u10, c10, r10, a10, i10, s10), r10 = l10.maxOutputSize, a10 = l10.iouThreshold, i10 = l10.scoreThreshold, s10 = l10.softNmsSigma, e11.next = 12, Promise.all([u10.data(), c10.data()]);
              case 12:
                return h10 = e11.sent, p10 = h10[0], f10 = h10[1], d10 = Xne(p10, f10, r10, a10, i10, s10), v10 = d10.selectedIndices, m10 = d10.selectedScores, u10 !== t10 && u10.dispose(), c10 !== n10 && c10.dispose(), e11.abrupt("return", { selectedIndices: Vte(v10, "int32"), selectedScores: Vte(m10) });
              case 19:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), nre.apply(this, arguments);
      }
      var rre = function(e10, t10, n10) {
        return nre.apply(this, arguments);
      };
      var are = B5({ nonMaxSuppressionPadded_: function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.5, a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Number.NEGATIVE_INFINITY, i10 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5], o10 = L5(e10, "boxes", "nonMaxSuppression"), s10 = L5(t10, "scores", "nonMaxSuppression"), u10 = Vne(o10, s10, n10, r10, a10, null), c10 = u10.maxOutputSize, l10 = u10.iouThreshold, h10 = u10.scoreThreshold, p10 = { boxes: o10, scores: s10 }, f10 = { maxOutputSize: c10, iouThreshold: l10, scoreThreshold: h10, padToMaxOutputSize: i10 }, d10 = E5.runKernel(k2, p10, f10);
        return { selectedIndices: d10[0], validOutputs: d10[1] };
      } });
      function ire() {
        return ire = c(o().mark(function e10(t10, n10, r10) {
          var a10, i10, s10, u10, c10, l10, h10, p10, f10, d10, v10, m10, g10, y10, b10, x10, k10 = arguments;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return a10 = k10.length > 3 && void 0 !== k10[3] ? k10[3] : 0.5, i10 = k10.length > 4 && void 0 !== k10[4] ? k10[4] : Number.NEGATIVE_INFINITY, s10 = k10.length > 5 && void 0 !== k10[5] && k10[5], u10 = L5(t10, "boxes", "nonMaxSuppressionAsync"), c10 = L5(n10, "scores", "nonMaxSuppressionAsync"), l10 = Vne(u10, c10, r10, a10, i10, null), h10 = l10.maxOutputSize, p10 = l10.iouThreshold, f10 = l10.scoreThreshold, e11.next = 11, Promise.all([u10.data(), c10.data()]);
              case 11:
                return d10 = e11.sent, v10 = S(d10, 2), m10 = v10[0], g10 = v10[1], y10 = Kne(m10, g10, h10, p10, f10, s10), b10 = y10.selectedIndices, x10 = y10.validOutputs, u10 !== t10 && u10.dispose(), c10 !== n10 && c10.dispose(), e11.abrupt("return", { selectedIndices: Vte(b10, "int32"), validOutputs: i9(x10, "int32") });
              case 19:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), ire.apply(this, arguments);
      }
      var ore = function(e10, t10, n10) {
        return ire.apply(this, arguments);
      };
      var sre = B5({ resizeBilinear_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a10 = L5(e10, "images", "resizeBilinear");
        F$(3 === a10.rank || 4 === a10.rank, function() {
          return "Error in resizeBilinear: x must be rank 3 or 4, but got " + "rank ".concat(a10.rank, ".");
        }), F$(2 === t10.length, function() {
          return "Error in resizeBilinear: new shape must 2D, but got shape " + "".concat(t10, ".");
        }), F$(false === r10 || false === n10, function() {
          return "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.";
        });
        var i10 = a10, o10 = false;
        3 === a10.rank && (o10 = true, i10 = X8(a10, [1, a10.shape[0], a10.shape[1], a10.shape[2]])), S(t10, 0);
        var s10 = { images: i10 }, u10 = { alignCorners: n10, halfPixelCenters: r10, size: t10 }, c10 = E5.runKernel(W2, s10, u10);
        return o10 ? X8(c10, [c10.shape[1], c10.shape[2], c10.shape[3]]) : c10;
      } });
      var ure = B5({ resizeNearestNeighbor_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a10 = L5(e10, "images", "resizeNearestNeighbor");
        F$(3 === a10.rank || 4 === a10.rank, function() {
          return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got " + "rank ".concat(a10.rank, ".");
        }), F$(2 === t10.length, function() {
          return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + "".concat(t10, ".");
        }), F$("float32" === a10.dtype || "int32" === a10.dtype, function() {
          return "`images` must have `int32` or `float32` as dtype";
        }), F$(false === r10 || false === n10, function() {
          return "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.";
        });
        var i10 = a10, o10 = false;
        3 === a10.rank && (o10 = true, i10 = X8(a10, [1, a10.shape[0], a10.shape[1], a10.shape[2]])), S(t10, 0);
        var s10 = { images: i10 }, u10 = { alignCorners: n10, halfPixelCenters: r10, size: t10 }, c10 = E5.runKernel(P2, s10, u10);
        return o10 ? X8(c10, [c10.shape[1], c10.shape[2], c10.shape[3]]) : c10;
      } });
      function cre(e10, t10) {
        for (var n10, r10, a10, i10, o10, s10, u10 = Vte([-1]), c10 = Vte([0]), l10 = Vte([0]), h10 = 0; h10 < e10.size - 1; h10++) {
          n10 = e7(e10, 0, h10 + 1), r10 = e7(e10, h10 + 1), o10 = m8(u9(n10), t10), s10 = m8(u9(r10), t10);
          var p10 = u9(g8(n10, ste(0, n10.size)));
          a10 = m8(p10, u9(n10));
          var f10 = f7(r10.shape, n10.size), d10 = d8(ste(0, r10.size), f10), v10 = g8(r10, d10);
          i10 = m8(u9(v10), u9(r10));
          var m10 = P9(a10, i10), g10 = P9(a10, i10), y10 = g8(o10, s10);
          l10 = g8(g8(y10, m10), g10);
          var b10 = b9(l10, c10);
          c10 = W7(b10, l10, c10), u10 = W7(b10, Vte([h10]), u10);
        }
        return u10;
      }
      var lre = B5({ threshold_: function(e10) {
        var t10, n10, r10, a10, i10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "binary", o10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.5, u10 = L5(e10, "image", "threshold"), c10 = 0.2989, l10 = 0.587, h10 = 0.114, p10 = u10.shape[0] * u10.shape[1], f10 = g8(Vte([s10]), 255);
        if (F$(3 === u10.rank, function() {
          return "Error in threshold: image must be rank 3," + "but got rank ".concat(u10.rank, ".");
        }), F$(3 === u10.shape[2] || 1 === u10.shape[2], function() {
          return "Error in threshold: image color channel must be equal to 3 or 1" + "but got ".concat(u10.shape[2], ".");
        }), F$("int32" === u10.dtype || "float32" === u10.dtype, function() {
          return "Error in dtype: image dtype must be int32 or float32," + "but got dtype ".concat(u10.dtype, ".");
        }), F$("otsu" === i10 || "binary" === i10, function() {
          return "Method must be binary or otsu, but was ".concat(i10);
        }), 3 === u10.shape[2]) {
          var d10 = Dte(u10, [1, 1, 1], -1), v10 = S(d10, 3);
          t10 = v10[0], n10 = v10[1], r10 = v10[2];
          var m10 = g8(t10, c10), g10 = g8(n10, l10), y10 = g8(r10, h10);
          a10 = d8(d8(m10, g10), y10);
        } else a10 = e10;
        if ("otsu" === i10) {
          var b10 = u7(h8(gte(a10), "int32"), V5([]), 256);
          f10 = cre(b10, p10);
        }
        var x10 = o10 ? E9(a10, f10) : b9(a10, f10), k10 = h8(g8(x10, 255), "int32");
        return k10;
      } });
      var hre = B5({ transform_: function(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "nearest", r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "constant", a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, i10 = arguments.length > 5 ? arguments[5] : void 0, o10 = L5(e10, "image", "transform", "float32"), s10 = L5(t10, "transforms", "transform", "float32");
        F$(4 === o10.rank, function() {
          return "Error in transform: image must be rank 4," + "but got rank ".concat(o10.rank, ".");
        }), F$(2 === s10.rank && (s10.shape[0] === o10.shape[0] || 1 === s10.shape[0]) && 8 === s10.shape[1], function() {
          return "Error in transform: Input transform should be batch x 8 or 1 x 8";
        }), F$(null == i10 || 2 === i10.length, function() {
          return "Error in transform: outputShape must be [height, width] or null, " + "but got ".concat(i10, ".");
        });
        var u10 = { image: o10, transforms: s10 }, c10 = { interpolation: n10, fillMode: r10, fillValue: a10, outputShape: i10 };
        return E5.runKernel(S3, u10, c10);
      } });
      var pre = B5({ bandPart_: function(e10, t10, n10) {
        var r10 = L5(e10, "a", "bandPart");
        F$(r10.rank >= 2, function() {
          return "bandPart(): Rank must be at least 2, got ".concat(r10.rank, ".");
        });
        var a10, i10, o10 = r10.shape, s10 = S(r10.shape.slice(-2), 2), u10 = s10[0], c10 = s10[1];
        "number" == typeof t10 ? (F$(t10 % 1 == 0, function() {
          return "bandPart(): numLower must be an integer, got ".concat(t10, ".");
        }), F$(t10 <= u10, function() {
          return "bandPart(): numLower (".concat(t10, ")") + " must not be greater than the number of rows (".concat(u10, ").");
        }), a10 = L5(t10 < 0 ? u10 : t10, "numLower", "bandPart")) : (F$("int32" === t10.dtype, function() {
          return "bandPart(): numLower's dtype must be an int32.";
        }), a10 = W7(T9(t10, 0), u10, nee(t10, u10))), "number" == typeof n10 ? (F$(n10 % 1 == 0, function() {
          return "bandPart(): numUpper must be an integer, got ".concat(n10, ".");
        }), F$(n10 <= c10, function() {
          return "bandPart(): numUpper (".concat(n10, ")") + " must not be greater than the number of columns (".concat(c10, ").");
        }), i10 = L5(n10 < 0 ? c10 : n10, "numUpper", "bandPart")) : (F$("int32" === n10.dtype, function() {
          return "bandPart(): numUpper's dtype must be an int32.";
        }), i10 = W7(T9(n10, 0), c10, nee(n10, c10)));
        var l10 = X8(ste(0, u10, 1, "int32"), [-1, 1]), h10 = ste(0, c10, 1, "int32"), p10 = P9(l10, h10), f10 = U9(E9(p10, a10), x9(p10, M9(i10))), d10 = $9([u10, c10], r10.dtype);
        return X8(Pte(rne(X8(r10, [-1, u10, c10])).map(function(e11) {
          return W7(f10, e11, d10);
        })), o10);
      } });
      var fre = B5({ gramSchmidt_: function(e10) {
        var t10;
        if (Array.isArray(e10)) {
          t10 = false, F$(null != e10 && e10.length > 0, function() {
            return "Gram-Schmidt process: input must not be null, undefined, or empty";
          });
          for (var n10 = e10[0].shape[0], r10 = function(t11) {
            F$(e10[t11].shape[0] === n10, function() {
              return "Gram-Schmidt: Non-unique lengths found in the input vectors: " + "(".concat(e10[t11].shape[0], " vs. ").concat(n10, ")");
            });
          }, a10 = 1; a10 < e10.length; ++a10) r10(a10);
        } else t10 = true, e10 = Dte(e10, e10.shape[0], 0).map(function(e11) {
          return zte(e11, [0]);
        });
        F$(e10.length <= e10[0].shape[0], function() {
          return "Gram-Schmidt: Number of vectors (".concat(e10.length, ") exceeds ") + "number of dimensions (".concat(e10[0].shape[0], ").");
        });
        for (var i10 = [], o10 = e10, s10 = function(e11) {
          i10.push(E5.tidy(function() {
            var t11 = o10[e11];
            if (e11 > 0) for (var n11 = 0; n11 < e11; ++n11) {
              var r11 = g8(u9(g8(i10[n11], t11)), i10[n11]);
              t11 = P9(t11, r11);
            }
            return m8(t11, l9(t11, "euclidean"));
          }));
        }, u10 = 0; u10 < e10.length; ++u10) s10(u10);
        return t10 ? Pte(i10, 0) : i10;
      } });
      function dre(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        return E5.tidy(function() {
          F$(2 === e10.shape.length, function() {
            return "qr2d() requires a 2D Tensor, but got a ".concat(e10.shape.length, "D Tensor.");
          });
          for (var n10 = e10.shape[0], r10 = e10.shape[1], a10 = m9(n10), i10 = p8(e10), o10 = Gte([[1]], [1, 1]), s10 = p8(o10), u10 = n10 >= r10 ? r10 : n10, c10 = function(e11) {
            var t11 = i10, u11 = s10, c11 = a10, l11 = S(E5.tidy(function() {
              var t12 = e7(i10, [e11, e11], [n10 - e11, 1]), u12 = l9(t12), c12 = e7(i10, [e11, e11], [1, 1]), l12 = W7(b9(c12, 0), Gte([[-1]]), Gte([[1]])), h10 = P9(c12, g8(l12, u12)), p10 = m8(t12, h10);
              s10 = 1 === p10.shape[0] ? p8(o10) : Z8([o10, e7(p10, [1, 0], [p10.shape[0] - 1, p10.shape[1]])], 0);
              var f10 = M9(m8(Q8(l12, h10), u12)), d10 = e7(i10, [e11, 0], [n10 - e11, r10]), v10 = g8(f10, s10), m10 = hne(s10);
              if (0 === e11) i10 = P9(d10, Q8(v10, Q8(m10, d10)));
              else {
                var g10 = P9(d10, Q8(v10, Q8(m10, d10)));
                i10 = Z8([e7(i10, [0, 0], [e11, r10]), g10], 0);
              }
              var y10 = hne(v10), b10 = e7(a10, [0, e11], [n10, a10.shape[1] - e11]);
              if (0 === e11) a10 = P9(b10, Q8(Q8(b10, s10), y10));
              else {
                var x10 = P9(b10, Q8(Q8(b10, s10), y10));
                a10 = Z8([e7(a10, [0, 0], [n10, e11]), x10], 1);
              }
              return [s10, i10, a10];
            }), 3);
            s10 = l11[0], i10 = l11[1], a10 = l11[2], Y5([t11, u11, c11]);
          }, l10 = 0; l10 < u10; ++l10) c10(l10);
          return !t10 && n10 > r10 && (a10 = e7(a10, [0, 0], [n10, r10]), i10 = e7(i10, [0, 0], [r10, r10])), [a10, i10];
        });
      }
      var vre, mre = B5({ qr_: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (F$(e10.rank >= 2, function() {
          return "qr() requires input tensor to have a rank >= 2, but got rank ".concat(e10.rank);
        }), 2 === e10.rank) return dre(e10, t10);
        var n10 = e10.shape.slice(0, e10.shape.length - 2).reduce(function(e11, t11) {
          return e11 * t11;
        }), r10 = rne(X8(e10, [n10, e10.shape[e10.shape.length - 2], e10.shape[e10.shape.length - 1]]), 0), a10 = [], i10 = [];
        r10.forEach(function(e11) {
          var n11 = S(dre(e11, t10), 2), r11 = n11[0], o11 = n11[1];
          a10.push(r11), i10.push(o11);
        });
        var o10 = X8(Pte(a10, 0), e10.shape), s10 = X8(Pte(i10, 0), e10.shape);
        return [o10, s10];
      } });
      e.Reduction = void 0, (vre = e.Reduction || (e.Reduction = {}))[vre.NONE = 0] = "NONE", vre[vre.MEAN = 1] = "MEAN", vre[vre.SUM = 2] = "SUM", vre[vre.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
      var gre = B5({ computeWeightedLoss_: function(t10, n10) {
        var r10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.Reduction.SUM_BY_NONZERO_WEIGHTS, a10 = L5(t10, "losses", "computeWeightedLoss"), i10 = null;
        null != n10 && (i10 = L5(n10, "weights", "computeWeightedLoss"));
        var o10 = null == i10 ? a10 : g8(a10, i10);
        if (r10 === e.Reduction.NONE) return o10;
        if (r10 === e.Reduction.SUM) return u9(o10);
        if (r10 === e.Reduction.MEAN) {
          if (null == i10) return Q9(o10);
          var s10 = a10.size / i10.size, u10 = m8(u9(o10), u9(i10));
          return s10 > 1 ? m8(u10, i9(s10)) : u10;
        }
        if (r10 === e.Reduction.SUM_BY_NONZERO_WEIGHTS) {
          if (null == i10) return m8(u9(o10), i9(a10.size));
          var c10 = g8(i10, eee(a10.shape)), l10 = h8(u9(uee(c10, i9(0))), "float32");
          return m8(u9(o10), l10);
        }
        throw Error("Unknown reduction: ".concat(r10));
      } });
      var yre = B5({ absoluteDifference_: function(t10, n10, r10) {
        var a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.Reduction.SUM_BY_NONZERO_WEIGHTS, i10 = L5(t10, "labels", "absoluteDifference"), o10 = L5(n10, "predictions", "absoluteDifference"), s10 = null;
        null != r10 && (s10 = L5(r10, "weights", "absoluteDifference")), D$(i10.shape, o10.shape, "Error in absoluteDifference: ");
        var u10 = y8(P9(i10, o10));
        return gre(u10, s10, a10);
      } });
      var bre = B5({ cosineDistance_: function(t10, n10, r10, a10) {
        var i10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : e.Reduction.SUM_BY_NONZERO_WEIGHTS, o10 = L5(t10, "labels", "cosineDistance"), s10 = L5(n10, "predictions", "cosineDistance"), u10 = null;
        null != a10 && (u10 = L5(a10, "weights", "cosineDistance")), D$(o10.shape, s10.shape, "Error in cosineDistance: ");
        var c10 = i9(1), l10 = P9(c10, u9(g8(o10, s10), r10, true));
        return gre(l10, u10, i10);
      } });
      var xre = B5({ hingeLoss_: function(t10, n10, r10) {
        var a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.Reduction.SUM_BY_NONZERO_WEIGHTS, i10 = L5(t10, "labels", "hingeLoss"), o10 = L5(n10, "predictions", "hingeLoss"), s10 = null;
        null != r10 && (s10 = L5(r10, "weights", "hingeLoss")), D$(i10.shape, o10.shape, "Error in hingeLoss: ");
        var u10 = i9(1);
        i10 = P9(g8(i9(2), i10), u10);
        var c10 = lte(P9(u10, g8(i10, o10)));
        return gre(c10, s10, a10);
      } });
      var kre = B5({ huberLoss_: function(t10, n10, r10) {
        var a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, i10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : e.Reduction.SUM_BY_NONZERO_WEIGHTS, o10 = L5(t10, "labels", "huberLoss"), s10 = L5(n10, "predictions", "huberLoss"), u10 = null;
        null != r10 && (u10 = L5(r10, "weights", "huberLoss")), D$(o10.shape, s10.shape, "Error in huberLoss: ");
        var c10 = i9(a10), l10 = y8(P9(s10, o10)), h10 = nee(l10, c10), p10 = P9(l10, h10), f10 = d8(g8(i9(0.5), s9(h10)), g8(c10, p10));
        return gre(f10, u10, i10);
      } });
      var wre = B5({ logLoss_: function(t10, n10, r10) {
        var a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e-7, i10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : e.Reduction.SUM_BY_NONZERO_WEIGHTS, o10 = L5(t10, "labels", "logLoss"), s10 = L5(n10, "predictions", "logLoss"), u10 = null;
        null != r10 && (u10 = L5(r10, "weights", "logLoss")), D$(o10.shape, s10.shape, "Error in logLoss: ");
        var c10 = i9(1), l10 = i9(a10), h10 = M9(g8(o10, R9(d8(s10, l10)))), p10 = g8(P9(c10, o10), R9(d8(P9(c10, s10), l10))), f10 = P9(h10, p10);
        return gre(f10, u10, i10);
      } });
      var Ire = B5({ meanSquaredError_: function(t10, n10, r10) {
        var a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.Reduction.SUM_BY_NONZERO_WEIGHTS, i10 = L5(t10, "labels", "meanSquaredError"), o10 = L5(n10, "predictions", "meanSquaredError"), s10 = null;
        null != r10 && (s10 = L5(r10, "weights", "meanSquaredError")), D$(i10.shape, o10.shape, "Error in meanSquaredError: ");
        var u10 = Lte(i10, o10);
        return gre(u10, s10, a10);
      } });
      function Nre(e10, t10) {
        var n10 = L5(e10, "labels", "sigmoidCrossEntropyWithLogits"), r10 = L5(t10, "logits", "sigmoidCrossEntropyWithLogits");
        D$(n10.shape, r10.shape, "Error in sigmoidCrossEntropyWithLogits: ");
        var a10 = lte(r10), i10 = g8(r10, n10), o10 = _9(p9(M9(y8(r10))));
        return d8(P9(a10, i10), o10);
      }
      var Sre = B5({ sigmoidCrossEntropy_: function(t10, n10, r10) {
        var a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, i10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : e.Reduction.SUM_BY_NONZERO_WEIGHTS, o10 = L5(t10, "multiClassLabels", "sigmoidCrossEntropy"), s10 = L5(n10, "logits", "sigmoidCrossEntropy"), u10 = null;
        if (null != r10 && (u10 = L5(r10, "weights", "sigmoidCrossEntropy")), D$(o10.shape, s10.shape, "Error in sigmoidCrossEntropy: "), a10 > 0) {
          var c10 = i9(a10), l10 = i9(1), h10 = i9(0.5);
          o10 = d8(g8(o10, P9(l10, c10)), g8(h10, c10));
        }
        var p10 = Nre(o10, s10);
        return gre(p10, u10, i10);
      } });
      function Tre(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1;
        if (-1 === n10 && (n10 = t10.rank - 1), n10 !== t10.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet " + "supported. Labels / logits was rank ".concat(t10.rank, " ") + "and dim was ".concat(n10));
        var r10 = F9(function(e11, t11, r11) {
          var a10 = W9(t11, [n10], true), i10 = P9(h8(t11, "float32"), a10);
          r11([e11, i10]);
          var o10 = M9(g8(i10, e11));
          return { value: u9(o10, [n10]), gradFunc: function(e12, t12) {
            var r12 = S(t12, 2), a11 = r12[0], i11 = r12[1], o11 = Z7(e12.shape, [n10]);
            return [g8(X8(e12, o11), P9(h8(a11, "float32"), p9(i11))), g8(X8(e12, o11), P9(p9(i11), h8(a11, "float32")))];
          } };
        });
        return r10(e10, t10);
      }
      var Ere = B5({ softmaxCrossEntropy_: function(t10, n10, r10) {
        var a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, i10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : e.Reduction.SUM_BY_NONZERO_WEIGHTS, o10 = L5(t10, "onehotLabels", "softmaxCrossEntropy"), s10 = L5(n10, "logits", "softmaxCrossEntropy"), u10 = null;
        if (null != r10 && (u10 = L5(r10, "weights", "softmaxCrossEntropy")), D$(o10.shape, s10.shape, "Error in softmaxCrossEntropy: "), a10 > 0) {
          var c10 = i9(a10), l10 = i9(1), h10 = i9(o10.shape[1]);
          o10 = d8(g8(o10, P9(l10, c10)), m8(c10, h10));
        }
        var p10 = Tre(o10, s10);
        return gre(p10, u10, i10);
      } });
      var Cre = B5({ sparseFillEmptyRows_: function(e10, t10, n10, r10) {
        var a10 = L5(e10, "indices", "sparseFillEmptyRows", "int32"), i10 = L5(t10, "values", "sparseFillEmptyRows"), o10 = L5(n10, "denseShape", "sparseFillEmptyRows", "int32"), s10 = L5(r10, "defaultValue", "sparseFillEmptyRows", i10.dtype);
        if (2 !== a10.rank) throw new Error("Indices should be Tensor2D but received shape\n        ".concat(a10.shape));
        if (1 !== i10.rank) throw new Error("Values should be Tensor1D but received shape ".concat(i10.shape));
        if (1 !== o10.rank) throw new Error("Dense shape should be Tensor1D but received shape ".concat(o10.shape));
        if (0 !== s10.rank) throw new Error("Default value should be a scalar but received shape ".concat(s10.shape));
        var u10 = { indices: a10, values: i10, denseShape: o10, defaultValue: s10 }, c10 = E5.runKernel(u3, u10);
        return { outputIndices: c10[0], outputValues: c10[1], emptyRowIndicator: c10[2], reverseIndexMap: c10[3] };
      } });
      var Are = B5({ sparseReshape_: function(e10, t10, n10) {
        var r10 = L5(e10, "inputIndices", "sparseReshape", "int32"), a10 = L5(t10, "inputShape", "sparseReshape", "int32"), i10 = L5(n10, "newShape", "sparseReshape", "int32");
        if (2 !== r10.rank) throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(r10.shape));
        if (1 !== a10.rank) throw new Error("Input shape should be Tensor1D but received shape ".concat(a10.shape));
        if (1 !== i10.rank) throw new Error("New shape should be Tensor1D but received shape ".concat(i10.shape));
        var o10 = { inputIndices: r10, inputShape: a10, newShape: i10 }, s10 = E5.runKernel(c3, o10);
        return { outputIndices: s10[0], outputShape: s10[1] };
      } });
      var Rre = B5({ sparseSegmentMean_: function(e10, t10, n10) {
        var r10 = L5(e10, "data", "sparseSegmentMean"), a10 = L5(t10, "indices", "sparseSegmentMean", "int32"), i10 = L5(n10, "segmentIds", "sparseSegmentMean", "int32");
        if (r10.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
        if (1 !== a10.rank) throw new Error("Indices should be Tensor1D but received shape\n          ".concat(a10.shape));
        if (1 !== i10.rank) throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(i10.shape));
        var o10 = { data: r10, indices: a10, segmentIds: i10 };
        return E5.runKernel(l3, o10);
      } });
      var _re = B5({ sparseSegmentSum_: function(e10, t10, n10) {
        var r10 = L5(e10, "data", "sparseSegmentSum"), a10 = L5(t10, "indices", "sparseSegmentSum", "int32"), i10 = L5(n10, "segmentIds", "sparseSegmentSum", "int32");
        if (r10.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
        if (1 !== a10.rank) throw new Error("Indices should be Tensor1D but received shape\n         ".concat(a10.shape));
        if (1 !== i10.rank) throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(i10.shape));
        var o10 = { data: r10, indices: a10, segmentIds: i10 };
        return E5.runKernel(h3, o10);
      } });
      var Ore = B5({ stringNGrams_: function(e10, t10, n10, r10, a10, i10, o10, s10) {
        var u10 = L5(e10, "data", "stringNGrams", "string");
        if ("string" !== u10.dtype) throw new Error("Data must be of datatype string");
        if (1 !== u10.shape.length) throw new Error("Data must be a vector, saw: ".concat(u10.shape));
        var c10 = L5(t10, "dataSplits", "stringNGrams");
        if ("int32" !== c10.dtype) throw new Error("Data splits must be of datatype int32");
        var l10 = { separator: n10, nGramWidths: r10, leftPad: a10, rightPad: i10, padWidth: o10, preserveShortSequences: s10 }, h10 = { data: u10, dataSplits: c10 }, p10 = E5.runKernel(g3, h10, l10);
        return { nGrams: p10[0], nGramsSplits: p10[1] };
      } });
      var Fre = B5({ stringSplit_: function(e10, t10) {
        var n10 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r10 = L5(e10, "input", "stringSplit", "string"), a10 = L5(t10, "delimiter", "stringSplit", "string");
        if (1 !== r10.rank) throw new Error("Input should be Tensor1D but received shape ".concat(r10.shape));
        if (0 !== a10.rank) throw new Error("Delimiter should be a scalar but received shape ".concat(a10.shape));
        var i10 = { skipEmpty: n10 }, o10 = { input: r10, delimiter: a10 }, s10 = E5.runKernel(y3, o10, i10);
        return { indices: s10[0], values: s10[1], shape: s10[2] };
      } });
      var Dre = B5({ stringToHashBucketFast_: function(e10, t10) {
        var n10 = L5(e10, "input", "stringToHashBucketFast", "string"), r10 = { numBuckets: t10 };
        if (t10 <= 0) throw new Error("Number of buckets must be at least 1");
        var a10 = { input: n10 };
        return E5.runKernel(b3, a10, r10);
      } });
      var Mre = B5({ staticRegexReplace_: function(e10, t10, n10) {
        var r10 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], a10 = L5(e10, "input", "staticRegexReplace", "string"), i10 = { pattern: t10, rewrite: n10, replaceGlobal: r10 };
        return E5.runKernel(v3, { x: a10 }, i10);
      } }), Lre = { fft: _te, ifft: Ote, rfft: Mte, irfft: Fte }, zre = { hammingWindow: Fne, hannWindow: Dne, frame: Mne, stft: Lne }, Pre = { flipLeftRight: Pne, grayscaleToRGB: Bne, resizeNearestNeighbor: ure, resizeBilinear: sre, rgbToGrayscale: Wne, rotateWithOffset: Une, cropAndResize: zne, nonMaxSuppression: Gne, nonMaxSuppressionAsync: ere, nonMaxSuppressionWithScore: tre, nonMaxSuppressionWithScoreAsync: rre, nonMaxSuppressionPadded: are, nonMaxSuppressionPaddedAsync: ore, threshold: lre, transform: hre }, Bre = { bandPart: pre, gramSchmidt: fre, qr: mre }, Wre = { absoluteDifference: yre, computeWeightedLoss: gre, cosineDistance: bre, hingeLoss: xre, huberLoss: kre, logLoss: wre, meanSquaredError: Ire, sigmoidCrossEntropy: Sre, softmaxCrossEntropy: Ere }, Ure = { sparseFillEmptyRows: Cre, sparseReshape: Are, sparseSegmentMean: Rre, sparseSegmentSum: _re }, Vre = { stringNGrams: Ore, stringSplit: Fre, stringToHashBucketFast: Dre, staticRegexReplace: Mre }, Gre = /* @__PURE__ */ new Map(), jre = /* @__PURE__ */ new Map(), Hre = function() {
        function e10() {
          l(this, e10);
        }
        return p(e10, [{ key: "getClassName", value: function() {
          return this.constructor.className;
        } }], [{ key: "fromConfig", value: function(e11, t10) {
          return new e11(t10);
        } }]), e10;
      }(), qre = function() {
        function e10() {
          l(this, e10), this.classNameMap = {};
        }
        return p(e10, null, [{ key: "getMap", value: function() {
          return null == e10.instance && (e10.instance = new e10()), e10.instance;
        } }, { key: "register", value: function(t10) {
          e10.getMap().classNameMap[t10.className] = [t10, t10.fromConfig];
        } }]), e10;
      }();
      function Kre(e10, t10, n10) {
        F$(null != e10.className, function() {
          return "Class being registered does not have the static className property defined.";
        }), F$("string" == typeof e10.className, function() {
          return "className is required to be a string, but got type " + s(e10.className);
        }), F$(e10.className.length > 0, function() {
          return "Class being registered has an empty-string as its className, which is disallowed.";
        }), void 0 === t10 && (t10 = "Custom"), void 0 === n10 && (n10 = e10.className);
        var r10 = t10 + ">" + n10;
        return qre.register(e10), Gre.set(r10, e10), jre.set(e10, r10), e10;
      }
      var Xre = { __proto__: null, Serializable: Hre, SerializationMap: qre, getRegisteredName: function(e10) {
        return jre.has(e10) ? jre.get(e10) : e10.className;
      }, registerClass: Kre }, Yre = function(e10) {
        d(s10, e10);
        var t10, n10, r10, a10, i10 = w(s10);
        function s10() {
          return l(this, s10), i10.apply(this, arguments);
        }
        return p(s10, [{ key: "minimize", value: function(e11) {
          var t11 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n11 = arguments.length > 2 ? arguments[2] : void 0, r11 = this.computeGradients(e11, n11), a11 = r11.value, i11 = r11.grads;
          if (null != n11) {
            var o10 = n11.map(function(e12) {
              return { name: e12.name, tensor: i11[e12.name] };
            });
            this.applyGradients(o10);
          } else this.applyGradients(i11);
          return Y5(i11), t11 ? a11 : (a11.dispose(), null);
        } }, { key: "iterations", get: function() {
          return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
        } }, { key: "incrementIterations", value: function() {
          this.iterations_ = this.iterations + 1;
        } }, { key: "computeGradients", value: function(e11, t11) {
          return O9(e11, t11);
        } }, { key: "dispose", value: function() {
          null != this.iterations_ && Y5(this.iterations_);
        } }, { key: "saveIterations", value: (a10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return null == this.iterations_ && (this.iterations_ = 0), e12.abrupt("return", { name: "iter", tensor: i9(this.iterations_, "int32") });
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return a10.apply(this, arguments);
        }) }, { key: "getWeights", value: (r10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                throw new Error("getWeights() is not implemented for this optimizer yet.");
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11);
        })), function() {
          return r10.apply(this, arguments);
        }) }, { key: "setWeights", value: (n10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                throw new Error("setWeights() is not implemented for this optimizer class " + "".concat(this.getClassName()));
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return n10.apply(this, arguments);
        }) }, { key: "extractIterations", value: (t10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, t11[0].tensor.data();
              case 2:
                return this.iterations_ = e12.sent[0], e12.abrupt("return", t11.slice(1));
              case 4:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }]), s10;
      }(Hre);
      Object.defineProperty(Yre, Symbol.hasInstance, { value: function(e10) {
        return null != e10.minimize && null != e10.computeGradients && null != e10.applyGradients;
      } });
      var Jre = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11, t11) {
          var n11, i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
          return l(this, a10), (n11 = r10.call(this)).learningRate = e11, n11.rho = t11, n11.epsilon = i10, n11.accumulatedGrads = [], n11.accumulatedUpdates = [], null == i10 && (n11.epsilon = E5.backend.epsilon()), n11;
        }
        return p(a10, [{ key: "applyGradients", value: function(e11) {
          var t11 = this;
          (Array.isArray(e11) ? e11.map(function(e12) {
            return e12.name;
          }) : Object.keys(e11)).forEach(function(n11, r11) {
            var a11 = E5.registeredVariables[n11];
            null == t11.accumulatedGrads[r11] && (t11.accumulatedGrads[r11] = { originalName: "".concat(n11, "/accum_grad"), variable: X5(function() {
              return U7(a11).variable(false);
            }) }), null == t11.accumulatedUpdates[r11] && (t11.accumulatedUpdates[r11] = { originalName: "".concat(n11, "/accum_var"), variable: X5(function() {
              return U7(a11).variable(false);
            }) });
            var i10 = Array.isArray(e11) ? e11[r11].tensor : e11[n11];
            if (null != i10) {
              var o10 = t11.accumulatedGrads[r11].variable, s10 = t11.accumulatedUpdates[r11].variable;
              X5(function() {
                var e12 = d8(g8(o10, t11.rho), g8(s9(i10), 1 - t11.rho)), n12 = g8(m8(o9(d8(s10, t11.epsilon)), o9(d8(o10, t11.epsilon))), i10), r12 = d8(g8(s10, t11.rho), g8(s9(n12), 1 - t11.rho));
                o10.assign(e12), s10.assign(r12);
                var u10 = d8(g8(n12, -t11.learningRate), a11);
                a11.assign(u10);
              });
            }
          }), this.incrementIterations();
        } }, { key: "dispose", value: function() {
          null != this.accumulatedUpdates && (Y5(this.accumulatedGrads.map(function(e11) {
            return e11.variable;
          })), Y5(this.accumulatedUpdates.map(function(e11) {
            return e11.variable;
          })));
        } }, { key: "getWeights", value: (n10 = c(o().mark(function e11() {
          var t11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return t11 = [].concat(T(this.accumulatedGrads), T(this.accumulatedUpdates)), e12.next = 3, this.saveIterations();
              case 3:
                return e12.t0 = e12.sent, e12.abrupt("return", [e12.t0].concat(t11.map(function(e13) {
                  return { name: e13.originalName, tensor: e13.variable };
                })));
              case 5:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "setWeights", value: (t10 = c(o().mark(function e11(t11) {
          var n11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.extractIterations(t11);
              case 2:
                t11 = e12.sent, n11 = t11.length / 2, this.accumulatedGrads = t11.slice(0, n11).map(function(e13) {
                  return { originalName: e13.name, variable: e13.tensor.variable(false) };
                }), this.accumulatedUpdates = t11.slice(n11, 2 * n11).map(function(e13) {
                  return { originalName: e13.name, variable: e13.tensor.variable(false) };
                });
              case 7:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "getConfig", value: function() {
          return { learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon };
        } }], [{ key: "className", get: function() {
          return "Adadelta";
        } }, { key: "fromConfig", value: function(e11, t11) {
          return new e11(t11.learningRate, t11.rho, t11.epsilon);
        } }]), a10;
      }(Yre), Zre = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11) {
          var t11, n11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.1;
          return l(this, a10), (t11 = r10.call(this)).learningRate = e11, t11.initialAccumulatorValue = n11, t11.accumulatedGrads = [], t11;
        }
        return p(a10, [{ key: "applyGradients", value: function(e11) {
          var t11 = this;
          (Array.isArray(e11) ? e11.map(function(e12) {
            return e12.name;
          }) : Object.keys(e11)).forEach(function(n11, r11) {
            var a11 = E5.registeredVariables[n11];
            if (null == t11.accumulatedGrads[r11]) {
              t11.accumulatedGrads[r11] = { originalName: "".concat(n11, "/accumulator"), variable: X5(function() {
                return f7(a11.shape, t11.initialAccumulatorValue).variable(false);
              }) };
            }
            var i10 = Array.isArray(e11) ? e11[r11].tensor : e11[n11];
            if (null != i10) {
              var o10 = t11.accumulatedGrads[r11].variable;
              X5(function() {
                var e12 = d8(o10, s9(i10));
                o10.assign(e12);
                var n12 = d8(g8(m8(i10, o9(d8(e12, E5.backend.epsilon()))), -t11.learningRate), a11);
                a11.assign(n12);
              });
            }
          }), this.incrementIterations();
        } }, { key: "dispose", value: function() {
          null != this.accumulatedGrads && Y5(this.accumulatedGrads.map(function(e11) {
            return e11.variable;
          }));
        } }, { key: "getWeights", value: (n10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.saveIterations();
              case 2:
                return e12.t0 = e12.sent, e12.abrupt("return", [e12.t0].concat(this.accumulatedGrads.map(function(e13) {
                  return { name: e13.originalName, tensor: e13.variable };
                })));
              case 4:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "setWeights", value: (t10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.extractIterations(t11);
              case 2:
                t11 = e12.sent, this.accumulatedGrads = t11.map(function(e13) {
                  return { originalName: e13.name, variable: e13.tensor.variable(false) };
                });
              case 5:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "getConfig", value: function() {
          return { learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue };
        } }], [{ key: "className", get: function() {
          return "Adagrad";
        } }, { key: "fromConfig", value: function(e11, t11) {
          return new e11(t11.learningRate, t11.initialAccumulatorValue);
        } }]), a10;
      }(Yre), Qre = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11, t11, n11) {
          var i10, o10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
          return l(this, a10), (i10 = r10.call(this)).learningRate = e11, i10.beta1 = t11, i10.beta2 = n11, i10.epsilon = o10, i10.accumulatedFirstMoment = [], i10.accumulatedSecondMoment = [], X5(function() {
            i10.accBeta1 = i9(t11).variable(), i10.accBeta2 = i9(n11).variable();
          }), null == o10 && (i10.epsilon = E5.backend.epsilon()), i10;
        }
        return p(a10, [{ key: "applyGradients", value: function(e11) {
          var t11 = this, n11 = Array.isArray(e11) ? e11.map(function(e12) {
            return e12.name;
          }) : Object.keys(e11);
          X5(function() {
            var r11 = P9(1, t11.accBeta1), a11 = P9(1, t11.accBeta2);
            n11.forEach(function(n12, i10) {
              var o10 = E5.registeredVariables[n12];
              null == t11.accumulatedFirstMoment[i10] && (t11.accumulatedFirstMoment[i10] = { originalName: "".concat(n12, "/m"), variable: X5(function() {
                return U7(o10).variable(false);
              }) }), null == t11.accumulatedSecondMoment[i10] && (t11.accumulatedSecondMoment[i10] = { originalName: "".concat(n12, "/v"), variable: X5(function() {
                return U7(o10).variable(false);
              }) });
              var s10 = Array.isArray(e11) ? e11[i10].tensor : e11[n12];
              if (null != s10) {
                var u10 = t11.accumulatedFirstMoment[i10].variable, c10 = t11.accumulatedSecondMoment[i10].variable, l10 = d8(g8(u10, t11.beta1), g8(s10, 1 - t11.beta1)), h10 = d8(g8(c10, t11.beta2), g8(s9(s10), 1 - t11.beta2)), p10 = m8(l10, r11), f10 = m8(h10, a11);
                u10.assign(l10), c10.assign(h10);
                var d10 = d8(g8(m8(p10, d8(o9(f10), t11.epsilon)), -t11.learningRate), o10);
                o10.assign(d10);
              }
            }), t11.accBeta1.assign(g8(t11.accBeta1, t11.beta1)), t11.accBeta2.assign(g8(t11.accBeta2, t11.beta2));
          }), this.incrementIterations();
        } }, { key: "dispose", value: function() {
          this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && Y5(this.accumulatedFirstMoment.map(function(e11) {
            return e11.variable;
          })), null != this.accumulatedSecondMoment && Y5(this.accumulatedSecondMoment.map(function(e11) {
            return e11.variable;
          }));
        } }, { key: "getWeights", value: (n10 = c(o().mark(function e11() {
          var t11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return t11 = [].concat(T(this.accumulatedFirstMoment), T(this.accumulatedSecondMoment)), e12.next = 3, this.saveIterations();
              case 3:
                return e12.t0 = e12.sent, e12.abrupt("return", [e12.t0].concat(t11.map(function(e13) {
                  return { name: e13.originalName, tensor: e13.variable };
                })));
              case 5:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "setWeights", value: (t10 = c(o().mark(function e11(t11) {
          var n11, r11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.extractIterations(t11);
              case 2:
                t11 = e12.sent, X5(function() {
                  r11.accBeta1.assign(a9(r11.beta1, r11.iterations_ + 1)), r11.accBeta2.assign(a9(r11.beta2, r11.iterations_ + 1));
                }), n11 = t11.length / 2, this.accumulatedFirstMoment = t11.slice(0, n11).map(function(e13) {
                  return { originalName: e13.name, variable: e13.tensor.variable(false) };
                }), this.accumulatedSecondMoment = t11.slice(n11, 2 * n11).map(function(e13) {
                  return { originalName: e13.name, variable: e13.tensor.variable(false) };
                });
              case 8:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "getConfig", value: function() {
          return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon };
        } }], [{ key: "className", get: function() {
          return "Adam";
        } }, { key: "fromConfig", value: function(e11, t11) {
          return new e11(t11.learningRate, t11.beta1, t11.beta2, t11.epsilon);
        } }]), a10;
      }(Yre), $re = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11, t11, n11) {
          var i10, o10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
          return l(this, a10), (i10 = r10.call(this)).learningRate = e11, i10.beta1 = t11, i10.beta2 = n11, i10.epsilon = o10, i10.decay = s10, i10.accumulatedFirstMoment = [], i10.accumulatedWeightedInfNorm = [], X5(function() {
            i10.iteration = i9(0).variable(), i10.accBeta1 = i9(t11).variable();
          }), null == o10 && (i10.epsilon = E5.backend.epsilon()), i10;
        }
        return p(a10, [{ key: "applyGradients", value: function(e11) {
          var t11 = this, n11 = Array.isArray(e11) ? e11.map(function(e12) {
            return e12.name;
          }) : Object.keys(e11);
          X5(function() {
            var r11 = P9(1, t11.accBeta1), a11 = m8(-t11.learningRate, d8(g8(t11.iteration, t11.decay), 1));
            n11.forEach(function(n12, i10) {
              var o10 = E5.registeredVariables[n12];
              null == t11.accumulatedFirstMoment[i10] && (t11.accumulatedFirstMoment[i10] = { originalName: "".concat(n12, "/m"), variable: U7(o10).variable(false) }), null == t11.accumulatedWeightedInfNorm[i10] && (t11.accumulatedWeightedInfNorm[i10] = { originalName: "".concat(n12, "/v"), variable: U7(o10).variable(false) });
              var s10 = Array.isArray(e11) ? e11[i10].tensor : e11[n12];
              if (null != s10) {
                var u10 = t11.accumulatedFirstMoment[i10].variable, c10 = t11.accumulatedWeightedInfNorm[i10].variable, l10 = d8(g8(u10, t11.beta1), g8(s10, 1 - t11.beta1)), h10 = g8(c10, t11.beta2), p10 = y8(s10), f10 = Z9(h10, p10);
                u10.assign(l10), c10.assign(f10);
                var d10 = d8(g8(m8(a11, r11), m8(l10, d8(f10, t11.epsilon))), o10);
                o10.assign(d10);
              }
            }), t11.iteration.assign(d8(t11.iteration, 1)), t11.accBeta1.assign(g8(t11.accBeta1, t11.beta1));
          }), this.incrementIterations();
        } }, { key: "dispose", value: function() {
          this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && Y5(this.accumulatedFirstMoment.map(function(e11) {
            return e11.variable;
          })), null != this.accumulatedWeightedInfNorm && Y5(this.accumulatedWeightedInfNorm.map(function(e11) {
            return e11.variable;
          }));
        } }, { key: "getWeights", value: (n10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                throw new Error("getWeights() is not implemented for Adamax yet.");
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "setWeights", value: (t10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                throw new Error("setWeights() is not implemented for Adamax yet.");
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "getConfig", value: function() {
          return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon, decay: this.decay };
        } }], [{ key: "className", get: function() {
          return "Adamax";
        } }, { key: "fromConfig", value: function(e11, t11) {
          return new e11(t11.learningRate, t11.beta1, t11.beta2, t11.epsilon, t11.decay);
        } }]), a10;
      }(Yre), eae = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11) {
          var t11;
          return l(this, a10), (t11 = r10.call(this)).learningRate = e11, t11.setLearningRate(e11), t11;
        }
        return p(a10, [{ key: "applyGradients", value: function(e11) {
          var t11 = this;
          (Array.isArray(e11) ? e11.map(function(e12) {
            return e12.name;
          }) : Object.keys(e11)).forEach(function(n11, r11) {
            var a11 = Array.isArray(e11) ? e11[r11].tensor : e11[n11];
            if (null != a11) {
              var i10 = E5.registeredVariables[n11];
              X5(function() {
                var e12 = d8(g8(t11.c, a11), i10);
                i10.assign(e12);
              });
            }
          }), this.incrementIterations();
        } }, { key: "setLearningRate", value: function(e11) {
          this.learningRate = e11, null != this.c && this.c.dispose(), this.c = J5(i9(-e11));
        } }, { key: "dispose", value: function() {
          this.c.dispose();
        } }, { key: "getWeights", value: (n10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.saveIterations();
              case 2:
                return e12.t0 = e12.sent, e12.abrupt("return", [e12.t0]);
              case 4:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "setWeights", value: (t10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.extractIterations(t11);
              case 2:
                if (0 === (t11 = e12.sent).length) {
                  e12.next = 5;
                  break;
                }
                throw new Error("SGD optimizer does not have settable weights.");
              case 5:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "getConfig", value: function() {
          return { learningRate: this.learningRate };
        } }], [{ key: "className", get: function() {
          return "SGD";
        } }, { key: "fromConfig", value: function(e11, t11) {
          return new e11(t11.learningRate);
        } }]), a10;
      }(Yre), tae = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11, t11) {
          var n11, i10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          return l(this, a10), (n11 = r10.call(this, e11)).learningRate = e11, n11.momentum = t11, n11.useNesterov = i10, n11.accumulations = [], n11.m = i9(n11.momentum), n11;
        }
        return p(a10, [{ key: "applyGradients", value: function(e11) {
          var t11 = this;
          (Array.isArray(e11) ? e11.map(function(e12) {
            return e12.name;
          }) : Object.keys(e11)).forEach(function(n11, r11) {
            var a11 = E5.registeredVariables[n11];
            if (null == t11.accumulations[r11]) {
              t11.accumulations[r11] = { originalName: "".concat(n11, "/momentum"), variable: X5(function() {
                return U7(a11).variable(false);
              }) };
            }
            var i10 = t11.accumulations[r11].variable, o10 = Array.isArray(e11) ? e11[r11].tensor : e11[n11];
            null != o10 && X5(function() {
              var e12, n12 = d8(g8(t11.m, i10), o10);
              e12 = t11.useNesterov ? d8(g8(t11.c, d8(o10, g8(n12, t11.m))), a11) : d8(g8(t11.c, n12), a11), i10.assign(n12), a11.assign(e12);
            });
          }), this.incrementIterations();
        } }, { key: "dispose", value: function() {
          this.m.dispose(), null != this.accumulations && Y5(this.accumulations.map(function(e11) {
            return e11.variable;
          }));
        } }, { key: "setMomentum", value: function(e11) {
          this.momentum = e11;
        } }, { key: "getWeights", value: (n10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.saveIterations();
              case 2:
                return e12.t0 = e12.sent, e12.abrupt("return", [e12.t0].concat(this.accumulations.map(function(e13) {
                  return { name: e13.originalName, tensor: e13.variable };
                })));
              case 4:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "setWeights", value: (t10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.extractIterations(t11);
              case 2:
                t11 = e12.sent, this.accumulations = t11.map(function(e13) {
                  return { originalName: e13.name, variable: e13.tensor.variable(false) };
                });
              case 5:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "getConfig", value: function() {
          return { learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov };
        } }], [{ key: "className", get: function() {
          return "Momentum";
        } }, { key: "fromConfig", value: function(e11, t11) {
          return new e11(t11.learningRate, t11.momentum, t11.useNesterov);
        } }]), a10;
      }(eae), nae = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11) {
          var t11, n11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.9, i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, o10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s10 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
          if (l(this, a10), (t11 = r10.call(this)).learningRate = e11, t11.decay = n11, t11.momentum = i10, t11.epsilon = o10, t11.accumulatedMeanSquares = [], t11.accumulatedMoments = [], t11.accumulatedMeanGrads = [], t11.centered = s10, null == o10 && (t11.epsilon = E5.backend.epsilon()), null == e11) throw new Error("learningRate for RMSPropOptimizer must be defined.");
          return t11;
        }
        return p(a10, [{ key: "applyGradients", value: function(e11) {
          var t11 = this;
          (Array.isArray(e11) ? e11.map(function(e12) {
            return e12.name;
          }) : Object.keys(e11)).forEach(function(n11, r11) {
            var a11 = E5.registeredVariables[n11], i10 = false;
            null == t11.accumulatedMeanSquares[r11] && (t11.accumulatedMeanSquares[r11] = { originalName: "".concat(n11, "/rms"), variable: X5(function() {
              return U7(a11).variable(i10);
            }) }), null == t11.accumulatedMoments[r11] && (t11.accumulatedMoments[r11] = { originalName: "".concat(n11, "/momentum"), variable: X5(function() {
              return U7(a11).variable(i10);
            }) }), null == t11.accumulatedMeanGrads[r11] && t11.centered && (t11.accumulatedMeanGrads[r11] = { originalName: "".concat(n11, "/mg"), variable: X5(function() {
              return U7(a11).variable(i10);
            }) });
            var o10 = Array.isArray(e11) ? e11[r11].tensor : e11[n11];
            if (null != o10) {
              var s10 = t11.accumulatedMeanSquares[r11].variable, u10 = t11.accumulatedMoments[r11].variable;
              X5(function() {
                var e12 = d8(g8(s10, t11.decay), g8(s9(o10), 1 - t11.decay));
                if (t11.centered) {
                  var n12 = t11.accumulatedMeanGrads[r11].variable, i11 = d8(g8(n12, t11.decay), g8(o10, 1 - t11.decay)), c10 = m8(g8(o10, t11.learningRate), o9(P9(e12, d8(s9(i11), t11.epsilon)))), l10 = d8(g8(u10, t11.momentum), c10);
                  s10.assign(e12), n12.assign(i11), u10.assign(l10);
                  var h10 = P9(a11, l10);
                  a11.assign(h10);
                } else {
                  var p10 = d8(g8(s10, t11.decay), g8(s9(o10), 1 - t11.decay)), f10 = d8(g8(u10, t11.momentum), m8(g8(o10, t11.learningRate), o9(d8(p10, t11.epsilon))));
                  s10.assign(p10), u10.assign(f10);
                  var d10 = P9(a11, f10);
                  a11.assign(d10);
                }
              });
            }
          }), this.incrementIterations();
        } }, { key: "dispose", value: function() {
          null != this.accumulatedMeanSquares && Y5(this.accumulatedMeanSquares.map(function(e11) {
            return e11.variable;
          })), null != this.accumulatedMeanGrads && this.centered && Y5(this.accumulatedMeanGrads.map(function(e11) {
            return e11.variable;
          })), null != this.accumulatedMoments && Y5(this.accumulatedMoments.map(function(e11) {
            return e11.variable;
          }));
        } }, { key: "getWeights", value: (n10 = c(o().mark(function e11() {
          var t11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return t11 = [].concat(T(this.accumulatedMeanSquares), T(this.accumulatedMoments)), this.centered && t11.push.apply(t11, T(this.accumulatedMeanGrads)), e12.next = 4, this.saveIterations();
              case 4:
                return e12.t0 = e12.sent, e12.abrupt("return", [e12.t0].concat(t11.map(function(e13) {
                  return { name: e13.originalName, tensor: e13.variable };
                })));
              case 6:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "setWeights", value: (t10 = c(o().mark(function e11(t11) {
          var n11, r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.extractIterations(t11);
              case 2:
                t11 = e12.sent, n11 = this.centered ? t11.length / 3 : t11.length / 2, r11 = false, this.accumulatedMeanSquares = t11.slice(0, n11).map(function(e13) {
                  return { originalName: e13.name, variable: e13.tensor.variable(r11) };
                }), this.accumulatedMoments = t11.slice(n11, 2 * n11).map(function(e13) {
                  return { originalName: e13.name, variable: e13.tensor.variable(r11) };
                }), this.centered && (this.accumulatedMeanGrads = t11.slice(2 * n11, 3 * n11).map(function(e13) {
                  return { originalName: e13.name, variable: e13.tensor.variable(r11) };
                }));
              case 8:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "getConfig", value: function() {
          return { learningRate: this.learningRate, decay: this.decay, momentum: this.momentum, epsilon: this.epsilon, centered: this.centered };
        } }], [{ key: "className", get: function() {
          return "RMSProp";
        } }, { key: "fromConfig", value: function(e11, t11) {
          return new e11(t11.learningRate, t11.decay, t11.momentum, t11.epsilon, t11.centered);
        } }]), a10;
      }(Yre), rae = [Jre, Zre, Qre, $re, tae, nae, eae];
      function aae(e10) {
        return new Promise(function(e11) {
          return setTimeout(e11);
        }).then(e10);
      }
      var iae = function() {
        function e10(t11) {
          if (l(this, e10), !k0().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
          t11.startsWith(e10.URL_SCHEME) && (t11 = t11.slice(e10.URL_SCHEME.length)), null != t11 && 0 !== t11.length || (t11 = "model"), this.modelJsonFileName = t11 + ".json", this.weightDataFileName = t11 + ".weights.bin";
        }
        var t10;
        return p(e10, [{ key: "save", value: (t10 = c(o().mark(function e11(t11) {
          var n10, r10, a10, i10, s10, u10, c10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if ("undefined" != typeof document) {
                  e12.next = 2;
                  break;
                }
                throw new Error("Browser downloads are not supported in this environment since `document` is not present");
              case 2:
                if (n10 = j5.join(t11.weightData), r10 = window.URL.createObjectURL(new Blob([n10], { type: "application/octet-stream" })), !(t11.modelTopology instanceof ArrayBuffer)) {
                  e12.next = 8;
                  break;
                }
                throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
              case 8:
                return a10 = [{ paths: ["./" + this.weightDataFileName], weights: t11.weightSpecs }], i10 = b6(t11, a10), s10 = window.URL.createObjectURL(new Blob([JSON.stringify(i10)], { type: "application/json" })), (u10 = null == this.modelJsonAnchor ? document.createElement("a") : this.modelJsonAnchor).download = this.modelJsonFileName, u10.href = s10, e12.next = 16, aae(function() {
                  return u10.dispatchEvent(new MouseEvent("click"));
                });
              case 16:
                if (null == t11.weightData) {
                  e12.next = 22;
                  break;
                }
                return (c10 = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, c10.href = r10, e12.next = 22, aae(function() {
                  return c10.dispatchEvent(new MouseEvent("click"));
                });
              case 22:
                return e12.abrupt("return", { modelArtifactsInfo: I6(t11) });
              case 23:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }]), e10;
      }();
      iae.URL_SCHEME = "downloads://";
      var oae = function() {
        function e10(t11) {
          if (l(this, e10), null == t11 || t11.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, " + "but received ".concat(t11));
          this.jsonFile = t11[0], this.weightsFiles = t11.slice(1);
        }
        var t10;
        return p(e10, [{ key: "load", value: (t10 = c(o().mark(function e11() {
          var t11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.abrupt("return", new Promise(function(e13, n10) {
                  var r10 = new FileReader();
                  r10.onload = function(r11) {
                    var a10 = JSON.parse(r11.target.result), i10 = a10.modelTopology;
                    if (null != i10) if (null != a10.weightsManifest) if (0 !== t11.weightsFiles.length) {
                      var o10 = k6(a10, function(e14) {
                        return t11.loadWeights(e14);
                      });
                      e13(o10);
                    } else e13({ modelTopology: i10 });
                    else n10(new Error("weightManifest field is missing from file ".concat(t11.jsonFile.name)));
                    else n10(new Error("modelTopology field is missing from file ".concat(t11.jsonFile.name)));
                  }, r10.onerror = function(e14) {
                    return n10("Failed to read model topology and weights manifest JSON " + "from file '".concat(t11.jsonFile.name, "'. BrowserFiles supports loading ") + "Keras-style tf.Model artifacts only.");
                  }, r10.readAsText(t11.jsonFile);
                }));
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11);
        })), function() {
          return t10.apply(this, arguments);
        }) }, { key: "loadWeights", value: function(e11) {
          var t11, n10 = this, r10 = [], a10 = [], i10 = O(e11);
          try {
            for (i10.s(); !(t11 = i10.n()).done; ) {
              var o10 = t11.value;
              r10.push.apply(r10, T(o10.weights)), a10.push.apply(a10, T(o10.paths));
            }
          } catch (e12) {
            i10.e(e12);
          } finally {
            i10.f();
          }
          var s10 = this.checkManifestAndWeightFiles(e11), u10 = a10.map(function(e12) {
            return n10.loadWeightsFile(e12, s10[e12]);
          });
          return Promise.all(u10).then(function(e12) {
            return [r10, e12];
          });
        } }, { key: "loadWeightsFile", value: function(e11, t11) {
          return new Promise(function(n10, r10) {
            var a10 = new FileReader();
            a10.onload = function(e12) {
              var t12 = e12.target.result;
              n10(t12);
            }, a10.onerror = function(t12) {
              return r10("Failed to weights data from file of path '".concat(e11, "'."));
            }, a10.readAsArrayBuffer(t11);
          });
        } }, { key: "checkManifestAndWeightFiles", value: function(e11) {
          var t11, n10 = this, r10 = [], a10 = this.weightsFiles.map(function(e12) {
            return y6(e12.name);
          }), i10 = {}, o10 = O(e11);
          try {
            for (o10.s(); !(t11 = o10.n()).done; ) {
              t11.value.paths.forEach(function(e12) {
                var t12 = y6(e12);
                if (-1 !== r10.indexOf(t12)) throw new Error("Duplicate file basename found in weights manifest: " + "'".concat(t12, "'"));
                if (r10.push(t12), -1 === a10.indexOf(t12)) throw new Error("Weight file with basename '".concat(t12, "' is not provided."));
                i10[e12] = n10.weightsFiles[a10.indexOf(t12)];
              });
            }
          } catch (e12) {
            o10.e(e12);
          } finally {
            o10.f();
          }
          if (r10.length !== this.weightsFiles.length) throw new Error("Mismatch in the number of files in weights manifest " + "(".concat(r10.length, ") and the number of weight files provided ") + "(".concat(this.weightsFiles.length, ")."));
          return i10;
        } }]), e10;
      }();
      function sae(e10, t10, n10, r10) {
        !function(e11) {
          F$(null != e11 && Array.isArray(e11) && e11.length > 0, function() {
            return "promises must be a none empty array";
          });
        }(e10), function(e11, t11) {
          F$(e11 >= 0 && e11 <= 1, function() {
            return "Progress fraction must be in range [0, 1], but " + "got startFraction ".concat(e11);
          }), F$(t11 >= 0 && t11 <= 1, function() {
            return "Progress fraction must be in range [0, 1], but " + "got endFraction ".concat(t11);
          }), F$(t11 >= e11, function() {
            return "startFraction must be no more than endFraction, but " + "got startFraction ".concat(e11, " and endFraction ") + "".concat(t11);
          });
        }(n10 = null == n10 ? 0 : n10, r10 = null == r10 ? 1 : r10);
        var a10 = 0;
        return Promise.all(e10.map(function(i10) {
          return i10.then(function(i11) {
            var o10 = n10 + ++a10 / e10.length * (r10 - n10);
            return t10(o10), i11;
          }), i10;
        }));
      }
      function uae(e10, t10) {
        return cae.apply(this, arguments);
      }
      function cae() {
        return (cae = c(o().mark(function e10(t10, n10) {
          var r10, a10, i10, s10, u10, c10, l10, h10, p10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                if (null == n10 && (n10 = {}), r10 = null == n10.fetchFunc ? k0().platform.fetch : n10.fetchFunc, a10 = t10.map(function(e12) {
                  return r10(e12, n10.requestInit, { isBinary: true });
                }), i10 = 0, s10 = 0.5, null != n10.onProgress) {
                  e11.next = 11;
                  break;
                }
                return e11.next = 8, Promise.all(a10);
              case 8:
                e11.t0 = e11.sent, e11.next = 14;
                break;
              case 11:
                return e11.next = 13, sae(a10, n10.onProgress, i10, s10);
              case 13:
                e11.t0 = e11.sent;
              case 14:
                if (u10 = e11.t0, c10 = u10.map(function(e12) {
                  return e12.arrayBuffer();
                }), l10 = 0.5, h10 = 1, null != n10.onProgress) {
                  e11.next = 24;
                  break;
                }
                return e11.next = 21, Promise.all(c10);
              case 21:
                e11.t1 = e11.sent, e11.next = 27;
                break;
              case 24:
                return e11.next = 26, sae(c10, n10.onProgress, l10, h10);
              case 26:
                e11.t1 = e11.sent;
              case 27:
                return p10 = e11.t1, e11.abrupt("return", p10);
              case 29:
              case "end":
                return e11.stop();
            }
          }, e10);
        }))).apply(this, arguments);
      }
      function lae(e10, t10) {
        var n10, r10, a10, i10 = null == t10.fetchFunc ? k0().platform.fetch : t10.fetchFunc, s10 = 0;
        return null === (n10 = t10.onProgress) || void 0 === n10 || n10.call(t10, 0), new ReadableStream({ pull: (a10 = c(o().mark(function n11(a11) {
          var u10, c10, l10, h10, p10;
          return o().wrap(function(n12) {
            for (; ; ) switch (n12.prev = n12.next) {
              case 0:
                if (!(s10 < e10.length)) {
                  n12.next = 20;
                  break;
                }
                if (r10) {
                  n12.next = 6;
                  break;
                }
                return n12.next = 4, i10(e10[s10], t10.requestInit, { isBinary: true });
              case 4:
                c10 = n12.sent.body, r10 = c10.getReader();
              case 6:
                return n12.next = 8, r10.read();
              case 8:
                if (l10 = n12.sent, h10 = l10.done, p10 = l10.value, !h10) {
                  n12.next = 16;
                  break;
                }
                return s10++, r10 = void 0, null === (u10 = t10.onProgress) || void 0 === u10 || u10.call(t10, s10 / e10.length), n12.abrupt("continue", 0);
              case 16:
                return a11.enqueue(p10), n12.abrupt("return");
              case 20:
                a11.close();
              case 21:
              case "end":
                return n12.stop();
            }
          }, n11);
        })), function(e11) {
          return a10.apply(this, arguments);
        }) });
      }
      function hae(e10) {
        return pae.apply(this, arguments);
      }
      function pae() {
        return pae = c(o().mark(function e10(t10) {
          var n10, r10, a10, i10, s10 = arguments;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return n10 = s10.length > 1 && void 0 !== s10[1] ? s10[1] : "", r10 = s10.length > 2 ? s10[2] : void 0, a10 = s10.length > 3 ? s10[3] : void 0, i10 = fae(function(e12) {
                  return uae(e12, { requestInit: a10 });
                }), e11.abrupt("return", i10(t10, n10, r10));
              case 6:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), pae.apply(this, arguments);
      }
      function fae(e10) {
        return function() {
          var t10 = c(o().mark(function t11(n10) {
            var r10, a10, i10, s10, u10, c10, l10, h10, p10, f10, d10, v10, m10 = arguments;
            return o().wrap(function(t12) {
              for (; ; ) switch (t12.prev = t12.next) {
                case 0:
                  if (r10 = m10.length > 1 && void 0 !== m10[1] ? m10[1] : "", a10 = m10.length > 2 ? m10[2] : void 0, i10 = n10.map(function() {
                    return false;
                  }), s10 = {}, u10 = null != a10 ? a10.map(function() {
                    return false;
                  }) : [], c10 = [], n10.forEach(function(e11, t13) {
                    var n11 = 0;
                    e11.weights.forEach(function(e12) {
                      var r11 = "quantization" in e12 ? e12.quantization.dtype : e12.dtype, o10 = G5[r11] * L$(e12.shape), l11 = function() {
                        i10[t13] = true, null == s10[t13] && (s10[t13] = []), s10[t13].push({ manifestEntry: e12, groupOffset: n11, sizeBytes: o10 });
                      };
                      null != a10 ? a10.forEach(function(t14, n12) {
                        t14 === e12.name && (l11(), u10[n12] = true);
                      }) : l11(), c10.push(e12.name), n11 += o10;
                    });
                  }), u10.every(function(e11) {
                    return e11;
                  })) {
                    t12.next = 10;
                    break;
                  }
                  throw l10 = a10.filter(function(e11, t13) {
                    return !u10[t13];
                  }), new Error("Could not find weights in manifest with names: " + "".concat(l10.join(", "), ". \n") + "Manifest JSON has weights with names: " + "".concat(c10.join(", "), "."));
                case 10:
                  return h10 = i10.reduce(function(e11, t13, n11) {
                    return t13 && e11.push(n11), e11;
                  }, []), p10 = [], h10.forEach(function(e11) {
                    n10[e11].paths.forEach(function(e12) {
                      var t13 = r10 + (r10.endsWith("/") ? "" : "/") + e12;
                      p10.push(t13);
                    });
                  }), t12.next = 15, e10(p10);
                case 15:
                  return f10 = t12.sent, d10 = {}, v10 = 0, h10.forEach(function(e11) {
                    var t13 = n10[e11].paths.length, r11 = new j5(f10.slice(v10, v10 + t13));
                    s10[e11].forEach(function(e12) {
                      var t14 = r6(r11.slice(e12.groupOffset, e12.groupOffset + e12.sizeBytes), [e12.manifestEntry]);
                      for (var n11 in t14) d10[n11] = t14[n11];
                    }), v10 += t13;
                  }), t12.abrupt("return", d10);
                case 20:
                case "end":
                  return t12.stop();
              }
            }, t11);
          }));
          return function(e11) {
            return t10.apply(this, arguments);
          };
        }();
      }
      S6.registerSaveRouter(function(e10) {
        return k0().getBool("IS_BROWSER") && !Array.isArray(e10) && e10.startsWith(iae.URL_SCHEME) ? function() {
          var e11 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "model";
          return new iae(e11);
        }(e10.slice(iae.URL_SCHEME.length)) : null;
      });
      var dae = function() {
        function e10(t11, n11) {
          if (l(this, e10), this.DEFAULT_METHOD = "POST", null == n11 && (n11 = {}), this.weightPathPrefix = n11.weightPathPrefix, this.weightUrlConverter = n11.weightUrlConverter, null != n11.fetchFunc ? (F$("function" == typeof n11.fetchFunc, function() {
            return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
          }), this.fetch = n11.fetchFunc) : this.fetch = k0().platform.fetch, F$(null != t11 && t11.length > 0, function() {
            return "URL path for http must not be null, undefined or empty.";
          }), Array.isArray(t11) && F$(2 === t11.length, function() {
            return "URL paths for http must have a length of 2, " + "(actual length is ".concat(t11.length, ").");
          }), this.path = t11, null != n11.requestInit && null != n11.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
          this.requestInit = n11.requestInit || {}, this.loadOptions = n11;
        }
        var t10, n10, r10, a10, i10;
        return p(e10, [{ key: "save", value: (i10 = c(o().mark(function e11(t11) {
          var n11, r11, a11, i11, s10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!(t11.modelTopology instanceof ArrayBuffer)) {
                  e12.next = 2;
                  break;
                }
                throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
              case 2:
                return (n11 = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit)).body = new FormData(), r11 = [{ paths: ["./model.weights.bin"], weights: t11.weightSpecs }], a11 = b6(t11, r11), n11.body.append("model.json", new Blob([JSON.stringify(a11)], { type: "application/json" }), "model.json"), null != t11.weightData && (i11 = j5.join(t11.weightData), n11.body.append("model.weights.bin", new Blob([i11], { type: "application/octet-stream" }), "model.weights.bin")), e12.next = 10, this.fetch(this.path, n11);
              case 10:
                if (!(s10 = e12.sent).ok) {
                  e12.next = 15;
                  break;
                }
                return e12.abrupt("return", { modelArtifactsInfo: I6(t11), responses: [s10] });
              case 15:
                throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + "".concat(s10.status, "."));
              case 16:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return i10.apply(this, arguments);
        }) }, { key: "loadModelJSON", value: (a10 = c(o().mark(function e11() {
          var t11, n11, r11, a11, i11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.fetch(this.path, this.requestInit);
              case 2:
                if ((t11 = e12.sent).ok) {
                  e12.next = 5;
                  break;
                }
                throw new Error("Request to ".concat(this.path, " failed with status code ") + "".concat(t11.status, ". Please verify this URL points to ") + "the model JSON of the model to load.");
              case 5:
                return e12.prev = 5, e12.next = 8, t11.json();
              case 8:
                n11 = e12.sent, e12.next = 16;
                break;
              case 11:
                throw e12.prev = 11, e12.t0 = e12.catch(5), r11 = "Failed to parse model JSON of response from ".concat(this.path, "."), this.path.endsWith(".pb") ? r11 += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : r11 += " Please make sure the server is serving valid JSON for this request.", new Error(r11);
              case 16:
                if (a11 = n11.modelTopology, i11 = n11.weightsManifest, null != a11 || null != i11) {
                  e12.next = 20;
                  break;
                }
                throw new Error("The JSON from HTTP path ".concat(this.path, " contains neither model ") + "topology or manifest for weights.");
              case 20:
                return e12.abrupt("return", n11);
              case 21:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[5, 11]]);
        })), function() {
          return a10.apply(this, arguments);
        }) }, { key: "load", value: (r10 = c(o().mark(function e11() {
          var t11, n11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!this.loadOptions.streamWeights) {
                  e12.next = 2;
                  break;
                }
                return e12.abrupt("return", this.loadStream());
              case 2:
                return e12.next = 4, this.loadModelJSON();
              case 4:
                return t11 = e12.sent, e12.abrupt("return", k6(t11, function(e13) {
                  return n11.loadWeights(e13);
                }));
              case 6:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return r10.apply(this, arguments);
        }) }, { key: "loadStream", value: (n10 = c(o().mark(function e11() {
          var t11, n11, r11, a11, i11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.loadModelJSON();
              case 2:
                return t11 = e12.sent, e12.next = 5, this.getWeightUrls(t11.weightsManifest);
              case 5:
                return n11 = e12.sent, r11 = N6(t11.weightsManifest), a11 = function() {
                  return lae(n11, i11.loadOptions);
                }, e12.abrupt("return", Object.assign(Object.assign({}, t11), { weightSpecs: r11, getWeightStream: a11 }));
              case 9:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "getWeightUrls", value: (t10 = c(o().mark(function e11(t11) {
          var n11, r11, a11, i11, s10, u10, c10, l10, h10, p10, f10, d10, v10, m10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                n11 = Array.isArray(this.path) ? this.path[1] : this.path, r11 = vae(n11), a11 = S(r11, 2), i11 = a11[0], s10 = a11[1], u10 = this.weightPathPrefix || i11, c10 = [], l10 = [], h10 = O(t11);
                try {
                  for (h10.s(); !(p10 = h10.n()).done; ) {
                    f10 = p10.value, d10 = O(f10.paths);
                    try {
                      for (d10.s(); !(v10 = d10.n()).done; ) m10 = v10.value, null != this.weightUrlConverter ? l10.push(this.weightUrlConverter(m10)) : c10.push(u10 + m10 + s10);
                    } catch (e13) {
                      d10.e(e13);
                    } finally {
                      d10.f();
                    }
                  }
                } catch (e13) {
                  h10.e(e13);
                } finally {
                  h10.f();
                }
                if (!this.weightUrlConverter) {
                  e12.next = 16;
                  break;
                }
                return e12.t0 = c10.push, e12.t1 = c10, e12.t2 = T, e12.next = 13, Promise.all(l10);
              case 13:
                e12.t3 = e12.sent, e12.t4 = (0, e12.t2)(e12.t3), e12.t0.apply.call(e12.t0, e12.t1, e12.t4);
              case 16:
                return e12.abrupt("return", c10);
              case 17:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "loadWeights", value: function() {
          var e11 = c(o().mark(function e12(t11) {
            var n11, r11, a11;
            return o().wrap(function(e13) {
              for (; ; ) switch (e13.prev = e13.next) {
                case 0:
                  return e13.next = 2, this.getWeightUrls(t11);
                case 2:
                  return n11 = e13.sent, r11 = N6(t11), e13.next = 6, uae(n11, this.loadOptions);
                case 6:
                  return a11 = e13.sent, e13.abrupt("return", [r11, a11]);
                case 8:
                case "end":
                  return e13.stop();
              }
            }, e12, this);
          }));
          return function(t11) {
            return e11.apply(this, arguments);
          };
        }() }]), e10;
      }();
      function vae(e10) {
        var t10 = e10.lastIndexOf("/"), n10 = e10.lastIndexOf("?");
        return [e10.substring(0, t10) + "/", n10 > t10 ? e10.substring(n10) : ""];
      }
      function mae(e10) {
        return null != e10.match(dae.URL_SCHEME_REGEX);
      }
      dae.URL_SCHEME_REGEX = /^https?:\/\//;
      var gae = function(e10, t10) {
        if ("undefined" == typeof fetch && (null == t10 || null == t10.fetchFunc)) return null;
        return (Array.isArray(e10) ? e10.every(function(e11) {
          return mae(e11);
        }) : mae(e10)) ? yae(e10, t10) : null;
      };
      function yae(e10, t10) {
        return new dae(e10, t10);
      }
      function bae(e10, t10) {
        return yae(e10, t10);
      }
      S6.registerSaveRouter(gae), S6.registerLoadRouter(gae);
      var xae = function() {
        function e10(t10) {
          l(this, e10), this.modelArtifacts = t10;
        }
        return p(e10, [{ key: "load", value: function() {
          return this.modelArtifacts;
        } }]), e10;
      }(), kae = function() {
        function e10(t10) {
          l(this, e10), this.saveHandler = t10;
        }
        return p(e10, [{ key: "save", value: function(e11) {
          return this.saveHandler(e11);
        } }]), e10;
      }(), wae = p(function e10(t10) {
        l(this, e10), t10.load && (this.load = function() {
          return Promise.resolve(t10.load());
        }), t10.save && (this.save = function(e11) {
          return Promise.resolve(t10.save(e11));
        });
      });
      function Iae(e10, t10, n10, r10) {
        if (1 === arguments.length) {
          var a10 = null != e10.modelTopology || null != e10.weightSpecs;
          return a10 ? new xae(e10) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new xae({ modelTopology: e10 }));
        }
        return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new xae({ modelTopology: e10, weightSpecs: t10, weightData: n10, trainingConfig: r10 });
      }
      var Nae = { __proto__: null, CompositeArrayBuffer: j5, browserFiles: function(e10) {
        return new oae(e10);
      }, browserHTTPRequest: bae, concatenateArrayBuffers: g6, copyModel: function(e10, t10) {
        return a8.apply(this, arguments);
      }, decodeWeights: r6, decodeWeightsStream: l6, encodeWeights: t6, fromMemory: function(e10, t10, n10, r10) {
        var a10 = arguments;
        return new wae(Iae.apply(void 0, T(a10)));
      }, fromMemorySync: Iae, getLoadHandlers: E6, getModelArtifactsForJSON: k6, getModelArtifactsForJSONSync: x6, getModelArtifactsInfoForJSON: I6, getSaveHandlers: T6, getWeightSpecs: N6, http: yae, isHTTPScheme: mae, listModels: function() {
        return n8.apply(this, arguments);
      }, loadWeights: hae, moveModel: function(e10, t10) {
        return i8.apply(this, arguments);
      }, registerLoadRouter: function(e10) {
        return S6.registerLoadRouter(e10);
      }, registerSaveRouter: function(e10) {
        return S6.registerSaveRouter(e10);
      }, removeModel: function(e10) {
        return r8.apply(this, arguments);
      }, weightsLoaderFactory: fae, withSaveHandler: function(e10) {
        return new kae(e10);
      }, withSaveHandlerSync: function(e10) {
        return new kae(e10);
      } };
      var Sae, Tae = { __proto__: null, confusionMatrix: B5({ confusionMatrix_: function(e10, t10, n10) {
        var r10 = L5(e10, "labels", "confusionMatrix"), a10 = L5(t10, "predictions", "confusionMatrix");
        F$(null == n10 || n10 > 0 && Number.isInteger(n10), function() {
          return "If provided, numClasses must be a positive integer, " + "but got ".concat(n10);
        }), F$(1 === r10.rank, function() {
          return "Expected the rank of labels to be 1, but got ".concat(r10.rank);
        }), F$(1 === a10.rank, function() {
          return "Expected the rank of predictions to be 1, " + "but got ".concat(a10.rank);
        }), F$(r10.shape[0] === a10.shape[0], function() {
          return "Mismatch in the number of examples: " + "".concat(r10.shape[0], " vs. ").concat(a10.shape[0], ". ") + "Labels and predictions should have the same number of elements.";
        }), F$(n10 > 0 && Number.isInteger(n10), function() {
          return "numClasses is required to be a positive integer, but got " + "".concat(n10);
        });
        var i10 = cee(h8(r10, "int32"), n10), o10 = cee(h8(a10, "int32"), n10), s10 = hne(i10), u10 = Q8(s10, o10);
        return h8(u10, "int32");
      } }) }, Eae = false;
      function Cae(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3;
        if (t10 > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
        if (null == e10) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
        var n10 = false, r10 = false, a10 = false, i10 = false, o10 = false, s10 = false;
        if (e10.data instanceof Uint8Array) n10 = true;
        else if ("undefined" != typeof ImageData && e10 instanceof ImageData) r10 = true;
        else if ("undefined" != typeof HTMLVideoElement && e10 instanceof HTMLVideoElement) a10 = true;
        else if ("undefined" != typeof HTMLImageElement && e10 instanceof HTMLImageElement) i10 = true;
        else if (null != e10.getContext) o10 = true;
        else {
          if (!("undefined" != typeof ImageBitmap && e10 instanceof ImageBitmap)) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, " + "but was ".concat(e10.constructor.name));
          s10 = true;
        }
        var u10 = W3(O3, E5.backendName);
        if (null != u10) {
          var c10 = { pixels: e10 }, l10 = { numChannels: t10 };
          return E5.runKernel(O3, c10, l10);
        }
        var h10, p10, f10 = a10 ? [e10.videoWidth, e10.videoHeight] : [e10.width, e10.height], d10 = S(f10, 2), v10 = d10[0], m10 = d10[1];
        if (o10) h10 = e10.getContext("2d").getImageData(0, 0, v10, m10).data;
        else if (r10 || n10) h10 = e10.data;
        else if (i10 || a10 || s10) {
          if (null == Sae) if ("undefined" == typeof document) {
            if ("undefined" == typeof OffscreenCanvas || "undefined" == typeof OffscreenCanvasRenderingContext2D) throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
            Sae = new OffscreenCanvas(1, 1).getContext("2d");
          } else Sae = document.createElement("canvas").getContext("2d", { willReadFrequently: true });
          Sae.canvas.width = v10, Sae.canvas.height = m10, Sae.drawImage(e10, 0, 0, v10, m10), h10 = Sae.getImageData(0, 0, v10, m10).data;
        }
        if (4 === t10) p10 = new Int32Array(h10);
        else {
          var g10 = v10 * m10;
          p10 = new Int32Array(g10 * t10);
          for (var y10 = 0; y10 < g10; y10++) for (var b10 = 0; b10 < t10; ++b10) p10[y10 * t10 + b10] = h10[4 * y10 + b10];
        }
        var x10 = [m10, v10, t10];
        return jte(p10, x10, "int32");
      }
      function Aae(e10) {
        return "undefined" != typeof window && "undefined" != typeof ImageBitmap && window.hasOwnProperty("createImageBitmap") && !(e10 instanceof ImageBitmap) && function(e11) {
          return null != e11 && 0 !== e11.width && 0 !== e11.height;
        }(e10) && !function(e11) {
          return null != e11 && e11.data instanceof Uint8Array;
        }(e10);
      }
      function Rae() {
        return Rae = c(o().mark(function e10(t10) {
          var n10, r10, a10, i10 = arguments;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                if (n10 = i10.length > 1 && void 0 !== i10[1] ? i10[1] : 3, r10 = null, !k0().getBool("WRAP_TO_IMAGEBITMAP") || !Aae(t10)) {
                  e11.next = 15;
                  break;
                }
                return e11.prev = 3, e11.next = 6, createImageBitmap(t10, { premultiplyAlpha: "none" });
              case 6:
                a10 = e11.sent, e11.next = 12;
                break;
              case 9:
                e11.prev = 9, e11.t0 = e11.catch(3), a10 = null;
              case 12:
                r10 = null != a10 && a10.width === t10.width && a10.height === t10.height ? a10 : t10, e11.next = 16;
                break;
              case 15:
                r10 = t10;
              case 16:
                return e11.abrupt("return", Cae(r10, n10));
              case 17:
              case "end":
                return e11.stop();
            }
          }, e10, null, [[3, 9]]);
        })), Rae.apply(this, arguments);
      }
      function _ae(e10) {
        if (2 !== e10.rank && 3 !== e10.rank) throw new Error("toPixels only supports rank 2 or 3 tensors, got rank ".concat(e10.rank, "."));
        var t10 = 2 === e10.rank ? 1 : e10.shape[2];
        if (t10 > 4 || 2 === t10) throw new Error("toPixels only supports depth of size " + "1, 3 or 4 but got ".concat(t10));
        if ("float32" !== e10.dtype && "int32" !== e10.dtype) throw new Error("Unsupported type for toPixels: ".concat(e10.dtype, ".") + " Please use float32 or int32 tensors.");
      }
      function Oae() {
        return Oae = c(o().mark(function e10(t10, n10) {
          var r10, a10, i10, s10, u10, c10, l10, h10, p10, f10, d10, v10, m10, g10, y10, b10, x10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return r10 = L5(t10, "img", "toPixels"), t10 instanceof n5 || (r10 = h8(a10 = r10, "int32"), a10.dispose()), _ae(r10), i10 = r10.shape.slice(0, 2), s10 = S(i10, 2), u10 = s10[0], c10 = s10[1], l10 = 2 === r10.rank ? 1 : r10.shape[2], e11.next = 7, r10.data();
              case 7:
                h10 = e11.sent, p10 = "float32" === r10.dtype ? 255 : 1, f10 = new Uint8ClampedArray(c10 * u10 * 4), d10 = 0;
              case 11:
                if (!(d10 < u10 * c10)) {
                  e11.next = 36;
                  break;
                }
                v10 = [0, 0, 0, 255], m10 = 0;
              case 14:
                if (!(m10 < l10)) {
                  e11.next = 28;
                  break;
                }
                if (g10 = h10[d10 * l10 + m10], "float32" !== r10.dtype) {
                  e11.next = 21;
                  break;
                }
                if (!(g10 < 0 || g10 > 1)) {
                  e11.next = 19;
                  break;
                }
                throw new Error("Tensor values for a float32 Tensor must be in the " + "range [0 - 1] but encountered ".concat(g10, "."));
              case 19:
                e11.next = 24;
                break;
              case 21:
                if ("int32" !== r10.dtype) {
                  e11.next = 24;
                  break;
                }
                if (!(g10 < 0 || g10 > 255)) {
                  e11.next = 24;
                  break;
                }
                throw new Error("Tensor values for a int32 Tensor must be in the " + "range [0 - 255] but encountered ".concat(g10, "."));
              case 24:
                1 === l10 ? (v10[0] = g10 * p10, v10[1] = g10 * p10, v10[2] = g10 * p10) : v10[m10] = g10 * p10;
              case 25:
                m10++, e11.next = 14;
                break;
              case 28:
                f10[(y10 = 4 * d10) + 0] = Math.round(v10[0]), f10[y10 + 1] = Math.round(v10[1]), f10[y10 + 2] = Math.round(v10[2]), f10[y10 + 3] = Math.round(v10[3]);
              case 33:
                ++d10, e11.next = 11;
                break;
              case 36:
                return null != n10 && (Eae || null != W3(x1, E5.backendName) && (console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."), Eae = true), n10.width = c10, n10.height = u10, b10 = n10.getContext("2d"), x10 = new ImageData(f10, c10, u10), b10.putImageData(x10, 0, 0)), r10 !== t10 && r10.dispose(), e11.abrupt("return", f10);
              case 39:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), Oae.apply(this, arguments);
      }
      var Fae = B5({ fromPixels_: Cae }), Dae = { __proto__: null, draw: function(e10, t10, n10) {
        var r10 = L5(e10, "img", "draw");
        if (!(e10 instanceof n5)) {
          var a10 = r10;
          r10 = h8(a10, "int32"), a10.dispose();
        }
        _ae(r10), function(e11) {
          var t11 = (null == e11 ? void 0 : e11.alpha) || 1;
          if (t11 > 1 || t11 < 0) throw new Error("Alpha value ".concat(t11, " is suppoed to be in range [0 - 1]."));
        }(null == n10 ? void 0 : n10.imageOptions);
        var i10 = { image: r10 }, o10 = { canvas: t10, options: n10 };
        E5.runKernel(x1, i10, o10);
      }, fromPixels: Fae, fromPixelsAsync: function(e10) {
        return Rae.apply(this, arguments);
      }, toPixels: function(e10, t10) {
        return Oae.apply(this, arguments);
      } };
      function Mae(e10, t10) {
        var n10 = e10.shape.length, r10 = t10.shape.length;
        if (n10 < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher," + " but the rank was ".concat(n10, "."));
        if (r10 < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher," + " but the rank was ".concat(r10, "."));
        if ("int32" !== t10.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type," + " but the dtype was ".concat(t10.dtype, "."));
        if (t10.shape[r10 - 1] > n10) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + "".concat(t10.shape[r10 - 1], " vs. ").concat(n10));
        if (0 === L$(e10.shape)) throw new Error("Requested more than 0 entries, but input is empty." + " Input shape: ".concat(e10.shape, "."));
        for (var a10 = t10.shape, i10 = a10[a10.length - 1], o10 = 1, s10 = 0; s10 < a10.length - 1; ++s10) o10 *= a10[s10];
        var u10 = e10.shape, c10 = a10.slice();
        c10.pop();
        for (var l10 = 1, h10 = i10; h10 < n10; ++h10) l10 *= u10[h10], c10.push(u10[h10]);
        var p10 = [].concat(T(i0(e10.shape).map(function(e11) {
          return e11 / l10;
        })), [1]).slice(0, i10);
        return [c10, o10, l10, p10];
      }
      var Lae = { __proto__: null, prepareAndValidate: Mae };
      function zae(e10, t10, n10) {
        var r10 = e10.shape.length;
        F$(r10 === t10.length, function() {
          return "Error in slice".concat(r10, "D: Length of begin ").concat(t10, " must ") + "match the rank of the array (".concat(r10, ").");
        }), F$(r10 === n10.length, function() {
          return "Error in slice".concat(r10, "D: Length of size ").concat(n10, " must ") + "match the rank of the array (".concat(r10, ").");
        });
        for (var a10 = function(a11) {
          F$(t10[a11] + n10[a11] <= e10.shape[a11], function() {
            return "Error in slice".concat(r10, "D: begin[").concat(a11, "] + size[").concat(a11, "] ") + "(".concat(t10[a11] + n10[a11], ") would overflow input.shape[").concat(a11, "] (").concat(e10.shape[a11], ")");
          });
        }, i10 = 0; i10 < r10; ++i10) a10(i10);
      }
      function Pae(e10, t10, n10) {
        for (var r10 = [], a10 = 0; a10 < e10.length; a10++) r10[a10] = Math.ceil((t10[a10] - e10[a10]) / n10[a10]);
        return r10;
      }
      function Bae(e10, t10, n10, r10) {
        for (var a10 = T(e10), i10 = a10.length; i10 < r10.length; i10++) a10.push(1);
        for (var o10 = 0; o10 < n10; o10++) 0 === o10 ? a10[t10] = 1 : (a10.splice(t10, 0, 1), a10.pop());
        return a10;
      }
      function Wae(e10, t10, n10) {
        return n10 <= e10 ? n10 : n10 - (t10 - 1);
      }
      function Uae(e10, t10) {
        for (var n10 = [], r10 = 0; r10 < e10; r10++) n10.push(t10 + r10);
        return n10;
      }
      function Vae(e10, t10, n10, r10, a10) {
        for (var i10 = T(a10), o10 = Uae(n10, t10), s10 = 0; s10 < i10.length; s10++) if (o10.indexOf(s10) > -1) i10[s10] = 0;
        else {
          var u10 = Wae(t10, n10, s10), c10 = r10[u10];
          e10 & 1 << u10 && (c10 = 0), i10[s10] = c10;
        }
        return i10;
      }
      function Gae(e10, t10, n10, r10, a10) {
        for (var i10 = T(a10), o10 = Uae(n10, t10), s10 = 0; s10 < i10.length; s10++) if (o10.indexOf(s10) > -1) i10[s10] = Number.MAX_SAFE_INTEGER;
        else {
          var u10 = Wae(t10, n10, s10), c10 = r10[u10];
          e10 & 1 << u10 && (c10 = Number.MAX_SAFE_INTEGER), i10[s10] = c10;
        }
        for (var l10 = 0; l10 < i10.length; l10++) {
          var h10 = a10[l10];
          i10[l10] < 0 && (i10[l10] += h10), i10[l10] = A$(0, i10[l10], a10[l10]);
        }
        return i10;
      }
      function jae(e10, t10, n10) {
        var r10 = e10[t10];
        return (n10 & 1 << t10 || null == r10) && (r10 = 1), r10;
      }
      function Hae(e10, t10, n10, r10, a10, i10) {
        var o10 = t10[a10], s10 = n10[a10] || 1;
        (e10 & 1 << a10 || i10 & 1 << a10 || null == o10) && (o10 = s10 > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
        var u10 = r10[a10];
        return o10 < 0 && (o10 += u10), o10 = A$(0, o10, u10 - 1);
      }
      function qae(e10, t10, n10, r10, a10, i10) {
        var o10 = t10[a10], s10 = n10[a10] || 1;
        (e10 & 1 << a10 || i10 & 1 << a10 || null == o10) && (o10 = s10 > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
        var u10 = r10[a10];
        return o10 < 0 && (o10 += u10), o10 = s10 > 0 ? A$(0, o10, u10) : A$(-1, o10, u10 - 1);
      }
      function Kae(e10, t10, n10) {
        for (var r10 = n10.length, a10 = 0; a10 < n10.length; a10++) if (n10[a10] > 1) {
          r10 = a10;
          break;
        }
        for (var i10 = r10 + 1; i10 < n10.length; i10++) if (t10[i10] > 0 || n10[i10] !== e10[i10]) return false;
        return true;
      }
      function Xae(e10, t10) {
        for (var n10 = e10.length > 0 ? e10[e10.length - 1] : 1, r10 = 0; r10 < e10.length - 1; r10++) n10 += e10[r10] * t10[r10];
        return n10;
      }
      function Yae(e10, t10, n10) {
        var r10, a10, i10 = e10.shape.length;
        return (r10 = "number" == typeof t10 ? [t10].concat(T(new Array(i10 - 1).fill(0))) : t10.length < i10 ? t10.concat(new Array(i10 - t10.length).fill(0)) : t10.slice()).forEach(function(e11) {
          F$(-1 !== e11, function() {
            return "slice() does not support negative begin indexing.";
          });
        }), a10 = (a10 = null == n10 ? new Array(i10).fill(-1) : "number" == typeof n10 ? [n10].concat(T(new Array(i10 - 1).fill(-1))) : n10.length < i10 ? n10.concat(new Array(i10 - n10.length).fill(-1)) : n10).map(function(t11, n11) {
          return t11 >= 0 ? t11 : (F$(-1 === t11, function() {
            return "Negative size values should be exactly -1 but got " + "".concat(t11, " for the slice() size at index ").concat(n11, ".");
          }), e10.shape[n11] - r10[n11]);
        }), [r10, a10];
      }
      function Jae(e10, t10, n10, r10, a10, i10, o10, s10, u10) {
        var c10;
        if (null == r10 ? (c10 = new Array(t10.length)).fill(1) : c10 = r10, null != o10 && 0 != (o10 & o10 - 1)) throw new Error("Multiple ellipses in slice is not allowed.");
        for (var l10 = false, h10 = { dims: c10.length, numAddAxisAfterEllipsis: 0, begin: t10.slice(), end: n10.slice(), strides: c10.slice(), beginMask: a10, endMask: i10, ellipsisMask: o10, newAxisMask: s10, shrinkAxisMask: u10 }, p10 = 0; p10 < h10.dims; p10++) l10 && 0 != (1 << p10 & s10) && h10.numAddAxisAfterEllipsis++, 1 << p10 & o10 && (l10 = true);
        l10 || (h10.ellipsisMask |= 1 << h10.dims, h10.dims++);
        var f10 = { dims: e10.length, beginMask: 0, endMask: 0, beginValid: false, endValid: false };
        !function(e11, t11) {
          t11.beginMask = 0, t11.endMask = 0, t11.shrinkAxisMask = 0;
          var n11 = 0;
          t11.beginValid = null != e11.begin, t11.endValid = null != e11.end, t11.begin = new Array(t11.dims), t11.end = new Array(t11.dims), t11.strides = new Array(t11.dims), t11.finalShapeGatherIndices = [], t11.finalShapeGatherIndicesSparse = [], t11.inputShapeGatherIndicesSparse = new Array(t11.dims);
          for (var r11 = 0; r11 < e11.dims; r11++) if (1 << r11 & e11.ellipsisMask) for (var a11 = Math.min(t11.dims - (e11.dims - r11) + 1 + e11.numAddAxisAfterEllipsis, t11.dims); n11 < a11; n11++) t11.begin[n11] = 0, t11.end[n11] = 0, t11.strides[n11] = 1, t11.beginMask |= 1 << n11, t11.endMask |= 1 << n11, t11.finalShapeGatherIndices.push(n11), t11.finalShapeGatherIndicesSparse.push(-1), t11.inputShapeGatherIndicesSparse[n11] = r11;
          else if (1 << r11 & e11.newAxisMask) t11.finalShapeGatherIndices.push(-2), t11.finalShapeGatherIndicesSparse.push(-1);
          else {
            if (n11 === t11.begin.length) throw Error("Index out of range using input dim ".concat(n11, "; input ") + "has only ".concat(t11.dims, " dims, ").concat(t11.begin.length, "."));
            null != e11.begin && (t11.begin[n11] = e11.begin[r11]), null != e11.end && (t11.end[n11] = e11.end[r11]), t11.strides[n11] = e11.strides[r11], e11.beginMask & 1 << r11 && (t11.beginMask |= 1 << n11), e11.endMask & 1 << r11 && (t11.endMask |= 1 << n11), e11.shrinkAxisMask & 1 << r11 ? (t11.finalShapeGatherIndices.push(-1), t11.finalShapeGatherIndicesSparse.push(-1), t11.shrinkAxisMask |= 1 << n11) : (t11.finalShapeGatherIndices.push(n11), t11.finalShapeGatherIndicesSparse.push(r11)), t11.inputShapeGatherIndicesSparse[n11] = r11, n11++;
          }
        }(h10, f10);
        for (var d10 = true, v10 = true, m10 = true, g10 = [], y10 = [], b10 = 0; b10 < e10.length; ++b10) {
          if (0 === f10.strides[b10]) throw Error("strides[".concat(b10, "] must be non-zero"));
          var x10 = !!(f10.shrinkAxisMask & 1 << b10), k10 = e10[b10];
          if (-1 !== k10) {
            var w10 = [f10.beginMask & 1 << b10, f10.endMask & 1 << b10], I10 = [f10.strides[b10] > 0 ? 0 : -1, f10.strides[b10] > 0 ? k10 : k10 - 1];
            if (x10 && f10.strides[b10] <= 0) throw Error("only stride 1 allowed on non-range indexing.");
            m10 = m10 && 1 === f10.strides[b10];
            var N10 = !!(f10.beginMask & 1 << b10 && f10.endMask & 1 << b10);
            if (f10.beginValid && f10.endValid) {
              if (x10) {
                var S10 = f10.begin[b10] < 0 ? k10 + f10.begin[b10] : f10.begin[b10];
                if (f10.begin[b10] = S10, f10.end[b10] = f10.begin[b10] + 1, S10 < 0 || S10 >= k10) throw Error("slice index ".concat(f10.begin[b10], " of dimension ").concat(b10, " out of bounds."));
              } else f10.begin[b10] = Zae(f10.begin[b10], 0, f10.strides[b10], k10, w10, I10), f10.end[b10] = Zae(f10.end[b10], 1, f10.strides[b10], k10, w10, I10);
              var T10 = 1 === f10.strides[b10] && 0 === f10.begin[b10] && f10.end[b10] === k10;
              d10 = d10 && T10, v10 = v10 && (0 === b10 && 1 === f10.strides[b10] || T10);
            } else d10 = d10 && 1 === f10.strides[b10] && N10, v10 = v10 && (0 === b10 && 1 === f10.strides[b10] || N10);
            var E10 = void 0, C10 = false;
            if (f10.beginValid && f10.endValid ? (E10 = f10.end[b10] - f10.begin[b10], C10 = true) : x10 ? (E10 = 1, C10 = true) : N10 && k10 >= 0 && (E10 = f10.strides[b10] < 0 ? -k10 : k10, C10 = true), C10) {
              var A10 = void 0;
              A10 = 0 === E10 || E10 < 0 != f10.strides[b10] < 0 ? 0 : Math.trunc(E10 / f10.strides[b10]) + (E10 % f10.strides[b10] != 0 ? 1 : 0), g10.push(A10);
            } else g10.push(-1);
          } else g10.push(x10 ? 1 : -1);
        }
        for (var R10 = 0; R10 < f10.finalShapeGatherIndices.length; ++R10) {
          var _10 = f10.finalShapeGatherIndices[R10];
          _10 >= 0 ? y10.push(g10[_10]) : -2 === _10 && y10.push(1);
        }
        var O10 = y10.filter(function(e11, t11) {
          return -2 !== f10.finalShapeGatherIndices[t11];
        });
        return { finalShapeSparse: O10, finalShape: y10, isIdentity: d10, sliceDim0: v10, isSimpleSlice: m10, begin: f10.begin, end: f10.end, strides: f10.strides };
      }
      function Zae(e10, t10, n10, r10, a10, i10) {
        if (a10[t10]) return n10 > 0 ? i10[t10] : i10[t10 + 1 & 1];
        var o10 = e10 < 0 ? r10 + e10 : e10;
        return o10 < i10[0] ? i10[0] : o10 > i10[1] ? i10[1] : o10;
      }
      var Qae, $ae = { __proto__: null, assertParamsValid: zae, computeFlatOffset: Xae, computeOutShape: Pae, getNormalizedAxes: function(e10, t10, n10, r10, a10, i10, o10, s10, u10) {
        var c10 = e10.length, l10 = new Array(c10), h10 = new Array(c10), p10 = new Array(c10);
        if (t10.length && n10 > 0) {
          var f10 = t10[0], d10 = n10 + 1;
          l10 = Vae(o10, f10, d10, r10, e10), h10 = Gae(s10, f10, d10, a10, e10), p10 = Bae(i10, f10, d10, e10);
        } else for (var v10 = 0; v10 < c10; v10++) l10[v10] = Hae(o10, r10, i10, e10, v10, u10), h10[v10] = qae(s10, a10, i10, e10, v10, u10), p10[v10] = jae(i10, v10, u10);
        return { begin: l10, end: h10, strides: p10 };
      }, isSliceContinous: Kae, maskToAxes: function(e10) {
        for (var t10 = [], n10 = 0; e10 > 0; ) 1 & e10 && t10.push(n10), e10 /= 2, n10++;
        return t10;
      }, parseSliceParams: Yae, sliceInfo: Jae, startForAxis: Hae, startIndicesWithElidedDims: Vae, stopForAxis: qae, stopIndicesWithElidedDims: Gae, stridesForAxis: jae, stridesWithElidedDims: Bae }, eie = "4.17.0", tie = function() {
        function e10() {
          l(this, e10);
        }
        return p(e10, null, [{ key: "sgd", value: function(e11) {
          return new eae(e11);
        } }, { key: "momentum", value: function(e11, t10) {
          var n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          return new tae(e11, t10, n10);
        } }, { key: "rmsprop", value: function(e11) {
          var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.9, n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, a10 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
          return new nae(e11, t10, n10, r10, a10);
        } }, { key: "adam", value: function() {
          var e11 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1e-3, t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.9, n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0.999, r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
          return new Qre(e11, t10, n10, r10);
        } }, { key: "adadelta", value: function() {
          var e11 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1e-3, t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.95, n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
          return new Jre(e11, t10, n10);
        } }, { key: "adamax", value: function() {
          var e11 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 2e-3, t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.9, n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0.999, r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
          return new $re(e11, t10, n10, r10, a10);
        } }, { key: "adagrad", value: function(e11) {
          var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.1;
          return new Zre(e11, t10);
        } }]), e10;
      }(), nie = tie, rie = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : function(e10) {
        return e10();
      };
      function aie() {
        return new Promise(function(e10) {
          return rie(function() {
            return e10();
          });
        });
      }
      function iie(e10, t10) {
        var n10 = e10[0].length;
        e10.forEach(function(e11, t11) {
          F$(e11.length === n10, function() {
            return "Error in concat".concat(n10, "D: rank of tensors[").concat(t11, "] must be the same ") + "as the rank of the rest (".concat(n10, ")");
          });
        }), F$(t10 >= 0 && t10 < n10, function() {
          return "Error in concat".concat(n10, "D: axis must be between 0 and ").concat(n10 - 1, ".");
        });
        var r10 = e10[0];
        e10.forEach(function(e11, a10) {
          for (var i10 = 0; i10 < n10; i10++) F$(i10 === t10 || e11[i10] === r10[i10], function() {
            return "Error in concat".concat(n10, "D: Shape of tensors[").concat(a10, "] (").concat(e11, ") ") + "does not match the shape of the rest (".concat(r10, ") ") + "along the non-concatenated axis ".concat(a10, ".");
          });
        });
      }
      function oie(e10, t10) {
        for (var n10 = e10[0].slice(), r10 = 1; r10 < e10.length; r10++) n10[t10] += e10[r10][t10];
        return n10;
      }
      function sie(e10, t10, n10) {
        var r10 = new Array();
        if (null == n10 && null == t10) return r10;
        if (null == t10) for (; r10.length < e10 + n10.length; ) r10.push(-1);
        else r10 = t10.slice();
        if (null == n10) return r10;
        if (e10 + n10.length !== r10.length) throw new Error("rt input.shape and shape=".concat(t10, " are incompatible: rt input.rank = ").concat(e10 + n10.length, ", but shape.rank = ").concat(r10.length));
        for (var a10 = 1; a10 < n10.length; ++a10) {
          var i10 = n10[a10], o10 = r10[r10.length - n10.length + a10], s10 = r10[o10];
          if (i10 >= 0) if (s10 >= 0) {
            if (s10 !== i10) throw new Error("rt input.shape and shape=".concat(t10, " are incompatible: rt input.shape[").concat(a10 + e10, "] = ").concat(i10, " but shape[").concat(a10 + e10, "] = ").concat(s10));
          } else r10[o10] = i10;
        }
        return r10;
      }
      function uie(e10) {
        var t10, n10 = { FIRST_DIM_SIZE: Qae.FIRST_DIM_SIZE, VALUE_ROWIDS: Qae.VALUE_ROWIDS, ROW_LENGTHS: Qae.ROW_LENGTHS, ROW_SPLITS: Qae.ROW_SPLITS, ROW_LIMITS: Qae.ROW_LIMITS, ROW_STARTS: Qae.ROW_STARTS }, r10 = [], a10 = O(e10);
        try {
          for (a10.s(); !(t10 = a10.n()).done; ) {
            var i10 = t10.value;
            if (!(i10 in n10)) break;
            r10.push(n10[i10]);
          }
        } catch (e11) {
          a10.e(e11);
        } finally {
          a10.f();
        }
        return r10;
      }
      function cie(e10) {
        return 0 === e10.length ? 0 : e10[0] === Qae.FIRST_DIM_SIZE ? e10.length - 1 : e10.length;
      }
      function lie(e10, t10) {
        if (null != e10 && null != t10) {
          var n10 = e10.length, r10 = t10.length;
          if (n10 >= r10) throw new Error("defaultValue.shape=".concat(e10, " and ragged tensor flatValues.shape=").concat(t10, ", are incompatible: defaultValue.rank = ").concat(n10, " must be less than ragged tensor input flatValues.rank = ").concat(r10, ")"));
          for (var a10 = 0; a10 < Math.min(n10, r10 - 1); ++a10) {
            var i10 = e10[a10], o10 = t10[a10 + 1];
            if (i10 >= 0 && o10 >= 0 && 1 !== i10 && i10 !== o10) throw new Error("defaultValue.shape=".concat(e10, ", and ragged tensor input flatValues.shape=").concat(t10, " are incompatible: defaultValue.shape[").concat(a10 - e10.length, "] = ").concat(i10, " but ragged tensor input.flatValues.shape[").concat(a10 - e10.length, "] = ").concat(o10));
          }
        }
      }
      !function(e10) {
        e10[e10.FIRST_DIM_SIZE = 0] = "FIRST_DIM_SIZE", e10[e10.VALUE_ROWIDS = 1] = "VALUE_ROWIDS", e10[e10.ROW_LENGTHS = 2] = "ROW_LENGTHS", e10[e10.ROW_SPLITS = 3] = "ROW_SPLITS", e10[e10.ROW_LIMITS = 4] = "ROW_LIMITS", e10[e10.ROW_STARTS = 5] = "ROW_STARTS";
      }(Qae || (Qae = {}));
      function hie(e10) {
        return e10 <= 30 ? e10 : a0(e10, Math.floor(Math.sqrt(e10)));
      }
      function pie(e10, t10, n10) {
        return [n10 * ("number" == typeof e10 ? e10 : e10[0]), t10 * ("number" == typeof e10 ? e10 : e10[1])];
      }
      function fie(e10, t10, n10) {
        var r10 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], a10 = [];
        if (r10) (a10 = a10.concat(t10.slice(0))).push(e10[0] / n10), a10 = a10.concat(e10.slice(1));
        else {
          a10 = a10.concat(e10[0]);
          for (var i10 = t10.length, o10 = 0; o10 < i10; ++o10) a10 = a10.concat([e10[o10 + 1] / t10[o10], t10[o10]]);
          a10 = a10.concat(e10.slice(i10 + 1));
        }
        return a10;
      }
      function die(e10, t10) {
        var n10 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r10 = [];
        if (n10) {
          r10.push(t10);
          for (var a10 = t10 + 1; a10 < e10; ++a10) a10 <= 2 * t10 ? (r10.push(a10), r10.push(a10 - (t10 + 1))) : r10.push(a10);
        } else {
          for (var i10 = [], o10 = [], s10 = 1; s10 < e10; ++s10) s10 >= 2 * t10 + 1 || s10 % 2 == 1 ? o10.push(s10) : i10.push(s10);
          r10.push.apply(r10, i10), r10.push(0), r10.push.apply(r10, o10);
        }
        return r10;
      }
      function vie(e10, t10, n10) {
        var r10 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], a10 = [];
        r10 ? a10.push(e10[0] / n10) : a10.push(e10[0] * n10);
        for (var i10 = 1; i10 < e10.length; ++i10) i10 <= t10.length ? r10 ? a10.push(t10[i10 - 1] * e10[i10]) : a10.push(e10[i10] / t10[i10 - 1]) : a10.push(e10[i10]);
        return a10;
      }
      function mie(e10, t10) {
        for (var n10 = [0], r10 = 0; r10 < t10; ++r10) n10.push(e10[r10][0]);
        return n10;
      }
      function gie(e10, t10, n10) {
        for (var r10 = e10.slice(0, 1), a10 = 0; a10 < n10; ++a10) r10.push(e10[a10 + 1] - t10[a10][0] - t10[a10][1]);
        return r10;
      }
      var yie = 1.7580993408473768, bie = 1.0507009873554805, xie = 0.3275911, kie = 0.254829592, wie = -0.284496736, Iie = 1.421413741, Nie = -1.453152027, Sie = 1.061405429;
      function Tie(e10, t10) {
        if (e10.length !== t10.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + "".concat(e10.length, ", imag: ").concat(t10.length, "."));
        for (var n10 = new Float32Array(2 * e10.length), r10 = 0; r10 < n10.length; r10 += 2) n10[r10] = e10[r10 / 2], n10[r10 + 1] = t10[r10 / 2];
        return n10;
      }
      function Eie(e10) {
        for (var t10 = new Float32Array(e10.length / 2), n10 = new Float32Array(e10.length / 2), r10 = 0; r10 < e10.length; r10 += 2) t10[r10 / 2] = e10[r10], n10[r10 / 2] = e10[r10 + 1];
        return { real: t10, imag: n10 };
      }
      function Cie(e10) {
        for (var t10 = Math.ceil(e10.length / 4), n10 = new Float32Array(t10), r10 = new Float32Array(t10), a10 = 0; a10 < e10.length; a10 += 4) n10[Math.floor(a10 / 4)] = e10[a10], r10[Math.floor(a10 / 4)] = e10[a10 + 1];
        return { real: n10, imag: r10 };
      }
      function Aie(e10) {
        for (var t10 = Math.floor(e10.length / 4), n10 = new Float32Array(t10), r10 = new Float32Array(t10), a10 = 2; a10 < e10.length; a10 += 4) n10[Math.floor(a10 / 4)] = e10[a10], r10[Math.floor(a10 / 4)] = e10[a10 + 1];
        return { real: n10, imag: r10 };
      }
      function Rie(e10, t10) {
        return { real: e10[2 * t10], imag: e10[2 * t10 + 1] };
      }
      function _ie(e10, t10, n10, r10) {
        e10[2 * r10] = t10, e10[2 * r10 + 1] = n10;
      }
      function Oie(e10, t10) {
        for (var n10 = new Float32Array(e10 / 2), r10 = new Float32Array(e10 / 2), a10 = 0; a10 < Math.ceil(e10 / 2); a10++) {
          var i10 = (t10 ? 2 : -2) * Math.PI * (a10 / e10);
          n10[a10] = Math.cos(i10), r10[a10] = Math.sin(i10);
        }
        return { real: n10, imag: r10 };
      }
      function Fie(e10, t10, n10) {
        var r10 = (n10 ? 2 : -2) * Math.PI * (e10 / t10);
        return { real: Math.cos(r10), imag: Math.sin(r10) };
      }
      var Die = "->", Mie = /->/g;
      function Lie(e10, t10) {
        var n10 = ((e10 = e10.replace(/\s/g, "")).length - e10.replace(Mie, "").length) / Die.length;
        if (n10 < 1) throw new Error("Equations without an arrow are not supported.");
        if (n10 > 1) throw new Error('Equation must contain exactly one arrow ("'.concat(Die, '").'));
        var r10 = S(e10.split(Die), 2), a10 = r10[0], i10 = r10[1];
        F$(-1 === a10.indexOf("..."), function() {
          return 'The ellipsis notation ("'.concat("...", '") is not supported yet.');
        });
        var o10 = a10.split(","), s10 = o10.length;
        if (t10 !== s10) throw new Error("Expected ".concat(s10, " input tensors, received ").concat(t10));
        if (s10 > 2) throw new Error("Support for more than 2 input tensors is not implemented yet.");
        for (var u10 = [], c10 = function() {
          var e11 = i10[l10];
          if (!o10.some(function(t11) {
            return -1 !== t11.indexOf(e11);
          })) throw new Error("Output subscripts contain the label ".concat(e11, " ") + "not present in the input subscripts.");
          -1 === u10.indexOf(e11) && u10.push(e11);
        }, l10 = 0; l10 < i10.length; ++l10) c10();
        for (var h10 = 0; h10 < a10.length; ++h10) {
          var p10 = a10[h10];
          -1 === u10.indexOf(p10) && "," !== p10 && u10.push(p10);
        }
        for (var f10 = new Array(o10.length), d10 = 0; d10 < s10; ++d10) {
          if (new Set(o10[d10].split("")).size !== o10[d10].length) throw new Error("Found duplicate axes in input component ".concat(o10[d10], ". ") + "Support for duplicate axes in input is not implemented yet.");
          f10[d10] = [];
          for (var v10 = 0; v10 < o10[d10].length; ++v10) f10[d10].push(u10.indexOf(o10[d10][v10]));
        }
        for (var m10 = u10.length, g10 = [], y10 = i10.length; y10 < m10; ++y10) g10.push(y10);
        return { allDims: u10, summedDims: g10, idDims: f10 };
      }
      function zie(e10, t10) {
        var n10 = new Array(e10);
        n10.fill(-1);
        for (var r10 = 0; r10 < t10.length; ++r10) n10[t10[r10]] = r10;
        for (var a10 = [], i10 = 0; i10 < e10; ++i10) -1 === n10[i10] && a10.push(i10);
        return { permutationIndices: n10 = n10.filter(function(e11) {
          return -1 !== e11;
        }), expandDims: a10 };
      }
      function Pie(e10, t10, n10) {
        for (var r10 = new Array(e10), a10 = function(e11) {
          for (var a11 = n10[e11].shape, i11 = function(n11) {
            void 0 === r10[t10[e11][n11]] ? r10[t10[e11][n11]] = a11[n11] : F$(r10[t10[e11][n11]] === a11[n11], function() {
              return "Expected dimension ".concat(r10[t10[e11][n11]], " at axis ").concat(n11, " ") + "of input shaped ".concat(JSON.stringify(a11), ", ") + "but got dimension ".concat(a11[n11]);
            });
          }, o10 = 0; o10 < t10[e11].length; ++o10) i11(o10);
        }, i10 = 0; i10 < n10.length; ++i10) a10(i10);
      }
      function Bie(e10, t10) {
        var n10, r10 = e10, a10 = [];
        0 === e10.length && r10.push(-1), n10 = e10.length + 1;
        for (var i10 = 0; i10 < n10; ++i10) a10.push([]);
        for (var o10 = [], s10 = 0; s10 < r10.length; ++s10) {
          var u10, c10 = O(Uie(t10, r10[s10]));
          try {
            for (c10.s(); !(u10 = c10.n()).done; ) {
              var l10 = u10.value;
              -1 === o10.indexOf(l10) && (a10[s10].push(l10), o10.push(l10));
            }
          } catch (e11) {
            c10.e(e11);
          } finally {
            c10.f();
          }
        }
        return { path: r10, steps: a10 };
      }
      function Wie(e10) {
        return e10.every(function(e11, t10) {
          return e11 === t10;
        });
      }
      function Uie(e10, t10) {
        for (var n10 = [], r10 = 0; r10 < e10.length; ++r10) 0 !== e10[r10].length && -1 === e10[r10].indexOf(t10) && -1 !== t10 || n10.push(r10);
        return n10;
      }
      function Vie(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r10 = [];
        if ("number" == typeof t10) F$(e10.shape[n10] % t10 == 0, function() {
          return "Number of splits must evenly divide the axis.";
        }), r10 = new Array(t10).fill(e10.shape[n10] / t10);
        else {
          var a10 = t10.reduce(function(e11, t11) {
            return -1 === t11 && (e11 += 1), e11;
          }, 0);
          F$(a10 <= 1, function() {
            return "There should be only one negative value in split array.";
          });
          var i10 = t10.indexOf(-1);
          if (-1 !== i10) {
            var o10 = t10.reduce(function(e11, t11) {
              return t11 > 0 ? e11 + t11 : e11;
            });
            t10[i10] = e10.shape[n10] - o10;
          }
          F$(e10.shape[n10] === t10.reduce(function(e11, t11) {
            return e11 + t11;
          }), function() {
            return "The sum of sizes must match the size of the axis dimension.";
          }), r10 = t10;
        }
        return r10;
      }
      function Gie(e10) {
        return "Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e10);
      }
      function jie(e10, t10) {
        return "indices(".concat(e10, ", 0) is invalid: ").concat(t10, " < 0");
      }
      function Hie(e10, t10, n10) {
        return "indices(".concat(e10, ", 0) is invalid: ").concat(t10, " >= ").concat(n10);
      }
      function qie(e10, t10) {
        return "only one output dimension may be -1, not both ".concat(e10, " and ").concat(t10);
      }
      function Kie(e10, t10) {
        return "size ".concat(e10, " must be non-negative, not ").concat(t10);
      }
      function Xie() {
        return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
      }
      function Yie(e10, t10) {
        var n10 = L$(e10), r10 = L$(t10);
        return "Input to reshape is a SparseTensor with ".concat(n10, "\n  dense values, but the requested shape requires a multiple of ").concat(r10, ". inputShape=").concat(e10, " outputShape= ").concat(t10);
      }
      function Jie(e10, t10) {
        var n10 = L$(e10), r10 = L$(t10);
        return "Input to reshape is a tensor with ".concat(n10, " dense values, but the requested shape has ").concat(r10, ". inputShape=").concat(e10, " outputShape=").concat(t10);
      }
      function Zie() {
        return "segment ids must be >= 0";
      }
      function Qie() {
        return "segment ids are not increasing";
      }
      function $ie(e10, t10) {
        return "Segment id ".concat(e10, " out of range [0, ").concat(t10, "), possibly because segmentIds input is not sorted.");
      }
      function eoe(e10, t10, n10) {
        return "Bad: indices[".concat(e10, "] == ").concat(t10, " out of range [0, ").concat(n10, ")");
      }
      function toe(e10, t10) {
        var n10, r10 = false;
        for (e10 <= 30 ? (n10 = e10, r10 = true) : n10 = a0(e10, Math.floor(Math.sqrt(e10))); !r10; ) n10 > t10 || n10 === e10 ? r10 = true : n10 = a0(e10, n10 + 1);
        return n10;
      }
      function noe(e10, t10, n10) {
        for (var r10 = [], a10 = e10.length, i10 = 0; i10 < a10; i10++) i10 !== t10 ? r10.push(e10[i10]) : r10.push(n10);
        return r10;
      }
      function roe(e10, t10, n10, r10) {
        var a10 = t10.shape.length, i10 = e10.shape.length;
        if (0 !== r10 && (r10 < -a10 || r10 > a10)) throw new Error("Expect batchDims in the range of [-".concat(a10, ", ").concat(a10, "], but got ").concat(r10));
        if (r10 < 0 && (r10 += a10), r10 > i10) throw new Error("batchDims (".concat(r10, ") must be less than rank(x) (\n    ").concat(i10, ")."));
        if (n10 < r10) throw new Error("batchDims (".concat(r10, ") must be less than or equal to axis (").concat(n10, ")."));
        for (var o10 = 0; o10 < r10; ++o10) if (e10.shape[o10] !== t10.shape[o10]) throw new Error("x.shape[".concat(o10, "]: ").concat(e10.shape[o10], " should be equal to indices.shape[").concat(o10, "]: ").concat(t10.shape[o10], "."));
        for (var s10 = e10.shape[n10], u10 = [], c10 = 1, l10 = 1, h10 = 1, p10 = 0; p10 < r10; ++p10) u10.push(e10.shape[p10]), c10 *= e10.shape[p10];
        for (var f10 = r10; f10 < n10; f10++) u10.push(e10.shape[f10]), l10 *= e10.shape[f10];
        for (var d10 = r10; d10 < a10; d10++) u10.push(t10.shape[d10]);
        for (var v10 = n10 + 1; v10 < i10; v10++) u10.push(e10.shape[v10]), h10 *= e10.shape[v10];
        return { batchSize: c10, sliceSize: h10, outerSize: l10, dimSize: s10, outputShape: u10 };
      }
      function aoe(e10) {
        try {
          return e10.map(function(e11) {
            return W4(e11);
          });
        } catch (e11) {
          throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(e11));
        }
      }
      function ioe(e10) {
        return e10.map(function(e11) {
          return B4(e11);
        });
      }
      var ooe = { __proto__: null, ERF_A1: kie, ERF_A2: wie, ERF_A3: Iie, ERF_A4: Nie, ERF_A5: Sie, ERF_P: xie, PARALLELIZE_THRESHOLD: 30, get RowPartitionType() {
        return Qae;
      }, SELU_SCALE: bie, SELU_SCALEALPHA: yie, applyActivation: Sne, assertAndGetBroadcastShape: z7, assertAxesAreInnerMostDims: Q7, assertParamsConsistent: iie, assignToTypedArray: _ie, axesAreInnerMostDims: X7, calculateShapes: Jte, checkEinsumDimSizes: Pie, checkPadOnDimRoundingMode: K8, combineLocations: Y7, combineRaggedTensorToTensorShapes: sie, complexWithEvenIndex: Cie, complexWithOddIndex: Aie, computeConv2DInfo: D8, computeConv3DInfo: M8, computeDefaultPad: L8, computeDilation2DInfo: _8, computeOptimalWindowSize: hie, computeOutAndReduceShapes: J7, computeOutShape: oie, computePool2DInfo: O8, computePool3DInfo: F8, convertConv2DDataFormat: q8, decodeEinsumEquation: Lie, eitherStridesOrDilationsAreOne: j8, expandShapeToKeepDim: Z7, exponent: Fie, exponents: Oie, fromStringArrayToUint8: ioe, fromUint8ToStringArray: aoe, getAxesPermutation: $7, getBroadcastDims: M7, getComplexWithIndex: Rie, getEinsumComputePath: Bie, getEinsumPermutation: zie, getFusedBiasGradient: Nne, getFusedDyActivation: Ine, getImageCenter: pie, getInnerMostAxes: t9, getPermuted: die, getRaggedRank: cie, getReductionAxes: L7, getReshaped: fie, getReshapedPermuted: vie, getRowPartitionTypesHelper: uie, getSliceBeginCoords: mie, getSliceSize: gie, getSparseFillEmptyRowsIndicesDenseShapeMismatch: Gie, getSparseFillEmptyRowsNegativeIndexErrorMessage: jie, getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: Hie, getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: Xie, getSparseReshapeInputOutputMismatchErrorMessage: Jie, getSparseReshapeInputOutputMultipleErrorMessage: Yie, getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: qie, getSparseReshapeNegativeOutputDimErrorMessage: Kie, getSparseSegmentReductionIndicesOutOfRangeErrorMessage: eoe, getSparseSegmentReductionNegativeSegmentIdsErrorMessage: Zie, getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: Qie, getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: $ie, getUndoAxesPermutation: e9, isIdentityPermutation: Wie, log: function() {
        var e10;
        k0().getBool("IS_TEST") || k0().getBool("PROD") || (e10 = console).log.apply(e10, arguments);
      }, mergeRealAndImagArrays: Tie, prepareAndValidate: Mae, prepareSplitSize: Vie, segment_util: { __proto__: null, collectGatherOpShapeInfo: roe, computeOutShape: noe, segOpComputeOptimalWindowSize: toe }, shouldFuse: Tne, slice_util: $ae, splitRealAndImagArrays: Eie, stridesOrDilationsArePositive: H8, tupleValuesAreOne: G8, upcastType: h5, validateDefaultValueShape: lie, validateInput: Yte, validateUpdateShape: Xte, warn: z3 }, soe = { __proto__: null, nonMaxSuppressionV3Impl: qne, nonMaxSuppressionV4Impl: Kne, nonMaxSuppressionV5Impl: Xne, whereImpl: one };
      !function() {
        var e10, t10 = O(rae);
        try {
          for (t10.s(); !(e10 = t10.n()).done; ) {
            Kre(e10.value);
          }
        } catch (e11) {
          t10.e(e11);
        } finally {
          t10.f();
        }
      }();
      var uoe = { kernelName: N0, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return g8(e10, Bte(h8(n10, "float32"), -1));
        } };
      } }, coe = { kernelName: S0, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          var t11 = s9(h8(n10, "float32")), r10 = o9(P9(i9(1), t11));
          return M9(m8(e10, r10));
        } };
      } }, loe = { kernelName: T0, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          var t11 = o9(P9(s9(h8(n10, "float32")), 1));
          return m8(e10, t11);
        } };
      } }, hoe = { kernelName: E0, inputsToSave: ["a", "b"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 2), r10 = n10[0], a10 = n10[1], i10 = z7(r10.shape, a10.shape);
        return { a: function() {
          var t11 = e10, n11 = L7(r10.shape, i10);
          return n11.length > 0 && (t11 = u9(t11, n11)), X8(t11, r10.shape);
        }, b: function() {
          var t11 = e10, n11 = L7(a10.shape, i10);
          return n11.length > 0 && (t11 = u9(t11, n11)), X8(t11, a10.shape);
        } };
      } }, poe = { kernelName: C0, saveAllInputs: true, gradFunc: function(e10, t10) {
        var n10 = {};
        return t10.forEach(function(t11, r10) {
          n10[r10] = function() {
            return e10.clone();
          };
        }), n10;
      } }, foe = { kernelName: _0, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return U7(n10);
        } };
      } }, doe = { kernelName: O0, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return U7(n10);
        } };
      } }, voe = { kernelName: F0, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return m8(e10, o9(P9(i9(1), s9(h8(n10, "float32")))));
        } };
      } }, moe = { kernelName: D0, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          var t11 = o9(d8(i9(1), s9(h8(n10, "float32"))));
          return m8(e10, t11);
        } };
      } }, goe = { kernelName: z0, inputsToSave: ["a", "b"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 2), r10 = n10[0], a10 = n10[1], i10 = z7(r10.shape, a10.shape);
        return { a: function() {
          var t11 = d8(s9(r10), s9(a10)), n11 = g8(e10, m8(a10, t11)), o10 = L7(r10.shape, i10);
          return o10.length > 0 && (n11 = u9(n11, o10)), X8(n11, r10.shape);
        }, b: function() {
          var t11 = d8(s9(r10), s9(a10)), n11 = M9(g8(e10, m8(r10, t11))), o10 = L7(a10.shape, i10);
          return o10.length > 0 && (n11 = u9(n11, o10)), X8(n11, a10.shape);
        } };
      } }, yoe = { kernelName: M0, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return m8(e10, d8(s9(h8(n10, "float32")), 1));
        } };
      } }, boe = { kernelName: L0, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return m8(e10, P9(i9(1), s9(h8(n10, "float32"))));
        } };
      } };
      var xoe = B5({ avgPool3dGrad_: function(e10, t10, n10, r10, a10, i10) {
        var o10 = L5(e10, "dy", "avgPool3dGrad"), s10 = L5(t10, "input", "avgPool3dGrad"), u10 = o10, c10 = s10, l10 = false;
        4 === s10.rank && (l10 = true, u10 = X8(o10, [1, o10.shape[0], o10.shape[1], o10.shape[2], o10.shape[3]]), c10 = X8(s10, [1, s10.shape[0], s10.shape[1], s10.shape[2], s10.shape[3]])), F$(5 === u10.rank, function() {
          return "Error in avgPool3dGrad: dy must be rank 5 but got rank " + "".concat(u10.rank, ".");
        }), F$(5 === c10.rank, function() {
          return "Error in avgPool3dGrad: input must be rank 5 but got rank " + "".concat(c10.rank, ".");
        }), K8("avgPool3dGrad", a10, i10);
        var h10 = { dy: u10, input: c10 }, p10 = { filterSize: n10, strides: r10, pad: a10, dimRoundingMode: i10 }, f10 = E5.runKernel(U0, h10, p10);
        return l10 ? X8(f10, [f10.shape[1], f10.shape[2], f10.shape[3], f10.shape[4]]) : f10;
      } }), koe = { kernelName: W0, inputsToSave: ["x"], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 1)[0], a10 = n10.filterSize, i10 = n10.strides, o10 = n10.pad, s10 = n10.dimRoundingMode;
        return { x: function() {
          return xoe(e10, r10, a10, i10, o10, s10);
        } };
      } };
      var woe = B5({ avgPoolGrad_: function(e10, t10, n10, r10, a10) {
        var i10 = L5(e10, "dy", "avgPoolGrad"), o10 = L5(t10, "input", "avgPoolGrad");
        F$(o10.rank === i10.rank, function() {
          return "Rank of input (".concat(o10.rank, ") does not match rank of dy (").concat(i10.rank, ")");
        });
        var s10 = o10, u10 = i10, c10 = false;
        3 === o10.rank && (c10 = true, s10 = X8(o10, [1, o10.shape[0], o10.shape[1], o10.shape[2]]), u10 = X8(i10, [1, i10.shape[0], i10.shape[1], i10.shape[2]])), F$(4 === u10.rank, function() {
          return "Error in avgPoolGrad: dy must be rank 4 but got rank " + "".concat(u10.rank, ".");
        }), F$(4 === s10.rank, function() {
          return "Error in avgPoolGrad: input must be rank 4 but got rank " + "".concat(s10.rank, ".");
        });
        var l10 = { dy: u10, input: s10 }, h10 = { filterSize: n10, strides: r10, pad: a10 }, p10 = E5.runKernel(B0, l10, h10);
        return c10 ? X8(p10, [p10.shape[1], p10.shape[2], p10.shape[3]]) : p10;
      } }), Ioe = { kernelName: P0, inputsToSave: ["x"], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 1)[0], a10 = n10.filterSize, i10 = n10.strides, o10 = n10.pad;
        return { x: function() {
          return woe(e10, r10, a10, i10, o10);
        } };
      } }, Noe = { kernelName: V0, inputsToSave: ["a", "b"], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 2), a10 = r10[0], i10 = r10[1], o10 = n10.transposeA, s10 = n10.transposeB;
        return o10 || s10 ? !o10 && s10 ? { a: function() {
          return Q8(e10, i10, false, false);
        }, b: function() {
          return Q8(e10, a10, true, false);
        } } : o10 && !s10 ? { a: function() {
          return Q8(i10, e10, false, true);
        }, b: function() {
          return Q8(a10, e10, false, false);
        } } : { a: function() {
          return Q8(i10, e10, true, true);
        }, b: function() {
          return Q8(e10, a10, true, true);
        } } : { a: function() {
          return Q8(e10, i10, false, true);
        }, b: function() {
          return Q8(a10, e10, true, false);
        } };
      } }, Soe = { kernelName: G0, gradFunc: function(e10, t10, n10) {
        var r10 = n10.blockShape, a10 = n10.crops;
        return { x: function() {
          return gee(e10, r10, a10);
        } };
      } }, Toe = { kernelName: q0, gradFunc: function(e10, t10, n10) {
        for (var r10 = n10, a10 = r10.inputShape, i10 = r10.shape, o10 = Array.from(i10), s10 = a10.length - 1; s10 >= 0; s10--) if (a10[s10] === i10[s10]) o10[s10] = 1;
        else if (1 !== a10[s10]) throw new Error("broadcastTo(): [".concat(a10, "] cannot be broadcast to [").concat(i10, "]."));
        for (var u10 = [], c10 = 0; c10 < o10.length; c10++) o10[c10] > 1 && u10.push(c10);
        return { x: function() {
          return u9(e10, u10, true);
        } };
      } }, Eoe = { kernelName: X0, gradFunc: function(e10) {
        return { x: function() {
          return e10.clone();
        } };
      } }, Coe = { kernelName: Y0, gradFunc: function(e10) {
        return { x: function() {
          return U7(e10);
        } };
      } }, Aoe = { kernelName: J0, inputsToSave: ["x"], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 1)[0], a10 = n10.clipValueMin, i10 = n10.clipValueMax;
        return { x: function() {
          return W7(U9(x9(r10, a10), E9(r10, i10)), e10, U7(e10));
        } };
      } }, Roe = { kernelName: Q0, inputsToSave: ["x"], gradFunc: uoe.gradFunc }, _oe = { kernelName: $0, saveAllInputs: true, gradFunc: function(e10, t10, n10) {
        var r10 = t10.map(function(e11) {
          return e11.shape;
        }), a10 = j$(n10.axis, t10[0].shape)[0], i10 = r10.map(function(e11) {
          return e11[a10];
        });
        return Dte(e10, i10, a10).map(function(e11) {
          return function() {
            return e11;
          };
        });
      } }, Ooe = { kernelName: e1, inputsToSave: ["x", "filter"], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 2), a10 = r10[0], i10 = r10[1], o10 = n10.dilations, s10 = n10.strides, u10 = n10.pad, c10 = n10.dataFormat;
        return F$(G8(o10), function() {
          return "Error in gradient of conv2D: dilation rates greater than 1 " + "are not yet supported in gradients. Got dilations '".concat(o10, "'");
        }), { x: function() {
          return k7(a10.shape, e10, i10, s10, u10, c10);
        }, filter: function() {
          return wne(a10, e10, i10.shape, s10, u10, c10);
        } };
      } }, Foe = { kernelName: n1, inputsToSave: ["dy", "filter"], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 2), a10 = r10[0], i10 = r10[1], o10 = n10.strides, s10 = n10.pad, u10 = n10.dataFormat, c10 = n10.dimRoundingMode;
        return { dy: function() {
          return b7(e10, i10, o10, s10, u10, 1, c10);
        }, filter: function() {
          return wne(e10, a10, i10.shape, o10, s10, u10, c10);
        } };
      } };
      var Doe = B5({ conv3DBackpropFilter_: function(e10, t10, n10, r10, a10) {
        var i10 = e10;
        4 === e10.rank && (i10 = X8(e10, [1, e10.shape[0], e10.shape[1], e10.shape[2], e10.shape[3]]));
        var o10 = t10;
        4 === o10.rank && (o10 = X8(t10, [1, t10.shape[0], t10.shape[1], t10.shape[2], t10.shape[3]])), F$(5 === i10.rank, function() {
          return "Error in conv3dDerFilter: input must be rank 5, but got shape " + "".concat(i10.shape, ".");
        }), F$(5 === o10.rank, function() {
          return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + "".concat(o10.shape, ".");
        }), F$(5 === n10.length, function() {
          return "Error in conv3dDerFilter: filterShape must be length 5, but got " + "".concat(n10, ".");
        }), F$(i10.shape[4] === n10[3], function() {
          return "Error in conv3dDerFilter: depth of input ".concat(i10.shape[4], ") must ") + "match input depth in filter (".concat(n10[3], ".");
        }), F$(o10.shape[4] === n10[4], function() {
          return "Error in conv3dDerFilter: depth of dy (".concat(o10.shape[4], ") must ") + "match output depth for filter (".concat(n10[4], ").");
        });
        var s10 = { x: i10, dy: o10 }, u10 = { strides: r10, pad: a10, filterShape: n10 };
        return E5.runKernel(a1, s10, u10);
      } }), Moe = { kernelName: r1, inputsToSave: ["x", "filter"], gradFunc: function(e10, t10, n10) {
        var r10 = n10.dilations, a10 = n10.strides, i10 = n10.pad;
        F$(G8(r10), function() {
          return "Error in gradient of conv3D: dilation rates greater than 1 are " + "not yet supported in gradients. Got dilations '".concat(r10, "'");
        });
        var o10 = S(t10, 2), s10 = o10[0], u10 = o10[1];
        return { x: function() {
          return N7(s10.shape, e10, u10, a10, i10);
        }, filter: function() {
          return Doe(s10, e10, u10.shape, a10, i10);
        } };
      } }, Loe = { kernelName: o1, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return g8(M9(Nte(h8(n10, "float32"))), e10);
        } };
      } }, zoe = { kernelName: s1, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return g8(Ste(h8(n10, "float32")), e10);
        } };
      } }, Poe = { kernelName: c1, inputsToSave: ["x"], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 1)[0], a10 = n10.axis, i10 = n10.exclusive, o10 = n10.reverse;
        return { x: function() {
          var t11 = $7([a10], r10.rank), n11 = A7(e10, a10, i10, !o10);
          return null != t11 && (n11 = hne(n11, t11)), n11;
        } };
      } }, Boe = { kernelName: f1, inputsToSave: ["x", "filter"], gradFunc: function(e10, t10, n10) {
        var r10 = n10.dilations, a10 = n10.strides, i10 = n10.pad, o10 = n10.dimRoundingMode, s10 = null == r10 ? [1, 1] : r10;
        F$(G8(s10), function() {
          return "Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations " + "'".concat(s10, "'");
        });
        var u10 = S(t10, 2), c10 = u10[0], l10 = u10[1];
        return F$(4 === c10.rank, function() {
          return "Error in gradient of depthwiseConv2dNative: input must be " + "rank 4, but got rank ".concat(c10.rank, ".");
        }), F$(4 === l10.rank, function() {
          return "Error in gradient of depthwiseConv2dNative: filter must be " + "rank 4, but got rank ".concat(l10.rank, ".");
        }), F$(c10.shape[3] === l10.shape[2], function() {
          return "Error in gradient of depthwiseConv2d: number of input " + "channels (".concat(c10.shape[3], ") must match the inChannels dimension ") + "in filter ".concat(l10.shape[2], ".");
        }), F$(j8(a10, s10), function() {
          return "Error in gradient of depthwiseConv2d: Either strides or " + "dilations must be  1. Got strides ".concat(a10, " and dilations ") + "'".concat(s10, "'.");
        }), K8("depthwiseConv2d", i10, o10), { x: function() {
          return Ane(c10.shape, e10, l10, a10, i10, s10, o10);
        }, filter: function() {
          return Cne(c10, e10, l10.shape, a10, i10, s10, o10);
        } };
      } }, Woe = { kernelName: g1, inputsToSave: ["x", "filter"], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 2), a10 = r10[0], i10 = r10[1], o10 = { x: a10, filter: i10, dy: e10 }, s10 = { x: a10, filter: i10, dy: e10 };
        return { x: function() {
          return E5.runKernel(y1, o10, n10);
        }, filter: function() {
          return E5.runKernel(b1, s10, n10);
        } };
      } }, Uoe = { kernelName: I1, outputsToSave: [true], gradFunc: function(e10, t10) {
        var n10 = { dy: e10, y: S(t10, 1)[0] };
        return { x: function() {
          return E5.runKernel(N1, n10);
        } };
      } }, Voe = { kernelName: S1, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0], r10 = g8(p9(M9(s9(n10))), 2 / Math.sqrt(Math.PI));
        return { x: function() {
          return g8(e10, r10);
        } };
      } }, Goe = { kernelName: E1, outputsToSave: [true], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return g8(e10, n10);
        } };
      } }, joe = { kernelName: C1, inputsToSave: ["input"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { input: function() {
          return X8(e10, n10.shape);
        } };
      } }, Hoe = { kernelName: A1, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return g8(e10, p9(n10));
        } };
      } }, qoe = { kernelName: F1, gradFunc: function(e10) {
        return { x: function() {
          return U7(e10);
        } };
      } }, Koe = { kernelName: D1, inputsToSave: ["a", "b"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 2), r10 = n10[0], a10 = n10[1], i10 = z7(r10.shape, a10.shape);
        return { a: function() {
          var t11 = m8(e10, h8(a10, "float32")), n11 = L7(r10.shape, i10);
          return n11.length > 0 ? X8(u9(t11, n11), r10.shape) : t11;
        }, b: function() {
          var t11 = g8(e10, h8(r10, "float32")), n11 = L7(a10.shape, i10);
          n11.length > 0 && (t11 = X8(u9(t11, n11), a10.shape));
          var o10 = s9(a10);
          return M9(m8(t11, h8(o10, "float32")));
        } };
      } }, Xoe = { kernelName: M1, inputsToSave: ["x", "mean", "variance", "scale"], gradFunc: function(e10, t10, n10) {
        var r10 = n10.varianceEpsilon, a10 = S(t10, 4), i10 = a10[0], o10 = a10[1], s10 = a10[2], u10 = a10[3], c10 = null == u10 ? i9(1) : u10, l10 = L7(o10.shape, i10.shape), h10 = [];
        if (1 === o10.rank) {
          for (var p10 = 0; p10 < i10.shape.length - 1; ++p10) h10.push(i10.shape[p10]);
          h10.push(1);
        }
        var f10 = P9(i10, o10), d10 = g8(e10, c10), v10 = yte(d8(s10, i9(r10))), m10 = g8(g8(g8(v10, v10), v10), i9(-0.5));
        return { x: function() {
          return 1 === o10.rank ? X8(g8(g8(e10, v9(X8(v10, [1, 1, 1, o10.shape[0]]), h10)), c10), i10.shape) : X8(g8(g8(e10, v10), c10), i10.shape);
        }, mean: function() {
          var e11 = g8(g8(v10, i9(-1)), d10);
          return 1 === o10.rank && (e11 = u9(e11, l10)), X8(e11, o10.shape);
        }, variance: function() {
          var e11 = g8(g8(m10, f10), d10);
          return 1 === o10.rank && (e11 = u9(e11, l10)), X8(e11, o10.shape);
        }, scale: function() {
          var t11 = g8(f10, v10), n11 = g8(e10, t11);
          return 1 === o10.rank && (n11 = u9(n11, l10)), X8(n11, o10.shape);
        }, offset: function() {
          var t11 = e10;
          return 1 === o10.rank && (t11 = u9(t11, l10)), X8(t11, o10.shape);
        } };
      } }, Yoe = { kernelName: L1, inputsToSave: ["x", "indices"], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 2), a10 = r10[0], i10 = r10[1], o10 = n10.axis, s10 = n10.batchDims, u10 = j$(o10, a10.shape)[0], c10 = function(e11, t11, n11) {
          return function() {
            var r11 = e11.shape, a11 = t11.size, i11 = r11.slice(0, u10), s11 = i11.length, c11 = r11.slice(o10, r11.length).slice(1), l11 = c11.length, h11 = Joe(0, s11), p10 = Joe(s11 + 1, s11 + 1 + l11), f10 = Zoe([i11, [a11], c11]), d10 = X8(n11, f10), v10 = X8(t11, [a11]), m10 = Zoe([[s11], h11, p10]), g10 = hne(d10, m10), y10 = nne(g10, v10, e11.shape[u10]), b10 = e9(m10);
            return y10 = hne(y10, b10);
          };
        };
        if (1 === s10) {
          var l10 = a10.shape[0], h10 = a10.split(l10, 0);
          return { x: function() {
            var t11 = Pte(h10.map(function(t12, n11) {
              return c10(t12, i10.slice(n11, 1), e10.slice(n11, 1))();
            }));
            return t11.reshape(a10.shape);
          }, indices: function() {
            return i10;
          } };
        }
        return { x: c10(a10, i10, e10), indices: function() {
          return i10;
        } };
      } };
      function Joe(e10, t10) {
        for (var n10 = [], r10 = e10; r10 < t10; ++r10) n10.push(r10);
        return n10;
      }
      function Zoe(e10) {
        for (var t10 = [], n10 = 0; n10 < e10.length; ++n10) for (var r10 = 0; r10 < e10[n10].length; ++r10) t10.push(e10[n10][r10]);
        return t10;
      }
      var Qoe = { kernelName: B1, inputsToSave: ["a", "b"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 2), r10 = n10[0], a10 = n10[1];
        return { a: function() {
          return U7(r10);
        }, b: function() {
          return U7(a10);
        } };
      } }, $oe = { kernelName: W1, gradFunc: function(e10) {
        return { x: function() {
          return h8(e10, "float32");
        } };
      } }, ese = { kernelName: G1, gradFunc: function(e10) {
        return { x: function() {
          return U7(e10);
        } };
      } }, tse = { kernelName: j1, gradFunc: function(e10) {
        return { x: function() {
          return U7(e10);
        } };
      } }, nse = { kernelName: H1, gradFunc: function(e10) {
        return { x: function() {
          return U7(e10);
        } };
      } }, rse = { kernelName: q1, inputsToSave: ["x"], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 1)[0], a10 = n10.alpha, i10 = b9(r10, 0);
        return { x: function() {
          return W7(i10, e10, g8(e10, a10));
        } };
      } }, ase = { kernelName: Z1, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return m8(e10, d8(n10, 1));
        } };
      } }, ise = { kernelName: J1, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return m8(e10, h8(n10, "float32"));
        } };
      } }, ose = { kernelName: t2, inputsToSave: [], outputsToSave: [true], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 1)[0], a10 = n10.axis;
        return { logits: function() {
          var t11 = p9(r10);
          return P9(e10, g8(u9(e10, a10, true), t11));
        } };
      } };
      var sse = B5({ localResponseNormalizationBackprop_: function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 5, a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, i10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1, o10 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0.5, s10 = { x: e10, y: t10, dy: n10 }, u10 = { depthRadius: r10, bias: a10, alpha: i10, beta: o10 };
        return E5.runKernel(r2, s10, u10);
      } }), use = { kernelName: n2, inputsToSave: ["x"], outputsToSave: [true], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 2), a10 = r10[0], i10 = r10[1], o10 = n10.depthRadius, s10 = n10.bias, u10 = n10.alpha, c10 = n10.beta;
        return { x: function() {
          return sse(a10, i10, e10, o10, s10, u10, c10);
        } };
      } };
      function cse(e10, t10, n10, r10) {
        return t10.rank < n10.rank && (t10 = X8(t10, Z7(t10.shape, r10))), e10.rank < n10.rank && (e10 = X8(e10, Z7(e10.shape, r10))), { x: function() {
          return g8(e10, h8(B7(n10, t10), e10.dtype));
        } };
      }
      var lse = { kernelName: a2, inputsToSave: ["x"], outputsToSave: [true], gradFunc: function(e10, t10, n10) {
        var r10 = n10.reductionIndices, a10 = t10[0], i10 = cse(e10, t10[1], a10, j$(r10, a10.shape));
        return { x: function() {
          return i10.x();
        } };
      } }, hse = { kernelName: i2, inputsToSave: ["a", "b"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 2), r10 = n10[0], a10 = n10[1];
        return { a: function() {
          return g8(e10, h8(x9(r10, a10), "float32"));
        }, b: function() {
          return g8(e10, h8(T9(r10, a10), "float32"));
        } };
      } };
      var pse = B5({ maxPool3dGrad_: function(e10, t10, n10, r10, a10, i10, o10) {
        var s10 = L5(e10, "dy", "maxPool3dGrad"), u10 = L5(t10, "input", "maxPool3dGrad"), c10 = L5(n10, "output", "maxPool3dGrad"), l10 = s10, h10 = u10, p10 = c10, f10 = false;
        4 === u10.rank && (f10 = true, l10 = X8(s10, [1, s10.shape[0], s10.shape[1], s10.shape[2], s10.shape[3]]), h10 = X8(u10, [1, u10.shape[0], u10.shape[1], u10.shape[2], u10.shape[3]]), p10 = X8(c10, [1, c10.shape[0], c10.shape[1], c10.shape[2], c10.shape[3]])), F$(5 === l10.rank, function() {
          return "Error in maxPool3dGrad: dy must be rank 5 but got rank " + "".concat(l10.rank, ".");
        }), F$(5 === h10.rank, function() {
          return "Error in maxPool3dGrad: input must be rank 5 but got rank " + "".concat(h10.rank, ".");
        }), F$(5 === p10.rank, function() {
          return "Error in maxPool3dGrad: output must be rank 5 but got rank " + "".concat(p10.rank, ".");
        }), K8("maxPool3dGrad", i10, o10);
        var d10 = { dy: l10, input: h10, output: p10 }, v10 = { filterSize: r10, strides: a10, pad: i10, dimRoundingMode: o10 }, m10 = E5.runKernel(c2, d10, v10);
        return f10 ? X8(m10, [m10.shape[1], m10.shape[2], m10.shape[3], m10.shape[4]]) : m10;
      } }), fse = { kernelName: u2, inputsToSave: ["x"], outputsToSave: [true], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 2), a10 = r10[0], i10 = r10[1], o10 = n10.filterSize, s10 = n10.strides, u10 = n10.pad, c10 = n10.dimRoundingMode;
        return { x: function() {
          return pse(e10, a10, i10, o10, s10, u10, c10);
        } };
      } };
      var dse = B5({ maxPoolGrad_: function(e10, t10, n10, r10, a10, i10, o10) {
        var s10 = L5(e10, "dy", "maxPoolGrad"), u10 = L5(t10, "input", "maxPoolGrad"), c10 = L5(n10, "output", "maxPoolGrad");
        F$(u10.rank === s10.rank, function() {
          return "Rank of input (".concat(u10.rank, ") does not match rank of dy ") + "(".concat(s10.rank, ")");
        }), F$(4 === s10.rank, function() {
          return "Error in maxPoolGrad: dy must be rank 4 but got rank " + "".concat(s10.rank, ".");
        }), F$(4 === u10.rank, function() {
          return "Error in maxPoolGrad: input must be rank 4 but got rank " + "".concat(u10.rank, ".");
        }), K8("maxPoolGrad", i10, o10);
        var l10 = { dy: s10, input: u10, output: c10 }, h10 = { filterSize: r10, strides: a10, pad: i10, dimRoundingMode: o10 };
        return E5.runKernel(s2, l10, h10);
      } }), vse = { kernelName: o2, inputsToSave: ["x"], outputsToSave: [true], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 2), a10 = r10[0], i10 = r10[1], o10 = n10.filterSize, s10 = n10.strides, u10 = n10.pad;
        return { x: function() {
          return dse(e10, a10, i10, o10, s10, u10);
        } };
      } }, mse = { kernelName: d2, inputsToSave: ["x"], gradFunc: function(e10, t10, n10) {
        var r10 = t10[0], a10 = n10.paddings.map(function(e11) {
          return e11[0];
        });
        return { x: function() {
          return e7(e10, a10, r10.shape);
        } };
      } }, gse = { kernelName: T2, inputsToSave: ["x"], gradFunc: function(e10, t10, n10) {
        var r10 = t10[0], a10 = n10.paddings.map(function(e11) {
          return e11[0];
        });
        return { x: function() {
          return e7(e10, a10, r10.shape);
        } };
      } }, yse = { kernelName: E2, inputsToSave: ["a", "b"], outputsToSave: [true], gradFunc: function(e10, t10) {
        var n10 = S(t10, 3), r10 = n10[0], a10 = n10[1], i10 = n10[2], o10 = r10, s10 = a10, u10 = z7(o10.shape, s10.shape);
        return { a: function() {
          var t11 = h8(s10, "float32"), n11 = g8(e10, g8(t11, a9(o10, P9(t11, i9(1))))), r11 = L7(o10.shape, u10);
          return r11.length > 0 && (n11 = u9(n11, r11)), X8(n11, o10.shape);
        }, b: function() {
          var t11 = b9(o10, 0), n11 = W7(t11, R9(o10), U7(o10)), r11 = g8(e10, g8(i10, n11)), a11 = L7(s10.shape, u10);
          return a11.length > 0 && (r11 = u9(r11, a11)), X8(r11, s10.shape);
        } };
      } };
      function bse(e10, t10, n10) {
        var r10 = e10.shape.length, a10 = r10 - n10.length, i10 = $7(n10, r10), o10 = e10;
        null != i10 && (o10 = hne(e10, i10));
        var s10 = o10.shape.slice(), u10 = s10.splice(r10 - n10.length, n10.length).reduce(function(e11, t11) {
          return e11 * t11;
        }, 1);
        s10.push(u10);
        var c10 = function(e11, t11, n11) {
          var r11 = e11.shape.slice();
          r11[n11] = 1;
          var a11 = X8(t11, r11), i11 = C7(e11, n11, true, false), o11 = C7(e11, n11, true, true), s11 = g8(i11, o11);
          return g8(a11, s11);
        }(o10.reshape(s10), t10, a10);
        if (c10 = c10.reshape(o10.shape), null != i10) {
          var l10 = e9(i10);
          c10 = hne(c10, l10);
        }
        return c10;
      }
      var xse = { kernelName: J2, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          var t11 = b9(n10, i9(0)), r10 = i9(yie), a10 = i9(bie), i10 = g8(e10, a10), o10 = g8(g8(e10, r10), p9(h8(n10, "float32")));
          return W7(t11, i10, o10);
        } };
      } }, kse = { kernelName: i3, gradFunc: function(e10, t10, n10) {
        var r10 = n10.blockShape, a10 = n10.paddings;
        return { x: function() {
          return r7(e10, r10, a10);
        } };
      } }, wse = { kernelName: o3, gradFunc: function(e10, t10, n10) {
        var r10 = n10.axis;
        return { x: function() {
          return Z8(e10, r10);
        } };
      } }, Ise = { kernelName: I3, inputsToSave: ["x"], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 1)[0], a10 = n10.reps;
        return { x: function() {
          var t11 = U7(r10);
          if (1 === r10.rank) for (var n11 = 0; n11 < a10[0]; ++n11) t11 = d8(t11, e7(e10, [n11 * r10.shape[0]], [r10.shape[0]]));
          else if (2 === r10.rank) for (var i10 = 0; i10 < a10[0]; ++i10) for (var o10 = 0; o10 < a10[1]; ++o10) t11 = d8(t11, e7(e10, [i10 * r10.shape[0], o10 * r10.shape[1]], [r10.shape[0], r10.shape[1]]));
          else if (3 === r10.rank) for (var s10 = 0; s10 < a10[0]; ++s10) for (var u10 = 0; u10 < a10[1]; ++u10) for (var c10 = 0; c10 < a10[2]; ++c10) t11 = d8(t11, e7(e10, [s10 * r10.shape[0], u10 * r10.shape[1], c10 * r10.shape[2]], [r10.shape[0], r10.shape[1], r10.shape[2]]));
          else {
            if (4 !== r10.rank) throw new Error("Gradient for tile operation is not implemented for rank-" + "".concat(r10.rank, " tensors yet."));
            for (var l10 = 0; l10 < a10[0]; ++l10) for (var h10 = 0; h10 < a10[1]; ++h10) for (var p10 = 0; p10 < a10[2]; ++p10) for (var f10 = 0; f10 < a10[3]; ++f10) t11 = d8(t11, e7(e10, [l10 * r10.shape[0], h10 * r10.shape[1], p10 * r10.shape[2], f10 * r10.shape[3]], [r10.shape[0], r10.shape[1], r10.shape[2], r10.shape[3]]));
          }
          return t11;
        } };
      } };
      for (var Nse = 0, Sse = [uoe, coe, loe, hoe, poe, foe, doe, voe, moe, goe, yoe, boe, koe, Ioe, Noe, Soe, Toe, Eoe, Coe, Aoe, Roe, _oe, Foe, Ooe, Moe, Loe, zoe, Poe, Boe, Woe, { kernelName: k1, inputsToSave: ["a", "b"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 2), r10 = n10[0], a10 = n10[1], i10 = z7(r10.shape, a10.shape);
        return { a: function() {
          var t11 = m8(e10, h8(a10, "float32")), n11 = L7(r10.shape, i10);
          return n11.length > 0 ? X8(u9(t11, n11), r10.shape) : t11;
        }, b: function() {
          var t11 = g8(e10, h8(r10, "float32")), n11 = L7(a10.shape, i10);
          n11.length > 0 && (t11 = X8(u9(t11, n11), a10.shape));
          var o10 = s9(a10);
          return M9(m8(t11, h8(o10, "float32")));
        } };
      } }, Uoe, Voe, Goe, joe, Hoe, Koe, qoe, Xoe, Yoe, Qoe, $oe, ese, tse, nse, rse, ase, ise, ose, use, lse, lse, hse, fse, vse, { kernelName: h2, inputsToSave: ["x"], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 1)[0], a10 = j$(n10.axis, r10.shape), i10 = L$(J7(r10.shape, a10)[1]);
        return { x: function() {
          var t11 = r10.shape.slice();
          a10.forEach(function(e11) {
            t11[e11] = 1;
          });
          var n11 = X8(e10, t11);
          return m8(g8(n11, eee(r10.shape, "float32")), i10);
        } };
      } }, { kernelName: p2, inputsToSave: ["x"], outputsToSave: [true], gradFunc: function(e10, t10, n10) {
        var r10 = n10.axis, a10 = S(t10, 2), i10 = a10[0], o10 = cse(e10, a10[1], i10, j$(r10, i10.shape));
        return { x: function() {
          return o10.x();
        } };
      } }, { kernelName: f2, inputsToSave: ["a", "b"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 2), r10 = n10[0], a10 = n10[1];
        return { a: function() {
          return g8(e10, h8(E9(r10, a10), "float32"));
        }, b: function() {
          return g8(e10, h8(b9(r10, a10), "float32"));
        } };
      } }, mse, { kernelName: v2, inputsToSave: ["a", "b"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 2), r10 = n10[0], a10 = n10[1], i10 = z7(r10.shape, a10.shape);
        return { a: function() {
          var t11 = L7(r10.shape, i10);
          return t11.length > 0 ? X8(u9(e10, t11), r10.shape) : e10;
        }, b: function() {
          var t11 = g8(e10, M9(g9(m8(r10, a10)))), n11 = L7(a10.shape, i10);
          return n11.length > 0 ? X8(u9(t11, n11), a10.shape) : t11;
        } };
      } }, { kernelName: g2, inputsToSave: ["a", "b"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 2), r10 = n10[0], a10 = n10[1], i10 = z7(r10.shape, a10.shape);
        return { a: function() {
          var t11 = g8(e10, h8(a10, "float32")), n11 = L7(r10.shape, i10);
          return n11.length > 0 ? X8(u9(t11, n11), r10.shape) : t11;
        }, b: function() {
          var t11 = g8(e10, h8(r10, "float32")), n11 = L7(a10.shape, i10);
          return n11.length > 0 ? X8(u9(t11, n11), a10.shape) : t11;
        } };
      } }, { kernelName: y2, gradFunc: function(e10) {
        return { x: function() {
          return M9(e10);
        } };
      } }, { kernelName: N2, inputsToSave: ["indices"], gradFunc: function(e10, t10) {
        var n10 = t10[0];
        return { indices: function() {
          return $9(n10.shape, "float32");
        } };
      } }, { kernelName: I2, gradFunc: function(e10) {
        return { x: function() {
          return U7(e10);
        } };
      } }, { kernelName: S2, saveAllInputs: true, gradFunc: function(e10, t10, n10) {
        var r10 = n10.axis;
        return rne(e10, r10).map(function(e11) {
          return function() {
            return e11;
          };
        });
      } }, gse, gse, yse, { kernelName: C2, inputsToSave: ["x", "alpha"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 2), r10 = n10[0], a10 = n10[1], i10 = b9(r10, 0);
        return { x: function() {
          return W7(i10, e10, g8(e10, a10));
        }, alpha: function() {
          var t11 = W7(i10, U7(e10), g8(e10, r10)), n11 = L7(a10.shape, e10.shape);
          return n11.length > 0 && (t11 = u9(t11, n11)), X8(t11, a10.shape);
        } };
      } }, { kernelName: A2, inputsToSave: ["x"], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 1)[0], a10 = n10.axis, i10 = [];
        return i10 = null == a10 ? r10.shape.map(function(e11, t11) {
          return t11;
        }) : "number" == typeof a10 ? [a10] : a10, { x: function() {
          return bse(r10, e10, i10);
        } };
      } }, { kernelName: M2, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return m8(e10, M9(s9(n10)));
        } };
      } }, { kernelName: V2, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0], r10 = g8(E9(n10, 6), Bte(n10));
        return { x: function() {
          return g8(e10, h8(r10, "float32"));
        } };
      } }, { kernelName: L2, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return g8(e10, h8(Bte(n10), "float32"));
        } };
      } }, { kernelName: z2, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return X8(e10, n10.shape);
        } };
      } }, { kernelName: W2, inputsToSave: ["images"], gradFunc: function(e10, t10, n10) {
        var r10 = { dy: e10, images: S(t10, 1)[0] };
        return { images: function() {
          return E5.runKernel(U2, r10, n10);
        } };
      } }, { kernelName: P2, inputsToSave: ["images"], gradFunc: function(e10, t10, n10) {
        var r10 = { dy: e10, images: S(t10, 1)[0] };
        return { images: function() {
          return E5.runKernel(B2, r10, n10);
        } };
      } }, { kernelName: G2, gradFunc: function(e10, t10, n10) {
        var r10 = j$(n10.dims, e10.shape);
        return { x: function() {
          return pte(e10, r10);
        } };
      } }, { kernelName: j2, gradFunc: function(e10) {
        return { x: function() {
          return U7(e10);
        } };
      } }, { kernelName: H2, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return M9(m8(e10, g8(a9(n10, 1.5), 2)));
        } };
      } }, { kernelName: Y2, inputsToSave: ["condition"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { condition: function() {
          return h8(U7(n10), "float32");
        }, t: function() {
          return g8(e10, h8(n10, e10.dtype));
        }, e: function() {
          return g8(e10, h8(V9(n10), e10.dtype));
        } };
      } }, xse, { kernelName: t3, outputsToSave: [true], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return g8(e10, g8(n10, P9(i9(1), n10)));
        } };
      } }, { kernelName: e3, gradFunc: function(e10) {
        return { x: function() {
          return U7(e10);
        } };
      } }, { kernelName: Q2, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return g8(T7(h8(n10, "float32")), e10);
        } };
      } }, { kernelName: $2, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return g8(E7(h8(n10, "float32")), e10);
        } };
      } }, { kernelName: Z2, inputsToSave: ["x"], gradFunc: function(e10, t10, n10) {
        for (var r10 = S(t10, 1)[0], a10 = n10.begin, i10 = n10.size, o10 = r10.shape, s10 = S(Yae(r10, a10, i10), 2), u10 = s10[0], c10 = s10[1], l10 = [], h10 = 0; h10 < e10.rank; h10++) l10.push([u10[h10], o10[h10] - u10[h10] - c10[h10]]);
        return { x: function() {
          return pee(e10, l10);
        } };
      } }, { kernelName: s3, outputsToSave: [true], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 1)[0], a10 = n10.dim, i10 = g8(e10, r10);
        return { logits: function() {
          return P9(i10, g8(u9(i10, [a10], true), r10));
        } };
      } }, { kernelName: n3, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return g8(e10, $8(n10));
        } };
      } }, kse, kse, wse, wse, { kernelName: r3, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return m8(e10, g8(o9(h8(n10, "float32")), 2));
        } };
      } }, { kernelName: f3, inputsToSave: ["a", "b"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 2), r10 = n10[0], a10 = n10[1], i10 = i9(2);
        return { a: function() {
          return g8(e10, g8(i10, P9(r10, a10)));
        }, b: function() {
          return g8(e10, g8(i10, P9(a10, r10)));
        } };
      } }, { kernelName: d3, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return g8(e10, g8(h8(n10, "float32"), 2));
        } };
      } }, { kernelName: _3, gradFunc: function(e10) {
        return { x: function() {
          return U7(e10);
        } };
      } }, { kernelName: x3, inputsToSave: ["a", "b"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 2), r10 = n10[0], a10 = n10[1], i10 = z7(r10.shape, a10.shape);
        return { a: function() {
          var t11 = e10, n11 = L7(r10.shape, i10);
          return n11.length > 0 && (t11 = u9(t11, n11)), X8(t11, r10.shape);
        }, b: function() {
          var t11 = e10, n11 = L7(a10.shape, i10);
          return n11.length > 0 && (t11 = u9(t11, n11)), X8(M9(t11), a10.shape);
        } };
      } }, { kernelName: a3, inputsToSave: ["x"], gradFunc: function(e10, t10, n10) {
        var r10 = S(t10, 1)[0], a10 = r10.shape.slice();
        j$(n10.axis, r10.shape).forEach(function(e11) {
          a10[e11] = 1;
        });
        var i10 = X8(e10, a10), o10 = g8(i10, eee(r10.shape, "float32"));
        return { x: function() {
          return o10;
        } };
      } }, { kernelName: k3, inputsToSave: ["x"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return m8(e10, s9(T7(n10)));
        } };
      } }, { kernelName: w3, outputsToSave: [true], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return g8(P9(i9(1), s9(n10)), e10);
        } };
      } }, Ise, { kernelName: T3, gradFunc: function(e10, t10, n10) {
        var r10 = e9(n10.perm);
        return { x: function() {
          return hne(e10, r10);
        } };
      } }, { kernelName: C3, gradFunc: function(e10, t10, n10) {
        var r10 = n10.axis;
        return { value: function() {
          return Pte(e10, r10);
        } };
      } }, { kernelName: A3, inputsToSave: ["segmentIds"], gradFunc: function(e10, t10) {
        var n10 = S(t10, 1)[0];
        return { x: function() {
          return function(e11, t11) {
            for (var n11 = Z9(t11, U7(t11)), r10 = y9(e11, n11), a10 = x9(t11, i9(0, "int32")), i10 = r10.rank - a10.rank, o10 = 0; o10 < i10; ++o10) a10 = f9(a10, o10 + 1);
            a10 = U9(a10, eee(r10.shape, "bool"));
            var s10 = U7(r10);
            return W7(a10, r10, s10);
          }(e10, n10);
        } };
      } }, { kernelName: R3, gradFunc: function(e10) {
        return { x: function() {
          return U7(e10);
        } };
      } }]; Nse < Sse.length; Nse++) {
        j3(Sse[Nse]);
      }
      r5().prototype.abs = function() {
        return this.throwIfDisposed(), y8(this);
      }, r5().prototype.acos = function() {
        return this.throwIfDisposed(), b8(this);
      }, r5().prototype.acosh = function() {
        return this.throwIfDisposed(), x8(this);
      }, r5().prototype.add = function(e10) {
        return this.throwIfDisposed(), d8(this, e10);
      }, r5().prototype.all = function(e10, t10) {
        return this.throwIfDisposed(), w8(this, e10, t10);
      }, r5().prototype.any = function(e10, t10) {
        return this.throwIfDisposed(), I8(this, e10, t10);
      }, r5().prototype.argMax = function(e10) {
        return this.throwIfDisposed(), N8(this, e10);
      }, r5().prototype.argMin = function(e10) {
        return this.throwIfDisposed(), S8(this, e10);
      }, r5().prototype.asScalar = function() {
        return this.throwIfDisposed(), F$(1 === this.size, function() {
          return "The array must have only 1 element.";
        }), X8(this, []);
      }, r5().prototype.asType = function(e10) {
        return this.throwIfDisposed(), h8(this, e10);
      }, r5().prototype.as1D = function() {
        return this.throwIfDisposed(), X8(this, [this.size]);
      }, r5().prototype.as2D = function(e10, t10) {
        return this.throwIfDisposed(), X8(this, [e10, t10]);
      }, r5().prototype.as3D = function(e10, t10, n10) {
        return this.throwIfDisposed(), X8(this, [e10, t10, n10]);
      }, r5().prototype.as4D = function(e10, t10, n10, r10) {
        return this.throwIfDisposed(), X8(this, [e10, t10, n10, r10]);
      }, r5().prototype.as5D = function(e10, t10, n10, r10, a10) {
        return this.throwIfDisposed(), X8(this, [e10, t10, n10, r10, a10]);
      }, r5().prototype.asin = function() {
        return this.throwIfDisposed(), T8(this);
      }, r5().prototype.asinh = function() {
        return this.throwIfDisposed(), E8(this);
      }, r5().prototype.atan = function() {
        return this.throwIfDisposed(), C8(this);
      }, r5().prototype.atan2 = function(e10) {
        return this.throwIfDisposed(), A8(this, e10);
      }, r5().prototype.atanh = function() {
        return this.throwIfDisposed(), R8(this);
      }, r5().prototype.avgPool = function(e10, t10, n10, r10) {
        return this.throwIfDisposed(), Y8(this, e10, t10, n10, r10);
      }, r5().prototype.batchToSpaceND = function(e10, t10) {
        return this.throwIfDisposed(), r7(this, e10, t10);
      }, r5().prototype.batchNorm = function(e10, t10, n10, r10, a10) {
        return this.throwIfDisposed(), a7(this, e10, t10, n10, r10, a10);
      }, r5().prototype.broadcastTo = function(e10) {
        return this.throwIfDisposed(), h7(this, e10);
      }, r5().prototype.cast = function(e10) {
        return this.throwIfDisposed(), h8(this, e10);
      }, r5().prototype.ceil = function() {
        return this.throwIfDisposed(), p7(this);
      }, r5().prototype.clipByValue = function(e10, t10) {
        return this.throwIfDisposed(), d7(this, e10, t10);
      }, r5().prototype.concat = function(e10, t10) {
        return this.throwIfDisposed(), e10 instanceof n5 && (e10 = [e10]), Z8([this].concat(T(e10)), t10);
      }, r5().prototype.conv1d = function(e10, t10, n10, r10, a10, i10) {
        return this.throwIfDisposed(), x7(this, e10, t10, n10, r10, a10, i10);
      }, r5().prototype.conv2dTranspose = function(e10, t10, n10, r10, a10) {
        return this.throwIfDisposed(), w7(this, e10, t10, n10, r10, a10);
      }, r5().prototype.conv2d = function(e10, t10, n10, r10, a10, i10) {
        return this.throwIfDisposed(), b7(this, e10, t10, n10, r10, a10, i10);
      }, r5().prototype.cos = function() {
        return this.throwIfDisposed(), T7(this);
      }, r5().prototype.cosh = function() {
        return this.throwIfDisposed(), E7(this);
      }, r5().prototype.cumprod = function(e10, t10, n10) {
        return this.throwIfDisposed(), C7(this, e10, t10, n10);
      }, r5().prototype.cumsum = function(e10, t10, n10) {
        return this.throwIfDisposed(), A7(this, e10, t10, n10);
      }, r5().prototype.depthToSpace = function(e10, t10) {
        return this.throwIfDisposed(), _7(this, e10, t10);
      }, r5().prototype.depthwiseConv2d = function(e10, t10, n10, r10, a10, i10) {
        return this.throwIfDisposed(), O7(this, e10, t10, n10, r10, a10, i10);
      }, r5().prototype.dilation2d = function(e10, t10, n10, r10, a10) {
        return this.throwIfDisposed(), D7(this, e10, t10, n10, r10, a10);
      }, r5().prototype.divNoNan = function(e10) {
        return this.throwIfDisposed(), V7(this, e10);
      }, r5().prototype.div = function(e10) {
        return this.throwIfDisposed(), m8(this, e10);
      }, r5().prototype.dot = function(e10) {
        return this.throwIfDisposed(), G7(this, e10);
      }, r5().prototype.elu = function() {
        return this.throwIfDisposed(), H7(this);
      }, r5().prototype.equal = function(e10) {
        return this.throwIfDisposed(), B7(this, e10);
      }, r5().prototype.erf = function() {
        return this.throwIfDisposed(), K7(this);
      }, r5().prototype.euclideanNorm = function(e10, t10) {
        return this.throwIfDisposed(), h9(this, e10, t10);
      }, r5().prototype.exp = function() {
        return this.throwIfDisposed(), p9(this);
      }, r5().prototype.expandDims = function(e10) {
        return this.throwIfDisposed(), f9(this, e10);
      }, r5().prototype.expm1 = function() {
        return this.throwIfDisposed(), d9(this);
      }, r5().prototype.fft = function() {
        return this.throwIfDisposed(), _te(this);
      }, r5().prototype.flatten = function() {
        return this.throwIfDisposed(), X8(this, [this.size]);
      }, r5().prototype.floor = function() {
        return this.throwIfDisposed(), g9(this);
      }, r5().prototype.floorDiv = function(e10) {
        return this.throwIfDisposed(), v8(this, e10);
      }, r5().prototype.gather = function(e10, t10, n10) {
        return this.throwIfDisposed(), y9(this, e10, t10, n10);
      }, r5().prototype.greaterEqual = function(e10) {
        return this.throwIfDisposed(), x9(this, e10);
      }, r5().prototype.greater = function(e10) {
        return this.throwIfDisposed(), b9(this, e10);
      }, r5().prototype.ifft = function() {
        return this.throwIfDisposed(), Ote(this);
      }, r5().prototype.irfft = function() {
        return this.throwIfDisposed(), Fte(this);
      }, r5().prototype.isFinite = function() {
        return this.throwIfDisposed(), w9(this);
      }, r5().prototype.isInf = function() {
        return this.throwIfDisposed(), I9(this);
      }, r5().prototype.isNaN = function() {
        return this.throwIfDisposed(), N9(this);
      }, r5().prototype.leakyRelu = function(e10) {
        return this.throwIfDisposed(), S9(this, e10);
      }, r5().prototype.lessEqual = function(e10) {
        return this.throwIfDisposed(), E9(this, e10);
      }, r5().prototype.less = function(e10) {
        return this.throwIfDisposed(), T9(this, e10);
      }, r5().prototype.localResponseNormalization = function(e10, t10, n10, r10) {
        return this.throwIfDisposed(), A9(this, e10, t10, n10, r10);
      }, r5().prototype.logSigmoid = function() {
        return this.throwIfDisposed(), z9(this);
      }, r5().prototype.logSoftmax = function(e10) {
        return this.throwIfDisposed(), B9(this, e10);
      }, r5().prototype.logSumExp = function(e10, t10) {
        return this.throwIfDisposed(), W9(this, e10, t10);
      }, r5().prototype.log = function() {
        return this.throwIfDisposed(), R9(this);
      }, r5().prototype.log1p = function() {
        return this.throwIfDisposed(), _9(this);
      }, r5().prototype.logicalAnd = function(e10) {
        return this.throwIfDisposed(), U9(this, e10);
      }, r5().prototype.logicalNot = function() {
        return this.throwIfDisposed(), V9(this);
      }, r5().prototype.logicalOr = function(e10) {
        return this.throwIfDisposed(), G9(this, e10);
      }, r5().prototype.logicalXor = function(e10) {
        return this.throwIfDisposed(), j9(this, e10);
      }, r5().prototype.matMul = function(e10, t10, n10) {
        return this.throwIfDisposed(), Q8(this, e10, t10, n10);
      }, r5().prototype.maxPool = function(e10, t10, n10, r10) {
        return this.throwIfDisposed(), X9(this, e10, t10, n10, r10);
      }, r5().prototype.max = function(e10, t10) {
        return this.throwIfDisposed(), n9(this, e10, t10);
      }, r5().prototype.maximum = function(e10) {
        return this.throwIfDisposed(), Z9(this, e10);
      }, r5().prototype.mean = function(e10, t10) {
        return this.throwIfDisposed(), Q9(this, e10, t10);
      }, r5().prototype.min = function(e10, t10) {
        return this.throwIfDisposed(), r9(this, e10, t10);
      }, r5().prototype.minimum = function(e10) {
        return this.throwIfDisposed(), nee(this, e10);
      }, r5().prototype.mirrorPad = function(e10, t10) {
        return this.throwIfDisposed(), ree(this, e10, t10);
      }, r5().prototype.mod = function(e10) {
        return this.throwIfDisposed(), aee(this, e10);
      }, r5().prototype.mul = function(e10) {
        return this.throwIfDisposed(), g8(this, e10);
      }, r5().prototype.neg = function() {
        return this.throwIfDisposed(), M9(this);
      }, r5().prototype.norm = function(e10, t10, n10) {
        return this.throwIfDisposed(), l9(this, e10, t10, n10);
      }, r5().prototype.notEqual = function(e10) {
        return this.throwIfDisposed(), uee(this, e10);
      }, r5().prototype.oneHot = function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return this.throwIfDisposed(), cee(this, e10, t10, n10);
      }, r5().prototype.onesLike = function() {
        return this.throwIfDisposed(), lee(this);
      }, r5().prototype.pad = function(e10, t10) {
        return this.throwIfDisposed(), pee(this, e10, t10);
      }, r5().prototype.pool = function(e10, t10, n10, r10, a10, i10) {
        return this.throwIfDisposed(), yee(this, e10, t10, n10, r10, a10, i10);
      }, r5().prototype.pow = function(e10) {
        return this.throwIfDisposed(), a9(this, e10);
      }, r5().prototype.prelu = function(e10) {
        return this.throwIfDisposed(), bee(this, e10);
      }, r5().prototype.prod = function(e10, t10) {
        return this.throwIfDisposed(), xee(this, e10, t10);
      }, r5().prototype.reciprocal = function() {
        return this.throwIfDisposed(), cte(this);
      }, r5().prototype.relu = function() {
        return this.throwIfDisposed(), lte(this);
      }, r5().prototype.relu6 = function() {
        return this.throwIfDisposed(), hte(this);
      }, r5().prototype.reshapeAs = function(e10) {
        return this.throwIfDisposed(), X8(this, e10.shape);
      }, r5().prototype.reshape = function(e10) {
        return this.throwIfDisposed(), X8(this, e10);
      }, r5().prototype.resizeBilinear = function(e10, t10, n10) {
        return this.throwIfDisposed(), sre(this, e10, t10, n10);
      }, r5().prototype.resizeNearestNeighbor = function(e10, t10, n10) {
        return this.throwIfDisposed(), ure(this, e10, t10, n10);
      }, r5().prototype.reverse = function(e10) {
        return this.throwIfDisposed(), pte(this, e10);
      }, r5().prototype.rfft = function() {
        return this.throwIfDisposed(), Mte(this);
      }, r5().prototype.round = function() {
        return this.throwIfDisposed(), gte(this);
      }, r5().prototype.rsqrt = function() {
        return this.throwIfDisposed(), yte(this);
      }, r5().prototype.selu = function() {
        return this.throwIfDisposed(), bte(this);
      }, r5().prototype.separableConv2d = function(e10, t10, n10, r10, a10, i10) {
        return this.throwIfDisposed(), xte(this, e10, t10, n10, r10, a10, i10);
      }, r5().prototype.sigmoid = function() {
        return this.throwIfDisposed(), $8(this);
      }, r5().prototype.sign = function() {
        return this.throwIfDisposed(), Ite(this);
      }, r5().prototype.sin = function() {
        return this.throwIfDisposed(), Nte(this);
      }, r5().prototype.sinh = function() {
        return this.throwIfDisposed(), Ste(this);
      }, r5().prototype.slice = function(e10, t10) {
        return this.throwIfDisposed(), e7(this, e10, t10);
      }, r5().prototype.softmax = function(e10) {
        return this.throwIfDisposed(), Rte(this, e10);
      }, r5().prototype.softplus = function() {
        return this.throwIfDisposed(), L9(this);
      }, r5().prototype.spaceToBatchND = function(e10, t10) {
        return this.throwIfDisposed(), gee(this, e10, t10);
      }, r5().prototype.split = function(e10, t10) {
        return this.throwIfDisposed(), Dte(this, e10, t10);
      }, r5().prototype.sqrt = function() {
        return this.throwIfDisposed(), o9(this);
      }, r5().prototype.square = function() {
        return this.throwIfDisposed(), s9(this);
      }, r5().prototype.squaredDifference = function(e10) {
        return this.throwIfDisposed(), Lte(this, e10);
      }, r5().prototype.squeeze = function(e10) {
        return this.throwIfDisposed(), zte(this, e10);
      }, r5().prototype.stack = function(e10, t10) {
        this.throwIfDisposed();
        var n10 = e10 instanceof n5 ? [this, e10] : [this].concat(T(e10));
        return Pte(n10, t10);
      }, r5().prototype.step = function(e10) {
        return this.throwIfDisposed(), Bte(this, e10);
      }, r5().prototype.stridedSlice = function(e10, t10, n10, r10, a10, i10, o10, s10) {
        return this.throwIfDisposed(), Wte(this, e10, t10, n10, r10, a10, i10, o10, s10);
      }, r5().prototype.sub = function(e10) {
        return this.throwIfDisposed(), P9(this, e10);
      }, r5().prototype.sum = function(e10, t10) {
        return this.throwIfDisposed(), u9(this, e10, t10);
      }, r5().prototype.tan = function() {
        return this.throwIfDisposed(), Ute(this);
      }, r5().prototype.tanh = function() {
        return this.throwIfDisposed(), t7(this);
      }, r5().prototype.tile = function(e10) {
        return this.throwIfDisposed(), v9(this, e10);
      }, r5().prototype.toBool = function() {
        return this.throwIfDisposed(), h8(this, "bool");
      }, r5().prototype.toFloat = function() {
        return this.throwIfDisposed(), h8(this, "float32");
      }, r5().prototype.toInt = function() {
        return this.throwIfDisposed(), h8(this, "int32");
      }, r5().prototype.topk = function(e10, t10) {
        return this.throwIfDisposed(), $te(this, e10, t10);
      }, r5().prototype.transpose = function(e10) {
        return this.throwIfDisposed(), hne(this, e10);
      }, r5().prototype.unique = function(e10) {
        return this.throwIfDisposed(), tne(this, e10);
      }, r5().prototype.unsortedSegmentSum = function(e10, t10) {
        return this.throwIfDisposed(), nne(this, e10, t10);
      }, r5().prototype.unstack = function(e10) {
        return this.throwIfDisposed(), rne(this, e10);
      }, r5().prototype.where = function(e10, t10) {
        return this.throwIfDisposed(), W7(e10, this, t10);
      }, r5().prototype.zerosLike = function() {
        return this.throwIfDisposed(), U7(this);
      };
      var Tse = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), r10 = t10.call(this, e11), Object.setPrototypeOf(x(r10), n10.prototype), r10;
        }
        return p(n10);
      }(b(Error)), Ese = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), r10 = t10.call(this, e11), Object.setPrototypeOf(x(r10), n10.prototype), r10;
        }
        return p(n10);
      }(b(Error)), Cse = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), r10 = t10.call(this, e11), Object.setPrototypeOf(x(r10), n10.prototype), r10;
        }
        return p(n10);
      }(b(Error)), Ase = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), r10 = t10.call(this, e11), Object.setPrototypeOf(x(r10), n10.prototype), r10;
        }
        return p(n10);
      }(b(Error)), Rse = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), r10 = t10.call(this, e11), Object.setPrototypeOf(x(r10), n10.prototype), r10;
        }
        return p(n10);
      }(b(Error)), _se = (Error, function() {
        function e10(t10) {
          l(this, e10), this.maxEntries = t10 || 100, this.cache = /* @__PURE__ */ new Map();
        }
        return p(e10, [{ key: "get", value: function(e11) {
          var t10;
          return this.cache.has(e11) && (t10 = this.cache.get(e11), this.cache.delete(e11), this.cache.set(e11, t10)), t10;
        } }, { key: "put", value: function(e11, t10) {
          if (this.cache.has(e11)) this.cache.delete(e11);
          else if (this.cache.size >= this.maxEntries) {
            var n10 = this.cache.keys().next().value;
            this.cache.delete(n10);
          }
          this.cache.set(e11, t10);
        } }, { key: "getMaxEntries", value: function() {
          return this.maxEntries;
        } }, { key: "setMaxEntries", value: function(e11) {
          if (e11 < 0) throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(e11, "."));
          if (this.maxEntries > e11) for (var t10 = 0; t10 < this.maxEntries - e11; t10++) {
            var n10 = this.cache.keys().next().value;
            this.cache.delete(n10);
          }
          this.maxEntries = e11;
        } }]), e10;
      }());
      function Ose(e10, t10) {
        if (Array.isArray(e10)) {
          for (var n10 = [], r10 = 0; r10 < t10; r10++) n10 = n10.concat(e10);
          return n10;
        }
        var a10 = new Array(t10);
        return a10.fill(e10), a10;
      }
      function Fse(e10, t10) {
        if (!e10) throw new Rse(t10);
      }
      function Dse(e10, t10) {
        var n10, r10 = 0, a10 = O(e10);
        try {
          for (a10.s(); !(n10 = a10.n()).done; ) {
            n10.value === t10 && r10++;
          }
        } catch (e11) {
          a10.e(e11);
        } finally {
          a10.f();
        }
        return r10;
      }
      function Mse(e10) {
        return 1 === e10.length ? e10[0] : e10;
      }
      function Lse(e10) {
        return Array.isArray(e10) ? e10 : [e10];
      }
      function zse(e10) {
        var t10 = e10.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
        return "_" !== t10[0] ? t10 : "private" + t10;
      }
      function Pse(e10) {
        return e10.length <= 1 || -1 === e10.indexOf("_") ? e10 : e10.replace(/[_]+(\w|$)/g, function(e11, t10) {
          return t10.toUpperCase();
        });
      }
      var Bse = {};
      function Wse(e10) {
        if (null == e10) return null;
        var t10 = {};
        return t10.className = e10.getClassName(), t10.config = e10.getConfig(), t10;
      }
      function Use(e10) {
        if (null != e10 && "object" === s(e10)) if (Array.isArray(e10)) e10.forEach(function(e11) {
          return Use(e11);
        });
        else for (var t10 = 0, n10 = Object.keys(e10); t10 < n10.length; t10++) {
          var r10 = n10[t10], a10 = e10[r10];
          null != a10 && "object" === s(a10) && (Array.isArray(a10) || "ndarray" !== a10.type || "number" != typeof a10.value ? Use(a10) : e10[r10] = a10.value);
        }
      }
      function Vse(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "object", a10 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        if ("string" == typeof e10) {
          var i10, o10 = e10;
          if (o10 in n10) i10 = n10[o10];
          else if (o10 in Bse) i10 = Bse[o10];
          else if (null == (i10 = t10[o10])) throw new Cse("Unknown ".concat(r10, ": ").concat(e10, ". ") + "This may be due to one of the following reasons:\n" + "1. The ".concat(r10, " is defined in Python, in which ") + "case it needs to be ported to TensorFlow.js or your JavaScript code.\n" + "2. The custom ".concat(r10, " is defined in JavaScript, ") + "but is not registered properly with tf.serialization.registerClass().");
          return i10;
        }
        var s10 = e10;
        if (null == s10.className || null == s10.config) throw new Cse("".concat(r10, ": Improper config format: ") + "".concat(JSON.stringify(s10), ".\n") + "'className' and 'config' must set.");
        var u10, c10, l10 = s10.className;
        if (l10 in n10) {
          var h10 = S(n10[l10], 2);
          u10 = h10[0], c10 = h10[1];
        } else if (l10 in Bse) {
          var p10 = S(Bse.className, 2);
          u10 = p10[0], c10 = p10[1];
        } else if (l10 in t10) {
          var f10 = S(t10[l10], 2);
          u10 = f10[0], c10 = f10[1];
        }
        if (null == u10) throw new Cse("Unknown ".concat(r10, ": ").concat(l10, ". ") + "This may be due to one of the following reasons:\n" + "1. The ".concat(r10, " is defined in Python, in which ") + "case it needs to be ported to TensorFlow.js or your JavaScript code.\n" + "2. The custom ".concat(r10, " is defined in JavaScript, ") + "but is not registered properly with tf.serialization.registerClass().");
        if (null != c10) {
          for (var d10 = {}, v10 = 0, m10 = Object.keys(Bse); v10 < m10.length; v10++) {
            var g10 = m10[v10];
            d10[g10] = Bse[g10];
          }
          for (var y10 = 0, b10 = Object.keys(n10); y10 < b10.length; y10++) {
            var x10 = b10[y10];
            d10[x10] = n10[x10];
          }
          var k10 = s10.config;
          k10.customObjects = d10;
          for (var w10 = Object.assign({}, Bse), I10 = 0, N10 = Object.keys(n10); I10 < N10.length; I10++) {
            var T10 = N10[I10];
            Bse[T10] = n10[T10];
          }
          Use(s10.config);
          var E10 = c10(u10, s10.config, n10, a10);
          return Bse = Object.assign({}, w10), E10;
        }
        for (var C10 = Object.assign({}, Bse), A10 = 0, R10 = Object.keys(n10); A10 < R10.length; A10++) {
          var _10 = R10[A10];
          Bse[_10] = n10[_10];
        }
        var O10 = new u10(s10.config);
        return Bse = Object.assign({}, C10), O10;
      }
      function Gse(e10, t10) {
        return -1 * function(e11, t11) {
          return e11 < t11 ? -1 : e11 > t11 ? 1 : 0;
        }(e10, t10);
      }
      function jse(e10) {
        if (null == e10) return e10;
        var t10, n10 = [], r10 = O(e10);
        try {
          for (r10.s(); !(t10 = r10.n()).done; ) {
            var a10 = t10.value;
            -1 === n10.indexOf(a10) && n10.push(a10);
          }
        } catch (e11) {
          r10.e(e11);
        } finally {
          r10.f();
        }
        return n10;
      }
      function Hse(e10) {
        if (null == e10) throw new Cse("Invalid value in obj: ".concat(JSON.stringify(e10)));
        for (var t10 in e10) if (e10.hasOwnProperty(t10)) return false;
        return true;
      }
      function qse(e10, t10, n10) {
        if (null != n10 && e10.indexOf(n10) < 0) throw new Cse("".concat(n10, " is not a valid ").concat(t10, ".  Valid values are ").concat(e10, " or null/undefined."));
      }
      function Kse(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0;
        return Fse(n10 >= 0), Fse(r10 >= n10), Array.isArray(e10) && e10.length >= n10 && e10.length <= r10 && e10.every(function(e11) {
          return s(e11) === t10;
        });
      }
      function Xse(e10, t10) {
        Array.isArray(e10) ? (F$(e10.length > 0, function() {
          return "".concat(t10, " is unexpectedly an empty array.");
        }), e10.forEach(function(e11, n10) {
          return Xse(e11, "element ".concat(n10 + 1, " of ").concat(t10));
        })) : F$(Number.isInteger(e10) && e10 > 0, function() {
          return "Expected ".concat(t10, " to be a positive integer, but got ") + "".concat(Yse(e10), ".");
        });
      }
      function Yse(e10) {
        return null === e10 ? "null" : Array.isArray(e10) ? "[" + e10.map(function(e11) {
          return Yse(e11);
        }).join(",") + "]" : "string" == typeof e10 ? '"'.concat(e10, '"') : "".concat(e10);
      }
      function Jse(e10) {
        return "relu" === e10 ? "relu" : "linear" === e10 ? "linear" : "elu" === e10 ? "elu" : null;
      }
      var Zse = 0;
      function Qse() {
        return Zse++;
      }
      var $se = {};
      function eue() {
        var e10 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
        return e10 in $se || ($se[e10] = 0), $se[e10] += 1, e10 + $se[e10].toString();
      }
      var tue = ["channelsFirst", "channelsLast"], nue = ["nearest", "bilinear"], rue = ["valid", "same", "causal"], aue = ["max", "avg"], iue = ["sum", "mul", "concat", "ave"], oue = /* @__PURE__ */ new Map();
      function sue(e10) {
        qse(tue, "DataFormat", e10);
      }
      function uue(e10) {
        qse(rue, "PaddingMode", e10);
      }
      function cue(e10) {
        qse(aue, "PoolMode", e10);
      }
      var lue = [];
      function hue(e10, t10) {
        lue.push(e10);
        try {
          var n10 = t10();
          return lue.pop(), n10;
        } catch (e11) {
          throw lue.pop(), e11;
        }
      }
      function pue(e10) {
        if (!mue(e10)) throw new Error("Not a valid tensor name: '" + e10 + "'");
        return (0 === lue.length ? "" : lue.join("/") + "/") + e10;
      }
      function fue(e10) {
        if (!mue(e10)) throw new Error("Not a valid tensor name: '" + e10 + "'");
        oue.has(e10) || oue.set(e10, 0);
        var t10 = oue.get(e10);
        if (oue.set(e10, oue.get(e10) + 1), t10 > 0) {
          var n10 = "".concat(e10, "_").concat(t10);
          return oue.set(n10, 1), n10;
        }
        return e10;
      }
      var due, vue = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
      function mue(e10) {
        return !!e10.match(vue);
      }
      function gue(e10, t10, n10) {
        null == t10 && (t10 = 0), null == n10 && (n10 = e10.length);
        for (var r10 = 1, a10 = t10; a10 < n10; ++a10) r10 *= e10[a10];
        return r10;
      }
      function yue(e10) {
        if (0 === e10.length) return Number.NaN;
        for (var t10 = Number.POSITIVE_INFINITY, n10 = 0; n10 < e10.length; n10++) {
          var r10 = e10[n10];
          r10 < t10 && (t10 = r10);
        }
        return t10;
      }
      function bue(e10) {
        if (0 === e10.length) return Number.NaN;
        for (var t10 = Number.NEGATIVE_INFINITY, n10 = 0; n10 < e10.length; n10++) {
          var r10 = e10[n10];
          r10 > t10 && (t10 = r10);
        }
        return t10;
      }
      function xue(e10, t10) {
        if (t10 < e10) throw new Cse("end (".concat(t10, ") < begin (").concat(e10, ") is forbidden."));
        for (var n10 = [], r10 = e10; r10 < t10; ++r10) n10.push(r10);
        return n10;
      }
      function kue() {
        return null == due && (due = e6().epsilon()), due;
      }
      function wue(e10, t10) {
        return h8(e10, t10);
      }
      function Iue(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1, n10 = e10.shape.slice();
        return t10 < 0 && (t10 = n10.length + t10 + 1), n10.splice(t10, 0, 1), X8(e10, n10);
      }
      function Nue(e10) {
        var t10 = [gue(e10.shape)];
        return X8(e10, t10);
      }
      function Sue(e10, t10, n10) {
        return X5(function() {
          switch (e10.rank) {
            case 1:
              return Tte(e10, t10, n10);
            case 2:
              return Ete(e10, [t10, 0], [n10, e10.shape[1]]);
            case 3:
              return Cte(e10, [t10, 0, 0], [n10, e10.shape[1], e10.shape[2]]);
            case 4:
              return Ate(e10, [t10, 0, 0, 0], [n10, e10.shape[1], e10.shape[2], e10.shape[3]]);
            case 5:
              return e7(e10, [t10, 0, 0, 0, 0], [n10, e10.shape[1], e10.shape[2], e10.shape[3], e10.shape[4]]);
            case 6:
              return e7(e10, [t10, 0, 0, 0, 0, 0], [n10, e10.shape[1], e10.shape[2], e10.shape[3], e10.shape[4], e10.shape[5]]);
            default:
              throw new Cse("sliceAlongFirstAxis() received an unsupported tensor rank: " + "".concat(e10.rank));
          }
        });
      }
      function Tue(e10, t10, n10) {
        return X5(function() {
          switch (e10.rank) {
            case 1:
              return Tte(e10, t10, n10);
            case 2:
              return Ete(e10, [0, t10], [e10.shape[0], n10]);
            case 3:
              return Cte(e10, [0, 0, t10], [e10.shape[0], e10.shape[1], n10]);
            case 4:
              return Ate(e10, [0, 0, 0, t10], [e10.shape[0], e10.shape[1], e10.shape[2], n10]);
            default:
              throw new Cse("sliceAlongLastAxis() received an unsupported tensor rank: " + "".concat(e10.rank));
          }
        });
      }
      function Eue(e10, t10, n10, r10) {
        return X5(function() {
          switch (e10.rank) {
            case 1:
              return Tte(e10, t10, n10);
            case 2:
              switch (r10) {
                case 1:
                  return Sue(e10, t10, n10);
                case 2:
                  return Tue(e10, t10, n10);
                default:
                  throw new Cse("The axis is not within the rank of the tensor " + "".concat(r10));
              }
            case 3:
              switch (r10) {
                case 1:
                  return Sue(e10, t10, n10);
                case 2:
                  return Cte(e10, [0, t10, 0], [e10.shape[0], n10, e10.shape[2]]);
                case 3:
                  return Tue(e10, t10, n10);
                default:
                  throw new Cse("The axis is not within the rank of the tensor " + "".concat(r10));
              }
            case 4:
              switch (r10) {
                case 1:
                  return Sue(e10, t10, n10);
                case 2:
                  return Ate(e10, [0, t10, 0, 0], [e10.shape[0], n10, e10.shape[2], e10.shape[3]]);
                case 3:
                  return Ate(e10, [0, 0, t10, 0], [e10.shape[0], e10.shape[1], n10, e10.shape[3]]);
                case 4:
                  return Tue(e10, t10, n10);
                default:
                  throw new Cse("The axis is not within the rank of the tensor " + "".concat(r10));
              }
            default:
              throw new Cse("sliceAlongLastAxis() received an unsupported tensor rank: " + "".concat(e10.rank));
          }
        });
      }
      function Cue(e10) {
        var t10, n10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
        return n10 < 0 && (n10 = 0 !== (t10 = e10[0].rank) ? t10 : 0), n10 === e10[0].rank && (n10 = -1), Z8(e10, n10);
      }
      function Aue(e10, t10) {
        switch (e10.rank) {
          case 1:
            return v7([e10, t10]);
          case 2:
            return m7([e10, t10], 0);
          case 3:
            return g7([e10, t10], 0);
          case 4:
            return y7([e10, t10], 0);
          default:
            throw new Cse("concatAlongFirstAxis() received an unsupported " + "tensor rank: ".concat(e10.rank));
        }
      }
      function Rue(e10, t10) {
        if (Array.isArray(t10) || (t10 = [t10]), e10.rank !== t10.length) throw new Cse("The length of input n (".concat(t10.length, ") does not match ") + "the number of dimensions in input x (".concat(e10.rank, ")"));
        return v9(e10, t10);
      }
      function _ue(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r10 = arguments.length > 3 ? arguments[3] : void 0, a10 = arguments.length > 4 ? arguments[4] : void 0;
        return rte(e10, t10, n10, r10, a10);
      }
      function Oue(e10, t10, n10, r10) {
        if (e10.rank < 2 || t10.rank < 2) throw new Ase("dot requires both inputs to be rank >= 2" + " but got x shape = ".concat(e10.shape, " and y shape = ").concat(t10.shape));
        if (t10.rank >= 3 && e10.shape.slice(-1)[0] !== t10.shape.slice(-2)[0]) throw new Ase("If rank y >= 3, then the second last dim" + " of y must equal the last dim of x but got x shape = ".concat(e10.shape, " and ") + " y shape = ".concat(t10.shape));
        if (2 === e10.rank && 2 === t10.rank) {
          return _ne({ a: e10, b: t10, transposeA: false, transposeB: false, bias: r10 ? Mue(e10.rank, r10, "channelsLast") : null, activation: n10 });
        }
        var a10 = e10.shape.slice(), i10 = a10.pop();
        e10 = X8(e10, [-1, i10]);
        var o10 = t10.shape.slice(), s10 = o10.pop(), u10 = o10.pop(), c10 = [].concat(T(o10), [s10]), l10 = Array.from({ length: t10.rank }, function(e11, n11) {
          return 0 === n11 ? t10.rank - 2 : n11 <= t10.rank - 2 ? n11 - 1 : n11;
        });
        t10 = X8(hne(t10, l10), [u10, -1]);
        var h10 = [].concat(T(a10), T(c10));
        return X8(_ne({ a: e10, b: t10, transposeA: false, transposeB: false, bias: r10 ? Mue(e10.rank, r10, "channelsLast") : null, activation: n10 }), h10);
      }
      function Fue(e10, t10, n10) {
        return X5(function() {
          return t10 = Array.isArray(t10) ? Vte(t10, "int32") : h8(t10, "int32"), y9(e10, t10, n10);
        });
      }
      function Due(e10) {
        return g8(e10, e10);
      }
      function Mue(e10, t10, n10) {
        var r10 = t10.shape;
        if (1 !== t10.rank && t10.rank !== e10) throw new Cse("Unexpected bias dimensions: ".concat(t10.rank) + "; expected it to be 1 or ".concat(e10));
        if (5 === e10) {
          if ("channelsFirst" === n10) return 1 === r10.length ? X8(t10, [1, r10[0], 1, 1, 1]) : X8(t10, [1, r10[3], r10[0], r10[1], r10[2]]);
          if ("channelsLast" === n10) return 1 === r10.length ? X8(t10, [1, 1, 1, 1, r10[0]]) : X8(t10, [1].concat(r10));
        } else if (4 === e10) {
          if ("channelsFirst" === n10) return 1 === r10.length ? X8(t10, [1, r10[0], 1, 1]) : X8(t10, [1, r10[2], r10[0], r10[1]]);
          if ("channelsLast" === n10) return 1 === r10.length ? X8(t10, [1, 1, 1, r10[0]]) : X8(t10, [1].concat(r10));
        } else if (3 === e10) {
          if ("channelsFirst" === n10) return 1 === r10.length ? X8(t10, [1, r10[0], 1]) : X8(t10, [1, r10[1], r10[0]]);
          if ("channelsLast" === n10) return 1 === r10.length ? X8(t10, [1, 1, r10[0]]) : X8(t10, [1].concat(r10));
        } else if (e10 < 3) return t10;
        throw new Cse("Unsupported input rank by biasAdd: ".concat(t10.rank));
      }
      function Lue(e10, t10, n10) {
        return X5(function() {
          return null == n10 && (n10 = "channelsLast"), sue(n10), d8(e10, Mue(e10.rank, t10, n10));
        });
      }
      function zue(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        if (1 !== t10) throw new Ase("Support for alpha values other than 1 (".concat(t10, ") is not implemented ") + "yet.");
        return H7(e10);
      }
      function Pue(e10, t10, n10, r10) {
        return X5(function() {
          return gne(e10, t10, n10, r10);
        });
      }
      function Bue(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return n10 ? e10() : t10();
      }
      var Wue = ["fanIn", "fanOut", "fanAvg"], Uue = ["normal", "uniform", "truncatedNormal"];
      var Vue = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "fromConfigUsesCustomObjects", value: function() {
          return false;
        } }, { key: "getConfig", value: function() {
          return {};
        } }]), n10;
      }(Hre), Gue = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11, t11) {
          return $9(e11, t11);
        } }]), n10;
      }(Vue);
      Gue.className = "Zeros", Kre(Gue);
      var jue = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11, t11) {
          return eee(e11, t11);
        } }]), n10;
      }(Vue);
      jue.className = "Ones", Kre(jue);
      var Hue = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), r10 = t10.call(this), "object" !== s(e11)) throw new Cse("Expected argument of type ConstantConfig but got ".concat(e11));
          if (void 0 === e11.value) throw new Cse("config must have value set but got ".concat(e11));
          return r10.value = e11.value, r10;
        }
        return p(n10, [{ key: "apply", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            return g8(i9(n11.value), eee(e11, t11));
          });
        } }, { key: "getConfig", value: function() {
          return { value: this.value };
        } }]), n10;
      }(Vue);
      Hue.className = "Constant", Kre(Hue);
      var que = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this)).DEFAULT_MINVAL = -0.05, r10.DEFAULT_MAXVAL = 0.05, r10.minval = e11.minval || r10.DEFAULT_MINVAL, r10.maxval = e11.maxval || r10.DEFAULT_MAXVAL, r10.seed = e11.seed, r10;
        }
        return p(n10, [{ key: "apply", value: function(e11, t11) {
          return ite(e11, this.minval, this.maxval, t11, this.seed);
        } }, { key: "getConfig", value: function() {
          return { minval: this.minval, maxval: this.maxval, seed: this.seed };
        } }]), n10;
      }(Vue);
      que.className = "RandomUniform", Kre(que);
      var Kue = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this)).DEFAULT_MEAN = 0, r10.DEFAULT_STDDEV = 0.05, r10.mean = e11.mean || r10.DEFAULT_MEAN, r10.stddev = e11.stddev || r10.DEFAULT_STDDEV, r10.seed = e11.seed, r10;
        }
        return p(n10, [{ key: "apply", value: function(e11, t11) {
          if ("float32" !== (t11 = t11 || "float32") && "int32" !== t11) throw new Ase("randomNormal does not support dType ".concat(t11, "."));
          return _ue(e11, this.mean, this.stddev, t11, this.seed);
        } }, { key: "getConfig", value: function() {
          return { mean: this.mean, stddev: this.stddev, seed: this.seed };
        } }]), n10;
      }(Vue);
      Kue.className = "RandomNormal", Kre(Kue);
      var Xue = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this)).DEFAULT_MEAN = 0, r10.DEFAULT_STDDEV = 0.05, r10.mean = e11.mean || r10.DEFAULT_MEAN, r10.stddev = e11.stddev || r10.DEFAULT_STDDEV, r10.seed = e11.seed, r10;
        }
        return p(n10, [{ key: "apply", value: function(e11, t11) {
          if ("float32" !== (t11 = t11 || "float32") && "int32" !== t11) throw new Ase("truncatedNormal does not support dType ".concat(t11, "."));
          return ene(e11, this.mean, this.stddev, t11, this.seed);
        } }, { key: "getConfig", value: function() {
          return { mean: this.mean, stddev: this.stddev, seed: this.seed };
        } }]), n10;
      }(Vue);
      Xue.className = "TruncatedNormal", Kre(Xue);
      var Yue = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this)).gain = null != e11.gain ? e11.gain : 1, r10;
        }
        return p(n10, [{ key: "apply", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            if (2 !== e11.length || e11[0] !== e11[1]) throw new Cse("Identity matrix initializer can only be used for 2D square matrices.");
            return g8(n11.gain, m9(e11[0]));
          });
        } }, { key: "getConfig", value: function() {
          return { gain: this.gain };
        } }]), n10;
      }(Vue);
      Yue.className = "Identity", Kre(Yue);
      var Jue = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10, a10;
          if (l(this, n10), r10 = t10.call(this), e11.scale < 0) throw new Cse("scale must be a positive float. Got: ".concat(e11.scale));
          return r10.scale = null == e11.scale ? 1 : e11.scale, r10.mode = null == e11.mode ? "fanIn" : e11.mode, a10 = r10.mode, qse(Wue, "FanMode", a10), r10.distribution = null == e11.distribution ? "normal" : e11.distribution, function(e12) {
            qse(Uue, "Distribution", e12);
          }(r10.distribution), r10.seed = e11.seed, r10;
        }
        return p(n10, [{ key: "apply", value: function(e11, t11) {
          var n11 = function(e12) {
            var t12, n12, r11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "channelsLast";
            if (sue(r11), 2 === e12.length) t12 = e12[0], n12 = e12[1];
            else if (-1 !== [3, 4, 5].indexOf(e12.length)) {
              if ("channelsFirst" === r11) {
                var a11 = gue(e12, 2);
                t12 = e12[1] * a11, n12 = e12[0] * a11;
              } else if ("channelsLast" === r11) {
                var i11 = gue(e12, 0, e12.length - 2);
                t12 = e12[e12.length - 2] * i11, n12 = e12[e12.length - 1] * i11;
              }
            } else {
              var o11 = gue(e12);
              t12 = Math.sqrt(o11), n12 = Math.sqrt(o11);
            }
            return [t12, n12];
          }(e11), r10 = n11[0], a10 = n11[1], i10 = this.scale;
          if ("fanIn" === this.mode ? i10 /= Math.max(1, r10) : "fanOut" === this.mode ? i10 /= Math.max(1, a10) : i10 /= Math.max(1, (r10 + a10) / 2), "normal" === this.distribution) {
            var o10 = Math.sqrt(i10);
            if ("float32" !== (t11 = t11 || "float32") && "int32" !== t11) throw new Ase("".concat(this.getClassName(), " does not support dType ").concat(t11, "."));
            return ene(e11, 0, o10, t11, this.seed);
          }
          var s10 = Math.sqrt(3 * i10);
          return ite(e11, -s10, s10, t11, this.seed);
        } }, { key: "getConfig", value: function() {
          return { scale: this.scale, mode: this.mode, distribution: this.distribution, seed: this.seed };
        } }]), n10;
      }(Vue);
      Jue.className = "VarianceScaling", Kre(Jue);
      var Zue = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, { scale: 1, mode: "fanAvg", distribution: "uniform", seed: null == e11 ? null : e11.seed });
        }
        return p(n10, [{ key: "getClassName", value: function() {
          return Jue.className;
        } }]), n10;
      }(Jue);
      Zue.className = "GlorotUniform", Kre(Zue);
      var Que = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, { scale: 1, mode: "fanAvg", distribution: "normal", seed: null == e11 ? null : e11.seed });
        }
        return p(n10, [{ key: "getClassName", value: function() {
          return Jue.className;
        } }]), n10;
      }(Jue);
      Que.className = "GlorotNormal", Kre(Que);
      var $ue = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, { scale: 2, mode: "fanIn", distribution: "normal", seed: null == e11 ? null : e11.seed });
        }
        return p(n10, [{ key: "getClassName", value: function() {
          return Jue.className;
        } }]), n10;
      }(Jue);
      $ue.className = "HeNormal", Kre($ue);
      var ece = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, { scale: 2, mode: "fanIn", distribution: "uniform", seed: null == e11 ? null : e11.seed });
        }
        return p(n10, [{ key: "getClassName", value: function() {
          return Jue.className;
        } }]), n10;
      }(Jue);
      ece.className = "HeUniform", Kre(ece);
      var tce = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, { scale: 1, mode: "fanIn", distribution: "normal", seed: null == e11 ? null : e11.seed });
        }
        return p(n10, [{ key: "getClassName", value: function() {
          return Jue.className;
        } }]), n10;
      }(Jue);
      tce.className = "LeCunNormal", Kre(tce);
      var nce = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, { scale: 1, mode: "fanIn", distribution: "uniform", seed: null == e11 ? null : e11.seed });
        }
        return p(n10, [{ key: "getClassName", value: function() {
          return Jue.className;
        } }]), n10;
      }(Jue);
      nce.className = "LeCunUniform", Kre(nce);
      var rce = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this)).DEFAULT_GAIN = 1, r10.ELEMENTS_WARN_SLOW = 2e3, r10.gain = null == e11.gain ? r10.DEFAULT_GAIN : e11.gain, r10.seed = e11.seed, r10;
        }
        return p(n10, [{ key: "apply", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            if (e11.length < 2) throw new Ase("Shape must be at least 2D.");
            if ("int32" !== t11 && "float32" !== t11 && void 0 !== t11) throw new TypeError("Unsupported data type ".concat(t11, "."));
            var r10 = L$(e11.slice(0, -1)), a10 = e11[e11.length - 1], i10 = r10 * a10;
            i10 > n11.ELEMENTS_WARN_SLOW && console.warn("Orthogonal initializer is being called on a matrix with more " + "than ".concat(n11.ELEMENTS_WARN_SLOW, " (").concat(i10, ") elements: ") + "Slowness may result.");
            var o10 = _ue([Math.max(a10, r10), Math.min(a10, r10)], 0, 1, t11, n11.seed), s10 = Bre.qr(o10, false), u10 = s10[0], c10 = s10[1].flatten().stridedSlice([0], [Math.min(a10, r10) * Math.min(a10, r10)], [Math.min(a10, r10) + 1]);
            return u10 = g8(u10, c10.sign()), r10 < a10 && (u10 = u10.transpose()), g8(i9(n11.gain), u10.reshape(e11));
          });
        } }, { key: "getConfig", value: function() {
          return { gain: this.gain, seed: this.seed };
        } }]), n10;
      }(Vue);
      rce.className = "Orthogonal", Kre(rce);
      var ace = { constant: "Constant", glorotNormal: "GlorotNormal", glorotUniform: "GlorotUniform", heNormal: "HeNormal", heUniform: "HeUniform", identity: "Identity", leCunNormal: "LeCunNormal", leCunUniform: "LeCunUniform", ones: "Ones", orthogonal: "Orthogonal", randomNormal: "RandomNormal", randomUniform: "RandomUniform", truncatedNormal: "TruncatedNormal", varianceScaling: "VarianceScaling", zeros: "Zeros" };
      function ice(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return Vse(e10, qre.getMap().classNameMap, t10, "initializer");
      }
      function oce(e10) {
        return Wse(e10);
      }
      function sce(e10) {
        if ("string" == typeof e10) {
          var t10 = e10 in ace ? ace[e10] : e10;
          if ("GlorotNormal" === t10) return new Que();
          if ("GlorotUniform" === t10) return new Zue();
          if ("HeNormal" === t10) return new $ue();
          if ("HeUniform" === t10) return new ece();
          if ("LeCunNormal" === t10) return new tce();
          if ("LeCunUniform" === t10) return new nce();
          var n10 = {};
          return n10.className = t10, n10.config = {}, ice(n10);
        }
        return e10 instanceof Vue ? e10 : ice(e10);
      }
      function uce(e10) {
        return Array.isArray(e10) && Array.isArray(e10[0]);
      }
      function cce(e10) {
        return 0 === e10.length ? [] : Array.isArray(e10[0]) ? e10 : [e10];
      }
      function lce(e10) {
        var t10;
        if (Array.isArray(e10)) {
          if (1 !== e10.length) throw new Cse("Expected Tensor length to be 1; got ".concat(e10.length));
          t10 = e10[0];
        } else t10 = e10;
        return t10;
      }
      function hce(e10) {
        if (Array.isArray(e10) && Array.isArray(e10[0])) {
          if (1 === e10.length) return e10[0];
          throw new Cse("Expected exactly 1 Shape; got ".concat(e10.length));
        }
        return e10;
      }
      function pce(e10) {
        var t10, n10 = 0, r10 = O(e10);
        try {
          for (r10.s(); !(t10 = r10.n()).done; ) {
            var a10 = t10.value;
            0 === a10.shape.length ? n10 += 1 : n10 += a10.shape.reduce(function(e11, t11) {
              return e11 * t11;
            });
          }
        } catch (e11) {
          r10.e(e11);
        } finally {
          r10.f();
        }
        return n10;
      }
      var fce = "Variable", dce = function() {
        function e10(t10) {
          var n10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "float32", r10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : fce, a10 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], i10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
          l(this, e10), this.dtype = null == n10 ? "float32" : n10, this.shape = t10.shape, this.id = Qse(), r10 = null == r10 ? fce : r10, this.originalName = pue(r10), this.name = fue(this.originalName), this.trainable_ = a10, this.constraint = i10, this.val = ine(t10, this.trainable_, this.name, this.dtype);
        }
        return p(e10, [{ key: "read", value: function() {
          return this.assertNotDisposed(), this.val;
        } }, { key: "write", value: function(e11) {
          return this.assertNotDisposed(), function(e12, t10) {
            if (e12.shape.toString() !== t10.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(e12.shape) + " vs. " + JSON.stringify(t10.shape));
          }(this.val, e11), this.val.id !== e11.id && (this.val.assign(e11), null != this.constraint && this.val.assign(this.constraint.apply(this.val))), this;
        } }, { key: "dispose", value: function() {
          this.assertNotDisposed(), this.val.dispose();
        } }, { key: "assertNotDisposed", value: function() {
          if (this.val.isDisposed) throw new Error("LayersVariable ".concat(this.name, " is already disposed."));
        } }, { key: "trainable", get: function() {
          return this.trainable_;
        }, set: function(e11) {
          this.trainable_ = e11, this.val.trainable = e11;
        } }]), e10;
      }();
      function vce(e10) {
        return e10.map(function(e11) {
          return e11.read();
        });
      }
      function mce(e10) {
        e10.forEach(function(e11) {
          e11[0].write(e11[1]);
        });
      }
      var gce = p(function e10(t10) {
        l(this, e10), this.dtype = t10.dtype, this.shape = t10.shape, null != t10.shape ? this.ndim = t10.shape.length : this.ndim = t10.ndim, this.maxNDim = t10.maxNDim, this.minNDim = t10.minNDim, this.axes = t10.axes || {};
      }), yce = p(function e10(t10, n10, r10, a10, i10, o10, s10) {
        l(this, e10), this.dtype = t10, this.shape = n10, this.sourceLayer = r10, this.inputs = a10, this.callArgs = i10, this.outputTensorIndex = s10, this.id = Qse(), null != o10 && (this.originalName = pue(o10), this.name = fue(this.originalName)), this.rank = n10.length;
      }), bce = 0, xce = function() {
        function e10(t10, n10) {
          l(this, e10), this.callArgs = n10, this.id = bce++, this.outboundLayer = t10.outboundLayer, this.inboundLayers = t10.inboundLayers, this.nodeIndices = t10.nodeIndices, this.tensorIndices = t10.tensorIndices, this.inputTensors = t10.inputTensors, this.outputTensors = t10.outputTensors, this.inputMasks = t10.inputMasks, this.outputMasks = t10.outputMasks, this.inputShapes = t10.inputShapes, this.outputShapes = t10.outputShapes;
          var r10, a10 = O(t10.inboundLayers);
          try {
            for (a10.s(); !(r10 = a10.n()).done; ) {
              var i10 = r10.value;
              null != i10 && i10.outboundNodes.push(this);
            }
          } catch (e11) {
            a10.e(e11);
          } finally {
            a10.f();
          }
          t10.outboundLayer.inboundNodes.push(this);
        }
        return p(e10, [{ key: "getConfig", value: function() {
          var e11, t10 = [], n10 = O(this.inboundLayers);
          try {
            for (n10.s(); !(e11 = n10.n()).done; ) {
              var r10 = e11.value;
              null != r10 ? t10.push(r10.name) : t10.push(null);
            }
          } catch (e12) {
            n10.e(e12);
          } finally {
            n10.f();
          }
          return { outboundLayer: this.outboundLayer ? this.outboundLayer.name : null, inboundLayers: t10, nodeIndices: this.nodeIndices, tensorIndices: this.tensorIndices };
        } }]), e10;
      }(), kce = 0, wce = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          var e11, r10 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          l(this, n10), (e11 = t10.call(this))._callHook = null, e11._addedWeightNames = [], e11._stateful = false, e11.id = kce++, e11.activityRegularizer = null, e11.inputSpec = null, e11.supportsMasking = false, e11._trainableWeights = [], e11._nonTrainableWeights = [], e11._losses = [], e11._updates = [], e11._built = false, e11.inboundNodes = [], e11.outboundNodes = [];
          var a10 = r10.name;
          if (!a10) {
            var i10 = e11.getClassName();
            a10 = zse(i10) + "_" + eue(i10);
          }
          if (e11.name = a10, e11.trainable_ = null == r10.trainable || r10.trainable, null != r10.inputShape || null != r10.batchInputShape) {
            var o10;
            if (null != r10.batchInputShape) o10 = r10.batchInputShape;
            else if (null != r10.inputShape) {
              var s10 = null;
              null != r10.batchSize && (s10 = r10.batchSize), o10 = [s10].concat(r10.inputShape);
            }
            e11.batchInputShape = o10;
            var u10 = r10.dtype;
            null == u10 && (u10 = r10.inputDType), null == u10 && (u10 = "float32"), e11.dtype = u10;
          }
          return null != r10.weights ? e11.initialWeights = r10.weights : e11.initialWeights = null, e11._refCount = null, e11.fastWeightInitDuringBuild = false, e11;
        }
        return p(n10, [{ key: "getNodeAtIndex", value: function(e11, t11) {
          if (0 === this.inboundNodes.length) throw new Ese("The layer has never been called " + "and thus has no defined ".concat(t11, "."));
          if (this.inboundNodes.length <= e11) throw new Cse("Asked to get ".concat(t11, " at node ").concat(e11, ", ") + "but the layer has only ".concat(this.inboundNodes.length, " inbound nodes."));
          return this.inboundNodes[e11];
        } }, { key: "getInputAt", value: function(e11) {
          return Mse(this.getNodeAtIndex(e11, "input").inputTensors);
        } }, { key: "getOutputAt", value: function(e11) {
          return Mse(this.getNodeAtIndex(e11, "output").outputTensors);
        } }, { key: "input", get: function() {
          if (this.inboundNodes.length > 1) throw new Tse("Layer ".concat(this.name) + ' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');
          if (0 === this.inboundNodes.length) throw new Tse("Layer ".concat(this.name) + " is not connected, no input to return.");
          return Mse(this.getNodeAtIndex(0, "input").inputTensors);
        } }, { key: "output", get: function() {
          if (0 === this.inboundNodes.length) throw new Tse("Layer ".concat(this.name) + " has no inbound nodes.");
          if (this.inboundNodes.length > 1) throw new Tse("Layer ".concat(this.name) + ' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');
          return Mse(this.getNodeAtIndex(0, "output").outputTensors);
        } }, { key: "losses", get: function() {
          return this._losses;
        } }, { key: "calculateLosses", value: function() {
          return this.losses.map(function(e11) {
            return e11();
          });
        } }, { key: "updates", get: function() {
          return this._updates;
        } }, { key: "built", get: function() {
          return this._built;
        }, set: function(e11) {
          this._built = e11;
        } }, { key: "trainable", get: function() {
          return this.trainable_;
        }, set: function(e11) {
          this._trainableWeights.forEach(function(t11) {
            return t11.trainable = e11;
          }), this.trainable_ = e11;
        } }, { key: "trainableWeights", get: function() {
          return this.trainable_ ? this._trainableWeights.filter(function(e11) {
            return e11.trainable;
          }) : [];
        }, set: function(e11) {
          this._trainableWeights = e11;
        } }, { key: "nonTrainableWeights", get: function() {
          return this.trainable ? this._trainableWeights.filter(function(e11) {
            return !e11.trainable;
          }).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights);
        }, set: function(e11) {
          this._nonTrainableWeights = e11;
        } }, { key: "weights", get: function() {
          return this.trainableWeights.concat(this.nonTrainableWeights);
        } }, { key: "stateful", get: function() {
          return this._stateful;
        } }, { key: "resetStates", value: function() {
          if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
        } }, { key: "assertInputCompatibility", value: function(e11) {
          var t11 = Lse(e11);
          if (null != this.inputSpec && 0 !== this.inputSpec.length) {
            var n11 = Lse(this.inputSpec);
            if (t11.length !== n11.length) throw new Cse("Layer ".concat(this.name, " expects ").concat(n11.length, " inputs, ") + "but it received ".concat(t11.length, " input tensors. ") + "Input received: ".concat(e11));
            for (var r10 = 0; r10 < t11.length; r10++) {
              var a10 = t11[r10], i10 = n11[r10];
              if (null != i10) {
                var o10 = a10.rank;
                if (null != i10.ndim && o10 !== i10.ndim) throw new Cse("Input ".concat(r10, " is incompatible with layer ").concat(this.name, ": ") + "expected ndim=".concat(i10.ndim, ", found ndim=").concat(o10));
                if (null != i10.maxNDim && o10 > i10.maxNDim) throw new Cse("Input ".concat(r10, " is incompatible with layer ").concat(this.name) + ": expected max_ndim=".concat(i10.maxNDim, ", found ndim=").concat(o10));
                if (null != i10.minNDim && o10 < i10.minNDim) throw new Cse("Input ".concat(r10, " is incompatible with layer ").concat(this.name) + ": expected min_ndim=".concat(i10.minNDim, ", found ndim=").concat(o10, "."));
                if (null != i10.dtype && a10.dtype !== i10.dtype) throw new Cse("Input ".concat(r10, " is incompatible with layer ").concat(this.name, " ") + ": expected dtype=".concat(i10.dtype, ", found dtype=").concat(a10.dtype, "."));
                if (i10.axes) {
                  var s10 = a10.shape;
                  for (var u10 in i10.axes) {
                    var c10 = Number(u10), l10 = i10.axes[u10], h10 = c10 >= 0 ? s10[c10] : s10[s10.length + c10];
                    if (null != l10 && -1 === [l10, null].indexOf(h10)) throw new Cse("Input ".concat(r10, " is incompatible with layer ") + "".concat(this.name, ": expected axis ").concat(c10, " of input shape to ") + "have value ".concat(l10, " but got shape ").concat(s10, "."));
                  }
                }
                if (null != i10.shape) for (var p10 = 0; p10 < i10.shape.length; ++p10) {
                  var f10 = i10.shape[p10], d10 = a10.shape[p10];
                  if (null != f10 && null != d10 && f10 !== d10) throw new Cse("Input ".concat(r10, " is incompatible with layer ") + "".concat(this.name, ": expected shape=").concat(i10.shape, ", ") + "found shape=".concat(a10.shape, "."));
                }
              }
            }
          }
        } }, { key: "call", value: function(e11, t11) {
          return e11;
        } }, { key: "invokeCallHook", value: function(e11, t11) {
          null != this._callHook && this._callHook(e11, t11);
        } }, { key: "setCallHook", value: function(e11) {
          this._callHook = e11;
        } }, { key: "clearCallHook", value: function() {
          this._callHook = null;
        } }, { key: "apply", value: function(e11, t11) {
          var n11 = this;
          t11 = t11 || {}, this.assertNotDisposed();
          var r10 = Lse(e11), a10 = function(e12) {
            var t12, n12 = true, r11 = O(Lse(e12));
            try {
              for (r11.s(); !(t12 = r11.n()).done; ) {
                if (!(t12.value instanceof yce)) {
                  n12 = false;
                  break;
                }
              }
            } catch (e13) {
              r11.e(e13);
            } finally {
              r11.f();
            }
            return n12;
          }(e11), i10 = function(e12) {
            var t12, n12 = true, r11 = O(Lse(e12));
            try {
              for (r11.s(); !(t12 = r11.n()).done; ) {
                if (t12.value instanceof yce) {
                  n12 = false;
                  break;
                }
              }
            } catch (e13) {
              r11.e(e13);
            } finally {
              r11.f();
            }
            return n12;
          }(e11);
          if (a10 === i10) throw new Cse("Arguments to apply() must be all SymbolicTensors or all Tensors");
          return hue(this.name, function() {
            if (!n11.built) {
              n11.assertInputCompatibility(e11);
              var a11, o10 = [], s10 = O(Lse(e11));
              try {
                for (s10.s(); !(a11 = s10.n()).done; ) {
                  var u10 = a11.value;
                  o10.push(u10.shape);
                }
              } catch (e12) {
                s10.e(e12);
              } finally {
                s10.f();
              }
              n11.build(Mse(o10)), n11.built = true, n11.initialWeights && n11.setWeights(n11.initialWeights), null === n11._refCount && i10 && (n11._refCount = 1);
            }
            if (n11.assertInputCompatibility(e11), i10) {
              var c10 = n11.call(e11, t11);
              n11.supportsMasking && n11.setMaskMetadata(e11, c10);
              var l10, h10 = [], p10 = O(Lse(c10));
              try {
                for (p10.s(); !(l10 = p10.n()).done; ) {
                  var f10 = l10.value;
                  -1 !== r10.indexOf(f10) && (f10 = f10.clone()), h10.push(f10);
                }
              } catch (e12) {
                p10.e(e12);
              } finally {
                p10.f();
              }
              if (c10 = Mse(h10), null != n11.activityRegularizer) throw new Ase("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
              return c10;
            }
            var d10, v10 = function(e12) {
              e12 = Lse(e12);
              var t12, n12 = [], r11 = O(e12);
              try {
                for (r11.s(); !(t12 = r11.n()).done; ) {
                  var a12 = t12.value;
                  n12.push(a12.shape);
                }
              } catch (e13) {
                r11.e(e13);
              } finally {
                r11.f();
              }
              return Mse(n12);
            }(e11), m10 = n11.computeOutputShape(v10), g10 = "float32";
            if (n11.warnOnIncompatibleInputShape(Array.isArray(e11) ? v10[0] : v10), d10 = null != m10 && m10.length > 0 && Array.isArray(m10[0]) ? m10.map(function(r11, a12) {
              return new yce(g10, r11, n11, Lse(e11), t11, n11.name, a12);
            }) : new yce(g10, m10, n11, Lse(e11), t11, n11.name), n11.addInboundNode(e11, d10, null, null, v10, m10, t11), n11._refCount++, null != n11.activityRegularizer) throw new Ase("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
            return d10;
          });
        } }, { key: "warnOnIncompatibleInputShape", value: function(e11) {
          if (null != this.batchInputShape) if (e11.length !== this.batchInputShape.length) console.warn("The rank of the input tensor provided (shape: " + "".concat(JSON.stringify(e11), ") does not match that of the ") + "batchInputShape (".concat(JSON.stringify(this.batchInputShape), ") ") + "of the layer ".concat(this.name));
          else {
            var t11 = false;
            this.batchInputShape.forEach(function(n11, r10) {
              null != n11 && null != e11[r10] && e11[r10] !== n11 && (t11 = true);
            }), t11 && console.warn("The shape of the input tensor " + "(".concat(JSON.stringify(e11), ") does not ") + "match the expectation of layer ".concat(this.name, ": ") + "".concat(JSON.stringify(this.batchInputShape)));
          }
        } }, { key: "outputShape", get: function() {
          if (null == this.inboundNodes || 0 === this.inboundNodes.length) throw new Tse("The layer ".concat(this.name, " has never been called and thus has no ") + "defined output shape.");
          var e11, t11 = [], n11 = O(this.inboundNodes);
          try {
            for (n11.s(); !(e11 = n11.n()).done; ) {
              var r10 = e11.value, a10 = JSON.stringify(r10.outputShapes);
              -1 === t11.indexOf(a10) && t11.push(a10);
            }
          } catch (e12) {
            n11.e(e12);
          } finally {
            n11.f();
          }
          if (1 === t11.length) {
            var i10 = this.inboundNodes[0].outputShapes;
            return Array.isArray(i10) && Array.isArray(i10[0]) && 1 === i10.length ? i10[0] : i10;
          }
          throw new Tse("The layer ".concat(this.name, " has multiple inbound nodes with different ") + 'output shapes. Hence the notion of "output shape" is ill-defined for the layer.');
        } }, { key: "countParams", value: function() {
          if (!this.built) throw new Ese("You tried to call countParams() on ".concat(this.name, ", ") + "but the layer is not built yet. Build it first by calling build(batchInputShape).");
          return pce(this.weights);
        } }, { key: "build", value: function(e11) {
          this.built = true;
        } }, { key: "getWeights", value: function() {
          var e11 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return vce(e11 ? this.trainableWeights : this.weights);
        } }, { key: "setWeights", value: function(e11) {
          var t11 = this;
          X5(function() {
            var n11 = t11.weights;
            if (n11.length !== e11.length) throw new Cse('You called setWeights(weights) on layer "'.concat(t11.name, '" ') + "with a weight list of length ".concat(e11.length, ", ") + "but the layer was expecting ".concat(n11.length, " weights. ") + "Provided weights: ".concat(e11, "..."));
            if (0 !== n11.length) {
              for (var r10 = [], a10 = vce(n11), i10 = 0; i10 < a10.length; ++i10) {
                var o10 = a10[i10], s10 = n11[i10], u10 = e11[i10];
                if (!P$(o10.shape, u10.shape)) throw new Cse("Layer weight shape ".concat(o10.shape, " ") + "not compatible with provided weight shape ".concat(u10.shape));
                r10.push([s10, u10]);
              }
              mce(r10);
            }
          });
        } }, { key: "addWeight", value: function(e11, t11, n11, r10, a10, i10, o10, s10) {
          if (-1 !== this._addedWeightNames.indexOf(e11)) throw new Cse("Duplicate weight name ".concat(e11, " for layer ").concat(this.name));
          this._addedWeightNames.push(e11), null == n11 && (n11 = "float32"), this.fastWeightInitDuringBuild && (r10 = null != s10 ? s10() : sce("zeros"));
          var u10 = r10.apply(t11, n11), c10 = new dce(u10, n11, e11, i10, o10);
          return u10.dispose(), null != a10 && this.addLoss(function() {
            return a10.apply(c10.read());
          }), null == i10 && (i10 = true), i10 ? this._trainableWeights.push(c10) : this._nonTrainableWeights.push(c10), c10;
        } }, { key: "setFastWeightInitDuringBuild", value: function(e11) {
          this.fastWeightInitDuringBuild = e11;
        } }, { key: "addLoss", value: function(e11) {
          var t11;
          null == e11 || Array.isArray(e11) && 0 === e11.length || (e11 = Lse(e11), void 0 !== this._losses && null !== this._losses && (t11 = this.losses).push.apply(t11, T(e11)));
        } }, { key: "computeOutputShape", value: function(e11) {
          return e11;
        } }, { key: "computeMask", value: function(e11, t11) {
          var n11 = this;
          if (!this.supportsMasking) {
            if (null != t11) {
              if (!Array.isArray(t11)) throw new TypeError("Layer ".concat(this.name, " does not support masking, ") + "but was passed an inputMask.");
              t11.forEach(function(e12) {
                if (null != e12) throw new TypeError("Layer ".concat(n11.name, " does not support masking, ") + "but was passed an inputMask.");
              });
            }
            return null;
          }
          return t11;
        } }, { key: "setMaskMetadata", value: function(e11, t11, n11) {
          if (this.supportsMasking) {
            var r10 = this.computeMask(e11, n11), a10 = Lse(t11), i10 = Lse(r10);
            if (a10.length !== i10.length) throw new Error("".concat(this.name, " outputs ").concat(a10.length, " tensors ") + "but ".concat(a10.length, " masks for those tensors"));
            for (var o10 = 0; o10 < a10.length; o10++) a10[o10].kerasMask = i10[o10];
          }
        } }, { key: "addInboundNode", value: function(e11, t11, n11, r10, a10, i10) {
          var o10 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, s10 = Lse(e11);
          t11 = Lse(t11), n11 = Lse(n11), r10 = Lse(r10), a10 = cce(a10), i10 = cce(i10);
          var u10, c10 = [], l10 = [], h10 = [], p10 = O(s10);
          try {
            for (p10.s(); !(u10 = p10.n()).done; ) {
              var f10 = u10.value;
              c10.push(f10.sourceLayer), l10.push(f10.nodeIndex), h10.push(f10.tensorIndex);
            }
          } catch (e12) {
            p10.e(e12);
          } finally {
            p10.f();
          }
          new xce({ outboundLayer: this, inboundLayers: c10, nodeIndices: l10, tensorIndices: h10, inputTensors: s10, outputTensors: t11, inputMasks: n11, outputMasks: r10, inputShapes: a10, outputShapes: i10 }, o10);
          for (var d10 = 0; d10 < t11.length; d10++) t11[d10].sourceLayer = this, t11[d10].nodeIndex = this.inboundNodes.length - 1, t11[d10].tensorIndex = d10;
        } }, { key: "getConfig", value: function() {
          var e11 = { name: this.name, trainable: this.trainable };
          return null != this.batchInputShape && (e11.batchInputShape = this.batchInputShape), null != this.dtype && (e11.dtype = this.dtype), e11;
        } }, { key: "disposeWeights", value: function() {
          return this.weights.forEach(function(e11) {
            return e11.dispose();
          }), this.weights.length;
        } }, { key: "assertNotDisposed", value: function() {
          if (0 === this._refCount) throw new Error("Layer '".concat(this.name, "' is already disposed."));
        } }, { key: "dispose", value: function() {
          if (!this.built) throw new Error("Cannot dispose Layer ".concat(this.name, " because it has not been ") + "built yet.");
          if (null === this._refCount) throw new Error("Cannot dispose Layer ".concat(this.name, " because it has not been used ") + "yet.");
          this.assertNotDisposed();
          var e11 = 0;
          return 0 == --this._refCount && (e11 = this.disposeWeights()), { refCountAfterDispose: this._refCount, numDisposedVariables: e11 };
        } }], [{ key: "nodeKey", value: function(e11, t11) {
          return e11.name + "_ib-" + t11.toString();
        } }]), n10;
      }(Hre);
      function Ice(e10, t10, n10) {
        if ((null == t10 || null != n10 && n10 > 0) && (t10 = e10.sourceLayer, n10 = e10.nodeIndex), 0 === t10.inboundNodes.length) return [e10];
        var r10 = t10.inboundNodes[n10];
        if (0 === r10.inboundLayers.length) return r10.inputTensors;
        for (var a10 = [], i10 = 0; i10 < r10.inboundLayers.length; i10++) {
          var o10, s10 = O(Ice(r10.inputTensors[i10], r10.inboundLayers[i10], r10.nodeIndices[i10]));
          try {
            for (s10.s(); !(o10 = s10.n()).done; ) {
              var u10 = o10.value;
              -1 === a10.indexOf(u10) && a10.push(u10);
            }
          } catch (e11) {
            s10.e(e11);
          } finally {
            s10.f();
          }
        }
        return a10;
      }
      var Nce = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), r10 = t10.call(this, { dtype: e11.dtype, name: null != e11.name ? e11.name : eue("input").toString() }), null == e11.batchSize && (e11.batchSize = null), null == e11.sparse && (e11.sparse = false), r10.trainable = false, r10.built = true, r10.sparse = e11.sparse, null != e11.inputShape && null != e11.batchInputShape) throw new Cse("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
          var a10 = e11.batchInputShape;
          if (null == a10) {
            if (null == e11.inputShape) throw new Cse("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
            a10 = [e11.batchSize].concat(e11.inputShape);
          } else if (null != e11.batchSize) throw new Cse("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
          var i10 = e11.dtype || "float32";
          r10.batchInputShape = a10, r10.dtype = i10, r10.inputSpec = [{ shape: a10 }];
          var o10 = new yce(r10.dtype, r10.batchInputShape, x(r10), [], {}, r10.name);
          return o10.nodeIndex = 0, o10.tensorIndex = 0, new xce({ outboundLayer: x(r10), inboundLayers: [], nodeIndices: [], tensorIndices: [], inputTensors: [o10], outputTensors: [o10], inputMasks: [null], outputMasks: [null], inputShapes: [a10], outputShapes: [a10] }), r10;
        }
        return p(n10, [{ key: "apply", value: function(e11, t11) {
          throw new Cse("Cannot pass any input to an " + "InputLayer's apply() method. InputLayer name: ".concat(this.name));
        } }, { key: "dispose", value: function() {
          return { refCountAfterDispose: this._refCount, numDisposedVariables: 0 };
        } }, { key: "getConfig", value: function() {
          return { batchInputShape: this.batchInputShape, dtype: this.dtype, sparse: this.sparse, name: this.name };
        } }]), n10;
      }(wce);
      function Sce(e10) {
        if (null == e10.batchShape && null == e10.shape) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
        if (null != e10.batchShape && null != e10.shape) throw new Cse("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
        var t10 = e10.batchShape;
        null != e10.shape && null == t10 && (t10 = [null].concat(e10.shape));
        var n10 = e10.dtype;
        return null == n10 && (n10 = "float32"), new Nce({ batchInputShape: t10, name: e10.name, dtype: n10, sparse: e10.sparse }).inboundNodes[0].outputTensors[0];
      }
      Nce.className = "InputLayer", Kre(Nce);
      var Tce = function() {
        function e10(t10) {
          if (l(this, e10), this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, t10 instanceof e10) for (var n10 in t10.id2Value) this.id2Value[n10] = t10.id2Value[n10], n10 in t10.id2Mask && (this.id2Mask[n10] = t10.id2Mask[n10]);
          else {
            if (null == t10) return;
            var r10, a10 = O(t10);
            try {
              for (a10.s(); !(r10 = a10.n()).done; ) {
                var i10 = r10.value;
                this.add(i10.key, i10.value);
              }
            } catch (e11) {
              a10.e(e11);
            } finally {
              a10.f();
            }
          }
        }
        return p(e10, [{ key: "add", value: function(e11, t10, n10) {
          if (null != this.id2Value[e11.id]) throw new Cse("Duplicate key: name=".concat(e11.name, ", id=").concat(e11.id));
          return this.id2Value[e11.id] = function(e12, t11) {
            if (null == e12.dtype || e12.dtype === t11.dtype) return t11;
            try {
              return h8(t11, e12.dtype);
            } catch (n11) {
              throw new Cse("The dtype of the feed (".concat(t11.dtype, ") can not be cast to the dtype ") + "of the key '".concat(e12.name, "' (").concat(e12.dtype, ")."));
            }
          }(e11, t10), this.name2Id[e11.name] = e11.id, null != n10 && (this.id2Mask[e11.id] = n10), this;
        } }, { key: "addFeed", value: function(e11) {
          this.add(e11.key, e11.value);
        } }, { key: "hasKey", value: function(e11) {
          return null != this.id2Value[e11.id];
        } }, { key: "names", value: function() {
          return Object.keys(this.name2Id);
        } }, { key: "getValue", value: function(e11) {
          if (e11 instanceof yce) {
            if (null == this.id2Value[e11.id]) throw new Cse("Nonexistent key: ".concat(e11.name));
            return this.id2Value[e11.id];
          }
          var t10 = this.name2Id[e11];
          if (null == t10) throw new Cse("Feed dict has no SymbolicTensor name: ".concat(e11));
          return this.id2Value[t10];
        } }, { key: "getMask", value: function(e11) {
          if (e11 instanceof yce) {
            if (null == this.id2Value[e11.id]) throw new Cse("Nonexistent key: ".concat(e11.name));
            return this.id2Mask[e11.id];
          }
          var t10 = this.name2Id[e11];
          if (null == t10) throw new Cse("Feed dict has no SymbolicTensor name: ".concat(e11));
          return this.id2Mask[t10];
        } }, { key: "disposeMasks", value: function() {
          null != this.id2Mask && Y5(this.id2Mask);
        } }]), e10;
      }(), Ece = new _se(), Cce = new _se();
      function Ace(e10, t10, n10, r10) {
        var a10, i10 = null != n10 && n10.training, o10 = Array.isArray(e10), s10 = o10 ? e10 : [e10], u10 = s10.map(function(e11) {
          return e11.name;
        }), c10 = [], l10 = t10.names(), h10 = O(u10);
        try {
          for (h10.s(); !(a10 = h10.n()).done; ) {
            var p10 = a10.value;
            -1 !== l10.indexOf(p10) ? c10.push(t10.getValue(p10)) : c10.push(null);
          }
        } catch (e11) {
          h10.e(e11);
        } finally {
          h10.f();
        }
        null != r10 && (r10.maxNumTensors = -1 / 0, r10.minNumTensors = 1 / 0);
        var f10, d10 = u10.join(",") + "|" + t10.names().sort().join(","), v10 = Ece.get(d10);
        if (null == v10) {
          var m10 = function(e11, t11) {
            F$(null != e11 && e11.length > 0, function() {
              return "Expected at least one fetch, got none";
            });
            var n11 = [], r11 = {};
            if (1 === e11.length) {
              var a11 = _ce(e11[0], t11);
              n11 = a11.sorted, r11 = a11.recipientMap;
            } else {
              var i11, o11 = /* @__PURE__ */ new Set(), s11 = O(e11);
              try {
                for (s11.s(); !(i11 = s11.n()).done; ) {
                  var u11, c11 = _ce(i11.value, t11), l11 = c11.sorted, h11 = c11.recipientMap, p11 = O(l11);
                  try {
                    for (p11.s(); !(u11 = p11.n()).done; ) {
                      var f11 = u11.value;
                      o11.has(f11.name) || (n11.push(f11), o11.add(f11.name));
                    }
                  } catch (e12) {
                    p11.e(e12);
                  } finally {
                    p11.f();
                  }
                  var d11 = function(e12) {
                    null == r11[e12] && (r11[e12] = /* @__PURE__ */ new Set()), h11[e12].forEach(function(t12) {
                      return r11[e12].add(t12);
                    });
                  };
                  for (var v11 in h11) d11(v11);
                }
              } catch (e12) {
                s11.e(e12);
              } finally {
                s11.f();
              }
            }
            return { sorted: n11, recipientCounts: Rce(r11) };
          }(s10, t10);
          v10 = m10.sorted, f10 = m10.recipientCounts, Ece.put(d10, v10), Cce.put(d10, f10);
        }
        f10 = {}, i10 || Object.assign(f10, Cce.get(d10));
        for (var g10 = new Tce(t10), y10 = 0; y10 < v10.length; ++y10) {
          if (null != r10) {
            var b10 = K5().numTensors;
            b10 > r10.maxNumTensors && (r10.maxNumTensors = b10), b10 < r10.minNumTensors && (r10.minNumTensors = b10);
          }
          var x10 = v10[y10], k10 = x10.sourceLayer;
          if (!(k10 instanceof Nce)) {
            var w10, I10 = [], N10 = [], S10 = [], T10 = false, E10 = O(x10.inputs);
            try {
              for (E10.s(); !(w10 = E10.n()).done; ) {
                var C10 = w10.value, A10 = g10.getValue(C10), R10 = g10.getMask(C10);
                I10.push(A10), N10.push(R10), null != R10 && (T10 = true), i10 || (f10[C10.name]--, 0 !== f10[C10.name] || t10.hasKey(C10) || -1 !== u10.indexOf(C10.name) || A10.isDisposed || true === C10.sourceLayer.stateful || S10.push(A10));
              }
            } catch (e11) {
              E10.e(e11);
            } finally {
              E10.f();
            }
            T10 && ((n10 = n10 || {}).mask = N10[0]);
            var _10 = Lse(k10.apply(I10, n10)), F10 = null;
            k10.supportsMasking && (F10 = k10.computeMask(I10, N10));
            for (var D10 = Oce(x10), M10 = Array.isArray(D10) ? D10 : [D10], L10 = 0; L10 < M10.length; ++L10) {
              g10.hasKey(M10[L10]) || g10.add(M10[L10], _10[L10], Array.isArray(F10) ? F10[0] : F10);
              var z10 = u10.indexOf(M10[L10].name);
              -1 !== z10 && (c10[z10] = _10[L10]);
            }
            i10 || Y5(S10);
          }
        }
        return g10.disposeMasks(), o10 ? c10 : c10[0];
      }
      function Rce(e10) {
        var t10 = {};
        for (var n10 in e10) t10[n10] = e10[n10].size;
        return t10;
      }
      function _ce(e10, t10) {
        var n10, r10 = /* @__PURE__ */ new Set(), a10 = [], i10 = {}, o10 = O(t10.names());
        try {
          for (o10.s(); !(n10 = o10.n()).done; ) {
            var s10 = n10.value;
            r10.add(s10);
          }
        } catch (e11) {
          o10.e(e11);
        } finally {
          o10.f();
        }
        var u10 = [], c10 = [];
        for (u10.push(e10); u10.length > 0; ) {
          var l10 = u10[u10.length - 1];
          if (r10.has(l10.name)) u10.pop();
          else {
            var h10 = c10[c10.length - 1] === u10.length - 1;
            if (0 === l10.inputs.length || h10) u10.pop(), a10.push(l10), r10.add(l10.name), h10 && c10.pop();
            else {
              c10.push(u10.length - 1);
              var p10, f10 = O(l10.inputs);
              try {
                for (f10.s(); !(p10 = f10.n()).done; ) {
                  var d10 = p10.value;
                  null == i10[d10.name] && (i10[d10.name] = /* @__PURE__ */ new Set()), i10[d10.name].add(l10.name), r10.has(d10.name) || u10.push(d10);
                }
              } catch (e11) {
                f10.e(e11);
              } finally {
                f10.f();
              }
            }
          }
        }
        return { sorted: a10, recipientMap: i10 };
      }
      function Oce(e10) {
        var t10;
        if (1 === e10.sourceLayer.inboundNodes.length) t10 = e10.sourceLayer.output;
        else {
          for (var n10 = null, r10 = 0; r10 < e10.sourceLayer.inboundNodes.length; ++r10) {
            var a10, i10 = O(e10.sourceLayer.inboundNodes[r10].outputTensors);
            try {
              for (i10.s(); !(a10 = i10.n()).done; ) {
                if (a10.value.id === e10.id) {
                  n10 = r10;
                  break;
                }
              }
            } catch (e11) {
              i10.e(e11);
            } finally {
              i10.f();
            }
          }
          t10 = e10.sourceLayer.getOutputAt(n10);
        }
        return t10;
      }
      function Fce(e10, t10) {
        return X5(function() {
          return o9(u9(g8(e10, e10), t10, true));
        });
      }
      k0().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES", function() {
        return 100;
      }, function(e10) {
        null != Ece && Ece.setMaxEntries(e10), null != Cce && Cce.setMaxEntries(e10);
      });
      var Dce = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "getConfig", value: function() {
          return {};
        } }]), n10;
      }(Hre), Mce = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this)).defaultMaxValue = 2, r10.defaultAxis = 0, r10.maxValue = null != e11.maxValue ? e11.maxValue : r10.defaultMaxValue, r10.axis = null != e11.axis ? e11.axis : r10.defaultAxis, r10;
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          var t11 = this;
          return X5(function() {
            var n11 = Fce(e11, t11.axis), r10 = d7(n11, 0, t11.maxValue);
            return g8(e11, m8(r10, d8(kue(), n11)));
          });
        } }, { key: "getConfig", value: function() {
          return { maxValue: this.maxValue, axis: this.axis };
        } }]), n10;
      }(Dce);
      Mce.className = "MaxNorm", Kre(Mce);
      var Lce = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this)).defaultAxis = 0, r10.axis = null != e11.axis ? e11.axis : r10.defaultAxis, r10;
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          var t11 = this;
          return X5(function() {
            return m8(e11, d8(kue(), Fce(e11, t11.axis)));
          });
        } }, { key: "getConfig", value: function() {
          return { axis: this.axis };
        } }]), n10;
      }(Dce);
      Lce.className = "UnitNorm", Kre(Lce);
      var zce = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          return lte(e11);
        } }]), n10;
      }(Dce);
      zce.className = "NonNeg", Kre(zce);
      var Pce = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this)).defaultMinValue = 0, r10.defaultMaxValue = 1, r10.defaultRate = 1, r10.defaultAxis = 0, r10.minValue = null != e11.minValue ? e11.minValue : r10.defaultMinValue, r10.maxValue = null != e11.maxValue ? e11.maxValue : r10.defaultMaxValue, r10.rate = null != e11.rate ? e11.rate : r10.defaultRate, r10.axis = null != e11.axis ? e11.axis : r10.defaultAxis, r10;
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          var t11 = this;
          return X5(function() {
            var n11 = Fce(e11, t11.axis), r10 = d8(g8(t11.rate, d7(n11, t11.minValue, t11.maxValue)), g8(1 - t11.rate, n11));
            return g8(e11, m8(r10, d8(kue(), n11)));
          });
        } }, { key: "getConfig", value: function() {
          return { minValue: this.minValue, maxValue: this.maxValue, rate: this.rate, axis: this.axis };
        } }]), n10;
      }(Dce);
      Pce.className = "MinMaxNorm", Kre(Pce);
      var Bce = { maxNorm: "MaxNorm", minMaxNorm: "MinMaxNorm", nonNeg: "NonNeg", unitNorm: "UnitNorm" };
      function Wce(e10) {
        return Wse(e10);
      }
      function Uce(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return Vse(e10, qre.getMap().classNameMap, t10, "constraint");
      }
      function Vce(e10) {
        return null == e10 ? null : "string" == typeof e10 ? Uce({ className: e10 in Bce ? Bce[e10] : e10, config: {} }) : e10 instanceof Dce ? e10 : Uce(e10);
      }
      var Gce = { __proto__: null, maxNorm: function(e10) {
        return new Mce(e10);
      }, minMaxNorm: function(e10) {
        return new Pce(e10);
      }, nonNeg: function() {
        return new zce();
      }, unitNorm: function(e10) {
        return new Lce(e10);
      } };
      var jce, Hce = { __proto__: null, constant: function(e10) {
        return new Hue(e10);
      }, glorotNormal: function(e10) {
        return new Que(e10);
      }, glorotUniform: function(e10) {
        return new Zue(e10);
      }, heNormal: function(e10) {
        return new $ue(e10);
      }, heUniform: function(e10) {
        return new ece(e10);
      }, identity: function(e10) {
        return new Yue(e10);
      }, leCunNormal: function(e10) {
        return new tce(e10);
      }, leCunUniform: function(e10) {
        return new nce(e10);
      }, ones: function() {
        return new jue();
      }, orthogonal: function(e10) {
        return new rce(e10);
      }, randomNormal: function(e10) {
        return new Kue(e10);
      }, randomUniform: function(e10) {
        return new que(e10);
      }, truncatedNormal: function(e10) {
        return new Xue(e10);
      }, varianceScaling: function(e10) {
        return new Jue(e10);
      }, zeros: function() {
        return new Gue();
      } };
      function qce(e10) {
        return Kce.apply(this, arguments);
      }
      function Kce() {
        return Kce = c(o().mark(function e10(t10) {
          var n10, r10, a10, i10, s10, u10, c10, l10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                if (null != t10) {
                  e11.next = 2;
                  break;
                }
                return e11.abrupt("return");
              case 2:
                for (i10 in n10 = [], r10 = [], a10 = [], t10) "number" != typeof (s10 = t10[i10]) && (u10 = s10, n10.push(u10.data()), r10.push(i10), a10.push(u10));
                if (!(n10.length > 0)) {
                  e11.next = 12;
                  break;
                }
                return e11.next = 9, Promise.all(n10);
              case 9:
                for (c10 = e11.sent, l10 = 0; l10 < c10.length; ++l10) t10[r10[l10]] = c10[l10][0];
                Y5(a10);
              case 12:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), Kce.apply(this, arguments);
      }
      function Xce(e10) {
        if (null != e10) for (var t10 in e10) {
          var n10 = e10[t10];
          "number" != typeof n10 && n10.dispose();
        }
      }
      !function(e10) {
        e10[e10.SILENT = 0] = "SILENT", e10[e10.VERBOSE = 1] = "VERBOSE";
      }(jce || (jce = {}));
      var Yce = function() {
        function e10() {
          l(this, e10), this.validationData = null;
        }
        var t10, n10, r10, a10, i10, s10;
        return p(e10, [{ key: "setParams", value: function(e11) {
          this.params = e11;
        } }, { key: "onEpochBegin", value: (s10 = c(o().mark(function e11(t11, n11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
              case "end":
                return e12.stop();
            }
          }, e11);
        })), function(e11, t11) {
          return s10.apply(this, arguments);
        }) }, { key: "onEpochEnd", value: (i10 = c(o().mark(function e11(t11, n11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
              case "end":
                return e12.stop();
            }
          }, e11);
        })), function(e11, t11) {
          return i10.apply(this, arguments);
        }) }, { key: "onBatchBegin", value: (a10 = c(o().mark(function e11(t11, n11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
              case "end":
                return e12.stop();
            }
          }, e11);
        })), function(e11, t11) {
          return a10.apply(this, arguments);
        }) }, { key: "onBatchEnd", value: (r10 = c(o().mark(function e11(t11, n11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
              case "end":
                return e12.stop();
            }
          }, e11);
        })), function(e11, t11) {
          return r10.apply(this, arguments);
        }) }, { key: "onTrainBegin", value: (n10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
              case "end":
                return e12.stop();
            }
          }, e11);
        })), function(e11) {
          return n10.apply(this, arguments);
        }) }, { key: "onTrainEnd", value: (t10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
              case "end":
                return e12.stop();
            }
          }, e11);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "setModel", value: function(e11) {
        } }]), e10;
      }(), Jce = function() {
        function e10(t11) {
          var n11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10;
          l(this, e10), null == t11 && (t11 = []), this.callbacks = t11, this.queueLength = n11;
        }
        var t10, n10, r10, a10, i10, s10;
        return p(e10, [{ key: "append", value: function(e11) {
          this.callbacks.push(e11);
        } }, { key: "setParams", value: function(e11) {
          var t11, n11 = O(this.callbacks);
          try {
            for (n11.s(); !(t11 = n11.n()).done; ) {
              t11.value.setParams(e11);
            }
          } catch (e12) {
            n11.e(e12);
          } finally {
            n11.f();
          }
        } }, { key: "setModel", value: function(e11) {
          var t11, n11 = O(this.callbacks);
          try {
            for (n11.s(); !(t11 = n11.n()).done; ) {
              t11.value.setModel(e11);
            }
          } catch (e12) {
            n11.e(e12);
          } finally {
            n11.f();
          }
        } }, { key: "onEpochBegin", value: (s10 = c(o().mark(function e11(t11, n11) {
          var r11, a11, i11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                null == n11 && (n11 = {}), r11 = O(this.callbacks), e12.prev = 2, r11.s();
              case 4:
                if ((a11 = r11.n()).done) {
                  e12.next = 10;
                  break;
                }
                return i11 = a11.value, e12.next = 8, i11.onEpochBegin(t11, n11);
              case 8:
                e12.next = 4;
                break;
              case 10:
                e12.next = 15;
                break;
              case 12:
                e12.prev = 12, e12.t0 = e12.catch(2), r11.e(e12.t0);
              case 15:
                return e12.prev = 15, r11.f(), e12.finish(15);
              case 18:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[2, 12, 15, 18]]);
        })), function(e11, t11) {
          return s10.apply(this, arguments);
        }) }, { key: "onEpochEnd", value: (i10 = c(o().mark(function e11(t11, n11) {
          var r11, a11, i11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                null == n11 && (n11 = {}), r11 = O(this.callbacks), e12.prev = 2, r11.s();
              case 4:
                if ((a11 = r11.n()).done) {
                  e12.next = 10;
                  break;
                }
                return i11 = a11.value, e12.next = 8, i11.onEpochEnd(t11, n11);
              case 8:
                e12.next = 4;
                break;
              case 10:
                e12.next = 15;
                break;
              case 12:
                e12.prev = 12, e12.t0 = e12.catch(2), r11.e(e12.t0);
              case 15:
                return e12.prev = 15, r11.f(), e12.finish(15);
              case 18:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[2, 12, 15, 18]]);
        })), function(e11, t11) {
          return i10.apply(this, arguments);
        }) }, { key: "onBatchBegin", value: (a10 = c(o().mark(function e11(t11, n11) {
          var r11, a11, i11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                null == n11 && (n11 = {}), r11 = O(this.callbacks), e12.prev = 2, r11.s();
              case 4:
                if ((a11 = r11.n()).done) {
                  e12.next = 10;
                  break;
                }
                return i11 = a11.value, e12.next = 8, i11.onBatchBegin(t11, n11);
              case 8:
                e12.next = 4;
                break;
              case 10:
                e12.next = 15;
                break;
              case 12:
                e12.prev = 12, e12.t0 = e12.catch(2), r11.e(e12.t0);
              case 15:
                return e12.prev = 15, r11.f(), e12.finish(15);
              case 18:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[2, 12, 15, 18]]);
        })), function(e11, t11) {
          return a10.apply(this, arguments);
        }) }, { key: "onBatchEnd", value: (r10 = c(o().mark(function e11(t11, n11) {
          var r11, a11, i11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                null == n11 && (n11 = {}), r11 = O(this.callbacks), e12.prev = 2, r11.s();
              case 4:
                if ((a11 = r11.n()).done) {
                  e12.next = 10;
                  break;
                }
                return i11 = a11.value, e12.next = 8, i11.onBatchEnd(t11, n11);
              case 8:
                e12.next = 4;
                break;
              case 10:
                e12.next = 15;
                break;
              case 12:
                e12.prev = 12, e12.t0 = e12.catch(2), r11.e(e12.t0);
              case 15:
                return e12.prev = 15, r11.f(), e12.finish(15);
              case 18:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[2, 12, 15, 18]]);
        })), function(e11, t11) {
          return r10.apply(this, arguments);
        }) }, { key: "onTrainBegin", value: (n10 = c(o().mark(function e11(t11) {
          var n11, r11, a11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                null == t11 && (t11 = {}), n11 = O(this.callbacks), e12.prev = 2, n11.s();
              case 4:
                if ((r11 = n11.n()).done) {
                  e12.next = 10;
                  break;
                }
                return a11 = r11.value, e12.next = 8, a11.onTrainBegin(t11);
              case 8:
                e12.next = 4;
                break;
              case 10:
                e12.next = 15;
                break;
              case 12:
                e12.prev = 12, e12.t0 = e12.catch(2), n11.e(e12.t0);
              case 15:
                return e12.prev = 15, n11.f(), e12.finish(15);
              case 18:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[2, 12, 15, 18]]);
        })), function(e11) {
          return n10.apply(this, arguments);
        }) }, { key: "onTrainEnd", value: (t10 = c(o().mark(function e11(t11) {
          var n11, r11, a11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                null == t11 && (t11 = {}), n11 = O(this.callbacks), e12.prev = 2, n11.s();
              case 4:
                if ((r11 = n11.n()).done) {
                  e12.next = 10;
                  break;
                }
                return a11 = r11.value, e12.next = 8, a11.onTrainEnd(t11);
              case 8:
                e12.next = 4;
                break;
              case 10:
                e12.next = 15;
                break;
              case 12:
                e12.prev = 12, e12.t0 = e12.catch(2), n11.e(e12.t0);
              case 15:
                return e12.prev = 15, n11.f(), e12.finish(15);
              case 18:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[2, 12, 15, 18]]);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }]), e10;
      }(), Zce = function(e10) {
        d(i10, e10);
        var t10, n10, r10, a10 = w(i10);
        function i10() {
          return l(this, i10), a10.call(this);
        }
        return p(i10, [{ key: "onEpochBegin", value: (r10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                this.seen = 0, this.totals = {};
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return r10.apply(this, arguments);
        }) }, { key: "onBatchEnd", value: (n10 = c(o().mark(function e11(t11, n11) {
          var r11, a11, i11, s10 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                null == n11 && (n11 = {}), r11 = null == n11.size ? 0 : n11.size, this.seen += r11, a11 = o().mark(function e13(t12) {
                  var a12, i12, u10;
                  return o().wrap(function(e14) {
                    for (; ; ) switch (e14.prev = e14.next) {
                      case 0:
                        "number" == typeof (a12 = n11[t12]) ? (s10.totals.hasOwnProperty(t12) || (s10.totals[t12] = 0), s10.totals[t12] = s10.totals[t12] + a12 * r11) : (t12 in s10.totals ? i12 = s10.totals[t12] : s10.totals[t12] = 0, u10 = X5(function() {
                          return d8(s10.totals[t12], g8(a12, r11));
                        }), s10.totals[t12] = u10, null != i12 && i12.dispose());
                      case 2:
                      case "end":
                        return e14.stop();
                    }
                  }, e13);
                }), e12.t0 = o().keys(n11);
              case 5:
                if ((e12.t1 = e12.t0()).done) {
                  e12.next = 10;
                  break;
                }
                return i11 = e12.t1.value, e12.delegateYield(a11(i11), "t2", 8);
              case 8:
                e12.next = 5;
                break;
              case 10:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return n10.apply(this, arguments);
        }) }, { key: "onEpochEnd", value: (t10 = c(o().mark(function e11(t11, n11) {
          var r11, a11, i11, s10 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (null == n11) {
                  e12.next = 20;
                  break;
                }
                r11 = O(this.params.metrics), e12.prev = 2, i11 = o().mark(function e13() {
                  var t12;
                  return o().wrap(function(e14) {
                    for (; ; ) switch (e14.prev = e14.next) {
                      case 0:
                        if (t12 = a11.value, null != s10.totals[t12]) {
                          e14.next = 3;
                          break;
                        }
                        return e14.abrupt("return", "continue");
                      case 3:
                        "number" == typeof s10.totals[t12] ? n11[t12] = s10.totals[t12] / s10.seen : X5(function() {
                          var e15 = g8(m8(1, s10.seen), s10.totals[t12]);
                          n11[t12] = e15, s10.totals[t12].dispose(), J5(n11[t12]);
                        });
                      case 4:
                      case "end":
                        return e14.stop();
                    }
                  }, e13);
                }), r11.s();
              case 5:
                if ((a11 = r11.n()).done) {
                  e12.next = 12;
                  break;
                }
                return e12.delegateYield(i11(), "t0", 7);
              case 7:
                if ("continue" !== e12.t0) {
                  e12.next = 10;
                  break;
                }
                return e12.abrupt("continue", 10);
              case 10:
                e12.next = 5;
                break;
              case 12:
                e12.next = 17;
                break;
              case 14:
                e12.prev = 14, e12.t1 = e12.catch(2), r11.e(e12.t1);
              case 17:
                return e12.prev = 17, r11.f(), e12.finish(17);
              case 20:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[2, 14, 17, 20]]);
        })), function(e11, n11) {
          return t10.apply(this, arguments);
        }) }]), i10;
      }(Yce), Qce = function(e10) {
        d(i10, e10);
        var t10, n10, r10, a10 = w(i10);
        function i10() {
          return l(this, i10), a10.apply(this, arguments);
        }
        return p(i10, [{ key: "onTrainBegin", value: (r10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                this.epoch = [], this.history = {};
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return r10.apply(this, arguments);
        }) }, { key: "onEpochEnd", value: (n10 = c(o().mark(function e11(t11, n11) {
          var r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                for (r11 in null == n11 && (n11 = {}), this.epoch.push(t11), n11) null == this.history[r11] && (this.history[r11] = []), this.history[r11].push(n11[r11]);
              case 3:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return n10.apply(this, arguments);
        }) }, { key: "syncData", value: (t10 = c(o().mark(function e11() {
          var t11, n11, r11, a11, i11, s10, u10, c10, l10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                for (a11 in t11 = [], n11 = [], r11 = [], this.history) for (i11 = this.history[a11], s10 = 0; s10 < i11.length; ++s10) "number" != typeof i11[s10] && (u10 = i11[s10], t11.push(u10.data()), n11.push(a11), r11.push(s10));
                return e12.next = 6, Promise.all(t11);
              case 6:
                for (c10 = e12.sent, l10 = 0; l10 < c10.length; ++l10) this.history[n11[l10]][r11[l10]].dispose(), this.history[n11[l10]][r11[l10]] = c10[l10][0];
              case 8:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), i10;
      }(Yce), $ce = function(e10) {
        d(f10, e10);
        var t10, n10, r10, a10, i10, s10, u10, h10 = w(f10);
        function f10(e11, t11) {
          var n11;
          if (l(this, f10), (n11 = h10.call(this)).currentEpoch = 0, n11.nowFunc = e11.nowFunc, n11.nextFrameFunc = e11.nextFrameFunc || aie, n11.yieldEvery = t11 || "auto", "auto" === n11.yieldEvery && (n11.yieldEvery = 125), "never" === n11.yieldEvery && null != e11.onYield) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
          return t0(n11.yieldEvery) && (n11.maybeWait = function(e12, t12, n12) {
            var r11, a11 = null != n12 ? n12() : z4();
            return function() {
              var i11 = null != n12 ? n12() : z4();
              return i11 - a11 < t12 ? r11 : (a11 = i11, r11 = e12.apply(void 0, arguments));
            };
          }(n11.maybeWait.bind(x(n11)), n11.yieldEvery, n11.nowFunc)), n11.trainBegin = e11.onTrainBegin, n11.trainEnd = e11.onTrainEnd, n11.epochBegin = e11.onEpochBegin, n11.epochEnd = e11.onEpochEnd, n11.batchBegin = e11.onBatchBegin, n11.batchEnd = e11.onBatchEnd, n11.yield = e11.onYield, n11;
        }
        return p(f10, [{ key: "maybeWait", value: (u10 = c(o().mark(function e11(t11, n11, r11) {
          var a11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (a11 = [], null == this.yield) {
                  e12.next = 5;
                  break;
                }
                return e12.next = 4, qce(r11);
              case 4:
                a11.push(this.yield(t11, n11, r11));
              case 5:
                return a11.push(this.nextFrameFunc()), e12.next = 8, Promise.all(a11);
              case 8:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11, n11) {
          return u10.apply(this, arguments);
        }) }, { key: "onEpochBegin", value: (s10 = c(o().mark(function e11(t11, n11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (this.currentEpoch = t11, null == this.epochBegin) {
                  e12.next = 6;
                  break;
                }
                return e12.next = 4, qce(n11);
              case 4:
                return e12.next = 6, this.epochBegin(t11, n11);
              case 6:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return s10.apply(this, arguments);
        }) }, { key: "onEpochEnd", value: (i10 = c(o().mark(function e11(t11, n11) {
          var r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (r11 = [], null == this.epochEnd) {
                  e12.next = 5;
                  break;
                }
                return e12.next = 4, qce(n11);
              case 4:
                r11.push(this.epochEnd(t11, n11));
              case 5:
                return "epoch" === this.yieldEvery && r11.push(this.nextFrameFunc()), e12.next = 8, Promise.all(r11);
              case 8:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return i10.apply(this, arguments);
        }) }, { key: "onBatchBegin", value: (a10 = c(o().mark(function e11(t11, n11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (null == this.batchBegin) {
                  e12.next = 5;
                  break;
                }
                return e12.next = 3, qce(n11);
              case 3:
                return e12.next = 5, this.batchBegin(t11, n11);
              case 5:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return a10.apply(this, arguments);
        }) }, { key: "onBatchEnd", value: (r10 = c(o().mark(function e11(t11, n11) {
          var r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (r11 = [], null == this.batchEnd) {
                  e12.next = 5;
                  break;
                }
                return e12.next = 4, qce(n11);
              case 4:
                r11.push(this.batchEnd(t11, n11));
              case 5:
                return "batch" === this.yieldEvery ? r11.push(this.nextFrameFunc()) : t0(this.yieldEvery) && r11.push(this.maybeWait(this.currentEpoch, t11, n11)), e12.next = 8, Promise.all(r11);
              case 8:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return r10.apply(this, arguments);
        }) }, { key: "onTrainBegin", value: (n10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (null == this.trainBegin) {
                  e12.next = 5;
                  break;
                }
                return e12.next = 3, qce(t11);
              case 3:
                return e12.next = 5, this.trainBegin(t11);
              case 5:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return n10.apply(this, arguments);
        }) }, { key: "onTrainEnd", value: (t10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (null == this.trainEnd) {
                  e12.next = 5;
                  break;
                }
                return e12.next = 3, qce(t11);
              case 3:
                return e12.next = 5, this.trainEnd(t11);
              case 5:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }]), f10;
      }(Yce);
      function ele(e10, t10) {
        return null == e10 && (e10 = {}), e10 instanceof Yce ? [e10] : Array.isArray(e10) && e10[0] instanceof Yce ? e10 : Lse(e10).map(function(e11) {
          return new $ce(e11, t10);
        });
      }
      var tle = function() {
        function e10() {
          l(this, e10);
        }
        return p(e10, null, [{ key: "registerCallbackConstructor", value: function(t10, n10) {
          F$(t10 >= 0 && Number.isInteger(t10), function() {
            return "Verbosity level is expected to be an integer >= 0, " + "but got ".concat(t10);
          }), e10.checkForDuplicate(n10), null == e10.constructors[t10] && (e10.constructors[t10] = []), e10.constructors[t10].push(n10);
        } }, { key: "checkForDuplicate", value: function(t10) {
          for (var n10 in e10.constructors) {
            e10.constructors[+n10].forEach(function(e11) {
              if (e11 === t10) throw new Cse("Duplicate callback constructor.");
            });
          }
        } }, { key: "clear", value: function() {
          e10.constructors = {};
        } }, { key: "createCallbacks", value: function(t10) {
          var n10 = [];
          for (var r10 in e10.constructors) {
            var a10 = +r10;
            t10 >= a10 && n10.push.apply(n10, T(e10.constructors[a10]));
          }
          return n10.map(function(e11) {
            return new e11();
          });
        } }]), e10;
      }();
      function nle(e10, t10, n10, r10, a10, i10, o10, s10, u10) {
        var c10 = new Qce(), l10 = [new Zce()].concat(T(tle.createCallbacks(t10)));
        null != e10 && l10.push.apply(l10, T(e10)), l10.push(c10);
        var h10 = new Jce(l10);
        return h10.setParams({ epochs: n10, initialEpoch: r10, samples: a10, steps: i10, batchSize: o10, verbose: t10, doValidation: s10, metrics: u10 }), { callbackList: h10, history: c10 };
      }
      function rle(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return Vse(e10, qre.getMap().classNameMap, t10, "layer", n10);
      }
      function ale(e10, t10) {
        return X5(function() {
          "float32" !== e10.dtype && (e10 = h8(e10, "float32"));
          var n10 = u9(Due(e10), t10, true), r10 = f7(n10.shape, kue()), a10 = o9(Z9(n10, r10));
          return m8(e10, a10);
        });
      }
      function ile(e10, t10) {
        return X5(function() {
          return Q9(Due(P9(t10, e10)), -1);
        });
      }
      function ole(e10, t10) {
        return X5(function() {
          return Q9(y8(P9(t10, e10)), -1);
        });
      }
      function sle(e10, t10) {
        return X5(function() {
          var n10 = P9(e10, t10), r10 = d7(y8(e10), kue(), Number.MAX_VALUE), a10 = y8(m8(n10, r10));
          return g8(100, Q9(a10, -1));
        });
      }
      function ule(e10, t10) {
        return X5(function() {
          var n10 = d7(t10, kue(), Number.MAX_VALUE), r10 = R9(d8(1, n10)), a10 = d7(e10, kue(), Number.MAX_VALUE), i10 = R9(d8(1, a10));
          return Q9(Due(P9(r10, i10)), -1);
        });
      }
      function cle(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return X5(function() {
          if (n10) t10 = Rte(t10);
          else {
            var r10 = u9(t10, t10.shape.length - 1, true);
            t10 = m8(t10, r10);
          }
          return t10 = d7(t10, kue(), 1 - kue()), M9(u9(g8(h8(e10, "float32"), R9(t10)), t10.shape.length - 1));
        });
      }
      function lle(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return X5(function() {
          var r10 = h8(g9(Nue(e10)), "int32"), a10 = (t10 = d7(t10, kue(), 1 - kue())).shape;
          return cle(X8(cee(r10, a10[a10.length - 1]), a10), t10, n10);
        });
      }
      function hle(e10, t10) {
        return X5(function() {
          var n10;
          return n10 = d7(t10, kue(), 1 - kue()), n10 = R9(m8(n10, P9(1, n10))), Q9(function(e11, t11) {
            if (!P$(e11.shape, t11.shape)) throw new Cse("logits and labels must have the same shape, but got shapes " + "".concat(JSON.stringify(e11.shape), " and ").concat(JSON.stringify(t11.shape)));
            return X5(function() {
              var n11 = lte(t11), r10 = M9(y8(t11));
              return d8(P9(n11, g8(t11, e11)), _9(p9(r10)));
            });
          }(e10, n10), -1);
        });
      }
      function ple(e10, t10) {
        return X5(function() {
          var n10 = d7(e10, kue(), 1), r10 = d7(t10, kue(), 1);
          return u9(g8(e10, R9(m8(n10, r10))), -1);
        });
      }
      function fle(e10, t10) {
        return X5(function() {
          var n10 = ale(e10, -1), r10 = ale(t10, -1), a10 = g8(n10, r10);
          return M9(u9(a10, -1));
        });
      }
      tle.constructors = {};
      var dle = { meanSquaredError: ile, meanAbsoluteError: ole, meanAbsolutePercentageError: sle, meanSquaredLogarithmicError: ule, squaredHinge: function(e10, t10) {
        return X5(function() {
          var n10 = Z9(0, P9(1, g8(e10, t10)));
          return Q9(Due(n10), -1);
        });
      }, hinge: function(e10, t10) {
        return X5(function() {
          var n10 = Z9(0, P9(1, g8(e10, t10)));
          return Q9(n10, -1);
        });
      }, categoricalHinge: function(e10, t10) {
        return X5(function() {
          var n10 = u9(g8(e10, t10), -1), r10 = n9(g8(P9(1, e10), t10), -1);
          return Z9(0, d8(1, P9(r10, n10)));
        });
      }, logcosh: function(e10, t10) {
        return X5(function() {
          var n10 = Math.log(2), r10 = P9(t10, e10), a10 = P9(d8(r10, L9(g8(-2, r10))), n10);
          return Q9(a10, -1);
        });
      }, categoricalCrossentropy: cle, sparseCategoricalCrossentropy: lle, binaryCrossentropy: hle, kullbackLeiblerDivergence: ple, poisson: function(e10, t10) {
        return X5(function() {
          var n10 = R9(d8(kue(), t10));
          return Q9(P9(t10, g8(e10, n10)), -1);
        });
      }, cosineProximity: fle };
      function vle(e10) {
        if ("string" == typeof e10) {
          if (e10 in dle) return dle[e10];
          var t10 = "Unknown loss ".concat(e10);
          throw e10.toLowerCase().includes("softmaxcrossentropy") && (t10 = "Unknown loss ".concat(e10, ". ") + 'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'), new Cse(t10);
        }
        return e10;
      }
      function mle(e10, t10) {
        return X5(function() {
          var n10 = g8(0.5, lee(t10)), r10 = wue(b9(t10, n10), e10.dtype);
          return Q9(B7(e10, r10), -1);
        });
      }
      function gle(e10, t10) {
        return X5(function() {
          return wue(B7(N8(e10, -1), N8(t10, -1)), "float32");
        });
      }
      function yle(e10, t10) {
        return X5(function() {
          return h8(u9(U9(B7(e10, 1), B7(t10, 1))), "float32");
        });
      }
      function ble(e10, t10) {
        return X5(function() {
          var n10 = yle(e10, t10), r10 = function(e11, t11) {
            return X5(function() {
              return h8(u9(U9(B7(e11, 0), B7(t11, 1))), "float32");
            });
          }(e10, t10), a10 = d8(n10, r10);
          return h8(W7(b9(a10, 0), m8(n10, a10), 0), "float32");
        });
      }
      function xle(e10, t10) {
        return X5(function() {
          var n10 = yle(e10, t10), r10 = function(e11, t11) {
            return X5(function() {
              return h8(u9(U9(B7(e11, 1), B7(t11, 0))), "float32");
            });
          }(e10, t10), a10 = d8(n10, r10);
          return h8(W7(b9(a10, 0), m8(n10, a10), 0), "float32");
        });
      }
      function kle(e10, t10) {
        return hle(e10, t10);
      }
      function wle(e10, t10) {
        return e10.rank === t10.rank && (e10 = zte(e10, [e10.rank - 1])), (t10 = N8(t10, -1)).dtype !== e10.dtype && (t10 = h8(t10, e10.dtype)), h8(B7(e10, t10), "float32");
      }
      var Ile = cle, Nle = lle, Sle = { binaryAccuracy: mle, categoricalAccuracy: gle, precision: ble, categoricalCrossentropy: Ile, sparseCategoricalCrossentropy: Nle, mse: ile, MSE: ile, mae: ole, MAE: ole, mape: sle, MAPE: sle, cosine: fle };
      function Tle(e10) {
        if (Fse(null !== e10, "Unknown LossOrMetricFn ".concat(e10)), "string" == typeof e10) return e10;
        for (var t10, n10 = 0, r10 = Object.keys(dle); n10 < r10.length; n10++) {
          var a10 = r10[n10];
          if (dle[a10] === e10) {
            t10 = a10;
            break;
          }
        }
        if (void 0 !== t10) return t10;
        for (var i10 = 0, o10 = Object.keys(Sle); i10 < o10.length; i10++) {
          var s10 = o10[i10];
          if (Sle[s10] === e10) {
            t10 = s10;
            break;
          }
        }
        return void 0 !== t10 ? t10 : e10.name;
      }
      var Ele = 1048576;
      function Cle(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if (null == e10 || "object" !== s(e10) || Object.getPrototypeOf(e10) !== Object.prototype || !Ale(e10)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
        if (n10) {
          var r10 = JSON.stringify(e10);
          r10.length > Ele && console.warn('User-defined metadata of model "'.concat(t10, '" is too large in ') + "size (length=".concat(r10.length, " when serialized). It is not ") + "recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= " + "".concat(Ele, "."));
        }
      }
      function Ale(e10) {
        if (null === e10) return true;
        if ("object" === s(e10)) {
          if (Object.getPrototypeOf(e10) === Object.prototype) {
            for (var t10 = 0, n10 = Object.keys(e10); t10 < n10.length; t10++) {
              var r10 = n10[t10];
              if ("string" != typeof r10) return false;
              if (!Ale(e10[r10])) return false;
            }
            return true;
          }
          if (Array.isArray(e10)) {
            var a10, i10 = O(e10);
            try {
              for (i10.s(); !(a10 = i10.n()).done; ) {
                if (!Ale(a10.value)) return false;
              }
            } catch (e11) {
              i10.e(e11);
            } finally {
              i10.f();
            }
            return true;
          }
          return false;
        }
        var o10 = s(e10);
        return "string" === o10 || "number" === o10 || "boolean" === o10;
      }
      function Rle(e10, t10, n10) {
        var r10, a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : console.log, i10 = Ole(e10), o10 = ["Layer (type)", "Input Shape", "Output shape", "Param #"];
        if (i10 ? (t10 = t10 || 90, n10 = n10 || [0.32, 0.61, 0.89, 1]) : (t10 = t10 || 115, n10 = n10 || [0.24, 0.48, 0.7, 0.8, 1]), n10[n10.length - 1] <= 1 && (n10 = n10.map(function(e11) {
          return Math.floor(t10 * e11);
        })), !i10) for (var s10 in o10.push("Receives inputs"), r10 = [], e10.nodesByDepth) {
          var u10;
          (u10 = r10).push.apply(u10, T(e10.nodesByDepth[s10]));
        }
        a10("_".repeat(t10)), Fle(o10, n10, a10), a10("=".repeat(t10));
        for (var c10 = e10.layers, l10 = 0; l10 < c10.length; ++l10) i10 ? Dle(c10[l10], n10, a10) : Mle(c10[l10], n10, r10, a10), a10((l10 === c10.length - 1 ? "=" : "_").repeat(t10));
        e10.checkTrainableWeightsConsistency();
        var h10 = _le(e10), p10 = pce(e10.nonTrainableWeights);
        a10("Total params: ".concat(h10 + p10)), a10("Trainable params: ".concat(h10)), a10("Non-trainable params: ".concat(p10)), a10("_".repeat(t10));
      }
      function _le(e10) {
        return null != e10.collectedTrainableWeights ? pce(e10.collectedTrainableWeights) : pce(e10.trainableWeights);
      }
      function Ole(e10) {
        var t10 = true, n10 = [], r10 = [];
        for (var a10 in e10.nodesByDepth) n10.push(e10.nodesByDepth[a10]);
        for (var i10 = 0, o10 = n10; i10 < o10.length; i10++) {
          var s10 = o10[i10];
          if (s10.length > 1 || 1 === s10.length && s10[0].inboundLayers.length > 1) {
            t10 = false;
            break;
          }
          r10.push.apply(r10, T(s10));
        }
        if (t10) {
          var u10, c10 = O(e10.layers);
          try {
            for (c10.s(); !(u10 = c10.n()).done; ) {
              var l10, h10 = u10.value, p10 = false, f10 = O(h10.inboundNodes);
              try {
                for (f10.s(); !(l10 = f10.n()).done; ) {
                  var d10 = l10.value;
                  if (-1 !== r10.indexOf(d10)) {
                    if (p10) {
                      t10 = false;
                      break;
                    }
                    p10 = true;
                  }
                }
              } catch (e11) {
                f10.e(e11);
              } finally {
                f10.f();
              }
              if (!t10) break;
            }
          } catch (e11) {
            c10.e(e11);
          } finally {
            c10.f();
          }
        }
        return t10;
      }
      function Fle(e10, t10) {
        for (var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : console.log, r10 = "", a10 = 0; a10 < e10.length; ++a10) a10 > 0 && (r10 = r10.slice(0, r10.length - 1) + " "), r10 = (r10 += e10[a10]).slice(0, t10[a10]), r10 += " ".repeat(t10[a10] - r10.length);
        n10(r10);
      }
      function Dle(e10, t10, n10) {
        var r10, a10;
        try {
          a10 = e10.inboundNodes.map(function(e11) {
            return JSON.stringify(e11.inputShapes);
          }).join(",");
        } catch (e11) {
          a10 = "multiple";
        }
        try {
          r10 = JSON.stringify(e10.outputShape);
        } catch (e11) {
          r10 = "multiple";
        }
        var i10 = e10.name, o10 = e10.getClassName();
        Fle(["".concat(i10, " (").concat(o10, ")"), a10, r10, e10.countParams().toString()], t10, n10);
      }
      function Mle(e10, t10, n10, r10) {
        var a10, i10;
        try {
          i10 = e10.inboundNodes.map(function(e11) {
            return JSON.stringify(e11.inputShapes);
          }).join(",");
        } catch (e11) {
          i10 = "multiple";
        }
        try {
          a10 = JSON.stringify(e10.outputShape);
        } catch (e11) {
          a10 = "multiple";
        }
        var o10, s10 = [], u10 = O(e10.inboundNodes);
        try {
          for (u10.s(); !(o10 = u10.n()).done; ) {
            var c10 = o10.value;
            if (!(null != n10 && n10.length > 0 && -1 === n10.indexOf(c10))) for (var l10 = 0; l10 < c10.inboundLayers.length; ++l10) {
              var h10 = c10.inboundLayers[l10].name, p10 = c10.nodeIndices[l10], f10 = c10.tensorIndices[l10];
              s10.push("".concat(h10, "[").concat(p10, "][").concat(f10, "]"));
            }
          }
        } catch (e11) {
          u10.e(e11);
        } finally {
          u10.f();
        }
        var d10 = e10.name, v10 = e10.getClassName(), m10 = 0 === s10.length ? "" : s10[0];
        Fle(["".concat(d10, " (").concat(v10, ")"), i10, a10, e10.countParams().toString(), m10], t10, r10);
        for (var g10 = 1; g10 < s10.length; ++g10) Fle(["", "", "", "", s10[g10]], t10, r10);
      }
      function Lle(e10, t10, n10) {
        return ("inboundNodes" === e10 || "outputLayers" === e10 || "inputLayers" === e10) && 0 === t10 && "string" == typeof n10;
      }
      function zle(e10, t10) {
        if (null === e10) return null;
        if ("string" == typeof e10) return Pse(e10);
        if ("number" == typeof e10 || "boolean" == typeof e10) return e10;
        if (e10 instanceof Array) {
          for (var n10 = [], r10 = e10.length, a10 = 0; a10 < r10; ++a10) {
            var i10 = e10[a10];
            Lle(t10, a10, i10) ? n10.push(i10) : n10.push(zle(i10, t10));
          }
          return n10;
        }
        for (var o10 = {}, s10 = 0, u10 = Object.keys(e10); s10 < u10.length; s10++) {
          var c10 = u10[s10], l10 = e10[c10];
          if ("name" === c10 && "string" == typeof l10) o10[c10] = l10;
          else {
            var h10 = Pse(c10);
            o10[h10] = zle(l10, h10);
          }
        }
        return o10;
      }
      function Ple(e10, t10) {
        if (null == e10) return null;
        if ("string" == typeof e10) return zse(e10);
        if ("number" == typeof e10 || "boolean" == typeof e10) return e10;
        if (e10 instanceof Array) {
          for (var n10 = [], r10 = e10.length, a10 = 0; a10 < r10; ++a10) {
            var i10 = e10[a10];
            Lle(t10, a10, i10) ? n10.push(i10) : n10.push(Ple(i10, t10));
          }
          return n10;
        }
        for (var o10 = {}, s10 = 0, u10 = Object.keys(e10); s10 < u10.length; s10++) {
          var c10 = u10[s10], l10 = e10[c10], h10 = zse(c10);
          o10[h10] = "name" !== c10 && "className" !== c10 || "string" != typeof l10 ? Ple(l10, c10) : l10;
        }
        return o10;
      }
      var Ble = "4.17.0", Wle = function(e10) {
        var t10 = Object.keys(e10);
        if (0 === t10.length) return false;
        var n10 = t10[0].split("/");
        return !isNaN(parseInt(n10[n10.length - 1], 10));
      }, Ule = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), (r10 = t10.call(this, {})).containerNodes = /* @__PURE__ */ new Set(), r10.name = e11.name, null == r10.name) {
            var a10 = r10.getClassName().toLowerCase();
            r10.name = eue(a10);
          }
          if (r10.supportsMasking = false, r10.trainable_ = true, Array.isArray(e11.inputs) ? r10.inputs = e11.inputs.slice() : r10.inputs = [e11.inputs], Array.isArray(e11.outputs) ? r10.outputs = e11.outputs.slice() : r10.outputs = [e11.outputs], jse(r10.inputs).length !== r10.inputs.length) throw new Cse("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: " + "".concat(r10.inputs.map(function(e12) {
            return e12.name;
          })));
          jse(r10.outputs).length !== r10.outputs.length && console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: " + "".concat(r10.outputs.map(function(e12) {
            return e12.name;
          }))), r10.inputLayers = [], r10.inputLayersNodeIndices = [], r10.inputLayersTensorIndices = [], r10.outputLayers = [], r10.outputLayersNodeIndices = [], r10.outputLayersTensorIndices = [], r10.layers = [], r10.internalContainerRefs = [];
          var i10, o10 = O(r10.outputs);
          try {
            for (o10.s(); !(i10 = o10.n()).done; ) {
              var s10 = i10.value, u10 = s10.sourceLayer, c10 = s10.nodeIndex, h10 = s10.tensorIndex;
              r10.outputLayers.push(u10), r10.outputLayersNodeIndices.push(c10), r10.outputLayersTensorIndices.push(h10);
            }
          } catch (e12) {
            o10.e(e12);
          } finally {
            o10.f();
          }
          var p10, f10 = O(r10.inputs);
          try {
            for (f10.s(); !(p10 = f10.n()).done; ) {
              var d10 = p10.value, v10 = d10.sourceLayer, m10 = d10.nodeIndex, g10 = d10.tensorIndex;
              Fse(0 === m10, "input layer has >1 nodes"), Fse(0 === g10, "input layer has >1 tensors"), r10.inputLayers.push(v10), r10.inputLayersNodeIndices.push(m10), r10.inputLayersTensorIndices.push(g10);
            }
          } catch (e12) {
            f10.e(e12);
          } finally {
            f10.f();
          }
          r10.inputNames = [], r10.outputNames = [], r10.feedInputShapes = [], r10.feedInputNames = [], r10.feedOutputNames = [];
          for (var y10 = 0; y10 < r10.inputLayers.length; y10++) {
            var b10 = r10.inputLayers[y10];
            if (!(b10 instanceof Nce)) throw new TypeError("Input layers to a LayersModel must be InputLayer objects. " + "Received inputs: ".concat(e11.inputs, ". ") + "Input ".concat(y10, " (0-based) originates ") + "from layer type ".concat(b10.getClassName(), "."));
            r10.inputNames.push(b10.name), r10.feedInputShapes.push(b10.batchInputShape), r10.feedInputNames.push(b10.name);
          }
          var k10, w10 = O(r10.outputLayers);
          try {
            for (w10.s(); !(k10 = w10.n()).done; ) {
              var I10 = k10.value;
              r10.outputNames.push(I10.name);
            }
          } catch (e12) {
            w10.e(e12);
          } finally {
            w10.f();
          }
          r10.internalInputShapes = r10.inputs.map(function(e12) {
            return e12.shape;
          }), r10.internalOutputShapes = r10.outputs.map(function(e12) {
            return e12.shape;
          });
          var N10, S10 = {}, T10 = {}, E10 = {}, C10 = {}, A10 = {}, R10 = [], _10 = function e12(t11, a11, i11, o11, s11, u11) {
            null != o11 && null != s11 && null != u11 || (o11 = t11.sourceLayer, s11 = t11.nodeIndex, u11 = t11.tensorIndex);
            var c11 = o11.inboundNodes[s11];
            if (-1 !== i11.indexOf(c11)) throw new Ese("The tensor ".concat(t11.name, ' at layer "').concat(o11.name, '" ') + "is part of a cycle.");
            if (-1 === a11.indexOf(c11)) {
              r10.containerNodes.add(n10.nodeKey(o11, s11)), o11.id in A10 || (A10[o11.id] = Object.keys(A10).length), -1 === i11.indexOf(c11) && i11.push(c11);
              for (var l10 = c11.inboundLayers.length, h11 = 0; h11 < l10; h11++) {
                e12(c11.inputTensors[h11], a11, i11, c11.inboundLayers[h11], c11.nodeIndices[h11], c11.tensorIndices[h11]);
              }
              for (a11.push(c11); i11.indexOf(c11) >= 0; ) i11.splice(i11.indexOf(c11), 1);
              R10.push(c11);
            }
          }, F10 = [], D10 = [], M10 = O(r10.outputs);
          try {
            for (M10.s(); !(N10 = M10.n()).done; ) {
              _10(N10.value, F10, D10);
            }
          } catch (e12) {
            M10.e(e12);
          } finally {
            M10.f();
          }
          var L10, z10 = O(R10.slice().reverse());
          try {
            for (z10.s(); !(L10 = z10.n()).done; ) {
              var P10 = L10.value;
              T10[P10.id] = P10, P10.id in S10 || (S10[P10.id] = 0);
              var B10 = S10[P10.id], W10 = null == E10[P10.outboundLayer.id] ? 0 : E10[P10.outboundLayer.id];
              B10 = Math.max(B10, W10), E10[P10.outboundLayer.id] = B10, C10[P10.outboundLayer.id] = P10.outboundLayer, S10[P10.id] = B10;
              for (var U10 = 0; U10 < P10.inboundLayers.length; U10++) {
                var V10 = P10.inboundLayers[U10], G10 = P10.nodeIndices[U10], j10 = V10.inboundNodes[G10], H10 = null == S10[j10.id] ? 0 : S10[j10.id];
                S10[j10.id] = Math.max(B10 + 1, H10), T10[j10.id] = j10;
              }
            }
          } catch (e12) {
            z10.e(e12);
          } finally {
            z10.f();
          }
          var q10 = {};
          for (var K10 in S10) {
            var X10 = S10[K10];
            X10 in q10 || (q10[X10] = []), q10[X10].push(T10[K10]);
          }
          var Y10 = {};
          for (var J10 in E10) {
            var Z10 = E10[J10];
            Z10 in Y10 || (Y10[Z10] = []), Y10[Z10].push(C10[J10]);
          }
          var Q10 = Object.keys(Y10).map(function(e12) {
            return parseInt(e12, 10);
          }).sort(Gse);
          r10.layers = [];
          var $10, ee2 = O(Q10);
          try {
            for (ee2.s(); !($10 = ee2.n()).done; ) {
              var te2 = Y10[$10.value];
              te2.sort(function(e12, t11) {
                var n11 = A10[e12.id], r11 = A10[t11.id];
                return n11 < r11 ? -1 : n11 > r11 ? 1 : 0;
              });
              var ne2, re2 = O(te2);
              try {
                for (re2.s(); !(ne2 = re2.n()).done; ) {
                  var ae2 = ne2.value;
                  ae2 instanceof n10 && r10.internalContainerRefs.push(ae2), r10.layers.push(ae2);
                }
              } catch (e12) {
                re2.e(e12);
              } finally {
                re2.f();
              }
            }
          } catch (e12) {
            ee2.e(e12);
          } finally {
            ee2.f();
          }
          r10.layersByDepth = Y10, Q10 = Object.keys(q10).map(function(e12) {
            return parseInt(e12, 10);
          }).sort(Gse);
          var ie2, oe2 = r10.inputs.slice(), se2 = [], ue2 = O(Q10);
          try {
            for (ue2.s(); !(ie2 = ue2.n()).done; ) {
              var ce2, le2 = O(q10[ie2.value]);
              try {
                for (le2.s(); !(ce2 = le2.n()).done; ) {
                  var he2 = ce2.value, pe2 = he2.outboundLayer;
                  if (null != pe2) {
                    var fe2, de2 = O(he2.inputTensors);
                    try {
                      for (de2.s(); !(fe2 = de2.n()).done; ) {
                        var ve2 = fe2.value;
                        if (-1 === oe2.indexOf(ve2)) throw new Ese("Graph disconnected: cannot obtain value for tensor ".concat(ve2) + ' at layer "'.concat(pe2.name, '". ') + "The following previous layers were accessed without " + "issue: ".concat(se2));
                      }
                    } catch (e12) {
                      de2.e(e12);
                    } finally {
                      de2.f();
                    }
                    var me2, ge2 = O(he2.outputTensors);
                    try {
                      for (ge2.s(); !(me2 = ge2.n()).done; ) {
                        var ye2 = me2.value;
                        oe2.push(ye2);
                      }
                    } catch (e12) {
                      ge2.e(e12);
                    } finally {
                      ge2.f();
                    }
                    se2.push(pe2.name);
                  }
                }
              } catch (e12) {
                le2.e(e12);
              } finally {
                le2.f();
              }
            }
          } catch (e12) {
            ue2.e(e12);
          } finally {
            ue2.f();
          }
          r10.nodesByDepth = q10;
          var be2, xe2 = r10.layers.map(function(e12) {
            return e12.name;
          }), ke2 = O(xe2);
          try {
            var we2 = function() {
              var e12 = be2.value, t11 = xe2.filter(function(t12) {
                return t12 === e12;
              }).length;
              if (1 !== t11) throw new Ese('The name "'.concat(e12, '" is used ').concat(t11, " times ") + "in the model. All layer names should be unique. Layer names: " + JSON.stringify(xe2));
            };
            for (ke2.s(); !(be2 = ke2.n()).done; ) we2();
          } catch (e12) {
            ke2.e(e12);
          } finally {
            ke2.f();
          }
          return r10.outboundNodes = [], r10.inboundNodes = [], new xce({ outboundLayer: x(r10), inboundLayers: [], nodeIndices: [], tensorIndices: [], inputTensors: r10.inputs, outputTensors: r10.outputs, inputMasks: r10.inputs.map(function(e12) {
            return null;
          }), outputMasks: r10.outputs.map(function(e12) {
            return null;
          }), inputShapes: r10.inputs.map(function(e12) {
            return e12.shape;
          }), outputShapes: r10.outputs.map(function(e12) {
            return e12.shape;
          }) }), r10.built = true, r10._refCount = 1, r10;
        }
        return p(n10, [{ key: "assertNotDisposed", value: function() {
          if (0 === this._refCount) throw new Error("Container '".concat(this.name, "' is already disposed."));
        } }, { key: "dispose", value: function() {
          this.assertNotDisposed();
          var e11 = { refCountAfterDispose: null, numDisposedVariables: 0 };
          if (0 == --this._refCount) {
            var t11, n11 = O(this.layers);
            try {
              for (n11.s(); !(t11 = n11.n()).done; ) {
                var r10 = t11.value;
                e11.numDisposedVariables += r10.dispose().numDisposedVariables;
              }
            } catch (e12) {
              n11.e(e12);
            } finally {
              n11.f();
            }
            var a10, i10 = O(this.internalContainerRefs);
            try {
              for (i10.s(); !(a10 = i10.n()).done; ) {
                var o10 = a10.value;
                e11.numDisposedVariables += o10.dispose().numDisposedVariables;
              }
            } catch (e12) {
              i10.e(e12);
            } finally {
              i10.f();
            }
          }
          return e11.refCountAfterDispose = this._refCount, e11;
        } }, { key: "trainable", get: function() {
          return this.trainable_;
        }, set: function(e11) {
          this.layers.forEach(function(t11) {
            t11._trainableWeights.forEach(function(t12) {
              return t12.trainable = e11;
            });
          }), this.trainable_ = e11;
        } }, { key: "trainableWeights", get: function() {
          if (this._trainableWeights.length > 0) throw new Cse("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
          if (!this.trainable) return [];
          var e11, t11 = [], n11 = O(this.layers);
          try {
            for (n11.s(); !(e11 = n11.n()).done; ) {
              var r10 = e11.value;
              t11 = t11.concat(r10.trainableWeights);
            }
          } catch (e12) {
            n11.e(e12);
          } finally {
            n11.f();
          }
          return t11;
        } }, { key: "nonTrainableWeights", get: function() {
          var e11, t11 = [], n11 = O(this.layers);
          try {
            for (n11.s(); !(e11 = n11.n()).done; ) {
              var r10 = e11.value;
              t11.push.apply(t11, T(r10.nonTrainableWeights));
            }
          } catch (e12) {
            n11.e(e12);
          } finally {
            n11.f();
          }
          if (!this.trainable) {
            var a10, i10 = [], o10 = O(this.layers);
            try {
              for (o10.s(); !(a10 = o10.n()).done; ) {
                var s10 = a10.value;
                i10.push.apply(i10, T(s10.trainableWeights));
              }
            } catch (e12) {
              o10.e(e12);
            } finally {
              o10.f();
            }
            return i10.concat(t11);
          }
          return t11;
        } }, { key: "weights", get: function() {
          return this.trainableWeights.concat(this.nonTrainableWeights);
        } }, { key: "loadWeights", value: function(e11) {
          var t11 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n11 = {}, r10 = 0, a10 = Wle(e11);
          a10 && this.parseWeights(e11);
          var i10, o10 = O(this.layers);
          try {
            for (o10.s(); !(i10 = o10.n()).done; ) {
              var s10, u10 = i10.value, c10 = O(u10.weights.entries());
              try {
                for (c10.s(); !(s10 = c10.n()).done; ) {
                  var l10 = S(s10.value, 2), h10 = l10[0], p10 = l10[1], f10 = a10 ? "".concat(p10.name.split("/").slice(0, -1).join("/") + "/").concat(h10) : p10.originalName;
                  if (null != n11[f10]) throw new Cse("Duplicate weight name: ".concat(f10));
                  n11[f10] = p10, r10++;
                }
              } catch (e12) {
                c10.e(e12);
              } finally {
                c10.f();
              }
            }
          } catch (e12) {
            o10.e(e12);
          } finally {
            o10.f();
          }
          var d10 = [];
          for (var v10 in e11) {
            var m10 = v10;
            if (null == n11[v10]) {
              var g10 = v10.split("/"), y10 = g10.slice(0, -2).concat([g10[g10.length - 1]]);
              m10 = y10.join("/");
            }
            if (null != n11[m10]) d10.push([n11[m10], e11[v10]]);
            else if (t11) throw new Cse("Provided weight data has no target variable: ".concat(v10));
            delete n11[m10];
          }
          if (t11) {
            var b10 = [];
            for (var x10 in n11) b10.push(x10);
            if (b10.length > 0) throw new Cse("".concat(b10.length, " of ").concat(r10, " weights are not set: ") + "".concat(b10));
          }
          mce(d10);
        } }, { key: "parseWeights", value: function(e11) {
          var t11 = function() {
            var t12 = n11.split("/"), r10 = ["vars", "layer_checkpoint_dependencies"], a10 = t12.map(function(e12) {
              return e12.startsWith("_") ? e12.slice(1) : e12;
            }).filter(function(e12) {
              return !r10.includes(e12);
            }).join("/");
            a10 !== n11 && (e11[a10] = e11[n11], delete e11[n11]);
          };
          for (var n11 in Object.keys(e11)) t11();
        } }, { key: "updatedConfig", value: function() {
          var e11 = this.getConfig(), t11 = {};
          return t11.className = this.getClassName(), t11.config = e11, t11.kerasVersion = "tfjs-layers ".concat(Ble), t11.backend = "TensorFlow.js", t11;
        } }, { key: "toJSON", value: function(e11) {
          var t11 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n11 = Ple(this.updatedConfig());
          return t11 ? JSON.stringify(n11) : n11;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            e11 = Lse(e11);
            for (var r10 = new Tce(), a10 = 0; a10 < n11.inputs.length; ++a10) r10.add(n11.inputs[a10], e11[a10]);
            return Ace(n11.outputs, r10, t11);
          });
        } }, { key: "computeMask", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var r10;
            return e11 = Lse(e11), r10 = null == t11 ? Ose(null, e11.length) : Lse(t11), n11.runInternalGraph(e11, r10)[1];
          });
        } }, { key: "computeOutputShape", value: function(e11) {
          var t11 = cce(e11);
          if (t11.length !== this.inputLayers.length) throw new Cse("Invalid inputShape argument ".concat(e11, ": ") + "model has ".concat(this.inputLayers.length, " tensor inputs."));
          for (var n11 = {}, r10 = 0; r10 < t11.length; r10++) {
            var a10 = this.inputLayers[r10], i10 = t11[r10];
            n11[a10.name + "_0_0"] = i10;
          }
          var o10 = Object.keys(this.nodesByDepth).map(function(e12) {
            return parseInt(e12, 10);
          }).sort(Gse);
          if (o10.length > 1) {
            var s10, u10 = O(o10);
            try {
              for (u10.s(); !(s10 = u10.n()).done; ) {
                var c10, l10 = s10.value, h10 = O(this.nodesByDepth[l10]);
                try {
                  for (h10.s(); !(c10 = h10.n()).done; ) {
                    var p10 = c10.value, f10 = p10.outboundLayer;
                    if (-1 === this.inputLayers.map(function(e12) {
                      return e12.id;
                    }).indexOf(f10.id)) {
                      for (var d10 = [], v10 = 0; v10 < p10.inboundLayers.length; v10++) {
                        var m10 = p10.inboundLayers[v10], g10 = p10.nodeIndices[v10], y10 = p10.tensorIndices[v10], b10 = n11["".concat(m10.name, "_").concat(g10, "_").concat(y10)];
                        d10.push(b10);
                      }
                      for (var x10 = cce(f10.computeOutputShape(Mse(d10))), k10 = f10.inboundNodes.indexOf(p10), w10 = 0; w10 < x10.length; w10++) {
                        n11["".concat(f10.name, "_").concat(k10, "_").concat(w10)] = x10[w10];
                      }
                    }
                  }
                } catch (e12) {
                  h10.e(e12);
                } finally {
                  h10.f();
                }
              }
            } catch (e12) {
              u10.e(e12);
            } finally {
              u10.f();
            }
          }
          for (var I10 = [], N10 = [], S10 = 0; S10 < this.outputLayers.length; S10++) {
            var T10 = this.outputLayers[S10], E10 = this.outputLayersNodeIndices[S10], C10 = this.outputLayersTensorIndices[S10], A10 = "".concat(T10.name, "_").concat(E10, "_").concat(C10);
            N10.push(A10);
          }
          for (var R10 = 0; R10 < N10.length; R10++) {
            var _10 = N10[R10];
            Fse(_10 in n11), I10.push(n11[_10]);
          }
          return Mse(I10);
        } }, { key: "runInternalGraph", value: function(e11, t11) {
          null == t11 && (t11 = Ose(null, e11.length));
          for (var n11 = {}, r10 = 0; r10 < this.inputs.length; ++r10) {
            var a10 = this.inputs[r10], i10 = e11[r10], o10 = t11[r10];
            n11[a10.id] = [i10, o10];
          }
          var s10, u10 = Object.keys(this.nodesByDepth).map(function(e12) {
            return parseInt(e12, 10);
          }).sort(Gse), c10 = O(u10);
          try {
            for (c10.s(); !(s10 = c10.n()).done; ) {
              var l10, h10 = s10.value, p10 = O(this.nodesByDepth[h10]);
              try {
                for (p10.s(); !(l10 = p10.n()).done; ) {
                  var f10, d10 = l10.value, v10 = d10.outboundLayer, m10 = d10.inputTensors, g10 = d10.outputTensors, y10 = new Array(), b10 = O(m10);
                  try {
                    for (b10.s(); !(f10 = b10.n()).done; ) {
                      var x10 = f10.value;
                      x10.id in n11 && y10.push(n11[x10.id]);
                    }
                  } catch (e12) {
                    b10.e(e12);
                  } finally {
                    b10.f();
                  }
                  if (y10.length === m10.length) {
                    var k10 = {}, w10 = void 0, I10 = void 0, N10 = void 0, T10 = void 0;
                    if (null != d10.callArgs && (k10 = d10.callArgs), 1 === y10.length) {
                      var E10 = S(y10[0], 2), C10 = E10[0], A10 = E10[1];
                      null == k10.mask && (k10.mask = A10), N10 = Lse(v10.call(C10, k10)), T10 = Lse(v10.computeMask(C10, A10)), w10 = [C10], I10 = [A10];
                    } else w10 = y10.map(function(e12) {
                      return e12[0];
                    }), I10 = y10.map(function(e12) {
                      return e12[1];
                    }), null == k10.mask && (k10.mask = I10), N10 = Lse(v10.call(w10, k10)), T10 = Lse(v10.computeMask(w10, I10));
                    if (v10.activityRegularizer) throw new Ase("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
                    for (var R10 = 0; R10 < g10.length; ++R10) {
                      var _10 = g10[R10], F10 = N10[R10], D10 = T10[R10];
                      n11[_10.id] = [F10, D10];
                    }
                  }
                }
              } catch (e12) {
                p10.e(e12);
              } finally {
                p10.f();
              }
            }
          } catch (e12) {
            c10.e(e12);
          } finally {
            c10.f();
          }
          var M10, L10 = [], z10 = [], P10 = [], B10 = O(this.outputs);
          try {
            for (B10.s(); !(M10 = B10.n()).done; ) {
              var W10 = M10.value;
              Fse(W10.id in n11, "Could not compute output ".concat(W10.name, " : ").concat(W10.id));
              var U10 = S(n11[W10.id], 2), V10 = U10[0], G10 = U10[1];
              P10.push(V10.shape), L10.push(V10), z10.push(G10);
            }
          } catch (e12) {
            B10.e(e12);
          } finally {
            B10.f();
          }
          return [L10, z10, P10];
        } }, { key: "buildNodeConversionMap", value: function(e11) {
          var t11, r10, a10 = {}, i10 = O(this.layers);
          try {
            for (i10.s(); !(r10 = i10.n()).done; ) {
              var o10 = r10.value;
              t11 = o10 instanceof n10 ? 1 : 0;
              for (var s10 = 0; s10 < o10.inboundNodes.length; s10++) {
                var u10 = n10.nodeKey(o10, s10);
                this.containerNodes.has(u10) && (a10[u10] = t11, t11 += 1);
              }
            }
          } catch (e12) {
            i10.e(e12);
          } finally {
            i10.f();
          }
          return a10;
        } }, { key: "getLayer", value: function(e11, t11) {
          if (null != t11) return this.findLayer(t11);
          if (null == e11) throw new Cse("Provide either a layer name or layer index");
          if ("number" == typeof e11) return this.findLayer(e11);
          var n11, r10 = O(this.layers);
          try {
            for (r10.s(); !(n11 = r10.n()).done; ) {
              var a10 = n11.value;
              if (a10.name === e11) return a10;
            }
          } catch (e12) {
            r10.e(e12);
          } finally {
            r10.f();
          }
          throw new Cse("No such layer: ".concat(e11));
        } }, { key: "findLayer", value: function(e11) {
          if (this.layers.length <= e11) throw new Cse("Was asked to retrieve layer at index ".concat(e11, ", but model only ") + "has ".concat(this.layers.length, " layer(s)."));
          return this.layers[e11];
        } }, { key: "calculateLosses", value: function() {
          var e11 = this;
          return X5(function() {
            var t11, r10 = [], a10 = O(e11.layers);
            try {
              for (a10.s(); !(t11 = a10.n()).done; ) for (var i10 = t11.value, o10 = 0; o10 < i10.inboundNodes.length; ++o10) {
                var s10 = n10.nodeKey(i10, o10);
                e11.containerNodes.has(s10) && r10.push.apply(r10, T(i10.calculateLosses()));
              }
            } catch (e12) {
              a10.e(e12);
            } finally {
              a10.f();
            }
            return r10;
          });
        } }, { key: "getConfig", value: function() {
          var e11, t11 = { name: this.name }, r10 = this.buildNodeConversionMap(this.layers), a10 = [], i10 = O(this.layers);
          try {
            for (i10.s(); !(e11 = i10.n()).done; ) {
              for (var o10 = e11.value, s10 = o10.getClassName(), u10 = o10.getConfig(), c10 = [], l10 = 0; l10 < o10.inboundNodes.length; l10++) {
                var h10 = o10.inboundNodes[l10], p10 = n10.nodeKey(o10, l10), f10 = {};
                if (this.containerNodes.has(p10)) {
                  if (h10.callArgs) try {
                    JSON.stringify(h10.callArgs), f10 = h10.callArgs;
                  } catch (e12) {
                    console.warn("Layer ".concat(o10.name, " was passed ") + "non-serializable keyword arguments: " + "".concat(h10.callArgs, ". They will not be included ") + "in the serialized model (and thus will be missing at deserialization time)."), f10 = {};
                  }
                  if (h10.inboundLayers.length > 0) {
                    for (var d10 = [], v10 = 0; v10 < h10.inboundLayers.length; v10++) {
                      var m10 = h10.inboundLayers[v10], g10 = h10.nodeIndices[v10], y10 = h10.tensorIndices[v10], b10 = r10[n10.nodeKey(m10, g10)];
                      null == b10 && (b10 = 0), d10.push([m10.name, b10, y10, f10]);
                    }
                    c10.push(d10);
                  }
                }
              }
              var x10 = {};
              x10.name = o10.name, x10.className = s10, x10.config = u10, x10.inboundNodes = c10, a10.push(x10);
            }
          } catch (e12) {
            i10.e(e12);
          } finally {
            i10.f();
          }
          t11.layers = a10;
          for (var k10 = [], w10 = 0; w10 < this.inputLayers.length; w10++) {
            var I10 = this.inputLayers[w10], N10 = this.inputLayersNodeIndices[w10], S10 = n10.nodeKey(I10, N10);
            if (this.containerNodes.has(S10)) {
              var T10 = r10[S10];
              null == T10 && (T10 = 0);
              var E10 = this.inputLayersTensorIndices[w10];
              k10.push([I10.name, T10, E10]);
            }
          }
          t11.inputLayers = k10;
          for (var C10 = [], A10 = 0; A10 < this.outputLayers.length; A10++) {
            var R10 = this.outputLayers[A10], _10 = this.outputLayersNodeIndices[A10], F10 = n10.nodeKey(R10, _10);
            if (this.containerNodes.has(F10)) {
              var D10 = r10[F10];
              null == D10 && (D10 = 0);
              var M10 = this.outputLayersTensorIndices[A10];
              C10.push([R10.name, D10, M10]);
            }
          }
          return t11.outputLayers = C10, t11;
        } }, { key: "stateful", get: function() {
          if (this._stateful) throw new Cse("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
          var e11, t11 = O(this.layers);
          try {
            for (t11.s(); !(e11 = t11.n()).done; ) {
              if (e11.value.stateful) return true;
            }
          } catch (e12) {
            t11.e(e12);
          } finally {
            t11.f();
          }
          return false;
        } }, { key: "resetStates", value: function() {
          var e11 = this;
          X5(function() {
            e11.layers.forEach(function(e12) {
              e12.stateful && e12.resetStates();
            });
          });
        } }], [{ key: "fromConfig", value: function(e11, t11) {
          var n11 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], r10 = {}, a10 = {};
          function i10(e12, t12) {
            e12.name in a10 ? a10[e12.name].push(t12) : a10[e12.name] = [t12];
          }
          function o10(e12, t12) {
            var n12, a11, o11 = [], s11 = O(t12);
            try {
              for (s11.s(); !(a11 = s11.n()).done; ) {
                var u11 = a11.value, c11 = u11[0], l11 = u11[1], h11 = u11[2];
                if (n12 = null == u11[3] ? {} : u11[3], !(c11 in r10)) return void i10(e12, t12);
                var p11 = r10[c11];
                if (p11.inboundNodes.length <= l11) return void i10(e12, t12);
                var f11 = p11.inboundNodes[l11];
                o11.push(f11.outputTensors[h11]);
              }
            } catch (e13) {
              s11.e(e13);
            } finally {
              s11.f();
            }
            o11.length > 0 && e12.apply(Mse(o11), n12);
          }
          function s10(e12) {
            var a11 = e12.name, o11 = rle(e12, null != t11.customObjects ? t11.customObjects : {});
            o11.setFastWeightInitDuringBuild(n11), r10[a11] = o11, e12.inboundNodes.forEach(function(e13) {
              if (!(e13 instanceof Array)) throw new Cse("Corrupted configuration, expected array for nodeData: ".concat(e13));
              i10(o11, e13);
            });
          }
          var u10, c10 = t11.name, l10 = t11.layers, h10 = O(l10);
          try {
            for (h10.s(); !(u10 = h10.n()).done; ) {
              var p10 = u10.value;
              s10(p10);
            }
          } catch (e12) {
            h10.e(e12);
          } finally {
            h10.f();
          }
          for (; !Hse(a10); ) {
            var f10, d10 = O(l10);
            try {
              for (d10.s(); !(f10 = d10.n()).done; ) {
                var v10 = f10.value, m10 = r10[v10.name];
                if (m10.name in a10) {
                  var g10 = a10[m10.name];
                  delete a10[m10.name];
                  var y10, b10 = O(g10);
                  try {
                    for (b10.s(); !(y10 = b10.n()).done; ) {
                      var x10 = y10.value;
                      o10(m10, x10);
                    }
                  } catch (e12) {
                    b10.e(e12);
                  } finally {
                    b10.f();
                  }
                }
              }
            } catch (e12) {
              d10.e(e12);
            } finally {
              d10.f();
            }
          }
          var k10, w10 = [], I10 = [], N10 = t11.inputLayers, S10 = O(N10);
          try {
            for (S10.s(); !(k10 = S10.n()).done; ) {
              var T10 = k10.value, E10 = T10[0], C10 = T10[1], A10 = T10[2];
              Fse(E10 in r10);
              var R10 = r10[E10], _10 = R10.inboundNodes[C10].outputTensors;
              w10.push(_10[A10]);
            }
          } catch (e12) {
            S10.e(e12);
          } finally {
            S10.f();
          }
          var F10, D10 = t11.outputLayers, M10 = O(D10);
          try {
            for (M10.s(); !(F10 = M10.n()).done; ) {
              var L10 = F10.value, z10 = L10[0], P10 = L10[1], B10 = L10[2];
              Fse(z10 in r10);
              var W10 = r10[z10], U10 = W10.inboundNodes[P10].outputTensors;
              I10.push(U10[B10]);
            }
          } catch (e12) {
            M10.e(e12);
          } finally {
            M10.f();
          }
          return new e11({ inputs: w10, outputs: I10, name: c10 });
        } }]), n10;
      }(wce);
      function Vle(e10, t10, n10) {
        var r10 = t10.length;
        if (null == e10 || Array.isArray(e10) && 0 === e10.length) return t10.map(function(e11) {
          return null;
        });
        if (1 === r10) return Array.isArray(e10) && 1 === e10.length ? e10 : "object" === s(e10) && t10[0] in e10 ? [e10[t10[0]]] : [e10];
        if (Array.isArray(e10)) {
          if (e10.length !== r10) throw new Error("Provided ".concat(n10, " is an array of ").concat(e10.length, " ") + "element(s), but the model has ".concat(r10, " outputs. ") + "Make sure a set of weights is provided for each model output.");
          return e10;
        }
        if ("object" === s(e10) && Object.keys(e10).length > 0 && "object" === s(e10[Object.keys(e10)[0]])) {
          var a10 = [];
          return t10.forEach(function(t11) {
            t11 in e10 ? a10.push(e10[t11]) : a10.push(null);
          }), a10;
        }
        throw new Error("The model has multiple (".concat(r10, ") outputs, ") + "so ".concat(n10, " must be either an array with ") + "".concat(r10, " elements or an object with ").concat(t10, " keys. ") + "Provided ".concat(n10, " not understood: ").concat(JSON.stringify(e10)));
      }
      function Gle(e10, t10) {
        return Vle(e10, t10, "classWeight");
      }
      function jle(e10, t10, n10, r10) {
        return Hle.apply(this, arguments);
      }
      function Hle() {
        return (Hle = c(o().mark(function e10(t10, n10, r10, a10) {
          var i10, s10, u10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                if (null == n10 && null == a10) {
                  e11.next = 2;
                  break;
                }
                throw new Error("Support sampleWeight is not implemented yet");
              case 2:
                if (null == r10) {
                  e11.next = 15;
                  break;
                }
                return i10 = X5(function() {
                  if (1 === t10.shape.length) return p8(t10);
                  if (2 === t10.shape.length) {
                    if (t10.shape[1] > 1) {
                      return N8(t10, 1);
                    }
                    if (1 === t10.shape[1]) return X8(t10, [t10.shape[0]]);
                    throw new Error("Encountered unexpected last-dimension size (".concat(t10.shape[1], ") ") + "during handling of class weights. The size is expected to be >= 1.");
                  }
                  throw new Error("Unexpected rank of target (y) tensor (".concat(t10.rank, ") during ") + "handling of class weights. The rank is expected to be 1 or 2.");
                }), e11.t0 = Array, e11.next = 7, i10.data();
              case 7:
                return e11.t1 = e11.sent, s10 = e11.t0.from.call(e11.t0, e11.t1), Y5(i10), u10 = [], s10.forEach(function(e12) {
                  if (null == r10[e12]) throw new Error("classWeight must contain all classes in the training data. " + "The class ".concat(e12, " exists in the data but not in ") + "classWeight");
                  u10.push(r10[e12]);
                }), e11.abrupt("return", Vte(u10, "float32"));
              case 15:
                return e11.abrupt("return", null);
              case 16:
              case "end":
                return e11.stop();
            }
          }, e10);
        }))).apply(this, arguments);
      }
      function qle(e10, t10) {
        return g8(e10, t10);
      }
      function Kle(e10, t10) {
        var n10, r10, a10 = t10;
        n10 = a10.xs, r10 = a10.ys, F$(null != n10 && null != r10, function() {
          return "A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates " + "".concat(t10);
        });
        var i10 = Xle("input", e10.inputNames, n10), o10 = Xle("output", e10.outputNames, r10), s10 = i10[0].shape[0];
        F$(i10.length === e10.inputs.length, function() {
          return "LayersModel has ".concat(e10.inputs.length, " inputs, but the dataset ") + "provides ".concat(i10.length, " inputs.  (Expected input keys: ") + "".concat(JSON.stringify(e10.inputNames), ")");
        }), F$(o10.length === e10.outputs.length, function() {
          return "LayersModel has ".concat(e10.outputs.length, " outputs, but the dataset ") + "provides ".concat(o10.length, " outputs.  (Expected output keys: ") + "".concat(JSON.stringify(e10.outputNames), ")");
        });
        for (var u10 = function(t11) {
          F$(i10[t11].shape[0] === s10, function() {
            return "Batch size mismatch: input " + "".concat(e10.inputNames[t11], " has ").concat(i10[t11].shape[0], "; ") + "expected  ".concat(s10, " based on input ").concat(e10.inputNames[0], ".");
          });
        }, c10 = 0; c10 < i10.length; c10++) u10(c10);
        for (var l10 = function(t11) {
          F$(o10[t11].shape[0] === s10, function() {
            return "Batch size mismatch: output " + "".concat(e10.outputNames[t11], " has ").concat(o10[t11].shape[0], "; ") + "expected  ".concat(s10, " based on input ").concat(e10.inputNames[0], ".");
          });
        }, h10 = 0; h10 < o10.length; h10++) l10(h10);
        return { xs: i10, ys: o10 };
      }
      function Xle(e10, t10, n10) {
        if (n10 instanceof n5) return [n10];
        if (Array.isArray(n10)) return F$(n10.length === t10.length, function() {
          return "Received an array of ".concat(n10.length, " Tensors, but expected ").concat(t10.length, " to match the ").concat(e10, " keys ").concat(t10, ".");
        }), n10;
        var r10, a10 = [], i10 = O(t10);
        try {
          for (i10.s(); !(r10 = i10.n()).done; ) {
            var o10 = r10.value;
            if (null == n10[o10]) throw new Cse("The feature data generated by the dataset lacks the required " + "".concat(e10, " key '").concat(o10, "'."));
            a10.push(n10[o10]);
          }
        } catch (e11) {
          i10.e(e11);
        } finally {
          i10.f();
        }
        return a10;
      }
      function Yle(e10) {
        if (3 === e10.length) throw new Ase("Validation with sample weights is not implemented yet.");
        return { xs: e10[0], ys: e10[1] };
      }
      function Jle(e10, t10, n10) {
        return Zle.apply(this, arguments);
      }
      function Zle() {
        return Zle = c(o().mark(function e10(t10, n10, r10) {
          var a10, i10, s10, u10, c10, l10, h10, p10, f10, d10, v10, m10, g10, y10, b10, x10, k10, w10, I10, N10, S10, T10, E10, C10, A10, R10, _10, O10, F10, D10, M10, L10, z10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                if (a10 = null != r10.batchesPerEpoch, F$(null != t10.optimizer, function() {
                  return "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).";
                }), F$(null != r10, function() {
                  return "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.";
                }), F$(null != r10.epochs && r10.epochs > 0 && Number.isInteger(r10.epochs), function() {
                  return "For fitDataset(), config.epochs is expected to be a positive " + "integer, but got ".concat(r10.epochs);
                }), F$(!a10 || r10.batchesPerEpoch > 0 && Number.isInteger(r10.batchesPerEpoch), function() {
                  return "For fitDataset(), config.batchesPerEpoch is expected to be a " + "positive integer if specified, but got ".concat(r10.batchesPerEpoch);
                }), F$(null == r10.validationSplit, function() {
                  return "`validationSplit` is not supported by `fitDataset()`. Use validationData instead.";
                }), !t10.isTraining) {
                  e11.next = 8;
                  break;
                }
                throw new Error("Cannot start training because another fit() call is ongoing.");
              case 8:
                return t10.isTraining = true, e11.prev = 9, (i10 = null != r10.validationData) && ($le(r10.validationData) ? F$(null == r10.validationBatches || r10.validationBatches > 0 && Number.isInteger(r10.validationBatches), function() {
                  return "For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, " + "but got ".concat(r10.validationBatches);
                }) : (c10 = Yle(r10.validationData), s10 = c10.xs, u10 = c10.ys)), l10 = t10.makeTrainFunction(), h10 = t10.getDedupedMetricsNames(), p10 = i10 ? h10.slice().concat(h10.map(function(e12) {
                  return "val_" + e12;
                })) : h10.slice(), f10 = ele(r10.callbacks, r10.yieldEvery), d10 = null == r10.verbose ? 1 : r10.verbose, v10 = nle(f10, d10, r10.epochs, null, null, Qle(n10, r10), null, i10, p10), m10 = v10.callbackList, g10 = v10.history, m10.setModel(t10), t10.history = g10, e11.next = 22, m10.onTrainBegin();
              case 22:
                return t10.stopTraining_ = false, y10 = null == r10.initialEpoch ? 0 : r10.initialEpoch, e11.next = 26, n10.iterator();
              case 26:
                b10 = e11.sent;
              case 27:
                if (!(y10 < r10.epochs)) {
                  e11.next = 98;
                  break;
                }
                return x10 = {}, e11.next = 31, m10.onEpochBegin(y10);
              case 31:
                if (k10 = 0, w10 = 0, a10) {
                  e11.next = 37;
                  break;
                }
                return e11.next = 36, n10.iterator();
              case 36:
                b10 = e11.sent;
              case 37:
                if (a10 && !(k10 < r10.batchesPerEpoch)) {
                  e11.next = 91;
                  break;
                }
                return e11.next = 40, b10.next();
              case 40:
                if (I10 = e11.sent, !a10 || !I10.done) {
                  e11.next = 44;
                  break;
                }
                return console.warn("You provided `batchesPerEpoch` as " + "".concat(r10.batchesPerEpoch, ", ") + "but your dataset iterator ran out of data after " + "".concat(k10, " batches; ") + "interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, " + "".concat(r10.batchesPerEpoch * r10.epochs, " batches). ") + "You may need to use the repeat() function when building your dataset."), e11.abrupt("break", 91);
              case 44:
                if (null == I10.value) {
                  e11.next = 73;
                  break;
                }
                return N10 = Kle(t10, I10.value), S10 = N10.xs, T10 = N10.ys, (E10 = {}).batch = w10, E10.size = S10[0].shape[0], e11.next = 51, m10.onBatchBegin(w10, E10);
              case 51:
                if (C10 = [], null == r10.classWeight) {
                  e11.next = 64;
                  break;
                }
                A10 = Gle(r10.classWeight, t10.outputNames), R10 = 0;
              case 55:
                if (!(R10 < A10.length)) {
                  e11.next = 64;
                  break;
                }
                return e11.t0 = C10, e11.next = 59, jle(T10[R10], null, A10[R10]);
              case 59:
                e11.t1 = e11.sent, e11.t0.push.call(e11.t0, e11.t1);
              case 61:
                ++R10, e11.next = 55;
                break;
              case 64:
                for (_10 = S10.concat(T10).concat(C10), O10 = l10(_10), Y5(_10), F10 = 0; F10 < h10.length; ++F10) D10 = h10[F10], M10 = O10[F10], E10[D10] = M10, J5(M10);
                return e11.next = 70, m10.onBatchEnd(w10, E10);
              case 70:
                Xce(E10), w10++, k10++;
              case 73:
                if (!(a10 ? k10 >= r10.batchesPerEpoch : I10.done)) {
                  e11.next = 87;
                  break;
                }
                if (!i10) {
                  e11.next = 86;
                  break;
                }
                if (L10 = void 0, !$le(r10.validationData)) {
                  e11.next = 84;
                  break;
                }
                return e11.t2 = Lse, e11.next = 80, t10.evaluateDataset(r10.validationData, { batches: r10.validationBatches });
              case 80:
                e11.t3 = e11.sent, L10 = (0, e11.t2)(e11.t3), e11.next = 85;
                break;
              case 84:
                L10 = Lse(t10.evaluate(s10, u10, { batchSize: null == r10.validationBatchSize ? 32 : r10.validationBatchSize, verbose: 0 }));
              case 85:
                for (z10 = 0; z10 < t10.metricsNames.length; ++z10) x10["val_".concat(t10.metricsNames[z10])] = L10[z10];
              case 86:
                return e11.abrupt("break", 91);
              case 87:
                if (!t10.stopTraining_) {
                  e11.next = 89;
                  break;
                }
                return e11.abrupt("break", 91);
              case 89:
                e11.next = 37;
                break;
              case 91:
                return e11.next = 93, m10.onEpochEnd(y10, x10);
              case 93:
                if (y10++, !t10.stopTraining_) {
                  e11.next = 96;
                  break;
                }
                return e11.abrupt("break", 98);
              case 96:
                e11.next = 27;
                break;
              case 98:
                return e11.next = 100, m10.onTrainEnd();
              case 100:
                return e11.next = 102, t10.history.syncData();
              case 102:
                return e11.abrupt("return", t10.history);
              case 103:
                return e11.prev = 103, t10.isTraining = false, e11.finish(103);
              case 106:
              case "end":
                return e11.stop();
            }
          }, e10, null, [[9, , 103, 106]]);
        })), Zle.apply(this, arguments);
      }
      function Qle(e10, t10) {
        var n10 = null;
        return null != t10.batchesPerEpoch ? n10 = t10.batchesPerEpoch : Number.isFinite(e10.size) && (n10 = e10.size), n10;
      }
      function $le(e10) {
        return "function" == typeof e10.iterator;
      }
      function ehe(e10) {
        return "function" == typeof e10.next;
      }
      function the(e10, t10, n10) {
        return nhe.apply(this, arguments);
      }
      function nhe() {
        return nhe = c(o().mark(function e10(t10, n10, r10) {
          var a10, i10, s10, u10, c10, l10, h10, p10, f10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                if (a10 = null != (r10 = r10 || {}).batches, i10 = t10.testFunction, s10 = [], !(r10.verbose > 0)) {
                  e11.next = 6;
                  break;
                }
                throw new Ase("Verbose mode is not implemented yet.");
              case 6:
                if (F$(!a10 || r10.batches > 0 && Number.isInteger(r10.batches), function() {
                  return "Test loop expects `batches` to be a positive integer, but " + "received ".concat(JSON.stringify(r10.batches));
                }), !ehe(n10)) {
                  e11.next = 11;
                  break;
                }
                e11.t0 = n10, e11.next = 14;
                break;
              case 11:
                return e11.next = 13, n10.iterator();
              case 13:
                e11.t0 = e11.sent;
              case 14:
                u10 = e11.t0, c10 = 0, l10 = 0, h10 = o().mark(function e12() {
                  var n11;
                  return o().wrap(function(e13) {
                    for (; ; ) switch (e13.prev = e13.next) {
                      case 0:
                        return e13.next = 2, u10.next();
                      case 2:
                        if (n11 = e13.sent, s10 = X5(function() {
                          if (n11.value) {
                            var e14 = Kle(t10, n11.value), r11 = e14.xs, a11 = e14.ys, o10 = r11.concat(a11), u11 = X5(function() {
                              return i10(o10);
                            });
                            if (Y5(o10), 0 === l10) for (var h11 = 0; h11 < u11.length; ++h11) s10.push(i9(0));
                            for (var p11 = o10[0].shape[0], f11 = function(e15) {
                              var t11 = u11[e15], n12 = s10[e15];
                              s10[e15] = X5(function() {
                                return d8(s10[e15], g8(p11, t11));
                              }), l10 > 0 && Y5(n12);
                            }, d10 = 0; d10 < u11.length; ++d10) f11(d10);
                            Y5(u11), c10 += p11, ++l10;
                          }
                          return s10;
                        }), !n11.done) {
                          e13.next = 7;
                          break;
                        }
                        return a10 && console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` " + "batches (in this case, ".concat(r10.batches, " batches). ") + "You may need to use the repeat() function when building your dataset."), e13.abrupt("return", "break");
                      case 7:
                      case "end":
                        return e13.stop();
                    }
                  }, e12);
                });
              case 18:
                if (a10 && !(l10 < r10.batches)) {
                  e11.next = 25;
                  break;
                }
                return e11.delegateYield(h10(), "t1", 20);
              case 20:
                if ("break" !== e11.t1) {
                  e11.next = 23;
                  break;
                }
                return e11.abrupt("break", 25);
              case 23:
                e11.next = 18;
                break;
              case 25:
                for (p10 = 0; p10 < s10.length; ++p10) f10 = s10[p10], s10[p10] = m8(s10[p10], c10), Y5(f10);
                return e11.abrupt("return", Mse(s10));
              case 27:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), nhe.apply(this, arguments);
      }
      function rhe(e10) {
        F$(e10 > 0 && Number.isInteger(e10), function() {
          return "batchSize is required to be a positive integer, but got ".concat(e10);
        });
      }
      function ahe(e10, t10, n10) {
        return null == e10 ? [null] : Array.isArray(e10) ? e10.map(function(e11) {
          return Sue(e11, t10, n10 - t10);
        }) : Sue(e10, t10, n10 - t10);
      }
      function ihe(e10, t10) {
        return X5(function() {
          return null == e10 ? null : Array.isArray(e10) ? e10.map(function(e11) {
            return ihe(e11, t10);
          }) : Fue(e10, "int32" === t10.dtype ? t10 : h8(t10, "int32"));
        });
      }
      function ohe(e10, t10) {
        for (var n10 = [], r10 = 0, a10 = null; r10 < e10; ) (a10 = r10 + t10) >= e10 && (a10 = e10), n10.push([r10, a10]), r10 = a10;
        return n10;
      }
      function she(e10) {
        var t10 = [];
        e10 instanceof n5 && (e10 = [e10]);
        for (var n10 = 0; n10 < e10.length; ++n10) {
          var r10 = e10[n10];
          if (1 === r10.rank) t10.push(Iue(r10, 1));
          else {
            if (0 === r10.rank) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
            t10.push(r10);
          }
        }
        return t10;
      }
      function uhe(e10, t10) {
        if (null != e10) {
          var n10 = [];
          if (t10 instanceof n5) n10.push(t10.id);
          else if (Array.isArray(t10)) t10.forEach(function(e11) {
            return n10.push(e11.id);
          });
          else if (null != t10) for (var r10 in t10) {
            var a10 = t10[r10];
            n10.push(a10.id);
          }
          var i10 = [];
          if (e10 instanceof n5) -1 === n10.indexOf(e10.id) && i10.push(e10);
          else if (Array.isArray(e10)) e10.forEach(function(e11) {
            -1 === n10.indexOf(e11.id) && i10.push(e11);
          });
          else if (null != e10) for (var o10 in e10) {
            var s10 = e10[o10];
            -1 === n10.indexOf(s10.id) && i10.push(s10);
          }
          i10.forEach(function(e11) {
            e11.isDisposed || e11.dispose();
          });
        }
      }
      function che(e10) {
        return Array.isArray(e10);
      }
      function lhe(e10) {
        return !function(e11) {
          return e11 instanceof n5;
        }(e10) && !che(e10);
      }
      function hhe(e10, t10, n10) {
        var r10, a10 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], i10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "";
        if (null == t10 || 0 === t10.length) {
          if (null != e10) {
            var o10 = false;
            if (che(e10) && e10.length > 0) o10 = true;
            else if (lhe(e10)) {
              for (var s10 in e10) if (e10.hasOwnProperty(s10)) {
                o10 = true;
                break;
              }
            } else o10 = true;
            if (o10) throw new Cse("Error when checking model ".concat(i10, " expected no data, ") + "but got ".concat(e10));
          }
          return [];
        }
        if (null == e10) return t10.map(function(e11) {
          return null;
        });
        if (lhe(e10)) {
          r10 = [];
          var u10, c10 = O(t10);
          try {
            for (c10.s(); !(u10 = c10.n()).done; ) {
              var l10 = u10.value;
              if (null == e10[l10]) throw new Cse('No data provided for "'.concat(l10, '". Need data for each key in: ') + "".concat(t10));
              r10.push(e10[l10]);
            }
          } catch (e11) {
            c10.e(e11);
          } finally {
            c10.f();
          }
        } else if (che(e10)) {
          if (e10.length !== t10.length) throw new Cse("Error when checking model ".concat(i10, ": the Array of ") + "Tensors that you are passing to your model is not the size the " + "model expected. Expected to see ".concat(t10.length, " Tensor(s), but ") + "instead got the following list of Tensor(s): ".concat(e10));
          r10 = e10;
        } else {
          if (t10.length > 1) throw new Cse("The model ".concat(i10, " expects ").concat(t10.length, " Tensor(s), ") + "but only received one Tensor. Found: Tensor with shape ".concat(e10.shape));
          r10 = [e10];
        }
        if (r10 = she(r10), null != n10) {
          for (var h10 = 0; h10 < t10.length; ++h10) if (null != n10[h10]) {
            var p10 = r10[h10];
            if (p10.shape.length !== n10[h10].length) throw new Cse("Error when checking ".concat(i10, ": expected ").concat(t10[h10], " ") + "to have ".concat(n10[h10].length, " dimension(s). but got array with ") + "shape ".concat(p10.shape));
            for (var f10 = 0; f10 < n10[h10].length; ++f10) if (0 !== f10 || a10) {
              var d10 = p10.shape[f10], v10 = n10[h10][f10];
              if (null != v10 && v10 >= 0 && d10 !== v10) throw new Cse("".concat(i10, " expected a batch of elements where each ") + "example has shape [".concat(n10[h10].slice(1, n10[h10].length), "] ") + "(i.e.,tensor shape [*,".concat(n10[h10].slice(1, n10[h10].length), "])") + " but the ".concat(i10, " received an input with ").concat(p10.shape[0]) + " examples, each with shape [".concat(p10.shape.slice(1, p10.shape.length), "]") + " (tensor shape [".concat(p10.shape, "])"));
            }
          }
        }
        return r10;
      }
      function phe(e10, t10, n10) {
        var r10 = jse(e10.map(function(e11) {
          return e11.shape[0];
        }));
        r10.sort();
        var a10 = jse(t10.map(function(e11) {
          return e11.shape[0];
        }));
        if (a10.sort(), r10.length > 1) throw new Cse("All input Tensors (x) should have the same number of samples. Got array shapes: " + "".concat(JSON.stringify(e10.map(function(e11) {
          return e11.shape;
        }))));
        if (a10.length > 1) throw new Cse("All target Tensors (y) should have the same number of samples. Got array shapes: " + "".concat(JSON.stringify(t10.map(function(e11) {
          return e11.shape;
        }))));
        if (r10.length > 0 && a10.length > 0 && !P$(r10, a10)) throw new Cse("Input Tensors should have the same number of samples as target " + "Tensors. Found ".concat(r10[0], " input sample(s) and ").concat(a10[0], " target ") + "sample(s).");
      }
      function fhe(e10, t10, n10) {
        for (var r10 = [ile, hle, cle], a10 = 0; a10 < e10.length; ++a10) {
          var i10 = e10[a10], o10 = t10[a10], s10 = n10[a10];
          if (null != o10) {
            if (o10 === cle && 1 === i10.shape[i10.shape.length - 1]) throw new Cse("You are passing a target array of shape ".concat(i10.shape, " while using ") + "a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");
            if (-1 !== r10.indexOf(o10)) for (var u10 = i10.shape.slice(1), c10 = s10.slice(1), l10 = 0; l10 < u10.length; ++l10) {
              var h10 = u10[l10], p10 = c10[l10];
              if (null != p10 && h10 !== p10) throw new Cse("A target Tensor with shape ".concat(i10.shape, " was passed for an ") + "output of shape ".concat(s10, ", while using a loss function that ") + "expects targets to have the same shape as the output.");
            }
          }
        }
      }
      function dhe(e10, t10, n10) {
        var r10, a10 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], i10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "";
        if (Array.isArray(e10)) {
          if (e10.length !== t10.length) throw new Cse("Error when checking model ".concat(i10, ": the Array of ") + "Tensors that you are passing to your model is not the size the " + "the model expected. Expected to see ".concat(t10.length, " Tensor(s),") + " but instead got ".concat(e10.length, " Tensors(s)."));
          r10 = e10;
        } else {
          if (t10.length > 1) throw new Cse("The model expects ".concat(t10.length, " ").concat(i10, " Tensors, ") + "but only received one Tensor. Found: array with shape " + "".concat(JSON.stringify(e10.shape), "."));
          r10 = [e10];
        }
        if (null != n10) {
          for (var o10 = 0; o10 < t10.length; ++o10) if (null != n10[o10]) {
            var s10 = r10[o10];
            if (s10.shape.length !== n10[o10].length) throw new Cse("Error when checking ".concat(i10, ": expected ").concat(t10[o10], " ") + "to have ".concat(n10[o10].length, " dimension(s), but got array with ") + "shape ".concat(JSON.stringify(s10.shape)));
            for (var u10 = 0; u10 < n10[o10].length; ++u10) if (0 !== u10 || a10) {
              var c10 = s10.shape[u10], l10 = n10[o10][u10];
              if (null != l10 && l10 !== c10) throw new Cse("Error when checking ".concat(i10, ": expected ") + "".concat(t10[o10], " to have shape ").concat(JSON.stringify(n10[o10]), " but ") + "got array with shape ".concat(JSON.stringify(s10.shape), "."));
            }
          }
        }
      }
      var vhe = function(e10) {
        d(m10, e10);
        var t10, n10, r10, a10, i10, u10, h10, f10 = w(m10);
        function m10(e11) {
          var t11;
          return l(this, m10), (t11 = f10.call(this, e11)).isTraining = false, t11;
        }
        return p(m10, [{ key: "summary", value: function(e11, t11) {
          var n11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : console.log;
          if (!this.built) throw new Cse("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
          Rle(this, e11, t11, n11);
        } }, { key: "compile", value: function(e11) {
          var t11 = this;
          if (null == e11.loss && (e11.loss = []), this.loss = e11.loss, "string" == typeof e11.optimizer) this.optimizer_ = function(e12) {
            var t12 = { Adagrad: function() {
              return nie.adagrad(0.01);
            }, Adadelta: function() {
              return nie.adadelta(1, 0.95, kue());
            }, Adam: function() {
              return nie.adam(1e-3, 0.9, 0.999, kue());
            }, Adamax: function() {
              return nie.adamax(2e-3, 0.9, 0.999, kue(), 0);
            }, RMSProp: function() {
              return nie.rmsprop(1e-3, 0.9, 0, kue());
            }, SGD: function() {
              return nie.sgd(0.01);
            } };
            if (t12.adagrad = t12.Adagrad, t12.adadelta = t12.Adadelta, t12.adam = t12.Adam, t12.adamax = t12.Adamax, t12.rmsprop = t12.RMSProp, t12.sgd = t12.SGD, e12 in t12) return t12[e12]();
            throw new Cse("Unknown Optimizer ".concat(e12));
          }(e11.optimizer), this.isOptimizerOwned = true;
          else {
            if (!(e11.optimizer instanceof Yre)) throw new Cse("User-defined optimizer must be an instance of tf.Optimizer.");
            this.optimizer_ = e11.optimizer, this.isOptimizerOwned = false;
          }
          var n11 = [];
          if (Array.isArray(e11.loss) || "string" == typeof e11.loss || "function" == typeof e11.loss) if (Array.isArray(e11.loss)) {
            if (e11.loss.length !== this.outputs.length) throw new Cse("When passing an Array as loss, it should have one entry per " + "model output. The model has ".concat(this.outputs.length, " output(s), ") + "but you passed loss=".concat(e11.loss, "."));
            var r11 = e11.loss;
            n11 = r11.map(function(e12) {
              return vle(e12);
            });
          } else {
            var a11 = vle(e11.loss);
            this.outputs.forEach(function(e12) {
              n11.push(a11);
            });
          }
          else {
            for (var i11 in e11.loss = e11.loss, e11.loss) if (-1 === this.outputNames.indexOf(i11)) throw new Cse('Unknown entry in loss dictionary: "'.concat(i11, '". ') + "Only expected the following keys: ".concat(this.outputNames));
            var o10, u11 = O(this.outputNames);
            try {
              for (u11.s(); !(o10 = u11.n()).done; ) {
                var c10 = o10.value;
                null == e11.loss[c10] && console.warn('Output "'.concat(c10, '" is missing from loss dictionary. We assume ') + "this was done on purpose, and we will not be expecting data " + "to be passed to ".concat(c10, " during training")), n11.push(vle(e11.loss[c10]));
              }
            } catch (e12) {
              u11.e(e12);
            } finally {
              u11.f();
            }
          }
          this.lossFunctions = n11, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];
          for (var l10 = 0; l10 < this.outputs.length; ++l10) {
            var h11 = this.internalOutputShapes[l10], p10 = this.outputNames[l10];
            this.feedOutputNames.push(p10), this.feedOutputShapes.push(h11), this.feedLossFns.push(this.lossFunctions[l10]);
          }
          var f11 = [];
          this.metrics = e11.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], hue("loss", function() {
            for (var e12 = 0; e12 < t11.outputs.length; ++e12) if (-1 === f11.indexOf(e12)) {
              var n12 = t11.lossFunctions[e12];
              t11.outputs.length > 1 && (t11.metricsTensors.push([n12, e12]), t11.metricsNames.push(t11.outputNames[e12] + "_loss"));
            }
          });
          var d10 = function(e12, t12) {
            if (null == e12 || Array.isArray(e12) && 0 === e12.length) return t12.map(function(e13) {
              return [];
            });
            var n12;
            if ("string" == typeof e12 || "function" == typeof e12) n12 = [e12];
            else {
              if (!Array.isArray(e12) && "object" !== s(e12)) throw new TypeError("Type of metrics argument not understood. Expected an string," + "function, Array, or Object, found: ".concat(e12));
              n12 = e12;
            }
            if (Array.isArray(n12)) return t12.map(function(e13) {
              return n12;
            });
            var r12, a12 = [], i12 = O(t12);
            try {
              for (i12.s(); !(r12 = i12.n()).done; ) {
                var o11 = r12.value, u12 = n12.hasOwnProperty(o11) ? n12[o11] : [];
                Array.isArray(u12) || (u12 = [u12]), a12.push(u12);
              }
            } catch (e13) {
              i12.e(e13);
            } finally {
              i12.f();
            }
            return a12;
          }(e11.metrics, this.outputNames);
          hue("metric", function() {
            for (var e12 = function(e13) {
              if (-1 !== f11.indexOf(e13)) return "continue";
              !function(n13) {
                var r12, a12, i12, o11, s10 = O(n13);
                try {
                  var u12 = function() {
                    var n14, s11 = o11.value;
                    if ("string" == typeof s11 && -1 !== ["accuracy", "acc", "crossentropy", "ce"].indexOf(s11)) {
                      var u13, c11 = t11.internalOutputShapes[e13];
                      1 === c11[c11.length - 1] || t11.lossFunctions[e13] === hle ? -1 !== ["accuracy", "acc"].indexOf(s11) ? a12 = mle : -1 !== ["crossentropy", "ce"].indexOf(s11) && (a12 = kle) : t11.lossFunctions[e13] === lle ? -1 !== ["accuracy", "acc"].indexOf(s11) ? a12 = wle : -1 !== ["crossentropy", "ce"].indexOf(s11) && (a12 = Nle) : -1 !== ["accuracy", "acc"].indexOf(s11) ? a12 = gle : -1 !== ["crossentropy", "ce"].indexOf(s11) && (a12 = Ile), -1 !== ["accuracy", "acc"].indexOf(s11) ? u13 = "acc" : -1 !== ["crossentropy", "ce"].indexOf(s11) && (u13 = "ce"), i12 = a12, r12 = "" + u13;
                    } else {
                      var l11 = function(e14) {
                        if ("string" == typeof e14 && e14 in Sle) return Sle[e14];
                        if ("string" != typeof e14 && null != e14) return e14;
                        throw new Cse("Unknown metric ".concat(e14));
                      }(s11);
                      i12 = l11, r12 = "" + Tle(s11);
                    }
                    hue(r12, function() {
                      n14 = i12;
                    }), function(e14, n15, r13) {
                      t11.outputNames.length > 1 && (n15 = t11.outputNames[e14] + "_" + n15), t11.metricsNames.push(n15), t11.metricsTensors.push([r13, e14]);
                    }(e13, r12, n14);
                  };
                  for (s10.s(); !(o11 = s10.n()).done; ) u12();
                } catch (e14) {
                  s10.e(e14);
                } finally {
                  s10.f();
                }
              }(d10[e13]);
            }, n12 = 0; n12 < t11.outputs.length; ++n12) e12(n12);
          }), this.collectedTrainableWeights = this.trainableWeights;
        } }, { key: "checkTrainableWeightsConsistency", value: function() {
          null != this.collectedTrainableWeights && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
        } }, { key: "evaluate", value: function(e11, t11) {
          var n11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r11 = null == n11.batchSize ? 32 : n11.batchSize;
          rhe(r11);
          var a11 = true, i11 = this.standardizeUserDataXY(e11, t11, a11, r11);
          try {
            var o10 = i11[0].concat(i11[1]);
            this.makeTestFunction();
            var s10 = this.testFunction, u11 = this.testLoop(s10, o10, r11, n11.verbose, n11.steps);
            return Mse(u11);
          } finally {
            uhe(i11[0], e11), uhe(i11[1], t11);
          }
        } }, { key: "evaluateDataset", value: (h10 = c(o().mark(function e11(t11, n11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.makeTestFunction(), e12.abrupt("return", the(this, t11, n11));
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return h10.apply(this, arguments);
        }) }, { key: "checkNumSamples", value: function(e11, t11, n11) {
          var r11, a11 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "steps";
          if (null != n11) {
            if (r11 = null, null != t11) throw new Cse("If ".concat(a11, " is set, batchSize must be null or undefined.") + "Got batchSize = ".concat(t11));
          } else {
            if (null == e11) throw new Cse("Either the input data should have a defined shape, or " + "".concat(a11, " shoud be specified."));
            r11 = Array.isArray(e11) ? e11[0].shape[0] : e11.shape[0];
          }
          return r11;
        } }, { key: "execute", value: function(e11, t11) {
          if (Array.isArray(t11) && 0 === t11.length) throw new Cse("`outputs` is an empty Array, which is not allowed.");
          var n11 = Array.isArray(t11), r11 = n11 ? t11 : [t11], a11 = this.retrieveSymbolicTensors(r11), i11 = new Tce();
          if (e11 instanceof n5 && (e11 = [e11]), Array.isArray(e11)) {
            if (e11.length !== this.inputs.length) throw new Cse("The number of inputs provided (".concat(e11.length, ") ") + "does not match the number of inputs of this model " + "(".concat(this.inputs.length, ")."));
            for (var o10 = 0; o10 < this.inputs.length; ++o10) i11.add(this.inputs[o10], e11[o10]);
          } else {
            var s10, u11 = O(this.inputs);
            try {
              for (u11.s(); !(s10 = u11.n()).done; ) {
                var c10 = s10.value, l10 = e11[c10.name];
                if (null == l10) throw new Cse("No value is provided for the model's input ".concat(c10.name));
                i11.add(c10, l10);
              }
            } catch (e12) {
              u11.e(e12);
            } finally {
              u11.f();
            }
          }
          var h11 = Ace(a11, i11);
          return n11 ? h11 : h11[0];
        } }, { key: "retrieveSymbolicTensors", value: function(e11) {
          var t11, n11 = Ose(null, e11.length), r11 = e11.length, a11 = O(this.layers);
          try {
            for (a11.s(); !(t11 = a11.n()).done; ) {
              for (var i11 = t11.value, o10 = Array.isArray(i11.output) ? i11.output : [i11.output], s10 = o10.map(function(e12) {
                return e12.name;
              }), u11 = 0; u11 < e11.length; ++u11) {
                var c10 = s10.indexOf(e11[u11]);
                if (-1 !== c10 && (n11[u11] = o10[c10], r11--), 0 === r11) break;
              }
              if (0 === r11) break;
            }
          } catch (e12) {
            a11.e(e12);
          } finally {
            a11.f();
          }
          if (r11 > 0) {
            var l10 = [];
            throw n11.forEach(function(t12, n12) {
              null == t12 && l10.push(e11[n12]);
            }), new Cse("Cannot find SymbolicTensors for output name(s): " + "".concat(JSON.stringify(l10)));
          }
          return n11;
        } }, { key: "predictLoop", value: function(e11) {
          var t11 = this, n11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 32, r11 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          return X5(function() {
            var a11 = t11.checkNumSamples(e11);
            if (r11) throw new Ase("Verbose predictLoop() is not implemented yet.");
            for (var i11 = ohe(a11, n11), o10 = t11.outputs.map(function(e12) {
              return [];
            }), s10 = function(n12) {
              X5(function() {
                var r12 = i11[n12][0], a12 = i11[n12][1], o11 = ahe(e11, r12, a12), s11 = [];
                if (Array.isArray(o11)) for (var u12 = 0; u12 < o11.length; ++u12) s11.push({ key: t11.inputs[u12], value: o11[u12] });
                else s11.push({ key: t11.inputs[0], value: o11 });
                var c10 = new Tce(s11);
                return Ace(t11.outputs, c10);
              }).forEach(function(e12, t12) {
                return o10[t12].push(e12);
              });
            }, u11 = 0; u11 < i11.length; ++u11) s10(u11);
            return Mse(o10.map(function(e12) {
              return Z8(e12, 0);
            }));
          });
        } }, { key: "predict", value: function(e11) {
          var t11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n11 = she(e11);
          dhe(n11, this.inputNames, this.feedInputShapes, false);
          try {
            var r11 = null == t11.batchSize ? 32 : t11.batchSize;
            return rhe(r11), this.predictLoop(n11, r11);
          } finally {
            uhe(n11, e11);
          }
        } }, { key: "predictOnBatch", value: function(e11) {
          dhe(e11, this.inputNames, this.feedInputShapes, true);
          var t11 = (Array.isArray(e11) ? e11[0] : e11).shape[0];
          return this.predictLoop(e11, t11);
        } }, { key: "standardizeUserDataXY", value: function(e11, t11) {
          var n11 = arguments.length > 3 ? arguments[3] : void 0;
          if (null == this.optimizer_) throw new Ese("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
          for (var r11 = [], a11 = 0; a11 < this.feedOutputShapes.length; ++a11) {
            var i11 = this.feedOutputShapes[a11], o10 = this.feedLossFns[a11];
            o10 === lle ? r11.push(i11.slice(0, i11.length - 1).concat([1])) : r11.push(i11);
          }
          if (phe(e11 = hhe(e11, this.feedInputNames, this.feedInputShapes, false, "input"), t11 = hhe(t11, this.feedOutputNames, r11, false, "target")), fhe(t11, this.feedLossFns, this.feedOutputShapes), this.stateful && null != n11 && n11 > 0 && e11[0].shape[0] % n11 != 0) throw new Cse("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size " + "".concat(n11, ". Found: ").concat(e11[0].shape[0], " sample(s)."));
          return [e11, t11];
        } }, { key: "standardizeUserData", value: (u10 = c(o().mark(function e11(t11, n11, r11, a11) {
          var i11, s10, u11, c10, l10, h11, p10, f11, d10, v10 = arguments;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (i11 = !(v10.length > 4 && void 0 !== v10[4]) || v10[4], s10 = v10.length > 5 ? v10[5] : void 0, u11 = this.standardizeUserDataXY(t11, n11, i11, s10), c10 = S(u11, 2), l10 = c10[0], h11 = c10[1], null == r11) {
                  e12.next = 5;
                  break;
                }
                throw new Error("sample weight is not supported yet.");
              case 5:
                if (p10 = null, null == a11) {
                  e12.next = 19;
                  break;
                }
                f11 = Gle(a11, this.outputNames), p10 = [], d10 = 0;
              case 10:
                if (!(d10 < f11.length)) {
                  e12.next = 19;
                  break;
                }
                return e12.t0 = p10, e12.next = 14, jle(h11[d10], null, f11[d10]);
              case 14:
                e12.t1 = e12.sent, e12.t0.push.call(e12.t0, e12.t1);
              case 16:
                ++d10, e12.next = 10;
                break;
              case 19:
                return e12.abrupt("return", [l10, h11, p10]);
              case 20:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11, n11, r11) {
          return u10.apply(this, arguments);
        }) }, { key: "testLoop", value: function(e11, t11, n11) {
          var r11 = this, a11 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, i11 = arguments.length > 4 ? arguments[4] : void 0;
          return X5(function() {
            var o10 = r11.checkNumSamples(t11, n11, i11, "steps"), s10 = [];
            if (a11 > 0) throw new Ase("Verbose mode is not implemented yet.");
            if (null != i11) throw new Ase("steps mode in testLoop() is not implemented yet");
            for (var u11 = ohe(o10, n11), c10 = Vte(xue(0, o10)), l10 = 0; l10 < u11.length; ++l10) {
              var h11 = u11[l10][0], p10 = u11[l10][1], f11 = Sue(c10, h11, p10 - h11), d10 = ihe(t11, f11), v10 = e11(d10);
              if (0 === l10) for (var m11 = 0; m11 < v10.length; ++m11) s10.push(i9(0));
              for (var g10 = 0; g10 < v10.length; ++g10) {
                var y10 = v10[g10];
                s10[g10] = d8(s10[g10], g8(p10 - h11, y10));
              }
            }
            for (var b10 = 0; b10 < s10.length; ++b10) s10[b10] = m8(s10[b10], o10);
            return s10;
          });
        } }, { key: "getDedupedMetricsNames", value: function() {
          for (var e11 = this.metricsNames, t11 = [], n11 = 0; n11 < e11.length; ++n11) {
            var r11 = e11[n11], a11 = r11;
            if (Dse(e11, r11) > 1) {
              var i11 = Dse(e11.slice(0, n11), r11);
              a11 += "_".concat(i11);
            }
            t11.push(a11);
          }
          return t11;
        } }, { key: "makeTrainFunction", value: function() {
          var e11 = this;
          return function(t11) {
            var n11 = [], r11 = t11.slice(0, e11.inputs.length), a11 = t11.slice(e11.inputs.length, e11.inputs.length + e11.outputs.length), i11 = t11.slice(e11.inputs.length + e11.outputs.length, e11.inputs.length + 2 * e11.outputs.length), o10 = [], s10 = e11.collectedTrainableWeights.map(function(e12) {
              return e12.read();
            });
            return [e11.optimizer_.minimize(function() {
              for (var t12 = [], s11 = 0; s11 < e11.inputs.length; ++s11) t12.push({ key: e11.inputs[s11], value: r11[s11] });
              for (var u11, c10 = new Tce(t12), l10 = Ace(e11.outputs, c10, { training: true }), h11 = 0; h11 < e11.lossFunctions.length; ++h11) {
                var p10 = (0, e11.lossFunctions[h11])(a11[h11], l10[h11]);
                null != i11[h11] && (p10 = qle(p10, i11[h11]));
                var f11 = Q9(p10);
                n11.push(f11), u11 = 0 === h11 ? p10 : d8(u11, p10);
              }
              for (var d10 = 0; d10 < e11.metricsTensors.length; ++d10) {
                var v10 = void 0;
                if (e11.outputs.length > 1 && d10 < e11.outputs.length) v10 = n11[d10];
                else {
                  var m11 = e11.metricsTensors[d10][0], g10 = e11.metricsTensors[d10][1];
                  v10 = Q9(m11(a11[g10], l10[g10]));
                }
                J5(v10), o10.push(v10);
              }
              return u11 = Q9(u11), e11.calculateLosses().forEach(function(e12) {
                u11 = d8(u11, e12);
              }), u11;
            }, true, s10)].concat(o10);
          };
        } }, { key: "makeTestFunction", value: function() {
          var e11 = this;
          this.testFunction = function(t11) {
            return X5(function() {
              for (var n11, r11 = [], a11 = t11.slice(0, e11.inputs.length), i11 = t11.slice(e11.inputs.length, e11.inputs.length + e11.outputs.length), o10 = [], s10 = 0; s10 < e11.inputs.length; ++s10) o10.push({ key: e11.inputs[s10], value: a11[s10] });
              for (var u11 = new Tce(o10), c10 = Ace(e11.outputs, u11), l10 = 0; l10 < e11.lossFunctions.length; ++l10) {
                var h11 = e11.lossFunctions[l10], p10 = Q9(h11(i11[l10], c10[l10]));
                n11 = 0 === l10 ? p10 : d8(n11, p10), r11.push(n11);
              }
              for (var f11 = 0; f11 < e11.metricsTensors.length; ++f11) {
                var d10 = e11.metricsTensors[f11][0], v10 = e11.metricsTensors[f11][1], m11 = Q9(d10(i11[v10], c10[v10]));
                r11.push(m11);
              }
              return r11;
            });
          };
        } }, { key: "fit", value: (i10 = c(o().mark(function e11(t11, n11) {
          var r11, a11, i11, s10, u11, c10, l10, h11, p10, f11, d10, v10, m11, g10, y10, b10, x10, k10, w10, I10, N10, S10, T10, E10, C10, A10, R10 = arguments;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (r11 = R10.length > 2 && void 0 !== R10[2] ? R10[2] : {}, !this.isTraining) {
                  e12.next = 3;
                  break;
                }
                throw new Error("Cannot start training because another fit() call is ongoing.");
              case 3:
                return this.isTraining = true, e12.prev = 4, rhe(d10 = null == r11.batchSize ? 32 : r11.batchSize), v10 = false, e12.next = 10, this.standardizeUserData(t11, n11, r11.sampleWeight, r11.classWeight, v10, d10);
              case 10:
                if (m11 = e12.sent, a11 = m11[0], i11 = m11[1], f11 = m11[2], g10 = false, !(null != r11.validationData && r11.validationData.length > 0)) {
                  e12.next = 36;
                  break;
                }
                if (g10 = true, 2 !== r11.validationData.length) {
                  e12.next = 22;
                  break;
                }
                c10 = r11.validationData[0], l10 = r11.validationData[1], e12.next = 27;
                break;
              case 22:
                if (3 !== r11.validationData.length) {
                  e12.next = 26;
                  break;
                }
                throw new Ase("validationData including sample weights is not supported yet.");
              case 26:
                throw new Cse("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; " + "".concat(r11.validationData, " is invalid."));
              case 27:
                return b10 = true, e12.next = 30, this.standardizeUserData(c10, l10, null, null, b10, d10);
              case 30:
                x10 = e12.sent, h11 = x10[0], p10 = x10[1], y10 = h11.concat(p10), e12.next = 37;
                break;
              case 36:
                null != r11.validationSplit && r11.validationSplit > 0 && r11.validationSplit < 1 ? (g10 = true, k10 = Math.floor(a11[0].shape[0] * (1 - r11.validationSplit)), w10 = a11[0].shape[0], h11 = ahe(a11, k10, w10), s10 = a11, a11 = ahe(a11, 0, k10), p10 = ahe(i11, k10, w10), u11 = i11, i11 = ahe(i11, 0, k10), y10 = h11.concat(p10)) : null != r11.validationSteps && (g10 = true);
              case 37:
                return I10 = a11.concat(i11).concat(f11), this.checkTrainableWeightsConsistency(), N10 = this.makeTrainFunction(), S10 = this.getDedupedMetricsNames(), g10 ? (this.makeTestFunction(), T10 = this.testFunction, E10 = S10.slice().concat(S10.map(function(e13) {
                  return "val_" + e13;
                }))) : (T10 = null, y10 = [], E10 = S10.slice()), C10 = ele(r11.callbacks, r11.yieldEvery), e12.next = 45, this.fitLoop(N10, I10, S10, d10, r11.epochs, r11.verbose, C10, T10, y10, r11.shuffle, E10, r11.initialEpoch, null, null);
              case 45:
                return A10 = e12.sent, e12.abrupt("return", A10);
              case 47:
                return e12.prev = 47, this.isTraining = false, uhe(a11, t11), uhe(i11, n11), uhe(s10, t11), uhe(u11, n11), uhe(h11, c10), uhe(p10, l10), null != f11 && Y5(f11), e12.finish(47);
              case 57:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[4, , 47, 57]]);
        })), function(e11, t11) {
          return i10.apply(this, arguments);
        }) }, { key: "fitLoop", value: (a10 = c(o().mark(function e11(t11, n11, r11, a11, i11, s10, u11, c10, l10, h11, p10, f11, d10, v10) {
          var m11, g10, y10, b10, x10, k10, w10, I10, N10 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (null == a11 && (a11 = 32), null == i11 && (i11 = 1), null == h11 && (h11 = true), null == f11 && (f11 = 0), m11 = false, null != c10 && null != l10 && (m11 = true), null == v10) {
                  e12.next = 10;
                  break;
                }
                if (m11 = true, null != d10) {
                  e12.next = 10;
                  break;
                }
                throw new Cse("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
              case 10:
                return null != (g10 = this.checkNumSamples(n11, a11, d10, "steps_per_epoch")) && (y10 = xue(0, g10)), null == s10 && (s10 = 1), b10 = nle(u11, s10, i11, f11, g10, d10, a11, m11, p10), x10 = b10.callbackList, k10 = b10.history, x10.setModel(this), this.history = k10, e12.next = 18, x10.onTrainBegin();
              case 18:
                this.stopTraining_ = false, w10 = o().mark(function e13() {
                  var i12, s11, u12, p11, f12;
                  return o().wrap(function(e14) {
                    for (; ; ) switch (e14.prev = e14.next) {
                      case 0:
                        return e14.next = 2, x10.onEpochBegin(I10);
                      case 2:
                        if (i12 = {}, null == d10) {
                          e14.next = 7;
                          break;
                        }
                        throw new Ase("stepsPerEpoch mode is not implemented yet.");
                      case 7:
                        if ("batch" !== h11) {
                          e14.next = 11;
                          break;
                        }
                        throw new Ase("batch shuffling is not implemneted yet");
                      case 11:
                        h11 && C$(y10);
                      case 12:
                        s11 = Vte(y10), u12 = ohe(g10, a11), p11 = o().mark(function e15(h12) {
                          var p12;
                          return o().wrap(function(e16) {
                            for (; ; ) switch (e16.prev = e16.next) {
                              case 0:
                                return p12 = {}, e16.next = 3, x10.onBatchBegin(h12, p12);
                              case 3:
                                return X5(function() {
                                  var e17 = u12[h12][0], o10 = u12[h12][1], f13 = Sue(s11, e17, o10 - e17);
                                  p12.batch = h12, p12.size = o10 - e17;
                                  for (var d11 = ihe(n11, f13), v11 = t11(d11), g11 = 0; g11 < r11.length; ++g11) {
                                    var y11 = r11[g11], b11 = v11[g11];
                                    p12[y11] = b11, J5(b11);
                                  }
                                  if (h12 === u12.length - 1 && m11) for (var x11 = N10.testLoop(c10, l10, a11), k11 = 0; k11 < r11.length; ++k11) {
                                    var w11 = r11[k11], I11 = x11[k11];
                                    J5(I11), i12["val_" + w11] = I11;
                                  }
                                }), e16.next = 6, x10.onBatchEnd(h12, p12);
                              case 6:
                                if (Xce(p12), !N10.stopTraining_) {
                                  e16.next = 9;
                                  break;
                                }
                                return e16.abrupt("return", "break");
                              case 9:
                              case "end":
                                return e16.stop();
                            }
                          }, e15);
                        }), f12 = 0;
                      case 16:
                        if (!(f12 < u12.length)) {
                          e14.next = 24;
                          break;
                        }
                        return e14.delegateYield(p11(f12), "t0", 18);
                      case 18:
                        if ("break" !== e14.t0) {
                          e14.next = 21;
                          break;
                        }
                        return e14.abrupt("break", 24);
                      case 21:
                        ++f12, e14.next = 16;
                        break;
                      case 24:
                        s11.dispose();
                      case 25:
                        return e14.next = 27, x10.onEpochEnd(I10, i12);
                      case 27:
                        if (!N10.stopTraining_) {
                          e14.next = 29;
                          break;
                        }
                        return e14.abrupt("return", "break");
                      case 29:
                      case "end":
                        return e14.stop();
                    }
                  }, e13);
                }), I10 = f11;
              case 21:
                if (!(I10 < i11)) {
                  e12.next = 29;
                  break;
                }
                return e12.delegateYield(w10(), "t0", 23);
              case 23:
                if ("break" !== e12.t0) {
                  e12.next = 26;
                  break;
                }
                return e12.abrupt("break", 29);
              case 26:
                ++I10, e12.next = 21;
                break;
              case 29:
                return e12.next = 31, x10.onTrainEnd();
              case 31:
                return e12.next = 33, this.history.syncData();
              case 33:
                return e12.abrupt("return", this.history);
              case 34:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11, n11, r11, i11, o10, s10, u11, c10, l10, h11, p10, f11, d10) {
          return a10.apply(this, arguments);
        }) }, { key: "fitDataset", value: (r10 = c(o().mark(function e11(t11, n11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.abrupt("return", Jle(this, t11, n11));
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return r10.apply(this, arguments);
        }) }, { key: "trainOnBatch", value: (n10 = c(o().mark(function e11(t11, n11) {
          var r11, a11, i11, s10, u11, c10, l10, h11, p10, f11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.standardizeUserData(t11, n11);
              case 2:
                r11 = e12.sent, a11 = r11[0], i11 = r11[1], s10 = this.makeTrainFunction(), u11 = s10(a11.concat(i11)), c10 = [], l10 = O(u11), e12.prev = 9, l10.s();
              case 11:
                if ((h11 = l10.n()).done) {
                  e12.next = 19;
                  break;
                }
                return p10 = h11.value, e12.next = 15, p10.data();
              case 15:
                f11 = e12.sent, c10.push(f11[0]);
              case 17:
                e12.next = 11;
                break;
              case 19:
                e12.next = 24;
                break;
              case 21:
                e12.prev = 21, e12.t0 = e12.catch(9), l10.e(e12.t0);
              case 24:
                return e12.prev = 24, l10.f(), e12.finish(24);
              case 27:
                return Y5(u11), uhe(r11[0], t11), uhe(r11[1], n11), e12.abrupt("return", Mse(c10));
              case 31:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[9, 21, 24, 27]]);
        })), function(e11, t11) {
          return n10.apply(this, arguments);
        }) }, { key: "getNamedWeights", value: function(e11) {
          for (var t11 = [], n11 = null != e11 && e11.trainableOnly, r11 = n11 ? this.trainableWeights : this.weights, a11 = this.getWeights(n11), i11 = 0; i11 < r11.length; ++i11) n11 && !r11[i11].trainable || t11.push({ name: r11[i11].originalName, tensor: a11[i11] });
          return t11;
        } }, { key: "stopTraining", get: function() {
          return this.stopTraining_;
        }, set: function(e11) {
          this.stopTraining_ = e11;
        } }, { key: "optimizer", get: function() {
          return this.optimizer_;
        }, set: function(e11) {
          this.optimizer_ !== e11 && (this.optimizer_ = e11, this.isOptimizerOwned = false);
        } }, { key: "dispose", value: function() {
          var e11 = N(v(m10.prototype), "dispose", this).call(this);
          if (0 === e11.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
            var t11 = K5().numTensors;
            this.optimizer_.dispose(), e11.numDisposedVariables += t11 - K5().numTensors;
          }
          return e11;
        } }, { key: "getLossIdentifiers", value: function() {
          var e11;
          if ("string" == typeof this.loss) e11 = zse(this.loss);
          else if (Array.isArray(this.loss)) {
            var t11, n11 = O(this.loss);
            try {
              for (n11.s(); !(t11 = n11.n()).done; ) {
                if ("string" != typeof t11.value) throw new Error("Serialization of non-string loss is not supported.");
              }
            } catch (e12) {
              n11.e(e12);
            } finally {
              n11.f();
            }
            e11 = this.loss.map(function(e12) {
              return zse(e12);
            });
          } else {
            var r11 = Object.keys(this.loss);
            e11 = {};
            for (var a11 = this.loss, i11 = 0, o10 = r11; i11 < o10.length; i11++) {
              var s10 = o10[i11];
              if ("string" != typeof a11[s10]) throw new Error("Serialization of non-string loss is not supported.");
              e11[s10] = zse(a11[s10]);
            }
          }
          return e11;
        } }, { key: "getMetricIdentifiers", value: function() {
          if ("string" == typeof this.metrics || "function" == typeof this.metrics) return [zse(Tle(this.metrics))];
          if (Array.isArray(this.metrics)) return this.metrics.map(function(e12) {
            return zse(Tle(e12));
          });
          var e11 = {};
          for (var t11 in this.metrics) e11[t11] = zse(Tle(this.metrics[t11]));
          return e11;
        } }, { key: "getTrainingConfig", value: function() {
          return { loss: this.getLossIdentifiers(), metrics: this.getMetricIdentifiers(), optimizer_config: { class_name: this.optimizer.getClassName(), config: this.optimizer.getConfig() } };
        } }, { key: "loadTrainingConfig", value: function(e11) {
          if (null != e11.weighted_metrics) throw new Error("Loading weight_metrics is not supported yet.");
          if (null != e11.loss_weights) throw new Error("Loading loss_weights is not supported yet.");
          if (null != e11.sample_weight_mode) throw new Error("Loading sample_weight_mode is not supported yet.");
          var t11, n11, r11 = rle(zle(e11.optimizer_config));
          if ("string" == typeof e11.loss) t11 = Pse(e11.loss);
          else if (Array.isArray(e11.loss)) t11 = e11.loss.map(function(e12) {
            return Pse(e12);
          });
          else if (null != e11.loss) for (var a11 in t11 = {}, e11.loss) t11[a11] = Pse(e11.loss[a11]);
          if (Array.isArray(e11.metrics)) n11 = e11.metrics.map(function(e12) {
            return Pse(e12);
          });
          else if (null != e11.metrics) for (var i11 in n11 = {}, e11.metrics) n11[i11] = Pse(e11.metrics[i11]);
          this.compile({ loss: t11, metrics: n11, optimizer: r11 });
        } }, { key: "save", value: (t10 = c(o().mark(function e11(t11, n11) {
          var r11, a11, i11, s10, u11, c10, l10, h11, p10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if ("string" != typeof t11) {
                  e12.next = 9;
                  break;
                }
                if (0 !== (r11 = T6(t11)).length) {
                  e12.next = 6;
                  break;
                }
                throw new Cse("Cannot find any save handlers for URL '".concat(t11, "'"));
              case 6:
                if (!(r11.length > 1)) {
                  e12.next = 8;
                  break;
                }
                throw new Cse("Found more than one (".concat(r11.length, ") save handlers for ") + "URL '".concat(t11, "'"));
              case 8:
                t11 = r11[0];
              case 9:
                if (null != t11.save) {
                  e12.next = 11;
                  break;
                }
                throw new Cse("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
              case 11:
                return e12.next = 13, t6(this.getNamedWeights(n11));
              case 13:
                if (a11 = e12.sent, i11 = this.toJSON(null, false), s10 = { modelTopology: i11, format: "layers-model", generatedBy: "TensorFlow.js tfjs-layers v".concat(Ble), convertedBy: null }, null == n11 || !n11.includeOptimizer || null == this.optimizer) {
                  e12.next = 34;
                  break;
                }
                return s10.trainingConfig = this.getTrainingConfig(), c10 = "optimizer", e12.t0 = Nae, e12.next = 25, this.optimizer.getWeights();
              case 25:
                return e12.t1 = e12.sent, e12.t2 = c10, e12.next = 29, e12.t0.encodeWeights.call(e12.t0, e12.t1, e12.t2);
              case 29:
                l10 = e12.sent, h11 = l10.data, p10 = l10.specs, (u11 = a11.specs).push.apply(u11, T(p10)), a11.data = g6([a11.data, h11]);
              case 34:
                return null != this.userDefinedMetadata && (Cle(this.userDefinedMetadata, this.name, true), s10.userDefinedMetadata = this.userDefinedMetadata), s10.weightData = a11.data, s10.weightSpecs = a11.specs, e12.abrupt("return", t11.save(s10));
              case 38:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, n11) {
          return t10.apply(this, arguments);
        }) }, { key: "setUserDefinedMetadata", value: function(e11) {
          Cle(e11, this.name), this.userDefinedMetadata = e11;
        } }, { key: "getUserDefinedMetadata", value: function() {
          return this.userDefinedMetadata;
        } }]), m10;
      }(Ule);
      vhe.className = "Model", Kre(vhe);
      var mhe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10);
      }(vhe);
      function ghe() {
        return ghe = c(o().mark(function e10(t10, n10) {
          var r10, a10, i10, s10, u10, c10, l10, h10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                if ("modelTopology" in t10 || (t10 = { modelTopology: t10 }), null != (r10 = t10.modelTopology).model_config && (r10 = r10.model_config), a10 = zle(r10), i10 = rle(a10, n10), null == t10.weightsManifest) {
                  e11.next = 15;
                  break;
                }
                return e11.next = 9, hae(t10.weightsManifest, t10.pathPrefix, i10.weights.map(function(e12) {
                  return e12.originalName;
                }));
              case 9:
                s10 = e11.sent, u10 = {}, c10 = O(i10.weights);
                try {
                  for (c10.s(); !(l10 = c10.n()).done; ) h10 = l10.value, u10[h10.originalName] = s10[h10.originalName];
                } catch (e12) {
                  c10.e(e12);
                } finally {
                  c10.f();
                }
                i10.loadWeights(u10), Y5(s10);
              case 15:
                return e11.abrupt("return", i10);
              case 16:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), ghe.apply(this, arguments);
      }
      function yhe() {
        return (yhe = c(o().mark(function e10(t10, n10) {
          var r10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                if (null == n10 && (n10 = {}), "string" != typeof t10) {
                  e11.next = 10;
                  break;
                }
                if (0 !== (r10 = E6(t10, n10)).length) {
                  e11.next = 7;
                  break;
                }
                r10.push(bae(t10, n10)), e11.next = 9;
                break;
              case 7:
                if (!(r10.length > 1)) {
                  e11.next = 9;
                  break;
                }
                throw new Cse("Found more than one (".concat(r10.length, ") load handlers for ") + "URL '".concat(t10, "'"));
              case 9:
                t10 = r10[0];
              case 10:
                return e11.abrupt("return", bhe(t10, void 0, n10));
              case 11:
              case "end":
                return e11.stop();
            }
          }, e10);
        }))).apply(this, arguments);
      }
      function bhe(e10, t10, n10) {
        return xhe.apply(this, arguments);
      }
      function xhe() {
        return xhe = c(o().mark(function e10(t10, n10, r10) {
          var a10, i10, s10, u10, c10, l10, h10, p10, f10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                if (null == r10 && (r10 = {}), null != t10.load) {
                  e11.next = 3;
                  break;
                }
                throw new Cse("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
              case 3:
                return e11.next = 5, t10.load();
              case 5:
                if (a10 = e11.sent, null != (i10 = a10.modelTopology).model_config && (i10 = i10.model_config), s10 = null == r10.strict || r10.strict, u10 = null != a10.weightData && null != a10.weightSpecs && s10, c10 = rle(zle(i10), n10, u10), null != (l10 = a10.trainingConfig) && c10.loadTrainingConfig(l10), null != a10.userDefinedMetadata && c10.setUserDefinedMetadata(a10.userDefinedMetadata), null == a10.weightData) {
                  e11.next = 24;
                  break;
                }
                if (null != a10.weightSpecs) {
                  e11.next = 17;
                  break;
                }
                throw new Cse("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");
              case 17:
                if (h10 = khe(a10.weightData, a10.weightSpecs), p10 = h10.modelWeights, f10 = h10.optimizerWeights, c10.loadWeights(p10, s10), !(null != c10.optimizer && f10.length > 0)) {
                  e11.next = 22;
                  break;
                }
                return e11.next = 22, c10.optimizer.setWeights(f10);
              case 22:
                Y5(p10), Y5(f10.map(function(e12) {
                  return e12.tensor;
                }));
              case 24:
                return e11.abrupt("return", c10);
              case 25:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), xhe.apply(this, arguments);
      }
      function khe(e10, t10) {
        var n10 = r6(e10, t10), r10 = {}, a10 = [];
        return t10.forEach(function(e11) {
          "optimizer" === e11.group ? a10.push({ name: e11.name, tensor: n10[e11.name] }) : r10[e11.name] = n10[e11.name];
        }), { modelWeights: r10, optimizerWeights: a10 };
      }
      mhe.className = "Functional", Kre(mhe);
      var whe = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11) {
          var t11;
          if (l(this, a10), e11 = e11 || {}, (t11 = r10.call(this, { inputs: [], outputs: [] })).trainable = true, t11.built = false, t11.name = null != e11.name ? e11.name : eue("sequential_"), null != e11.layers) {
            var n11, i10 = O(e11.layers);
            try {
              for (i10.s(); !(n11 = i10.n()).done; ) {
                var o10 = n11.value;
                t11.add(o10);
              }
            } catch (e12) {
              i10.e(e12);
            } finally {
              i10.f();
            }
          }
          return t11;
        }
        return p(a10, [{ key: "checkShape", value: function(e11) {
          if (e11.inboundNodes[0].outputTensors[0].shape.some(function(e12) {
            return e12 < 0;
          })) throw new Cse("Negative dimension size caused by adding layer " + "".concat(e11.name, " with input shape [") + "".concat(e11.inboundNodes[0].inputTensors[0].shape, "]"));
        } }, { key: "add", value: function(e11) {
          var t11, n11 = e11 instanceof a10 || e11 instanceof vhe;
          if (n11) {
            if (1 !== (t11 = e11).outputs.length) throw new Cse("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
            if (1 !== t11.inputs.length) throw new Cse("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
          }
          if (0 === this.outputs.length) {
            if (0 === e11.inboundNodes.length) {
              if (null == e11.batchInputShape) throw new Cse("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
              var r11 = Sce({ batchShape: e11.batchInputShape, dtype: e11.dtype, name: e11.name + "_input" });
              e11.apply(r11);
            }
            if (n11) this.outputs = t11.outputs, this.inputs = t11.inputs;
            else {
              if (1 !== e11.inboundNodes.length) throw new Cse("A layer added to a Sequential model must not already be " + "connected somewhere else. LayersModel received layer ".concat(e11.name, " ") + "which has ".concat(e11.inboundNodes.length, " pre-existing inbound ") + "connections.");
              if (1 !== e11.inboundNodes[0].outputTensors.length) throw new Cse("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
              this.checkShape(e11), this.outputs = [e11.inboundNodes[0].outputTensors[0]], this.inputs = Ice(this.outputs[0]);
            }
            this.inboundNodes = [], new xce({ outboundLayer: this, inboundLayers: [], nodeIndices: [], tensorIndices: [], inputTensors: this.inputs, outputTensors: this.outputs, inputMasks: Ose(null, this.inputs.length), outputMasks: [null], inputShapes: this.inputs.map(function(e12) {
              return e12.shape;
            }), outputShapes: this.outputs[0].shape });
          } else {
            var i10 = e11.apply(this.outputs[0]);
            if (Array.isArray(i10)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
            this.checkShape(e11), this.outputs = [i10], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
          }
          this.layers.push(e11), this.built = false;
        } }, { key: "pop", value: function() {
          if (0 === this.layers.length) throw new TypeError("There are no layers in the model.");
          if (this.layers.pop(), 0 === this.layers.length) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];
          else {
            var e11 = this.layers.length - 1;
            this.layers[e11].outboundNodes = [], this.outputs = [this.layers[e11].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
          }
        } }, { key: "call", value: function(e11, t11) {
          return null == this.model && this.build(), this.model.call(e11, t11);
        } }, { key: "build", value: function(e11) {
          if (hce(e11), 0 === this.inputs.length || 0 === this.outputs.length) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
          this.model = new vhe({ inputs: this.inputs, outputs: this.outputs[0], name: this.name + "_model" }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = true;
        } }, { key: "countParams", value: function() {
          return this.built || this.build(), N(v(a10.prototype), "countParams", this).call(this);
        } }, { key: "summary", value: function(e11, t11) {
          var n11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : console.log;
          this.built || this.build(), N(v(a10.prototype), "summary", this).call(this, e11, t11, n11);
        } }, { key: "setWeights", value: function(e11) {
          null == this.model && this.build(), this.model.setWeights(e11);
        } }, { key: "evaluate", value: function(e11, t11) {
          var n11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          if (!this.built) throw new Ese("The model needs to be compiled before being used.");
          return this.model.evaluate(e11, t11, n11);
        } }, { key: "evaluateDataset", value: function() {
          var e11 = c(o().mark(function e12(t11, n11) {
            return o().wrap(function(e13) {
              for (; ; ) switch (e13.prev = e13.next) {
                case 0:
                  if (this.built) {
                    e13.next = 2;
                    break;
                  }
                  throw new Ese("The model needs to be compiled before being used.");
                case 2:
                  return e13.abrupt("return", this.model.evaluateDataset(t11, n11));
                case 3:
                case "end":
                  return e13.stop();
              }
            }, e12, this);
          }));
          return function(t11, n11) {
            return e11.apply(this, arguments);
          };
        }() }, { key: "predict", value: function(e11) {
          var t11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          return null == this.model && this.build(), this.model.predict(e11, t11);
        } }, { key: "predictOnBatch", value: function(e11) {
          return null == this.model && this.build(), this.model.predictOnBatch(e11);
        } }, { key: "compile", value: function(e11) {
          this.build(), this.model.compile(e11), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames;
        } }, { key: "optimizer", get: function() {
          return null == this.model ? void 0 : this.model.optimizer;
        }, set: function(e11) {
          this.model.optimizer = e11;
        } }, { key: "fit", value: (n10 = c(o().mark(function e11(t11, n11) {
          var r11, a11 = arguments;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (r11 = a11.length > 2 && void 0 !== a11[2] ? a11[2] : {}, this.built) {
                  e12.next = 3;
                  break;
                }
                throw new Ese("The model needs to be compiled before being used.");
              case 3:
                return e12.abrupt("return", this.model.fit(t11, n11, r11));
              case 4:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return n10.apply(this, arguments);
        }) }, { key: "fitDataset", value: function() {
          var e11 = c(o().mark(function e12(t11, n11) {
            return o().wrap(function(e13) {
              for (; ; ) switch (e13.prev = e13.next) {
                case 0:
                  if (this.built) {
                    e13.next = 2;
                    break;
                  }
                  throw new Ese("The model needs to be compiled before being used.");
                case 2:
                  return e13.abrupt("return", this.model.fitDataset(t11, n11));
                case 3:
                case "end":
                  return e13.stop();
              }
            }, e12, this);
          }));
          return function(t11, n11) {
            return e11.apply(this, arguments);
          };
        }() }, { key: "trainOnBatch", value: (t10 = c(o().mark(function e11(t11, n11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.abrupt("return", this.model.trainOnBatch(t11, n11));
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, n11) {
          return t10.apply(this, arguments);
        }) }, { key: "stopTraining", get: function() {
          if (null == this.model) throw new Cse("Cannot get the stopTraining property of a sequential model before it is compiled.");
          return this.model.stopTraining;
        }, set: function(e11) {
          if (null == this.model) throw new Cse("Cannot set the stopTraining property of a sequential model before it is compiled.");
          this.model.stopTraining = e11;
        } }, { key: "getConfig", value: function() {
          var e11, t11 = [], n11 = O(this.layers);
          try {
            for (n11.s(); !(e11 = n11.n()).done; ) {
              var r11 = e11.value, a11 = {};
              a11.className = r11.getClassName(), a11.config = r11.getConfig(), t11.push(a11);
            }
          } catch (e12) {
            n11.e(e12);
          } finally {
            n11.f();
          }
          return { name: this.name, layers: t11 };
        } }], [{ key: "fromConfig", value: function(e11, t11) {
          var n11, r11 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i10 = {};
          if (t11 instanceof Array) {
            if (null == t11[0].className || "Merge" === t11[0].className) throw new Cse("Legacy serialization format not supported yet.");
            n11 = t11;
          } else F$(null != t11.layers, function() {
            return "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.";
          }), n11 = t11.layers, delete t11.layers, i10 = t11;
          var o10 = new e11(i10);
          if (!(o10 instanceof a10)) throw new Ase("Sequential.fromConfig called on non-Sequential input: ".concat(o10));
          var s10, u10 = O(n11);
          try {
            for (u10.s(); !(s10 = u10.n()).done; ) {
              var c10 = s10.value, l10 = void 0, h10 = rle(c10, l10, r11);
              r11 && h10.setFastWeightInitDuringBuild(true), o10.add(h10);
            }
          } catch (e12) {
            u10.e(e12);
          } finally {
            u10.f();
          }
          return o10;
        } }]), a10;
      }(vhe);
      function Ihe(e10) {
        return Sce(e10);
      }
      whe.className = "Sequential", Kre(whe);
      var Nhe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "getConfig", value: function() {
          return {};
        } }]), n10;
      }(Hre), She = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          var t11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          return zue(e11, t11);
        } }]), n10;
      }(Nhe);
      She.className = "elu", Kre(She);
      var The = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          return bte(e11);
        } }]), n10;
      }(Nhe);
      The.className = "selu", Kre(The);
      var Ehe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          return lte(e11);
        } }]), n10;
      }(Nhe);
      Ehe.className = "relu", Kre(Ehe);
      var Che = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          return X5(function() {
            return nee(6, lte(e11));
          });
        } }]), n10;
      }(Nhe);
      Che.className = "relu6", Kre(Che);
      var Ahe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          return e11;
        } }]), n10;
      }(Nhe);
      Ahe.className = "linear", Kre(Ahe);
      var Rhe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          return $8(e11);
        } }]), n10;
      }(Nhe);
      Rhe.className = "sigmoid", Kre(Rhe);
      var _he = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          return function(e12) {
            return X5(function() {
              var t11 = d8(0.5, g8(0.2, e12));
              return d7(t11, 0, 1);
            });
          }(e11);
        } }]), n10;
      }(Nhe);
      _he.className = "hardSigmoid", Kre(_he);
      var Ohe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          return L9(e11);
        } }]), n10;
      }(Nhe);
      Ohe.className = "softplus", Kre(Ohe);
      var Fhe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          return function(e12) {
            return X5(function() {
              return m8(e12, d8(y8(e12), 1));
            });
          }(e11);
        } }]), n10;
      }(Nhe);
      Fhe.className = "softsign", Kre(Fhe);
      var Dhe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          return t7(e11);
        } }]), n10;
      }(Nhe);
      Dhe.className = "tanh", Kre(Dhe);
      var Mhe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          var t11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
          return Rte(e11, t11);
        } }]), n10;
      }(Nhe);
      Mhe.className = "softmax", Kre(Mhe);
      var Lhe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          var t11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
          return B9(e11, t11);
        } }]), n10;
      }(Nhe);
      Lhe.className = "logSoftmax", Kre(Lhe);
      var zhe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          var t11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          return X5(function() {
            return g8($8(g8(e11, t11)), e11);
          });
        } }]), n10;
      }(Nhe);
      zhe.className = "swish", Kre(zhe);
      var Phe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          return X5(function() {
            return g8(e11, t7(L9(e11)));
          });
        } }]), n10;
      }(Nhe);
      function Bhe(e10) {
        return e10.getClassName();
      }
      function Whe(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return Vse(e10, qre.getMap().classNameMap, t10, "activation");
      }
      function Uhe(e10) {
        if (null == e10) {
          var t10 = { className: "linear", config: {} };
          return Whe(t10);
        }
        if ("string" == typeof e10) {
          var n10 = {};
          return n10.className = e10, n10.config = {}, Whe(n10);
        }
        return e10 instanceof Nhe ? e10 : Whe(e10);
      }
      function Vhe(e10) {
        if (null != e10 && "object" !== s(e10)) throw new Error("Argument to L1L2 regularizer's constructor is expected to be an " + "object, but received: ".concat(e10));
      }
      Phe.className = "mish", Kre(Phe);
      var Ghe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10);
      }(Hre), jhe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), r10 = t10.call(this), Vhe(e11), r10.l1 = null == e11 || null == e11.l1 ? 0.01 : e11.l1, r10.l2 = null == e11 || null == e11.l2 ? 0.01 : e11.l2, r10.hasL1 = 0 !== r10.l1, r10.hasL2 = 0 !== r10.l2, r10;
        }
        return p(n10, [{ key: "apply", value: function(e11) {
          var t11 = this;
          return X5(function() {
            var n11 = $9([1]);
            return t11.hasL1 && (n11 = d8(n11, u9(g8(t11.l1, y8(e11))))), t11.hasL2 && (n11 = d8(n11, u9(g8(t11.l2, Due(e11))))), X8(n11, []);
          });
        } }, { key: "getConfig", value: function() {
          return { l1: this.l1, l2: this.l2 };
        } }], [{ key: "fromConfig", value: function(e11, t11) {
          return new e11({ l1: t11.l1, l2: t11.l2 });
        } }]), n10;
      }(Ghe);
      jhe.className = "L1L2", Kre(jhe);
      var Hhe = { l1l2: "L1L2" };
      function qhe(e10) {
        return Wse(e10);
      }
      function Khe(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return Vse(e10, qre.getMap().classNameMap, t10, "regularizer");
      }
      function Xhe(e10) {
        return null == e10 ? null : "string" == typeof e10 ? Khe({ className: e10 in Hhe ? Hhe[e10] : e10, config: {} }) : e10 instanceof Ghe ? e10 : Khe(e10);
      }
      var Yhe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, null == e11 ? {} : e11)).supportsMasking = true, null != e11 && (r10.maxValue = e11.maxValue), r10;
        }
        return p(n10, [{ key: "call", value: function(e11, t11) {
          e11 = lce(e11);
          var n11 = lte(e11);
          return null != this.maxValue && (n11 = d7(n11, 0, this.maxValue)), n11;
        } }, { key: "computeOutputShape", value: function(e11) {
          return e11;
        } }, { key: "getConfig", value: function() {
          var e11 = { maxValue: this.maxValue }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      Yhe.className = "ReLU", Kre(Yhe);
      var Jhe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, null == e11 ? {} : e11)).DEFAULT_ALPHA = 0.3, null == e11 && (e11 = {}), r10.alpha = null == e11.alpha ? r10.DEFAULT_ALPHA : e11.alpha, r10;
        }
        return p(n10, [{ key: "call", value: function(e11, t11) {
          var n11 = lce(e11);
          return S9(n11, this.alpha);
        } }, { key: "computeOutputShape", value: function(e11) {
          return e11;
        } }, { key: "getConfig", value: function() {
          var e11 = { alpha: this.alpha }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      Jhe.className = "LeakyReLU", Kre(Jhe);
      var Zhe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), (r10 = t10.call(this, null == e11 ? {} : e11)).DEFAULT_ALPHA_INITIALIZER = "zeros", null == e11 && (e11 = {}), r10.supportsMasking = true, r10.alphaInitializer = sce(e11.alphaInitializer || r10.DEFAULT_ALPHA_INITIALIZER), r10.alphaRegularizer = Xhe(e11.alphaRegularizer), r10.alphaConstraint = Vce(e11.alphaConstraint), null == e11.sharedAxes) r10.sharedAxes = null;
          else if (Array.isArray(e11.sharedAxes)) r10.sharedAxes = e11.sharedAxes;
          else {
            if ("number" != typeof e11.sharedAxes) throw new Cse("Expected sharedAxes to be a number or an array of numbers, " + "but got ".concat(e11.sharedAxes));
            r10.sharedAxes = [e11.sharedAxes];
          }
          return r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          var t11 = (e11 = hce(e11)).slice(1);
          if (null != this.sharedAxes) {
            var n11, r10 = O(this.sharedAxes);
            try {
              for (r10.s(); !(n11 = r10.n()).done; ) {
                t11[n11.value - 1] = 1;
              }
            } catch (e12) {
              r10.e(e12);
            } finally {
              r10.f();
            }
          }
          this.alpha = this.addWeight("alpha", t11, "float32", this.alphaInitializer, this.alphaRegularizer, true, this.alphaConstraint);
          var a10 = {};
          if (null != this.sharedAxes) for (var i10 = 1; i10 < e11.length; ++i10) a10[i10] = e11[i10];
          this.inputSpec = [new gce({ ndim: e11.length, axes: a10 })], this.built = true;
        } }, { key: "call", value: function(e11, t11) {
          return e11 = lce(e11), bee(e11, this.alpha.read());
        } }, { key: "getConfig", value: function() {
          var e11 = { alphaInitializer: oce(this.alphaInitializer), alphaRegularizer: qhe(this.alphaRegularizer), alphaConstraint: Wce(this.alphaConstraint), sharedAxes: this.sharedAxes }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      Zhe.className = "PReLU", Kre(Zhe);
      var Qhe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), (r10 = t10.call(this, null == e11 ? {} : e11)).DEFAULT_ALPHA = 1, null == e11 && (e11 = {}), null != e11.alpha && e11.alpha !== r10.DEFAULT_ALPHA) throw new Ase("Non-default alpha value (".concat(e11.alpha, ") is not supported by the ") + "ELU layer yet.");
          return r10.alpha = null == e11.alpha ? r10.DEFAULT_ALPHA : e11.alpha, r10;
        }
        return p(n10, [{ key: "call", value: function(e11, t11) {
          var n11 = lce(e11);
          return H7(n11);
        } }, { key: "computeOutputShape", value: function(e11) {
          return e11;
        } }, { key: "getConfig", value: function() {
          var e11 = { alpha: this.alpha }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      Qhe.className = "ELU", Kre(Qhe);
      var $he = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, null == e11 ? {} : e11)).DEFAULT_THETA = 1, null == e11 && (e11 = {}), r10.theta = null == e11.theta ? r10.DEFAULT_THETA : e11.theta, r10;
        }
        return p(n10, [{ key: "call", value: function(e11, t11) {
          var n11 = lce(e11);
          return g8(n11, h8(b9(n11, this.theta), "float32"));
        } }, { key: "computeOutputShape", value: function(e11) {
          return e11;
        } }, { key: "getConfig", value: function() {
          var e11 = { theta: this.theta }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      $he.className = "ThresholdedReLU", Kre($he);
      var epe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, null == e11 ? {} : e11)).DEFAULT_AXIS = 1, null == e11 && (e11 = {}), r10.softmax = new Mhe().apply, r10.axis = null == e11.axis ? r10.DEFAULT_AXIS : e11.axis, r10;
        }
        return p(n10, [{ key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var r10 = lce(e11), a10 = t11.mask;
            if (null != a10) {
              var i10 = g8(P9(eee(r10.shape), h8(a10, r10.dtype)), i9(-1e9));
              r10 = d8(r10, i10);
            }
            return n11.axis instanceof Array ? n11.axis.length > 1 ? p9(P9(r10, W9(r10, n11.axis, true))) : n11.softmax(r10, n11.axis[0]) : n11.softmax(r10, n11.axis);
          });
        } }, { key: "computeOutputShape", value: function(e11) {
          return e11;
        } }, { key: "getConfig", value: function() {
          var e11 = { axis: this.axis }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      function tpe(e10, t10, n10) {
        if ("number" == typeof e10) return Ose(e10, t10);
        if (e10.length !== t10) throw new Cse("The ".concat(n10, " argument must be an integer or tuple of ").concat(t10, " integers.") + " Received: ".concat(e10.length, " elements."));
        for (var r10 = 0; r10 < t10; ++r10) {
          var a10 = e10[r10];
          if ((i10 = a10) !== parseInt(i10.toString(), 10)) throw new Cse("The ".concat(n10, " argument must be an integer or tuple of ").concat(t10) + " integers. Received: ".concat(JSON.stringify(e10), " including a") + " non-integer number ".concat(a10));
        }
        return e10;
        var i10;
      }
      function npe(e10, t10, n10, r10) {
        var a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1;
        if (null == e10) return e10;
        var i10, o10 = t10 + (t10 - 1) * (a10 - 1);
        return i10 = "same" === n10 ? e10 : e10 - o10 + 1, Math.floor((i10 + r10 - 1) / r10);
      }
      function rpe(e10, t10, n10, r10) {
        if (null == e10) return null;
        if ("valid" === r10) e10 = e10 * t10 + bue([n10 - t10, 0]);
        else {
          if ("same" !== r10) throw new Cse("Unsupport padding mode: ".concat(r10, "."));
          e10 *= t10;
        }
        return e10;
      }
      function ape(e10, t10) {
        return X5(function() {
          return sue(t10), "channelsFirst" === t10 ? hne(e10, [0, 2, 3, 1]) : e10;
        });
      }
      function ipe(e10, t10) {
        return X5(function() {
          return sue(t10), "channelsFirst" === t10 ? hne(e10, [0, 2, 3, 4, 1]) : e10;
        });
      }
      function ope(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "valid", i10 = arguments.length > 5 ? arguments[5] : void 0, o10 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1;
        return X5(function() {
          if (null == i10 && (i10 = "channelsLast"), sue(i10), 3 !== e10.shape.length) throw new Cse("The input of a conv1dWithBias operation should be 3, but is " + "".concat(e10.shape.length, " instead."));
          if (3 !== t10.shape.length) throw new Cse("The kernel for a conv1dWithBias operation should be 3, but is " + "".concat(t10.shape.length, " instead"));
          if (null != n10 && 1 !== n10.shape.length) throw new Cse("The bias for a conv1dWithBias operation should be 1, but is " + "".concat(t10.shape.length, " instead"));
          if ("channelsFirst" === i10 && (e10 = hne(e10, [0, 2, 1])), "causal" === a10) throw new Ase("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
          var s10 = x7(e10, t10, r10, "same" === a10 ? "same" : "valid", "NWC", o10);
          return null != n10 && (s10 = Lue(s10, n10)), s10;
        });
      }
      function spe(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [1, 1], a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "valid", i10 = arguments.length > 5 ? arguments[5] : void 0, o10 = arguments.length > 6 ? arguments[6] : void 0, s10 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null;
        return X5(function() {
          if (null == i10 && (i10 = "channelsLast"), sue(i10), 3 !== e10.rank && 4 !== e10.rank) throw new Cse("conv2dWithBiasActivation expects input to be of rank 3 or 4, " + "but received ".concat(e10.rank, "."));
          if (3 !== t10.rank && 4 !== t10.rank) throw new Cse("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, " + "but received ".concat(e10.rank, "."));
          var u10 = ape(e10, i10);
          if ("causal" === a10) throw new Ase("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
          return u10 = Ene({ x: u10, filter: t10, strides: r10, pad: "same" === a10 ? "same" : "valid", dilations: o10, dataFormat: "NHWC", bias: n10, activation: s10 }), "channelsFirst" === i10 && (u10 = hne(u10, [0, 3, 1, 2])), u10;
        });
      }
      function upe(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [1, 1, 1], a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "valid", i10 = arguments.length > 5 ? arguments[5] : void 0, o10 = arguments.length > 6 ? arguments[6] : void 0;
        return X5(function() {
          if (null == i10 && (i10 = "channelsLast"), sue(i10), 4 !== e10.rank && 5 !== e10.rank) throw new Cse("conv3dWithBias expects input to be of rank 4 or 5, but received " + "".concat(e10.rank, "."));
          if (4 !== t10.rank && 5 !== t10.rank) throw new Cse("conv3dWithBias expects kernel to be of rank 4 or 5, but received " + "".concat(e10.rank, "."));
          var s10 = ipe(e10, i10);
          if ("causal" === a10) throw new Ase("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
          return s10 = I7(s10, t10, r10, "same" === a10 ? "same" : "valid", "NDHWC", o10), null != n10 && (s10 = Lue(s10, n10)), "channelsFirst" === i10 && (s10 = hne(s10, [0, 4, 1, 2, 3])), s10;
        });
      }
      epe.className = "Softmax", Kre(epe);
      var cpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11, r10) {
          var a10;
          if (l(this, n10), (a10 = t10.call(this, r10)).bias = null, a10.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", a10.DEFAULT_BIAS_INITIALIZER = "zeros", n10.verifyArgs(r10), a10.rank = e11, Xse(a10.rank, "rank"), 1 !== a10.rank && 2 !== a10.rank && 3 !== a10.rank) throw new Ase("Convolution layer for rank other than 1, 2, or 3 (".concat(a10.rank, ") is ") + "not implemented yet.");
          if (a10.kernelSize = tpe(r10.kernelSize, e11, "kernelSize"), a10.strides = tpe(null == r10.strides ? 1 : r10.strides, e11, "strides"), a10.padding = null == r10.padding ? "valid" : r10.padding, uue(a10.padding), a10.dataFormat = null == r10.dataFormat ? "channelsLast" : r10.dataFormat, sue(a10.dataFormat), a10.activation = Uhe(r10.activation), a10.useBias = null == r10.useBias || r10.useBias, a10.biasInitializer = sce(r10.biasInitializer || a10.DEFAULT_BIAS_INITIALIZER), a10.biasConstraint = Vce(r10.biasConstraint), a10.biasRegularizer = Xhe(r10.biasRegularizer), a10.activityRegularizer = Xhe(r10.activityRegularizer), a10.dilationRate = tpe(null == r10.dilationRate ? 1 : r10.dilationRate, e11, "dilationRate"), 1 === a10.rank && Array.isArray(a10.dilationRate) && 1 !== a10.dilationRate.length) throw new Cse("dilationRate must be a number or an array of a single number for 1D convolution, but received " + "".concat(JSON.stringify(a10.dilationRate)));
          if (2 === a10.rank) {
            if ("number" == typeof a10.dilationRate) a10.dilationRate = [a10.dilationRate, a10.dilationRate];
            else if (2 !== a10.dilationRate.length) throw new Cse("dilationRate must be a number or array of two numbers for 2D " + "convolution, but received ".concat(JSON.stringify(a10.dilationRate)));
          } else if (3 === a10.rank) {
            if ("number" == typeof a10.dilationRate) a10.dilationRate = [a10.dilationRate, a10.dilationRate, a10.dilationRate];
            else if (3 !== a10.dilationRate.length) throw new Cse("dilationRate must be a number or array of three numbers for 3D " + "convolution, but received ".concat(JSON.stringify(a10.dilationRate)));
          }
          return a10;
        }
        return p(n10, [{ key: "getConfig", value: function() {
          var e11 = { kernelSize: this.kernelSize, strides: this.strides, padding: this.padding, dataFormat: this.dataFormat, dilationRate: this.dilationRate, activation: Bhe(this.activation), useBias: this.useBias, biasInitializer: oce(this.biasInitializer), biasRegularizer: qhe(this.biasRegularizer), activityRegularizer: qhe(this.activityRegularizer), biasConstraint: Wce(this.biasConstraint) }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }], [{ key: "verifyArgs", value: function(e11) {
          if (Fse("kernelSize" in e11, "required key 'kernelSize' not in config"), "number" != typeof e11.kernelSize && !Kse(e11.kernelSize, "number", 1, 3)) throw new Cse("BaseConv expects config.kernelSize to be number or number[] with " + "length 1, 2, or 3, but received ".concat(JSON.stringify(e11.kernelSize), "."));
        } }]), n10;
      }(wce), lpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11, r10) {
          var a10;
          return l(this, n10), (a10 = t10.call(this, e11, r10)).kernel = null, n10.verifyArgs(r10), a10.filters = r10.filters, Xse(a10.filters, "filters"), a10.kernelInitializer = sce(r10.kernelInitializer || a10.DEFAULT_KERNEL_INITIALIZER), a10.kernelConstraint = Vce(r10.kernelConstraint), a10.kernelRegularizer = Xhe(r10.kernelRegularizer), a10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          e11 = hce(e11);
          var t11 = "channelsFirst" === this.dataFormat ? 1 : e11.length - 1;
          if (null == e11[t11]) throw new Cse("The channel dimension of the input should be defined. " + "Found ".concat(e11[t11]));
          var n11 = e11[t11], r10 = this.kernelSize.concat([n11, this.filters]);
          this.kernel = this.addWeight("kernel", r10, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [{ ndim: this.rank + 2, axes: f({}, t11, n11) }], this.built = true;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var t12;
            e11 = lce(e11);
            var r10 = null == n11.bias ? null : n11.bias.read(), a10 = Jse(n11.activation.getClassName());
            if (null != a10 && 2 === n11.rank) t12 = spe(e11, n11.kernel.read(), r10, n11.strides, n11.padding, n11.dataFormat, n11.dilationRate, a10);
            else {
              if (1 === n11.rank) t12 = ope(e11, n11.kernel.read(), r10, n11.strides[0], n11.padding, n11.dataFormat, n11.dilationRate[0]);
              else if (2 === n11.rank) t12 = spe(e11, n11.kernel.read(), r10, n11.strides, n11.padding, n11.dataFormat, n11.dilationRate);
              else {
                if (3 !== n11.rank) throw new Ase("convolutions greater than 3D are not implemented yet.");
                t12 = upe(e11, n11.kernel.read(), r10, n11.strides, n11.padding, n11.dataFormat, n11.dilationRate);
              }
              null != n11.activation && (t12 = n11.activation.apply(t12));
            }
            return t12;
          });
        } }, { key: "computeOutputShape", value: function(e11) {
          e11 = hce(e11);
          for (var t11 = [], n11 = "channelsLast" === this.dataFormat ? e11.slice(1, e11.length - 1) : e11.slice(2), r10 = 0; r10 < n11.length; ++r10) {
            var a10 = npe(n11[r10], this.kernelSize[r10], this.padding, this.strides[r10], "number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[r10]);
            t11.push(a10);
          }
          var i10 = [e11[0]];
          return "channelsLast" === this.dataFormat ? (i10 = i10.concat(t11)).push(this.filters) : (i10.push(this.filters), i10 = i10.concat(t11)), i10;
        } }, { key: "getConfig", value: function() {
          var e11 = { filters: this.filters, kernelInitializer: oce(this.kernelInitializer), kernelRegularizer: qhe(this.kernelRegularizer), kernelConstraint: Wce(this.kernelConstraint) }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }], [{ key: "verifyArgs", value: function(e11) {
          if (!("filters" in e11) || "number" != typeof e11.filters || e11.filters < 1) throw new Cse("Convolution layer expected config.filters to be a 'number' > 0 " + "but got ".concat(JSON.stringify(e11.filters)));
        } }]), n10;
      }(cpe), hpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), r10 = t10.call(this, 2, e11), n10.verifyArgs(e11), r10;
        }
        return p(n10, [{ key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this);
          return delete e11.rank, e11;
        } }], [{ key: "verifyArgs", value: function(e11) {
          if ("number" != typeof e11.kernelSize && !Kse(e11.kernelSize, "number", 1, 2)) throw new Cse("Conv2D expects config.kernelSize to be number or number[] with " + "length 1 or 2, but received ".concat(JSON.stringify(e11.kernelSize), "."));
        } }]), n10;
      }(lpe);
      hpe.className = "Conv2D", Kre(hpe);
      var ppe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), r10 = t10.call(this, 3, e11), n10.verifyArgs(e11), r10;
        }
        return p(n10, [{ key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this);
          return delete e11.rank, e11;
        } }], [{ key: "verifyArgs", value: function(e11) {
          if ("number" != typeof e11.kernelSize && (!Array.isArray(e11.kernelSize) || 1 !== e11.kernelSize.length && 3 !== e11.kernelSize.length)) throw new Cse("Conv3D expects config.kernelSize to be number or" + " [number, number, number], but received ".concat(JSON.stringify(e11.kernelSize), "."));
        } }]), n10;
      }(lpe);
      ppe.className = "Conv3D", Kre(ppe);
      var fpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), (r10 = t10.call(this, e11)).inputSpec = [new gce({ ndim: 4 })], "same" !== r10.padding && "valid" !== r10.padding) throw new Cse("Conv2DTranspose currently supports only padding modes 'same' " + "and 'valid', but received padding mode ".concat(r10.padding));
          return r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          if (4 !== (e11 = hce(e11)).length) throw new Cse("Input should have rank 4; Received input shape: " + JSON.stringify(e11));
          var t11 = "channelsFirst" === this.dataFormat ? 1 : e11.length - 1;
          if (null == e11[t11]) throw new Cse("The channel dimension of the inputs should be defined. Found `None`.");
          var n11 = e11[t11], r10 = this.kernelSize.concat([this.filters, n11]);
          this.kernel = this.addWeight("kernel", r10, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [new gce({ ndim: 4, axes: f({}, t11, n11) })], this.built = true;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var t12 = lce(e11);
            if (4 !== t12.shape.length) throw new Cse("Conv2DTranspose.call() expects input tensor to be rank-4, but " + "received a tensor of rank-".concat(t12.shape.length));
            var r10, a10, i10 = t12.shape, o10 = i10[0];
            "channelsFirst" === n11.dataFormat ? (r10 = 2, a10 = 3) : (r10 = 1, a10 = 2);
            var s10 = i10[r10], u10 = i10[a10], c10 = n11.kernelSize[0], l10 = n11.kernelSize[1], h10 = n11.strides[0], p10 = n11.strides[1], f10 = [o10, rpe(s10, h10, c10, n11.padding), rpe(u10, p10, l10, n11.padding), n11.filters];
            "channelsLast" !== n11.dataFormat && (t12 = hne(t12, [0, 2, 3, 1]));
            var d10 = w7(t12, n11.kernel.read(), f10, n11.strides, n11.padding);
            return "channelsLast" !== n11.dataFormat && (d10 = hne(d10, [0, 3, 1, 2])), null != n11.bias && (d10 = Lue(d10, n11.bias.read(), n11.dataFormat)), null != n11.activation && (d10 = n11.activation.apply(d10)), d10;
          });
        } }, { key: "computeOutputShape", value: function(e11) {
          var t11, n11, r10, a10 = (e11 = hce(e11)).slice();
          "channelsFirst" === this.dataFormat ? (t11 = 1, n11 = 2, r10 = 3) : (t11 = 3, n11 = 1, r10 = 2);
          var i10 = this.kernelSize[0], o10 = this.kernelSize[1], s10 = this.strides[0], u10 = this.strides[1];
          return a10[t11] = this.filters, a10[n11] = rpe(a10[n11], s10, i10, this.padding), a10[r10] = rpe(a10[r10], u10, o10, this.padding), a10;
        } }, { key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this);
          return delete e11.dilationRate, e11;
        } }]), n10;
      }(hpe);
      fpe.className = "Conv2DTranspose", Kre(fpe);
      var dpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), (r10 = t10.call(this, e11)).inputSpec = [new gce({ ndim: 5 })], "same" !== r10.padding && "valid" !== r10.padding) throw new Cse("Conv3DTranspose currently supports only padding modes 'same' " + "and 'valid', but received padding mode ".concat(r10.padding));
          return r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          if (5 !== (e11 = hce(e11)).length) throw new Cse("Input should have rank 5; Received input shape: " + JSON.stringify(e11));
          var t11 = "channelsFirst" === this.dataFormat ? 1 : e11.length - 1;
          if (null == e11[t11]) throw new Cse("The channel dimension of the inputs should be defined. Found `None`.");
          var n11 = e11[t11], r10 = this.kernelSize.concat([this.filters, n11]);
          this.kernel = this.addWeight("kernel", r10, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [new gce({ ndim: 5, axes: f({}, t11, n11) })], this.built = true;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var t12 = lce(e11);
            if (5 !== t12.shape.length) throw new Cse("Conv3DTranspose.call() expects input tensor to be rank-4, but " + "received a tensor of rank-".concat(t12.shape.length));
            var r10, a10, i10, o10 = t12.shape, s10 = o10[0];
            "channelsFirst" === n11.dataFormat ? (i10 = 2, r10 = 3, a10 = 4) : (i10 = 1, r10 = 2, a10 = 3);
            var u10 = o10[i10], c10 = o10[r10], l10 = o10[a10], h10 = n11.kernelSize[0], p10 = n11.kernelSize[1], f10 = n11.kernelSize[2], d10 = n11.strides[0], v10 = n11.strides[1], m10 = n11.strides[2], g10 = [s10, rpe(u10, d10, h10, n11.padding), rpe(c10, v10, p10, n11.padding), rpe(l10, m10, f10, n11.padding), n11.filters];
            "channelsLast" !== n11.dataFormat && (t12 = hne(t12, [0, 2, 3, 4, 1]));
            var y10 = S7(t12, n11.kernel.read(), g10, n11.strides, n11.padding);
            return "channelsLast" !== n11.dataFormat && (y10 = hne(y10, [0, 4, 1, 2, 3])), null !== n11.bias && (y10 = Lue(y10, n11.bias.read(), n11.dataFormat)), null !== n11.activation && (y10 = n11.activation.apply(y10)), y10;
          });
        } }, { key: "computeOutputShape", value: function(e11) {
          var t11, n11, r10, a10, i10 = (e11 = hce(e11)).slice();
          "channelsFirst" === this.dataFormat ? (t11 = 1, n11 = 2, r10 = 3, a10 = 4) : (t11 = 4, n11 = 1, r10 = 2, a10 = 3);
          var o10 = this.kernelSize[0], s10 = this.kernelSize[1], u10 = this.kernelSize[2], c10 = this.strides[0], l10 = this.strides[1], h10 = this.strides[2];
          return i10[t11] = this.filters, i10[n11] = rpe(i10[n11], c10, o10, this.padding), i10[r10] = rpe(i10[r10], l10, s10, this.padding), i10[a10] = rpe(i10[a10], h10, u10, this.padding), i10;
        } }, { key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this);
          return delete e11.dilationRate, e11;
        } }]), n10;
      }(ppe);
      dpe.className = "Conv3DTranspose", Kre(dpe);
      var vpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11, r10) {
          var a10;
          if (l(this, n10), (a10 = t10.call(this, e11, r10)).DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", a10.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", a10.depthwiseKernel = null, a10.pointwiseKernel = null, null == r10.filters) throw new Cse("The `filters` configuration field is required by SeparableConv, but is unspecified.");
          if (null != r10.kernelInitializer || null != r10.kernelRegularizer || null != r10.kernelConstraint) throw new Cse("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
          if (null != r10.padding && "same" !== r10.padding && "valid" !== r10.padding) throw new Cse("SeparableConv".concat(a10.rank, "D supports only padding modes: ") + "'same' and 'valid', but received ".concat(JSON.stringify(r10.padding)));
          return a10.depthMultiplier = null == r10.depthMultiplier ? 1 : r10.depthMultiplier, a10.depthwiseInitializer = sce(r10.depthwiseInitializer || a10.DEFAULT_DEPTHWISE_INITIALIZER), a10.depthwiseRegularizer = Xhe(r10.depthwiseRegularizer), a10.depthwiseConstraint = Vce(r10.depthwiseConstraint), a10.pointwiseInitializer = sce(r10.depthwiseInitializer || a10.DEFAULT_POINTWISE_INITIALIZER), a10.pointwiseRegularizer = Xhe(r10.pointwiseRegularizer), a10.pointwiseConstraint = Vce(r10.pointwiseConstraint), a10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          if ((e11 = hce(e11)).length < this.rank + 2) throw new Cse("Inputs to SeparableConv".concat(this.rank, "D should have rank ") + "".concat(this.rank + 2, ", but received input shape: ") + "".concat(JSON.stringify(e11)));
          var t11 = "channelsFirst" === this.dataFormat ? 1 : e11.length - 1;
          if (null == e11[t11] || e11[t11] < 0) throw new Cse("The channel dimension of the inputs should be defined, " + "but found ".concat(JSON.stringify(e11[t11])));
          for (var n11 = e11[t11], r10 = this.kernelSize.concat([n11, this.depthMultiplier]), a10 = [], i10 = 0; i10 < this.rank; ++i10) a10.push(1);
          a10.push(n11 * this.depthMultiplier, this.filters);
          var o10 = true;
          this.depthwiseKernel = this.addWeight("depthwise_kernel", r10, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, o10, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", a10, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, o10, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, o10, this.biasConstraint) : this.bias = null, this.inputSpec = [new gce({ ndim: this.rank + 2, axes: f({}, t11, n11) })], this.built = true;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var t12;
            if (e11 = lce(e11), 1 === n11.rank) throw new Ase("1D separable convolution is not implemented yet.");
            return 2 === n11.rank && ("channelsFirst" === n11.dataFormat && (e11 = hne(e11, [0, 2, 3, 1])), t12 = xte(e11, n11.depthwiseKernel.read(), n11.pointwiseKernel.read(), n11.strides, n11.padding, n11.dilationRate, "NHWC")), n11.useBias && (t12 = Lue(t12, n11.bias.read(), n11.dataFormat)), null != n11.activation && (t12 = n11.activation.apply(t12)), "channelsFirst" === n11.dataFormat && (t12 = hne(t12, [0, 3, 1, 2])), t12;
          });
        } }, { key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this);
          return delete e11.rank, delete e11.kernelInitializer, delete e11.kernelRegularizer, delete e11.kernelConstraint, e11.depthwiseInitializer = oce(this.depthwiseInitializer), e11.pointwiseInitializer = oce(this.pointwiseInitializer), e11.depthwiseRegularizer = qhe(this.depthwiseRegularizer), e11.pointwiseRegularizer = qhe(this.pointwiseRegularizer), e11.depthwiseConstraint = Wce(this.depthwiseConstraint), e11.pointwiseConstraint = Wce(this.pointwiseConstraint), e11;
        } }]), n10;
      }(lpe);
      vpe.className = "SeparableConv";
      var mpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, 2, e11);
        }
        return p(n10);
      }(vpe);
      mpe.className = "SeparableConv2D", Kre(mpe);
      var gpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), r10 = t10.call(this, 1, e11), n10.verifyArgs(e11), r10.inputSpec = [{ ndim: 3 }], r10;
        }
        return p(n10, [{ key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this);
          return delete e11.rank, delete e11.dataFormat, e11;
        } }], [{ key: "verifyArgs", value: function(e11) {
          if ("number" != typeof e11.kernelSize && !Kse(e11.kernelSize, "number", 1, 1)) throw new Cse("Conv1D expects config.kernelSize to be number or number[] with " + "length 1, but received ".concat(JSON.stringify(e11.kernelSize), "."));
        } }]), n10;
      }(lpe);
      gpe.className = "Conv1D", Kre(gpe);
      var ype = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), r10 = t10.call(this, e11), "number" == typeof e11.cropping ? r10.cropping = [[e11.cropping, e11.cropping], [e11.cropping, e11.cropping]] : "number" == typeof e11.cropping[0] ? r10.cropping = [[e11.cropping[0], e11.cropping[0]], [e11.cropping[1], e11.cropping[1]]] : r10.cropping = e11.cropping, r10.dataFormat = void 0 === e11.dataFormat ? "channelsLast" : e11.dataFormat, r10.inputSpec = [{ ndim: 4 }], r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          return "channelsFirst" === this.dataFormat ? [e11[0], e11[1], e11[2] - this.cropping[0][0] - this.cropping[0][1], e11[3] - this.cropping[1][0] - this.cropping[1][1]] : [e11[0], e11[1] - this.cropping[0][0] - this.cropping[0][1], e11[2] - this.cropping[1][0] - this.cropping[1][1], e11[3]];
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            if (e11 = lce(e11), "channelsLast" === n11.dataFormat) {
              var t12 = Eue(e11, n11.cropping[0][0], e11.shape[1] - n11.cropping[0][0] - n11.cropping[0][1], 2);
              return Eue(t12, n11.cropping[1][0], e11.shape[2] - n11.cropping[1][1] - n11.cropping[1][0], 3);
            }
            var r10 = Eue(e11, n11.cropping[0][0], e11.shape[2] - n11.cropping[0][0] - n11.cropping[0][1], 3);
            return Eue(r10, n11.cropping[1][0], e11.shape[3] - n11.cropping[1][1] - n11.cropping[1][0], 4);
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { cropping: this.cropping, dataFormat: this.dataFormat }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      ype.className = "Cropping2D", Kre(ype);
      var bpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10, a10;
          return l(this, n10), (r10 = t10.call(this, e11)).DEFAULT_SIZE = [2, 2], r10.inputSpec = [{ ndim: 4 }], r10.size = null == e11.size ? r10.DEFAULT_SIZE : e11.size, r10.dataFormat = null == e11.dataFormat ? "channelsLast" : e11.dataFormat, sue(r10.dataFormat), r10.interpolation = null == e11.interpolation ? "nearest" : e11.interpolation, a10 = r10.interpolation, qse(nue, "InterpolationFormat", a10), r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          if ("channelsFirst" === this.dataFormat) {
            var t11 = null == e11[2] ? null : this.size[0] * e11[2], n11 = null == e11[3] ? null : this.size[1] * e11[3];
            return [e11[0], e11[1], t11, n11];
          }
          var r10 = null == e11[1] ? null : this.size[0] * e11[1], a10 = null == e11[2] ? null : this.size[1] * e11[2];
          return [e11[0], r10, a10, e11[3]];
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var t12 = lce(e11), r10 = t12.shape;
            if ("channelsFirst" === n11.dataFormat) {
              t12 = hne(t12, [0, 2, 3, 1]);
              var a10 = n11.size[0] * r10[2], i10 = n11.size[1] * r10[3], o10 = "nearest" === n11.interpolation ? Pre.resizeNearestNeighbor(t12, [a10, i10]) : Pre.resizeBilinear(t12, [a10, i10]);
              return hne(o10, [0, 3, 1, 2]);
            }
            var s10 = n11.size[0] * r10[1], u10 = n11.size[1] * r10[2];
            return "nearest" === n11.interpolation ? Pre.resizeNearestNeighbor(t12, [s10, u10]) : Pre.resizeBilinear(t12, [s10, u10]);
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { size: this.size, dataFormat: this.dataFormat, interpolation: this.interpolation }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      bpe.className = "UpSampling2D", Kre(bpe);
      var xpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, 2, e11)).depthwiseKernel = null, r10.depthMultiplier = null == e11.depthMultiplier ? 1 : e11.depthMultiplier, r10.depthwiseInitializer = sce(e11.depthwiseInitializer || r10.DEFAULT_KERNEL_INITIALIZER), r10.depthwiseConstraint = Vce(e11.depthwiseConstraint), r10.depthwiseRegularizer = Xhe(e11.depthwiseRegularizer), r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          if ((e11 = hce(e11)).length < 4) throw new Cse("Inputs to DepthwiseConv2D should have rank 4. " + "Received input shape: ".concat(JSON.stringify(e11), "."));
          var t11 = "channelsFirst" === this.dataFormat ? 1 : 3;
          if (null == e11[t11] || e11[t11] < 0) throw new Cse("The channel dimension of the inputs to DepthwiseConv2D should " + "be defined, but is not (".concat(e11[t11], ")."));
          var n11 = e11[t11], r10 = [this.kernelSize[0], this.kernelSize[1], n11, this.depthMultiplier];
          this.depthwiseKernel = this.addWeight("depthwise_kernel", r10, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [n11 * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var t12 = function(e12, t13) {
              var n12 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [1, 1], r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "valid", a10 = arguments.length > 4 ? arguments[4] : void 0, i10 = arguments.length > 5 ? arguments[5] : void 0;
              return X5(function() {
                null == a10 && (a10 = "channelsLast"), sue(a10);
                var o10 = ape(e12, a10);
                if (4 !== e12.rank) throw new Cse("Input for depthwiseConv2d is required to be 4-D, but is instead " + "".concat(e12.rank, "-D"));
                if (4 !== t13.rank) throw new Cse("depthwiseKernel is required to be 4-D, but is instead " + "".concat(t13.rank, "-D"));
                return o10 = O7(o10, t13, n12, "same" === r10 ? "same" : "valid", "NHWC", i10), "channelsFirst" === a10 && (o10 = hne(o10, [0, 3, 1, 2])), o10;
              });
            }(e11 = lce(e11), n11.depthwiseKernel.read(), n11.strides, n11.padding, n11.dataFormat, null);
            return n11.useBias && (t12 = Lue(t12, n11.bias.read(), n11.dataFormat)), null != n11.activation && (t12 = n11.activation.apply(t12)), t12;
          });
        } }, { key: "computeOutputShape", value: function(e11) {
          e11 = hce(e11);
          var t11 = "channelsFirst" === this.dataFormat ? e11[2] : e11[1], n11 = "channelsFirst" === this.dataFormat ? e11[3] : e11[2], r10 = "channelsFirst" === this.dataFormat ? e11[1] * this.depthMultiplier : e11[3] * this.depthMultiplier, a10 = npe(t11, this.kernelSize[0], this.padding, this.strides[0]), i10 = npe(n11, this.kernelSize[1], this.padding, this.strides[1]);
          return "channelsFirst" === this.dataFormat ? [e11[0], r10, a10, i10] : [e11[0], a10, i10, r10];
        } }, { key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this);
          return e11.depthMultiplier = this.depthMultiplier, e11.depthwiseInitializer = oce(this.depthwiseInitializer), e11.depthwiseRegularizer = qhe(this.depthwiseRegularizer), e11.depthwiseConstraint = Wce(this.depthwiseRegularizer), e11;
        } }]), n10;
      }(cpe);
      function kpe(e10, t10, n10, r10) {
        if (Array.isArray(e10)) {
          if (null != t10 || null != n10) throw new Cse("When inputs is an array, neither initialState or constants should be provided");
          null != r10 && (n10 = e10.slice(e10.length - r10, e10.length), e10 = e10.slice(0, e10.length - r10)), e10.length > 1 && (t10 = e10.slice(1, e10.length)), e10 = e10[0];
        }
        function a10(e11) {
          return null == e11 || Array.isArray(e11) ? e11 : [e11];
        }
        return { inputs: e10, initialState: t10 = a10(t10), constants: n10 = a10(n10) };
      }
      function wpe(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a10 = arguments.length > 4 ? arguments[4] : void 0, i10 = arguments.length > 5 ? arguments[5] : void 0, o10 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6], s10 = arguments.length > 7 && void 0 !== arguments[7] && arguments[7];
        return X5(function() {
          var u10 = t10.shape.length;
          if (u10 < 3) throw new Cse("Input should be at least 3D, but is ".concat(u10, "D."));
          var c10 = [1, 0].concat(xue(2, u10));
          if (t10 = hne(t10, c10), null != i10) throw new Ase("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
          o10 && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), null != a10 && ((a10 = h8(h8(a10, "bool"), "float32")).rank === u10 - 1 && (a10 = f9(a10, -1)), a10 = hne(a10, c10)), r10 && (t10 = pte(t10, 0), null != a10 && (a10 = pte(a10, 0)));
          var l10, h10, p10 = [], f10 = n10, d10 = t10.shape[0], v10 = rne(t10);
          null != a10 && (h10 = rne(a10));
          for (var m10, g10 = function(t11) {
            var n11 = v10[t11], r11 = X5(function() {
              return e10(n11, f10);
            });
            if (null == a10) l10 = r11[0], f10 = r11[1];
            else {
              var i11 = X5(function() {
                var e11 = h10[t11], n12 = P9(lee(e11), e11);
                return { output: d8(g8(r11[0], e11), g8(f10[0], n12)), newStates: f10.map(function(t12, a11) {
                  return d8(g8(r11[1][a11], e11), g8(t12, n12));
                }) };
              });
              l10 = i11.output, f10 = i11.newStates;
            }
            s10 && p10.push(l10);
          }, y10 = 0; y10 < d10; ++y10) g10(y10);
          if (s10) {
            m10 = Pte(p10, 1);
          }
          return [l10, m10, f10];
        });
      }
      xpe.className = "DepthwiseConv2D", Kre(xpe);
      var Ipe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10, a10;
          if (l(this, n10), r10 = t10.call(this, e11), null == e11.cell) throw new Cse("cell property is missing for the constructor of RNN.");
          if (null == (a10 = Array.isArray(e11.cell) ? new _pe({ cells: e11.cell }) : e11.cell).stateSize) throw new Cse("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
          return r10.cell = a10, r10.returnSequences = null != e11.returnSequences && e11.returnSequences, r10.returnState = null != e11.returnState && e11.returnState, r10.goBackwards = null != e11.goBackwards && e11.goBackwards, r10._stateful = null != e11.stateful && e11.stateful, r10.unroll = null != e11.unroll && e11.unroll, r10.supportsMasking = true, r10.inputSpec = [new gce({ ndim: 3 })], r10.stateSpec = null, r10.states_ = null, r10.numConstants = null, r10.keptStates = [], r10;
        }
        return p(n10, [{ key: "getStates", value: function() {
          return null == this.states_ ? xue(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map(function(e11) {
            return null;
          }) : this.states_;
        } }, { key: "setStates", value: function(e11) {
          this.states_ = e11;
        } }, { key: "computeOutputShape", value: function(e11) {
          uce(e11) && (e11 = e11[0]);
          var t11 = this.cell.stateSize;
          Array.isArray(t11) || (t11 = [t11]);
          var n11, r10 = t11[0];
          if (n11 = this.returnSequences ? [e11[0], e11[1], r10] : [e11[0], r10], this.returnState) {
            var a10, i10 = [], o10 = O(t11);
            try {
              for (o10.s(); !(a10 = o10.n()).done; ) {
                var s10 = a10.value;
                i10.push([e11[0], s10]);
              }
            } catch (e12) {
              o10.e(e12);
            } finally {
              o10.f();
            }
            return [n11].concat(i10);
          }
          return n11;
        } }, { key: "computeMask", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            Array.isArray(t11) && (t11 = t11[0]);
            var e12 = n11.returnSequences ? t11 : null;
            if (n11.returnState) {
              var r10 = n11.states.map(function(e13) {
                return null;
              });
              return [e12].concat(r10);
            }
            return e12;
          });
        } }, { key: "states", get: function() {
          if (null == this.states_) {
            for (var e11 = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, t11 = [], n11 = 0; n11 < e11; ++n11) t11.push(null);
            return t11;
          }
          return this.states_;
        }, set: function(e11) {
          this.states_ = e11;
        } }, { key: "build", value: function(e11) {
          if (null != this.numConstants) throw new Ase("Constants support is not implemented in RNN yet.");
          uce(e11) && (e11 = e11[0]);
          var t11 = this.stateful ? e11[0] : null, n11 = e11.slice(2);
          this.inputSpec[0] = new gce({ shape: [t11, null].concat(T(n11)) });
          var r10, a10 = [e11[0]].concat(e11.slice(2));
          if (this.cell.build(a10), r10 = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize], null != this.stateSpec) {
            if (!P$(this.stateSpec.map(function(e12) {
              return e12.shape[e12.shape.length - 1];
            }), r10)) throw new Cse("An initialState was passed that is not compatible with " + "cell.stateSize. Received stateSpec=".concat(this.stateSpec, "; ") + "However cell.stateSize is ".concat(this.cell.stateSize));
          } else this.stateSpec = r10.map(function(e12) {
            return new gce({ shape: [null, e12] });
          });
          this.stateful && this.resetStates();
        } }, { key: "resetStates", value: function(e11) {
          var t11 = this, n11 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          X5(function() {
            if (!t11.stateful) throw new Tse("Cannot call resetStates() on an RNN Layer that is not stateful.");
            var r10 = t11.inputSpec[0].shape[0];
            if (null == r10) throw new Cse("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
            if (null == t11.states_) Array.isArray(t11.cell.stateSize) ? t11.states_ = t11.cell.stateSize.map(function(e12) {
              return $9([r10, e12]);
            }) : t11.states_ = [$9([r10, t11.cell.stateSize])];
            else if (null == e11) Y5(t11.states_), null != t11.keptStates && (Y5(t11.keptStates), t11.keptStates = []), Array.isArray(t11.cell.stateSize) ? t11.states_ = t11.cell.stateSize.map(function(e12) {
              return $9([r10, e12]);
            }) : t11.states_[0] = $9([r10, t11.cell.stateSize]);
            else {
              if (Array.isArray(e11) || (e11 = [e11]), e11.length !== t11.states_.length) throw new Cse("Layer ".concat(t11.name, " expects ").concat(t11.states_.length, " state(s), ") + "but it received ".concat(e11.length, " state value(s). Input ") + "received: ".concat(e11));
              true === n11 ? t11.keptStates.push(t11.states_.slice()) : Y5(t11.states_);
              for (var a10 = 0; a10 < t11.states_.length; ++a10) {
                var i10 = e11[a10], o10 = Array.isArray(t11.cell.stateSize) ? t11.cell.stateSize[a10] : t11.cell.stateSize, s10 = [r10, o10];
                if (!P$(i10.shape, s10)) throw new Cse("State ".concat(a10, " is incompatible with layer ").concat(t11.name, ": ") + "expected shape=".concat(s10, ", received shape=").concat(i10.shape));
                t11.states_[a10] = i10;
              }
            }
            t11.states_ = t11.states_.map(function(e12) {
              return J5(e12.clone());
            });
          });
        } }, { key: "apply", value: function(e11, t11) {
          var r10 = null == t11 ? null : t11.initialState, a10 = null == t11 ? null : t11.constants;
          null == t11 && (t11 = {});
          var i10 = kpe(e11, r10, a10, this.numConstants);
          e11 = i10.inputs, r10 = i10.initialState, a10 = i10.constants;
          var o10 = [], s10 = [];
          if (null != r10) {
            t11.initialState = r10, o10 = o10.concat(r10), this.stateSpec = [];
            var u10, c10 = O(r10);
            try {
              for (c10.s(); !(u10 = c10.n()).done; ) {
                var l10 = u10.value;
                this.stateSpec.push(new gce({ shape: l10.shape }));
              }
            } catch (e12) {
              c10.e(e12);
            } finally {
              c10.f();
            }
            s10 = s10.concat(this.stateSpec);
          }
          if (null != a10 && (t11.constants = a10, o10 = o10.concat(a10), this.numConstants = a10.length), o10[0] instanceof yce) {
            var h10 = [e11].concat(o10), p10 = this.inputSpec.concat(s10), f10 = this.inputSpec;
            this.inputSpec = p10;
            var d10 = N(v(n10.prototype), "apply", this).call(this, h10, t11);
            return this.inputSpec = f10, d10;
          }
          return N(v(n10.prototype), "apply", this).call(this, e11, t11);
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var r10 = null == t11 ? null : t11.mask, a10 = null == t11 ? null : t11.training, i10 = null == t11 ? null : t11.initialState;
            e11 = lce(e11), null == i10 && (i10 = n11.stateful ? n11.states_ : n11.getInitialState(e11));
            var o10 = Array.isArray(n11.cell.stateSize) ? n11.cell.stateSize.length : 1;
            if (i10.length !== o10) throw new Cse("RNN Layer has ".concat(o10, " state(s) but was passed ") + "".concat(i10.length, " initial state(s)."));
            n11.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
            var s10 = { training: a10 }, u10 = wpe(function(e12, t12) {
              var r11 = n11.cell.call([e12].concat(t12), s10);
              return [r11[0], r11.slice(1)];
            }, e11, i10, n11.goBackwards, r10, null, n11.unroll, n11.returnSequences), c10 = u10[0], l10 = u10[1], h10 = u10[2];
            n11.stateful && n11.resetStates(h10, a10);
            var p10 = n11.returnSequences ? l10 : c10;
            return n11.returnState ? [p10].concat(h10) : p10;
          });
        } }, { key: "getInitialState", value: function(e11) {
          var t11 = this;
          return X5(function() {
            var n11 = $9(e11.shape);
            return n11 = Iue(n11 = u9(n11, [1, 2])), Array.isArray(t11.cell.stateSize) ? t11.cell.stateSize.map(function(e12) {
              return e12 > 1 ? Rue(n11, [1, e12]) : n11;
            }) : t11.cell.stateSize > 1 ? [Rue(n11, [1, t11.cell.stateSize])] : [n11];
          });
        } }, { key: "trainableWeights", get: function() {
          return this.trainable ? this.cell.trainableWeights : [];
        } }, { key: "nonTrainableWeights", get: function() {
          return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
        } }, { key: "setFastWeightInitDuringBuild", value: function(e11) {
          N(v(n10.prototype), "setFastWeightInitDuringBuild", this).call(this, e11), null != this.cell && this.cell.setFastWeightInitDuringBuild(e11);
        } }, { key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this), t11 = { returnSequences: this.returnSequences, returnState: this.returnState, goBackwards: this.goBackwards, stateful: this.stateful, unroll: this.unroll };
          null != this.numConstants && (t11.numConstants = this.numConstants);
          var r10 = this.cell.getConfig();
          return this.getClassName() === n10.className && (t11.cell = { className: this.cell.getClassName(), config: r10 }), Object.assign(Object.assign(Object.assign({}, r10), e11), t11);
        } }], [{ key: "fromConfig", value: function(e11, t11) {
          var n11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r10 = t11.cell, a10 = rle(r10, n11);
          return new e11(Object.assign(t11, { cell: a10 }));
        } }]), n10;
      }(wce);
      Ipe.className = "RNN", Kre(Ipe);
      var Npe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10);
      }(wce), Spe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).DEFAULT_ACTIVATION = "tanh", r10.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", r10.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", r10.DEFAULT_BIAS_INITIALIZER = "zeros", r10.units = e11.units, Xse(r10.units, "units"), r10.activation = Uhe(null == e11.activation ? r10.DEFAULT_ACTIVATION : e11.activation), r10.useBias = null == e11.useBias || e11.useBias, r10.kernelInitializer = sce(e11.kernelInitializer || r10.DEFAULT_KERNEL_INITIALIZER), r10.recurrentInitializer = sce(e11.recurrentInitializer || r10.DEFAULT_RECURRENT_INITIALIZER), r10.biasInitializer = sce(e11.biasInitializer || r10.DEFAULT_BIAS_INITIALIZER), r10.kernelRegularizer = Xhe(e11.kernelRegularizer), r10.recurrentRegularizer = Xhe(e11.recurrentRegularizer), r10.biasRegularizer = Xhe(e11.biasRegularizer), r10.kernelConstraint = Vce(e11.kernelConstraint), r10.recurrentConstraint = Vce(e11.recurrentConstraint), r10.biasConstraint = Vce(e11.biasConstraint), r10.dropout = yue([1, bue([0, null == e11.dropout ? 0 : e11.dropout])]), r10.recurrentDropout = yue([1, bue([0, null == e11.recurrentDropout ? 0 : e11.recurrentDropout])]), r10.dropoutFunc = e11.dropoutFunc, r10.stateSize = r10.units, r10.dropoutMask = null, r10.recurrentDropoutMask = null, r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          e11 = hce(e11), this.kernel = this.addWeight("kernel", [e11[e11.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            if (2 !== e11.length) throw new Cse("SimpleRNNCell expects 2 input Tensors, got ".concat(e11.length, "."));
            var r10 = e11[1];
            e11 = e11[0];
            var a10, i10 = null != t11.training && t11.training;
            0 < n11.dropout && n11.dropout < 1 && null == n11.dropoutMask && (n11.dropoutMask = Ope({ ones: function() {
              return lee(e11);
            }, rate: n11.dropout, training: i10, dropoutFunc: n11.dropoutFunc })), 0 < n11.recurrentDropout && n11.recurrentDropout < 1 && null == n11.recurrentDropoutMask && (n11.recurrentDropoutMask = Ope({ ones: function() {
              return lee(r10);
            }, rate: n11.recurrentDropout, training: i10, dropoutFunc: n11.dropoutFunc }));
            var o10 = n11.dropoutMask, s10 = n11.recurrentDropoutMask;
            a10 = Oue(null != o10 ? g8(e11, o10) : e11, n11.kernel.read()), null != n11.bias && (a10 = Lue(a10, n11.bias.read())), null != s10 && (r10 = g8(r10, s10));
            var u10 = d8(a10, Oue(r10, n11.recurrentKernel.read()));
            return null != n11.activation && (u10 = n11.activation.apply(u10)), [u10, u10];
          });
        } }, { key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this), t11 = { units: this.units, activation: Bhe(this.activation), useBias: this.useBias, kernelInitializer: oce(this.kernelInitializer), recurrentInitializer: oce(this.recurrentInitializer), biasInitializer: oce(this.biasInitializer), kernelRegularizer: qhe(this.kernelRegularizer), recurrentRegularizer: qhe(this.recurrentRegularizer), biasRegularizer: qhe(this.biasRegularizer), activityRegularizer: qhe(this.activityRegularizer), kernelConstraint: Wce(this.kernelConstraint), recurrentConstraint: Wce(this.recurrentConstraint), biasConstraint: Wce(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout };
          return Object.assign(Object.assign({}, e11), t11);
        } }]), n10;
      }(Npe);
      Spe.className = "SimpleRNNCell", Kre(Spe);
      var Tpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), e11.cell = new Spe(e11), t10.call(this, e11);
        }
        return p(n10, [{ key: "call", value: function(e11, t11) {
          var r10 = this;
          return X5(function() {
            null != r10.cell.dropoutMask && (Y5(r10.cell.dropoutMask), r10.cell.dropoutMask = null), null != r10.cell.recurrentDropoutMask && (Y5(r10.cell.recurrentDropoutMask), r10.cell.recurrentDropoutMask = null);
            var a10 = null == t11 ? null : t11.mask, i10 = null == t11 ? null : t11.training, o10 = null == t11 ? null : t11.initialState;
            return N(v(n10.prototype), "call", r10).call(r10, e11, { mask: a10, training: i10, initialState: o10 });
          });
        } }], [{ key: "fromConfig", value: function(e11, t11) {
          return new e11(t11);
        } }]), n10;
      }(Ipe);
      Tpe.className = "SimpleRNN", Kre(Tpe);
      var Epe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), (r10 = t10.call(this, e11)).DEFAULT_ACTIVATION = "tanh", r10.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", r10.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", r10.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", r10.DEFAULT_BIAS_INITIALIZER = "zeros", e11.resetAfter) throw new Cse("GRUCell does not support reset_after parameter set to true.");
          return r10.units = e11.units, Xse(r10.units, "units"), r10.activation = Uhe(void 0 === e11.activation ? r10.DEFAULT_ACTIVATION : e11.activation), r10.recurrentActivation = Uhe(void 0 === e11.recurrentActivation ? r10.DEFAULT_RECURRENT_ACTIVATION : e11.recurrentActivation), r10.useBias = null == e11.useBias || e11.useBias, r10.kernelInitializer = sce(e11.kernelInitializer || r10.DEFAULT_KERNEL_INITIALIZER), r10.recurrentInitializer = sce(e11.recurrentInitializer || r10.DEFAULT_RECURRENT_INITIALIZER), r10.biasInitializer = sce(e11.biasInitializer || r10.DEFAULT_BIAS_INITIALIZER), r10.kernelRegularizer = Xhe(e11.kernelRegularizer), r10.recurrentRegularizer = Xhe(e11.recurrentRegularizer), r10.biasRegularizer = Xhe(e11.biasRegularizer), r10.kernelConstraint = Vce(e11.kernelConstraint), r10.recurrentConstraint = Vce(e11.recurrentConstraint), r10.biasConstraint = Vce(e11.biasConstraint), r10.dropout = yue([1, bue([0, null == e11.dropout ? 0 : e11.dropout])]), r10.recurrentDropout = yue([1, bue([0, null == e11.recurrentDropout ? 0 : e11.recurrentDropout])]), r10.dropoutFunc = e11.dropoutFunc, r10.implementation = e11.implementation, r10.stateSize = r10.units, r10.dropoutMask = null, r10.recurrentDropoutMask = null, r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          var t11 = (e11 = hce(e11))[e11.length - 1];
          this.kernel = this.addWeight("kernel", [t11, 3 * this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 3 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [3 * this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            if (2 !== e11.length) throw new Cse("GRUCell expects 2 input Tensors (inputs, h, c), got " + "".concat(e11.length, "."));
            var r10 = null != t11.training && t11.training, a10 = e11[1];
            e11 = e11[0], 0 < n11.dropout && n11.dropout < 1 && null == n11.dropoutMask && (n11.dropoutMask = Ope({ ones: function() {
              return lee(e11);
            }, rate: n11.dropout, training: r10, count: 3, dropoutFunc: n11.dropoutFunc })), 0 < n11.recurrentDropout && n11.recurrentDropout < 1 && null == n11.recurrentDropoutMask && (n11.recurrentDropoutMask = Ope({ ones: function() {
              return lee(a10);
            }, rate: n11.recurrentDropout, training: r10, count: 3, dropoutFunc: n11.dropoutFunc }));
            var i10, o10, s10, u10 = n11.dropoutMask, c10 = n11.recurrentDropoutMask;
            0 < n11.dropout && n11.dropout < 1 && (e11 = g8(e11, u10[0]));
            var l10 = Oue(e11, n11.kernel.read());
            n11.useBias && (l10 = Lue(l10, n11.bias.read())), 0 < n11.recurrentDropout && n11.recurrentDropout < 1 && (a10 = g8(a10, c10[0]));
            var h10 = n11.recurrentKernel.read(), p10 = S(Dte(h10, [2 * n11.units, n11.units], h10.rank - 1), 2), f10 = p10[0], d10 = p10[1], v10 = Oue(a10, f10), m10 = S(Dte(l10, 3, l10.rank - 1), 3), g10 = m10[0], y10 = m10[1], b10 = m10[2], x10 = S(Dte(v10, 2, v10.rank - 1), 2), k10 = x10[0], w10 = x10[1];
            i10 = n11.recurrentActivation.apply(d8(g10, k10)), o10 = n11.recurrentActivation.apply(d8(y10, w10));
            var I10 = Oue(g8(o10, a10), d10);
            s10 = n11.activation.apply(d8(b10, I10));
            var N10 = d8(g8(i10, a10), g8(d8(1, M9(i10)), s10));
            return [N10, N10];
          });
        } }, { key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this), t11 = { units: this.units, activation: Bhe(this.activation), recurrentActivation: Bhe(this.recurrentActivation), useBias: this.useBias, kernelInitializer: oce(this.kernelInitializer), recurrentInitializer: oce(this.recurrentInitializer), biasInitializer: oce(this.biasInitializer), kernelRegularizer: qhe(this.kernelRegularizer), recurrentRegularizer: qhe(this.recurrentRegularizer), biasRegularizer: qhe(this.biasRegularizer), activityRegularizer: qhe(this.activityRegularizer), kernelConstraint: Wce(this.kernelConstraint), recurrentConstraint: Wce(this.recurrentConstraint), biasConstraint: Wce(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout, implementation: this.implementation, resetAfter: false };
          return Object.assign(Object.assign({}, e11), t11);
        } }]), n10;
      }(Npe);
      Epe.className = "GRUCell", Kre(Epe);
      var Cpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), 0 === e11.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e11.cell = new Epe(e11), t10.call(this, e11);
        }
        return p(n10, [{ key: "call", value: function(e11, t11) {
          var r10 = this;
          return X5(function() {
            null != r10.cell.dropoutMask && (Y5(r10.cell.dropoutMask), r10.cell.dropoutMask = null), null != r10.cell.recurrentDropoutMask && (Y5(r10.cell.recurrentDropoutMask), r10.cell.recurrentDropoutMask = null);
            var a10 = null == t11 ? null : t11.mask, i10 = null == t11 ? null : t11.training, o10 = null == t11 ? null : t11.initialState;
            return N(v(n10.prototype), "call", r10).call(r10, e11, { mask: a10, training: i10, initialState: o10 });
          });
        } }], [{ key: "fromConfig", value: function(e11, t11) {
          return 0 === t11.implmentation && (t11.implementation = 1), new e11(t11);
        } }]), n10;
      }(Ipe);
      Cpe.className = "GRU", Kre(Cpe);
      var Ape = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).DEFAULT_ACTIVATION = "tanh", r10.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", r10.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", r10.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", r10.DEFAULT_BIAS_INITIALIZER = "zeros", r10.units = e11.units, Xse(r10.units, "units"), r10.activation = Uhe(void 0 === e11.activation ? r10.DEFAULT_ACTIVATION : e11.activation), r10.recurrentActivation = Uhe(void 0 === e11.recurrentActivation ? r10.DEFAULT_RECURRENT_ACTIVATION : e11.recurrentActivation), r10.useBias = null == e11.useBias || e11.useBias, r10.kernelInitializer = sce(e11.kernelInitializer || r10.DEFAULT_KERNEL_INITIALIZER), r10.recurrentInitializer = sce(e11.recurrentInitializer || r10.DEFAULT_RECURRENT_INITIALIZER), r10.biasInitializer = sce(e11.biasInitializer || r10.DEFAULT_BIAS_INITIALIZER), r10.unitForgetBias = e11.unitForgetBias, r10.kernelRegularizer = Xhe(e11.kernelRegularizer), r10.recurrentRegularizer = Xhe(e11.recurrentRegularizer), r10.biasRegularizer = Xhe(e11.biasRegularizer), r10.kernelConstraint = Vce(e11.kernelConstraint), r10.recurrentConstraint = Vce(e11.recurrentConstraint), r10.biasConstraint = Vce(e11.biasConstraint), r10.dropout = yue([1, bue([0, null == e11.dropout ? 0 : e11.dropout])]), r10.recurrentDropout = yue([1, bue([0, null == e11.recurrentDropout ? 0 : e11.recurrentDropout])]), r10.dropoutFunc = e11.dropoutFunc, r10.implementation = e11.implementation, r10.stateSize = [r10.units, r10.units], r10.dropoutMask = null, r10.recurrentDropoutMask = null, r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          var t11, n11, r10 = (e11 = hce(e11))[e11.length - 1];
          if (this.kernel = this.addWeight("kernel", [r10, 4 * this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 4 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias) {
            if (this.unitForgetBias) {
              var a10 = this.biasInitializer, i10 = this.units;
              n11 = new (t11 = function(e12) {
                d(n12, e12);
                var t12 = w(n12);
                function n12() {
                  return l(this, n12), t12.apply(this, arguments);
                }
                return p(n12, [{ key: "apply", value: function(e13, t13) {
                  var n13 = a10.apply([i10]), r11 = new jue().apply([i10]), o10 = a10.apply([2 * i10]);
                  return Aue(Aue(n13, r11), o10);
                } }]), n12;
              }(Vue), t11.className = "CustomInit", t11)();
            } else n11 = this.biasInitializer;
            this.bias = this.addWeight("bias", [4 * this.units], null, n11, this.biasRegularizer, true, this.biasConstraint);
          } else this.bias = null;
          this.built = true;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var r10 = null != t11.training && t11.training;
            if (3 !== e11.length) throw new Cse("LSTMCell expects 3 input Tensors (inputs, h, c), got " + "".concat(e11.length, "."));
            var a10 = e11[1], i10 = e11[2];
            e11 = e11[0], 0 < n11.dropout && n11.dropout < 1 && null == n11.dropoutMask && (n11.dropoutMask = Ope({ ones: function() {
              return lee(e11);
            }, rate: n11.dropout, training: r10, count: 4, dropoutFunc: n11.dropoutFunc })), 0 < n11.recurrentDropout && n11.recurrentDropout < 1 && null == n11.recurrentDropoutMask && (n11.recurrentDropoutMask = Ope({ ones: function() {
              return lee(a10);
            }, rate: n11.recurrentDropout, training: r10, count: 4, dropoutFunc: n11.dropoutFunc }));
            var o10, s10, u10, c10, l10 = n11.dropoutMask, h10 = n11.recurrentDropoutMask;
            0 < n11.dropout && n11.dropout < 1 && (e11 = g8(e11, l10[0]));
            var p10 = Oue(e11, n11.kernel.read());
            0 < n11.recurrentDropout && n11.recurrentDropout < 1 && (a10 = g8(a10, h10[0])), p10 = d8(p10, Oue(a10, n11.recurrentKernel.read())), n11.useBias && (p10 = Lue(p10, n11.bias.read()));
            var f10 = S(Dte(p10, 4, p10.rank - 1), 4), d10 = f10[0], v10 = f10[1], m10 = f10[2], g10 = f10[3];
            o10 = n11.recurrentActivation.apply(d10), s10 = n11.recurrentActivation.apply(v10), u10 = d8(g8(s10, i10), g8(o10, n11.activation.apply(m10))), c10 = n11.recurrentActivation.apply(g10);
            var y10 = g8(c10, n11.activation.apply(u10));
            return [y10, y10, u10];
          });
        } }, { key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this), t11 = { units: this.units, activation: Bhe(this.activation), recurrentActivation: Bhe(this.recurrentActivation), useBias: this.useBias, kernelInitializer: oce(this.kernelInitializer), recurrentInitializer: oce(this.recurrentInitializer), biasInitializer: oce(this.biasInitializer), unitForgetBias: this.unitForgetBias, kernelRegularizer: qhe(this.kernelRegularizer), recurrentRegularizer: qhe(this.recurrentRegularizer), biasRegularizer: qhe(this.biasRegularizer), activityRegularizer: qhe(this.activityRegularizer), kernelConstraint: Wce(this.kernelConstraint), recurrentConstraint: Wce(this.recurrentConstraint), biasConstraint: Wce(this.biasConstraint), dropout: this.dropout, recurrentDropout: this.recurrentDropout, implementation: this.implementation };
          return Object.assign(Object.assign({}, e11), t11);
        } }]), n10;
      }(Npe);
      Ape.className = "LSTMCell", Kre(Ape);
      var Rpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), 0 === e11.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e11.cell = new Ape(e11), t10.call(this, e11);
        }
        return p(n10, [{ key: "call", value: function(e11, t11) {
          var r10 = this;
          return X5(function() {
            null != r10.cell.dropoutMask && (Y5(r10.cell.dropoutMask), r10.cell.dropoutMask = null), null != r10.cell.recurrentDropoutMask && (Y5(r10.cell.recurrentDropoutMask), r10.cell.recurrentDropoutMask = null);
            var a10 = null == t11 ? null : t11.mask, i10 = null == t11 ? null : t11.training, o10 = null == t11 ? null : t11.initialState;
            return N(v(n10.prototype), "call", r10).call(r10, e11, { mask: a10, training: i10, initialState: o10 });
          });
        } }], [{ key: "fromConfig", value: function(e11, t11) {
          return 0 === t11.implmentation && (t11.implementation = 1), new e11(t11);
        } }]), n10;
      }(Ipe);
      Rpe.className = "LSTM", Kre(Rpe);
      var _pe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).cells = e11.cells, r10;
        }
        return p(n10, [{ key: "stateSize", get: function() {
          var e11, t11 = [], n11 = O(this.cells.slice().reverse());
          try {
            for (n11.s(); !(e11 = n11.n()).done; ) {
              var r10 = e11.value;
              Array.isArray(r10.stateSize) ? t11.push.apply(t11, T(r10.stateSize)) : t11.push(r10.stateSize);
            }
          } catch (e12) {
            n11.e(e12);
          } finally {
            n11.f();
          }
          return t11;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var r10, a10 = e11.slice(1), i10 = [], o10 = O(n11.cells.slice().reverse());
            try {
              for (o10.s(); !(r10 = o10.n()).done; ) {
                var s10 = r10.value;
                Array.isArray(s10.stateSize) ? i10.push(a10.splice(0, s10.stateSize.length)) : i10.push(a10.splice(0, 1));
              }
            } catch (e12) {
              o10.e(e12);
            } finally {
              o10.f();
            }
            i10.reverse();
            for (var u10, c10 = [], l10 = 0; l10 < n11.cells.length; ++l10) {
              var h10 = n11.cells[l10];
              a10 = i10[l10], u10 = 0 === l10 ? [e11[0]].concat(a10) : [u10[0]].concat(a10), u10 = h10.call(u10, t11), c10.push(u10.slice(1));
            }
            a10 = [];
            var p10, f10 = O(c10.slice().reverse());
            try {
              for (f10.s(); !(p10 = f10.n()).done; ) {
                var d10, v10 = p10.value;
                (d10 = a10).push.apply(d10, T(v10));
              }
            } catch (e12) {
              f10.e(e12);
            } finally {
              f10.f();
            }
            return [u10[0]].concat(a10);
          });
        } }, { key: "build", value: function(e11) {
          var t11;
          uce(e11) && (e11 = e11[0]), this.cells.forEach(function(n11, r10) {
            hue("RNNCell_".concat(r10), function() {
              n11.build(e11), t11 = Array.isArray(n11.stateSize) ? n11.stateSize[0] : n11.stateSize, e11 = [e11[0], t11];
            });
          }), this.built = true;
        } }, { key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this), t11 = { cells: this.cells.map(function(e12) {
            return { className: e12.getClassName(), config: e12.getConfig() };
          }) };
          return Object.assign(Object.assign({}, e11), t11);
        } }, { key: "trainableWeights", get: function() {
          if (!this.trainable) return [];
          var e11, t11 = [], n11 = O(this.cells);
          try {
            for (n11.s(); !(e11 = n11.n()).done; ) {
              var r10 = e11.value;
              t11.push.apply(t11, T(r10.trainableWeights));
            }
          } catch (e12) {
            n11.e(e12);
          } finally {
            n11.f();
          }
          return t11;
        } }, { key: "nonTrainableWeights", get: function() {
          var e11, t11 = [], n11 = O(this.cells);
          try {
            for (n11.s(); !(e11 = n11.n()).done; ) {
              var r10 = e11.value;
              t11.push.apply(t11, T(r10.nonTrainableWeights));
            }
          } catch (e12) {
            n11.e(e12);
          } finally {
            n11.f();
          }
          if (!this.trainable) {
            var a10, i10 = [], o10 = O(this.cells);
            try {
              for (o10.s(); !(a10 = o10.n()).done; ) {
                var s10 = a10.value;
                i10.push.apply(i10, T(s10.trainableWeights));
              }
            } catch (e12) {
              o10.e(e12);
            } finally {
              o10.f();
            }
            return i10.concat(t11);
          }
          return t11;
        } }, { key: "getWeights", value: function() {
          var e11, t11 = [], n11 = O(this.cells);
          try {
            for (n11.s(); !(e11 = n11.n()).done; ) {
              var r10 = e11.value;
              t11.push.apply(t11, T(r10.weights));
            }
          } catch (e12) {
            n11.e(e12);
          } finally {
            n11.f();
          }
          return vce(t11);
        } }, { key: "setWeights", value: function(e11) {
          var t11, n11 = [], r10 = O(this.cells);
          try {
            for (r10.s(); !(t11 = r10.n()).done; ) for (var a10 = t11.value, i10 = a10.weights.length, o10 = e11.splice(i10), s10 = 0; s10 < a10.weights.length; ++s10) n11.push([a10.weights[s10], o10[s10]]);
          } catch (e12) {
            r10.e(e12);
          } finally {
            r10.f();
          }
          mce(n11);
        } }], [{ key: "fromConfig", value: function(e11, t11) {
          var n11, r10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, a10 = [], i10 = O(t11.cells);
          try {
            for (i10.s(); !(n11 = i10.n()).done; ) {
              var o10 = n11.value;
              a10.push(rle(o10, r10));
            }
          } catch (e12) {
            i10.e(e12);
          } finally {
            i10.f();
          }
          return new e11({ cells: a10 });
        } }]), n10;
      }(Npe);
      function Ope(e10) {
        var t10 = e10.ones, n10 = e10.rate, r10 = e10.training, a10 = void 0 !== r10 && r10, i10 = e10.count, o10 = void 0 === i10 ? 1 : i10, s10 = e10.dropoutFunc, u10 = function() {
          return null != s10 ? s10(t10(), n10) : Pue(t10(), n10);
        }, c10 = function() {
          return Bue(u10, t10, a10);
        };
        return !o10 || o10 <= 1 ? J5(c10().clone()) : Array(o10).fill(void 0).map(c10).map(function(e11) {
          return J5(e11.clone());
        });
      }
      _pe.className = "StackedRNNCells", Kre(_pe);
      var Fpe = function(e10, t10) {
        var n10 = {};
        for (var r10 in e10) Object.prototype.hasOwnProperty.call(e10, r10) && t10.indexOf(r10) < 0 && (n10[r10] = e10[r10]);
        if (null != e10 && "function" == typeof Object.getOwnPropertySymbols) {
          var a10 = 0;
          for (r10 = Object.getOwnPropertySymbols(e10); a10 < r10.length; a10++) t10.indexOf(r10[a10]) < 0 && Object.prototype.propertyIsEnumerable.call(e10, r10[a10]) && (n10[r10[a10]] = e10[r10[a10]]);
        }
        return n10;
      }, Dpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), e11.unroll) throw new Ase("Unrolling is not possible with convolutional RNNs.");
          if (Array.isArray(e11.cell)) throw new Ase("It is not possible at the moment to stack convolutional cells.");
          return (r10 = t10.call(this, e11)).inputSpec = [new gce({ ndim: 5 })], r10;
        }
        return p(n10, [{ key: "call", value: function(e11, t11) {
          var r10 = this;
          return X5(function() {
            if (null != r10.cell.dropoutMask && (Y5(r10.cell.dropoutMask), r10.cell.dropoutMask = null), null != r10.cell.recurrentDropoutMask && (Y5(r10.cell.recurrentDropoutMask), r10.cell.recurrentDropoutMask = null), t11 && t11.constants) throw new Cse("ConvRNN2D cell does not support constants");
            var a10 = null == t11 ? null : t11.mask, i10 = null == t11 ? null : t11.training, o10 = null == t11 ? null : t11.initialState;
            return N(v(n10.prototype), "call", r10).call(r10, e11, { mask: a10, training: i10, initialState: o10 });
          });
        } }, { key: "computeOutputShape", value: function(e11) {
          var t11 = this.computeSingleOutputShape(e11);
          return this.returnSequences || (t11 = [t11[0]].concat(T(t11.slice(2)))), this.returnState && (t11 = [t11].concat(T(Array(2).fill([e11[0]].concat(T(t11.slice(-3))))))), t11;
        } }, { key: "getInitialState", value: function(e11) {
          var t11 = this;
          return X5(function() {
            var n11 = t11.cell.stateSize, r10 = e11.shape, a10 = t11.computeSingleOutputShape(r10), i10 = $9([a10[0]].concat(T(a10.slice(2))));
            return Array.isArray(n11) ? Array(n11.length).fill(i10) : [i10];
          });
        } }, { key: "resetStates", value: function(e11) {
          var t11 = this, n11 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          X5(function() {
            if (!t11.stateful) throw new Tse("Cannot call resetStates() on an RNN Layer that is not stateful.");
            var r10 = t11.inputSpec[0].shape, a10 = t11.computeSingleOutputShape(r10), i10 = [a10[0]].concat(T(a10.slice(2)));
            if (null == r10[0]) throw new Cse("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
            if (null == t11.getStates()) Array.isArray(t11.cell.stateSize) ? t11.states_ = t11.cell.stateSize.map(function() {
              return $9(i10);
            }) : t11.states_ = [$9(i10)];
            else if (null == e11) Y5(t11.states_), null != t11.keptStates && (Y5(t11.keptStates), t11.keptStates = []), Array.isArray(t11.cell.stateSize) ? t11.states_ = t11.cell.stateSize.map(function() {
              return $9(i10);
            }) : t11.states_[0] = $9(i10);
            else {
              if (Array.isArray(e11) || (e11 = [e11]), e11.length !== t11.states_.length) throw new Cse("Layer ".concat(t11.name, " expects ").concat(t11.states_.length, " state(s), ") + "but it received ".concat(e11.length, " state value(s). Input ") + "received: ".concat(e11));
              n11 ? t11.keptStates.push(t11.states_.slice()) : Y5(t11.states_);
              for (var o10 = 0; o10 < t11.states_.length; ++o10) {
                var s10 = e11[o10], u10 = i10;
                if (!P$(s10.shape, u10)) throw new Cse("State ".concat(o10, " is incompatible with layer ").concat(t11.name, ": ") + "expected shape=".concat(u10, ", received shape=").concat(s10.shape));
                t11.states_[o10] = s10;
              }
            }
            t11.states_ = t11.states_.map(function(e12) {
              return J5(e12.clone());
            });
          });
        } }, { key: "computeSingleOutputShape", value: function(e11) {
          var t11 = this.cell, n11 = t11.dataFormat, r10 = t11.filters, a10 = t11.kernelSize, i10 = t11.padding, o10 = t11.strides, s10 = t11.dilationRate, u10 = "channelsFirst" === n11, c10 = e11[u10 ? 3 : 2], l10 = e11[u10 ? 4 : 3], h10 = npe(c10, a10[0], i10, o10[0], s10[0]), p10 = npe(l10, a10[1], i10, o10[1], s10[1]);
          return [].concat(T(e11.slice(0, 2)), T(u10 ? [r10, h10, p10] : [h10, p10, r10]));
        } }]), n10;
      }(Ipe);
      Dpe.className = "ConvRNN2D";
      var Mpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          l(this, n10);
          var a10 = e11.filters, i10 = e11.kernelSize, o10 = e11.strides, s10 = e11.padding, u10 = e11.dataFormat, c10 = e11.dilationRate;
          return (r10 = t10.call(this, Object.assign(Object.assign({}, e11), { units: a10 }))).filters = a10, Xse(r10.filters, "filters"), r10.kernelSize = tpe(i10, 2, "kernelSize"), r10.kernelSize.forEach(function(e12) {
            return Xse(e12, "kernelSize");
          }), r10.strides = tpe(o10 || 1, 2, "strides"), r10.strides.forEach(function(e12) {
            return Xse(e12, "strides");
          }), r10.padding = s10 || "valid", uue(r10.padding), r10.dataFormat = u10 || "channelsLast", sue(r10.dataFormat), r10.dilationRate = tpe(c10 || 1, 2, "dilationRate"), r10.dilationRate.forEach(function(e12) {
            return Xse(e12, "dilationRate");
          }), r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          var t11;
          e11 = hce(e11);
          var n11 = "channelsFirst" === this.dataFormat ? 1 : e11.length - 1;
          if (null == e11[n11]) throw new Cse("The channel dimension of the input should be defined. " + "Found ".concat(e11[n11]));
          var r10 = e11[n11], a10 = this.kernelSize.concat([r10, 4 * this.filters]);
          this.kernel = this.addWeight("kernel", a10, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
          var i10 = this.kernelSize.concat([this.filters, 4 * this.filters]);
          if (this.recurrentKernel = this.addWeight("recurrent_kernel", i10, null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias) {
            var o10;
            if (this.unitForgetBias) {
              var s10 = this.biasInitializer, u10 = this.filters;
              o10 = new (t11 = function(e12) {
                d(n12, e12);
                var t12 = w(n12);
                function n12() {
                  return l(this, n12), t12.apply(this, arguments);
                }
                return p(n12, [{ key: "apply", value: function(e13, t13) {
                  return Cue([s10.apply([u10]), eee([u10]), s10.apply([2 * u10])]);
                } }]), n12;
              }(Vue), t11.className = "CustomInit", t11)();
            } else o10 = this.biasInitializer;
            this.bias = this.addWeight("bias", [4 * this.filters], null, o10, this.biasRegularizer, true, this.biasConstraint);
          }
          this.built = true;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            if (3 !== e11.length) throw new Cse("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got " + "".concat(e11.length, "."));
            var r10 = t11.training || false, a10 = e11[0], i10 = e11[1], o10 = e11[2];
            0 < n11.dropout && n11.dropout < 1 && null == n11.dropoutMask && (n11.dropoutMask = Ope({ ones: function() {
              return lee(a10);
            }, rate: n11.dropout, training: r10, count: 4, dropoutFunc: n11.dropoutFunc }));
            var s10 = n11.dropoutMask, u10 = function(e12, t12, n12) {
              return t12 && t12[n12] ? g8(t12[n12], e12) : e12;
            }, c10 = u10(a10, s10, 0), l10 = u10(a10, s10, 1), h10 = u10(a10, s10, 2), p10 = u10(a10, s10, 3);
            0 < n11.recurrentDropout && n11.recurrentDropout < 1 && null == n11.recurrentDropoutMask && (n11.recurrentDropoutMask = Ope({ ones: function() {
              return lee(i10);
            }, rate: n11.recurrentDropout, training: r10, count: 4, dropoutFunc: n11.dropoutFunc }));
            var f10 = n11.recurrentDropoutMask, d10 = u10(i10, f10, 0), v10 = u10(i10, f10, 1), m10 = u10(i10, f10, 2), g10 = u10(i10, f10, 3), y10 = S(Dte(n11.kernel.read(), 4, 3), 4), b10 = y10[0], x10 = y10[1], k10 = y10[2], w10 = y10[3], I10 = S(n11.useBias ? Dte(n11.bias.read(), 4) : [null, null, null, null], 4), N10 = I10[0], T10 = I10[1], E10 = I10[2], C10 = I10[3];
            c10 = n11.inputConv(c10, b10, N10, n11.padding), l10 = n11.inputConv(l10, x10, T10, n11.padding), h10 = n11.inputConv(h10, k10, E10, n11.padding), p10 = n11.inputConv(p10, w10, C10, n11.padding);
            var A10 = S(Dte(n11.recurrentKernel.read(), 4, 3), 4), R10 = A10[0], _10 = A10[1], O10 = A10[2], F10 = A10[3];
            d10 = n11.recurrentConv(d10, R10), v10 = n11.recurrentConv(v10, _10), m10 = n11.recurrentConv(m10, O10), g10 = n11.recurrentConv(g10, F10);
            var D10 = n11.recurrentActivation.apply(d8(c10, d10)), M10 = n11.recurrentActivation.apply(d8(l10, v10)), L10 = d8(g8(M10, o10), g8(D10, n11.activation.apply(d8(h10, m10)))), z10 = g8(n11.recurrentActivation.apply(d8(p10, g10)), n11.activation.apply(L10));
            return [z10, z10, L10];
          });
        } }, { key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this), t11 = (e11.units, Fpe(e11, ["units"])), r10 = { filters: this.filters, kernelSize: this.kernelSize, padding: this.padding, dataFormat: this.dataFormat, dilationRate: this.dilationRate, strides: this.strides };
          return Object.assign(Object.assign({}, t11), r10);
        } }, { key: "inputConv", value: function(e11, t11, n11, r10) {
          var a10 = b7(e11, t11, this.strides, r10 || "valid", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC", this.dilationRate);
          return n11 ? Lue(a10, n11, this.dataFormat) : a10;
        } }, { key: "recurrentConv", value: function(e11, t11) {
          return b7(e11, t11, 1, "same", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC");
        } }]), n10;
      }(Ape);
      Mpe.className = "ConvLSTM2DCell", Kre(Mpe);
      var Lpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          l(this, n10);
          var r10 = new Mpe(e11);
          return t10.call(this, Object.assign(Object.assign({}, e11), { cell: r10 }));
        }
        return p(n10, null, [{ key: "fromConfig", value: function(e11, t11) {
          return new e11(t11);
        } }]), n10;
      }(Dpe);
      Lpe.className = "ConvLSTM2D", Kre(Lpe);
      var zpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).rate = Math.max(Math.min(e11.rate, 1), 0), r10.noiseShape = e11.noiseShape, r10.seed = e11.seed, r10.supportsMasking = true, r10;
        }
        return p(n10, [{ key: "getNoiseShape", value: function(e11) {
          if (null == this.noiseShape) return this.noiseShape;
          for (var t11 = e11.shape, n11 = [], r10 = 0; r10 < this.noiseShape.length; ++r10) n11.push(null == this.noiseShape[r10] ? t11[r10] : this.noiseShape[r10]);
          return n11;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            n11.invokeCallHook(e11, t11);
            var r10 = lce(e11);
            if (0 < n11.rate && n11.rate < 1) {
              var a10 = null != t11.training && t11.training, i10 = n11.getNoiseShape(r10);
              return Bue(function() {
                return Pue(r10, n11.rate, i10, n11.seed);
              }, function() {
                return r10;
              }, a10);
            }
            return e11;
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { rate: this.rate, noiseShape: this.noiseShape, seed: this.seed }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }, { key: "dispose", value: function() {
          return N(v(n10.prototype), "dispose", this).call(this);
        } }]), n10;
      }(wce);
      zpe.className = "Dropout", Kre(zpe);
      var Ppe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).inputSpec = [{ ndim: 3 }], r10;
        }
        return p(n10, [{ key: "getNoiseShape", value: function(e11) {
          var t11 = e11.shape;
          return [t11[0], 1, t11[2]];
        } }]), n10;
      }(zpe);
      Ppe.className = "SpatialDropout1D", Kre(Ppe);
      var Bpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), (r10 = t10.call(this, e11)).activation = null, r10.useBias = true, r10.kernel = null, r10.bias = null, r10.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", r10.DEFAULT_BIAS_INITIALIZER = "zeros", null == e11.batchInputShape && null == e11.inputShape && null != e11.inputDim) {
            var a10 = null;
            null != e11.batchSize && (a10 = e11.batchSize), r10.batchInputShape = [a10, e11.inputDim];
          }
          return r10.units = e11.units, Xse(r10.units, "units"), r10.activation = Uhe(e11.activation), null != e11.useBias && (r10.useBias = e11.useBias), r10.kernelInitializer = sce(e11.kernelInitializer || r10.DEFAULT_KERNEL_INITIALIZER), r10.biasInitializer = sce(e11.biasInitializer || r10.DEFAULT_BIAS_INITIALIZER), r10.kernelConstraint = Vce(e11.kernelConstraint), r10.biasConstraint = Vce(e11.biasConstraint), r10.kernelRegularizer = Xhe(e11.kernelRegularizer), r10.biasRegularizer = Xhe(e11.biasRegularizer), r10.activityRegularizer = Xhe(e11.activityRegularizer), r10.supportsMasking = true, r10.inputSpec = [{ minNDim: 2 }], r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          var t11 = (e11 = hce(e11))[e11.length - 1];
          null == this.kernel && (this.kernel = this.addWeight("kernel", [t11, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint))), this.inputSpec = [{ minNDim: 2, axes: f({}, -1, t11) }], this.built = true;
        } }, { key: "computeOutputShape", value: function(e11) {
          var t11 = (e11 = hce(e11)).slice();
          return t11[t11.length - 1] = this.units, t11;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            n11.invokeCallHook(e11, t11);
            var r10, a10 = lce(e11), i10 = Jse(n11.activation.getClassName());
            return null != i10 ? r10 = Oue(a10, n11.kernel.read(), i10, n11.bias ? n11.bias.read() : null) : (r10 = Oue(a10, n11.kernel.read()), null != n11.bias && (r10 = Lue(r10, n11.bias.read())), null != n11.activation && (r10 = n11.activation.apply(r10))), r10;
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { units: this.units, activation: Bhe(this.activation), useBias: this.useBias, kernelInitializer: oce(this.kernelInitializer), biasInitializer: oce(this.biasInitializer), kernelRegularizer: qhe(this.kernelRegularizer), biasRegularizer: qhe(this.biasRegularizer), activityRegularizer: qhe(this.activityRegularizer), kernelConstraint: Wce(this.kernelConstraint), biasConstraint: Wce(this.biasConstraint) }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      Bpe.className = "Dense", Kre(Bpe);
      var Wpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), e11 = e11 || {}, (r10 = t10.call(this, e11)).inputSpec = [{ minNDim: 3 }], r10.dataFormat = e11.dataFormat, r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          var t11, n11 = O((e11 = hce(e11)).slice(1));
          try {
            for (n11.s(); !(t11 = n11.n()).done; ) {
              if (null == t11.value) throw new Cse('The shape of the input to "Flatten" is not fully defined ' + "(got ".concat(e11.slice(1), "). Make sure to pass a complete ") + '"input_shape" or "batch_input_shape" argument to the first layer in your model.');
            }
          } catch (e12) {
            n11.e(e12);
          } finally {
            n11.f();
          }
          return [e11[0], gue(e11, 1)];
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            n11.invokeCallHook(e11, t11);
            var r10 = lce(e11);
            if ("channelsFirst" === n11.dataFormat && r10.rank > 1) {
              for (var a10 = [0], i10 = 2; i10 < r10.rank; ++i10) a10.push(i10);
              a10.push(1), r10 = hne(r10, a10);
            }
            return function(e12) {
              if (e12.rank <= 1) throw new Cse("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e12.rank, "."));
              var t12 = [e12.shape[0], gue(e12.shape, 1)];
              return X8(e12, t12);
            }(r10);
          });
        } }, { key: "getConfig", value: function() {
          var e11 = {};
          null != this.dataFormat && (e11.dataFormat = this.dataFormat);
          var t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      Wpe.className = "Flatten", Kre(Wpe);
      var Upe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).supportsMasking = true, r10.activation = Uhe(e11.activation), r10;
        }
        return p(n10, [{ key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            n11.invokeCallHook(e11, t11);
            var r10 = lce(e11);
            return n11.activation.apply(r10);
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { activation: Bhe(this.activation) }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      Upe.className = "Activation", Kre(Upe);
      var Vpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).n = e11.n, r10.inputSpec = [{ ndim: 2 }], r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          return [e11[0], this.n, e11[1]];
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            return e11 = lce(e11), t12 = e11, r10 = n11.n, X5(function() {
              if (2 !== t12.shape.length) throw new Cse("repeat() expects a rank-2 tensor, but received a " + "rank-".concat(t12.shape.length, " tensor."));
              return Rue(Iue(t12, 1), [1, r10, 1]);
            });
            var t12, r10;
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { n: this.n }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      Vpe.className = "RepeatVector", Kre(Vpe);
      var Gpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          l(this, n10), (r10 = t10.call(this, e11)).targetShape = e11.targetShape;
          for (var a10 = 0; a10 < r10.targetShape.length; ++a10) r10.isUnknown(r10.targetShape[a10]) && (r10.targetShape[a10] = null);
          return r10;
        }
        return p(n10, [{ key: "isUnknown", value: function(e11) {
          return e11 < 0 || null == e11;
        } }, { key: "fixUnknownDimension", value: function(e11, t11) {
          for (var n11 = "Total size of new array must be unchanged.", r10 = t11.slice(), a10 = 1, i10 = null, o10 = 0; o10 < r10.length; ++o10) {
            var s10 = r10[o10];
            if (this.isUnknown(s10)) {
              if (null !== i10) throw new Cse("Can only specifiy one unknown dimension.");
              i10 = o10;
            } else a10 *= s10;
          }
          var u10 = gue(e11);
          if (null !== i10) {
            if (0 === a10 || u10 % a10 != 0) throw new Cse(n11);
            r10[i10] = u10 / a10;
          } else if (u10 !== a10) throw new Cse(n11);
          return r10;
        } }, { key: "computeOutputShape", value: function(e11) {
          for (var t11 = false, n11 = 0; n11 < e11.length; ++n11) if (this.isUnknown(e11[n11])) {
            t11 = true;
            break;
          }
          return t11 ? e11.slice(0, 1).concat(this.targetShape) : e11.slice(0, 1).concat(this.fixUnknownDimension(e11.slice(1), this.targetShape));
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            n11.invokeCallHook(e11, t11);
            var r10 = lce(e11), a10 = r10.shape, i10 = a10.slice(0, 1).concat(n11.fixUnknownDimension(a10.slice(1), n11.targetShape));
            return X8(r10, i10);
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { targetShape: this.targetShape }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      Gpe.className = "Reshape", Kre(Gpe);
      var jpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), r10 = t10.call(this, e11), null == e11.dims) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
          if (!Array.isArray(e11.dims)) throw new Error("Permute constructor requires `dims` to be an Array, but received " + "".concat(e11.dims, " instead."));
          var a10 = xue(1, e11.dims.length + 1);
          if (!P$(e11.dims.slice().sort(), a10)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(e11.dims) + " `dims` must contain consecutive integers starting from 1.");
          return r10.dims = e11.dims, r10.dimsIncludingBatch = [0].concat(r10.dims), r10.inputSpec = [new gce({ ndim: r10.dims.length + 1 })], r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          var t11 = (e11 = hce(e11)).slice();
          return this.dims.forEach(function(n11, r10) {
            t11[r10 + 1] = e11[n11];
          }), t11;
        } }, { key: "call", value: function(e11, t11) {
          return hne(lce(e11), this.dimsIncludingBatch);
        } }, { key: "getConfig", value: function() {
          var e11 = { dims: this.dims }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      jpe.className = "Permute", Kre(jpe);
      var Hpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, null == e11 ? {} : e11)).supportsMasking = true, r10.maskValue = null != e11 ? null == e11.maskValue ? 0 : e11.maskValue : 0, r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          return e11;
        } }, { key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this), t11 = { maskValue: this.maskValue };
          return Object.assign(t11, e11), t11;
        } }, { key: "computeMask", value: function(e11, t11) {
          var n11 = lce(e11);
          return I8(uee(n11, this.maskValue), -1);
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            n11.invokeCallHook(e11, t11);
            var r10 = lce(e11), a10 = I8(uee(r10, n11.maskValue), -1, true);
            return g8(r10, h8(a10, r10.dtype));
          });
        } }]), n10;
      }(wce);
      Hpe.className = "Masking", Kre(Hpe);
      var qpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), (r10 = t10.call(this, e11)).embeddings = null, r10.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", null == e11.batchInputShape && null == e11.inputShape) {
            var a10 = null;
            null != e11.batchSize && (a10 = e11.batchSize), null == e11.inputLength ? r10.batchInputShape = [a10, null] : r10.batchInputShape = [a10].concat(Lse(e11.inputLength));
          }
          return r10.inputDim = e11.inputDim, Xse(r10.inputDim, "inputDim"), r10.outputDim = e11.outputDim, Xse(r10.outputDim, "outputDim"), r10.embeddingsInitializer = sce(e11.embeddingsInitializer || r10.DEFAULT_EMBEDDINGS_INITIALIZER), r10.embeddingsRegularizer = Xhe(e11.embeddingsRegularizer), r10.activityRegularizer = Xhe(e11.activityRegularizer), r10.embeddingsConstraint = Vce(e11.embeddingsConstraint), r10.maskZero = e11.maskZero, r10.supportsMasking = e11.maskZero, r10.inputLength = e11.inputLength, r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint), this.built = true;
        } }, { key: "warnOnIncompatibleInputShape", value: function(e11) {
        } }, { key: "computeMask", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            return n11.maskZero ? (e11 = lce(e11), uee(e11, U7(e11))) : null;
          });
        } }, { key: "computeOutputShape", value: function(e11) {
          if (e11 = hce(e11), null == this.inputLength) return [].concat(T(e11), [this.outputDim]);
          var t11 = Lse(this.inputLength);
          if (t11.length !== e11.length - 1) throw new Cse('"inputLength" is '.concat(this.inputLength, ", but received ") + "input shape has shape ".concat(e11));
          for (var n11 = 0, r10 = 0; r10 < t11.length; ++r10) {
            var a10 = t11[r10], i10 = e11[r10 + 1];
            if (null != a10 && null != i10 && a10 !== i10) throw new Cse('"inputLength" is '.concat(this.inputLength, ", but received ") + "input shape has shape ".concat(e11));
            null == a10 && (t11[n11] = i10), n11++;
          }
          return [e11[0]].concat(T(t11), [this.outputDim]);
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            n11.invokeCallHook(e11, t11);
            var r10 = lce(e11);
            "int32" !== r10.dtype && (r10 = wue(r10, "int32"));
            var a10 = Fue(n11.embeddings.read(), X8(r10, [r10.size]));
            return X8(a10, hce(n11.computeOutputShape(r10.shape)));
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { inputDim: this.inputDim, outputDim: this.outputDim, embeddingsInitializer: oce(this.embeddingsInitializer), embeddingsRegularizer: qhe(this.embeddingsRegularizer), activityRegularizer: qhe(this.activityRegularizer), embeddingsConstraint: Wce(this.embeddingsConstraint), maskZero: this.maskZero, inputLength: this.inputLength }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      qpe.className = "Embedding", Kre(qpe);
      var Kpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11 || {})).supportsMasking = true, r10;
        }
        return p(n10, [{ key: "mergeFunction", value: function(e11) {
          throw new Ase();
        } }, { key: "computeElementwiseOpOutputShape", value: function(e11, t11) {
          if (null == e11 || null == t11) return null;
          if (e11.length < t11.length) return this.computeElementwiseOpOutputShape(t11, e11);
          if (0 === t11.length) return e11;
          for (var n11 = e11.slice(0, e11.length - t11.length), r10 = 0; r10 < t11.length; ++r10) {
            var a10 = e11[e11.length - t11.length + r10], i10 = t11[r10];
            if (null == a10 || null == i10 || a10 < 0 || i10 < 0) n11.push(null);
            else if (1 === a10) n11.push(i10);
            else if (1 === i10) n11.push(a10);
            else {
              if (a10 !== i10) throw new Cse("Operands could not be broadcast together with shapes " + JSON.stringify(e11) + " " + JSON.stringify(t11));
              n11.push(a10);
            }
          }
          return n11;
        } }, { key: "build", value: function(e11) {
          if (Array.isArray(e11) && !Array.isArray(e11[0]) && (e11 = [hce(e11)]), e11.length < 2) throw new Cse("A merge layer should be called on an Array of at least 2 inputs." + " Got ".concat(e11.length, " input(s)."));
          var t11, n11 = [], r10 = O(e11);
          try {
            for (r10.s(); !(t11 = r10.n()).done; ) {
              var a10 = t11.value;
              null != a10 && null !== a10[0] && n11.push(a10[0]);
            }
          } catch (e12) {
            r10.e(e12);
          } finally {
            r10.f();
          }
          if ((n11 = jse(n11)).length > 1) throw new Cse("Can not merge tensors with different batch sizes. " + "Got tensors with shapes: ".concat(JSON.stringify(e11), "."));
          for (var i10 = null == e11[0] ? null : e11[0].slice(1), o10 = 1; o10 < e11.length; ++o10) {
            var s10 = null == e11[o10] ? null : e11[o10].slice(1);
            i10 = this.computeElementwiseOpOutputShape(i10, s10);
          }
          var u10 = e11.map(function(e12) {
            return e12.length;
          });
          -1 === e11.indexOf(null) && 1 === jse(u10).length ? this.reshapeRequired = false : this.reshapeRequired = true;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            if (n11.reshapeRequired) {
              var t12 = [], r10 = e11.map(function(e12) {
                return e12.rank;
              });
              if (-1 === r10.indexOf(null)) {
                var a10, i10 = bue(r10), o10 = O(e11);
                try {
                  for (o10.s(); !(a10 = o10.n()).done; ) {
                    for (var s10 = a10.value, u10 = s10.rank, c10 = 0; c10 < i10 - u10; ++c10) s10 = Iue(s10, 1);
                    t12.push(s10);
                  }
                } catch (e12) {
                  o10.e(e12);
                } finally {
                  o10.f();
                }
                return n11.mergeFunction(t12);
              }
              var l10, h10 = false, p10 = O(e11);
              try {
                for (p10.s(); !(l10 = p10.n()).done; ) {
                  var f10 = l10.value, d10 = f10.rank;
                  if (null == d10) {
                    var v10 = f10.shape, m10 = v10[0], g10 = v10.slice(1).concat([m10]), y10 = X8(f10, [m10].concat(gue(v10.slice(1))));
                    y10 = hne(y10, [1, 0]), y10 = X8(y10, g10), t12.push(y10), h10 = true;
                  } else if (d10 > 1) {
                    var b10 = xue(1, d10).concat([0]);
                    t12.push(hne(f10, b10)), h10 = true;
                  } else t12.push(f10);
                }
              } catch (e12) {
                p10.e(e12);
              } finally {
                p10.f();
              }
              var x10 = n11.mergeFunction(t12), k10 = x10.rank;
              if (h10) {
                if (null == k10) {
                  var w10 = x10.shape, I10 = w10[w10.length - 1], N10 = [I10].concat(w10.slice(0, w10.length - 1));
                  x10 = X8(hne(X8(x10, [-1, I10]), [1, 0]), N10);
                } else if (k10 > 1) {
                  var S10 = [k10 - 1].concat(xue(0, k10 - 1));
                  x10 = hne(x10, S10);
                }
              }
              return x10;
            }
            return n11.mergeFunction(e11);
          });
        } }, { key: "computeOutputShape", value: function(e11) {
          var t11;
          t11 = null == e11[0] ? null : e11[0].slice(1);
          for (var n11 = 1; n11 < e11.length; ++n11) {
            var r10 = null == e11[n11] ? null : e11[n11].slice(1);
            t11 = this.computeElementwiseOpOutputShape(t11, r10);
          }
          var a10, i10 = [], o10 = O(e11);
          try {
            for (o10.s(); !(a10 = o10.n()).done; ) {
              var s10 = a10.value;
              null != s10 && null !== s10[0] && i10.push(s10[0]);
            }
          } catch (e12) {
            o10.e(e12);
          } finally {
            o10.f();
          }
          return t11 = 1 === (i10 = jse(i10)).length ? i10.concat(t11) : [null].concat(t11);
        } }, { key: "computeMask", value: function(e11, t11) {
          return X5(function() {
            if (null == t11) return null;
            if (!Array.isArray(t11)) throw new Cse("`mask` should be an Array");
            if (!Array.isArray(e11)) throw new Cse("`inputs` should be an Array");
            if (t11.length !== e11.length) throw new Cse("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths " + "(".concat(e11.length, " vs ").concat(t11.length, ")"));
            if (t11.every(function(e12) {
              return null == e12;
            })) return null;
            for (var n11 = (t11 = t11.map(function(e12) {
              return null == e12 ? e12 : f9(e12, 0);
            }))[0], r10 = 1; r10 < t11.length - 1; ++r10) n11 = U9(n11, t11[r10]);
            return n11;
          });
        } }]), n10;
      }(wce), Xpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, e11);
        }
        return p(n10, [{ key: "mergeFunction", value: function(e11) {
          return X5(function() {
            for (var t11 = e11[0].clone(), n11 = 1; n11 < e11.length; ++n11) t11 = d8(t11, e11[n11]);
            return t11;
          });
        } }]), n10;
      }(Kpe);
      Xpe.className = "Add", Kre(Xpe);
      var Ype = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, e11);
        }
        return p(n10, [{ key: "mergeFunction", value: function(e11) {
          return X5(function() {
            for (var t11 = e11[0].clone(), n11 = 1; n11 < e11.length; ++n11) t11 = g8(t11, e11[n11]);
            return t11;
          });
        } }]), n10;
      }(Kpe);
      Ype.className = "Multiply", Kre(Ype);
      var Jpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, e11);
        }
        return p(n10, [{ key: "mergeFunction", value: function(e11) {
          return X5(function() {
            for (var t11 = e11[0].clone(), n11 = 1; n11 < e11.length; ++n11) t11 = d8(t11, e11[n11]);
            return g8(1 / e11.length, t11);
          });
        } }]), n10;
      }(Kpe);
      Jpe.className = "Average", Kre(Jpe);
      var Zpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, e11);
        }
        return p(n10, [{ key: "mergeFunction", value: function(e11) {
          return X5(function() {
            for (var t11 = e11[0], n11 = 1; n11 < e11.length; ++n11) t11 = Z9(t11, e11[n11]);
            return t11;
          });
        } }]), n10;
      }(Kpe);
      Zpe.className = "Maximum", Kre(Zpe);
      var Qpe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, e11);
        }
        return p(n10, [{ key: "mergeFunction", value: function(e11) {
          return X5(function() {
            for (var t11 = e11[0], n11 = 1; n11 < e11.length; ++n11) t11 = nee(t11, e11[n11]);
            return t11;
          });
        } }]), n10;
      }(Kpe);
      Qpe.className = "Minimum", Kre(Qpe);
      var $pe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).DEFAULT_AXIS = -1, null == e11 && (e11 = {}), r10.axis = null == e11.axis ? r10.DEFAULT_AXIS : e11.axis, r10.supportsMasking = true, r10.reshapeRequired = false, r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          if (!Array.isArray(e11) || !Array.isArray(e11[0]) || 1 === e11.length) throw new Cse("A `Concatenate` layer should be called on a list of at least 2 inputs");
          var t11, n11 = true, r10 = O(e11);
          try {
            for (r10.s(); !(t11 = r10.n()).done; ) {
              if (null != t11.value) {
                n11 = false;
                break;
              }
            }
          } catch (e12) {
            r10.e(e12);
          } finally {
            r10.f();
          }
          if (!n11) {
            for (var a10 = [], i10 = 0; i10 < e11.length; ++i10) {
              var o10 = e11[i10].slice();
              o10.splice(this.axis, 1);
              var s10, u10 = false, c10 = O(a10);
              try {
                for (c10.s(); !(s10 = c10.n()).done; ) {
                  if (P$(s10.value, o10)) {
                    u10 = true;
                    break;
                  }
                }
              } catch (e12) {
                c10.e(e12);
              } finally {
                c10.f();
              }
              u10 || a10.push(o10);
            }
            if (a10.length > 1) throw new Cse("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e11));
          }
        } }, { key: "mergeFunction", value: function(e11) {
          var t11 = this;
          return X5(function() {
            return Cue(e11, t11.axis);
          });
        } }, { key: "computeOutputShape", value: function(e11) {
          if (!Array.isArray(e11) || !Array.isArray(e11[0])) throw new Cse("A `Concatenate` layer should be called on a list of inputs.");
          var t11, n11 = e11, r10 = n11[0].slice(), a10 = this.axis < 0 ? r10.length + this.axis : this.axis, i10 = O(n11.slice(1));
          try {
            for (i10.s(); !(t11 = i10.n()).done; ) {
              var o10 = t11.value;
              if (null == r10[a10] || null == o10[a10]) {
                r10[a10] = null;
                break;
              }
              r10[a10] += o10[a10];
            }
          } catch (e12) {
            i10.e(e12);
          } finally {
            i10.f();
          }
          return r10;
        } }, { key: "computeMask", value: function(e11, t11) {
          var n11 = this;
          if (null == t11) return null;
          if (!Array.isArray(t11)) throw new Cse("`mask` should be an array for Concatenate");
          if (!Array.isArray(e11)) throw new Cse("`inputs` should be an array for Concatenate");
          if (t11.length !== e11.length) throw new Cse("Mismatch in the length of mask (".concat(t11.length, ") ") + "and the legnth of inputs (".concat(e11.length, ")"));
          return X5(function() {
            var r10 = true;
            if (t11.forEach(function(e12) {
              null == e12 || (r10 = false);
            }), r10) return null;
            for (var a10 = [], i10 = 0; i10 < e11.length; ++i10) null == t11[i10] ? a10.push(h8(lee(e11[i10]), "bool")) : t11[i10].rank < e11[i10].rank ? a10.push(f9(t11[i10], -1)) : a10.push(t11[i10]);
            var o10 = Z8(a10, n11.axis);
            return w8(o10, -1, false);
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { axis: this.axis }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(Kpe);
      function efe(e10, t10) {
        for (; e10 < 0; ) e10 += t10;
        return e10;
      }
      $pe.className = "Concatenate", Kre($pe);
      var tfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).axes = e11.axes, r10.normalize = null != e11.normalize && e11.normalize, r10.supportsMasking = true, r10.reshapeRequired = false, r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          F$(Array.isArray(e11) && 2 === e11.length && Array.isArray(e11[0]) && Array.isArray(e11[1]), function() {
            return "A `Dot` layer should be called on a list of exactly 2 inputs.";
          });
          var t11 = e11[0], n11 = e11[1];
          if (t11.length > 3 || n11.length > 3) throw new Ase("Dot layer does not support tensors of 4D or higher rank yet.");
          var r10 = this.interpretAxes(t11, n11);
          if (t11[r10[0]] !== n11[r10[1]]) throw new Cse("Dimension incompatibility: " + "".concat(t11[r10[0]], " !== ").concat(n11[r10[1]]));
        } }, { key: "mergeFunction", value: function(e11) {
          if (2 !== e11.length) throw new Cse("A `Dot` layer must be called on exactly 2 inputs, " + "but received ".concat(e11.length, " input(s)."));
          var t11, n11 = e11[0], r10 = e11[1];
          return t11 = Array.isArray(this.axes) ? this.axes.map(function(t12, n12) {
            return efe(t12, e11[n12].shape.length);
          }) : [efe(this.axes, n11.shape.length), efe(this.axes, r10.shape.length)], this.normalize && (n11 = ale(n11, t11[0]), r10 = ale(r10, t11[1])), function(e12, t12, n12) {
            if (e12.shape.length > 3 || t12.shape.length > 3) throw new Ase("batchDot is not implemented for tensors of 4D or higher rank yet");
            if (F$(e12.shape.length >= 2, function() {
              return "batchDot requires the rank of x to be >= 2, " + "but got ".concat(e12.shape.length);
            }), F$(e12.shape.length >= 2, function() {
              return "batchDot requires the rank of y to be >= 2, " + "but got ".concat(t12.shape.length);
            }), "number" == typeof n12 && (n12 = [n12, n12]), "complex64" === e12.dtype || "complex64" === t12.dtype) throw new Ase("batchDot is not implemented for complex64-type Tensors yet.");
            var r11 = e12.shape.length, a10 = t12.shape.length;
            null == n12 && (n12 = [r11 - 1, a10 - 2]);
            var i10 = n12;
            return X5(function() {
              var n13, o10;
              if (r11 > a10) {
                n13 = r11 - a10;
                for (var s10 = [], u10 = 0; u10 < n13; ++u10) s10.push(1);
                t12 = X8(t12, t12.shape.concat(s10));
              } else if (a10 > r11) {
                n13 = a10 - r11;
                for (var c10 = [], l10 = 0; l10 < n13; ++l10) c10.push(1);
                e12 = X8(e12, e12.shape.concat(c10));
              } else n13 = 0;
              if (2 === e12.shape.length && 2 === t12.shape.length) o10 = i10[0] === i10[1] ? u9(g8(e12, t12), i10[0]) : u9(g8(hne(e12, [1, 0]), t12), i10[1]);
              else {
                var h10 = i10[0] !== e12.shape.length - 1, p10 = i10[1] === t12.shape.length - 1;
                o10 = Q8(e12, t12, h10, p10);
              }
              if (n13 > 0) {
                for (var f10, d10 = [], v10 = f10 = r11 > a10 ? r11 + a10 - 3 : r11 - 1; v10 < f10 + n13; ++v10) d10.push(v10);
                o10 = zte(o10, d10);
              }
              return 1 === o10.shape.length && (o10 = f9(o10, 1)), o10;
            });
          }(n11, r10, t11);
        } }, { key: "interpretAxes", value: function(e11, t11) {
          return Array.isArray(this.axes) ? this.axes : [efe(this.axes, e11.length), efe(this.axes, t11.length)];
        } }, { key: "computeOutputShape", value: function(e11) {
          F$(Array.isArray(e11) && 2 === e11.length && Array.isArray(e11[0]) && Array.isArray(e11[1]), function() {
            return "A `Dot` layer should be called on a list of exactly 2 inputs.";
          });
          var t11 = e11[0].slice(), n11 = e11[1].slice();
          if (t11.length > 3 || n11.length > 3) throw new Ase("Dot layer does not support tensors of 4D or higher rank yet.");
          var r10 = this.interpretAxes(t11, n11);
          t11.splice(r10[0], 1), n11.splice(r10[1], 1), n11.splice(0, 1);
          var a10 = t11.concat(n11);
          return 1 === a10.length && a10.push(1), a10;
        } }, { key: "computeMask", value: function(e11, t11) {
          return null;
        } }, { key: "getConfig", value: function() {
          var e11 = { axes: this.axes, normalize: this.normalize }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(Kpe);
      tfe.className = "Dot", Kre(tfe);
      var nfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).supportsMasking = true, r10.stddev = e11.stddev, r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          return e11;
        } }, { key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this), t11 = { stddev: this.stddev };
          return Object.assign(t11, e11), t11;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            n11.invokeCallHook(e11, t11);
            var r10 = lce(e11);
            return Bue(function() {
              return d8(_ue(r10.shape, 0, n11.stddev), r10);
            }, function() {
              return r10;
            }, t11.training || false);
          });
        } }]), n10;
      }(wce);
      nfe.className = "GaussianNoise", Kre(nfe);
      var rfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).supportsMasking = true, r10.rate = e11.rate, r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          return e11;
        } }, { key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this), t11 = { rate: this.rate };
          return Object.assign(t11, e11), t11;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            n11.invokeCallHook(e11, t11);
            var r10 = lce(e11);
            if (n11.rate > 0 && n11.rate < 1) {
              return Bue(function() {
                var e12 = Math.sqrt(n11.rate / (1 - n11.rate));
                return g8(r10, _ue(r10.shape, 1, e12));
              }, function() {
                return r10;
              }, t11.training || false);
            }
            return r10;
          });
        } }]), n10;
      }(wce);
      rfe.className = "GaussianDropout", Kre(rfe);
      var afe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).supportsMasking = true, r10.rate = e11.rate, r10.noiseShape = e11.noiseShape, r10;
        }
        return p(n10, [{ key: "_getNoiseShape", value: function(e11) {
          return this.noiseShape || lce(e11).shape;
        } }, { key: "computeOutputShape", value: function(e11) {
          return e11;
        } }, { key: "getConfig", value: function() {
          var e11 = N(v(n10.prototype), "getConfig", this).call(this), t11 = { rate: this.rate };
          return Object.assign(t11, e11), t11;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            if (n11.rate < 1 && n11.rate > 0) {
              var r10 = n11._getNoiseShape(e11);
              return Bue(function() {
                var t12 = lce(e11), a10 = -1.7580993408473766, i10 = x9(ite(r10), n11.rate);
                i10 = wue(i10, "float32");
                var o10 = Math.pow((1 - n11.rate) * (1 + n11.rate * Math.pow(a10, 2)), -0.5), s10 = -o10 * a10 * n11.rate, u10 = d8(g8(t12, i10), g8(d8(i10, -1), a10));
                return d8(g8(u10, o10), s10);
              }, function() {
                return lce(e11);
              }, t11.training || false);
            }
            return e11;
          });
        } }]), n10;
      }(wce);
      function ife(e10, t10, n10, r10, a10) {
        var i10, o10 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1e-3;
        if (2 === e10.rank) i10 = i7(e10, t10, n10, r10, a10, o10);
        else if (3 === e10.rank) i10 = o7(e10, t10, n10, r10, a10, o10);
        else {
          if (4 !== e10.rank) throw new Ase("batchNormalization is not implemented for array of rank ".concat(e10.rank, " ") + "yet");
          i10 = s7(e10, t10, n10, r10, a10, o10);
        }
        return i10;
      }
      function ofe(e10, t10, n10, r10) {
        var a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e-3;
        return X5(function() {
          var i10 = iee(e10, r10), o10 = i10.mean, s10 = i10.variance;
          return [ife(e10, o10, s10, n10, t10, a10), o10, s10];
        });
      }
      function sfe(e10, t10, n10, r10) {
        var a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e-3;
        return X5(function() {
          var i10, o10 = iee(e10, r10), s10 = o10.mean, u10 = o10.variance, c10 = [], l10 = O(xue(0, e10.rank));
          try {
            for (l10.s(); !(i10 = l10.n()).done; ) {
              var h10 = i10.value;
              -1 !== r10.indexOf(h10) ? c10.push(1) : c10.push(e10.shape[h10]);
            }
          } catch (e11) {
            l10.e(e11);
          } finally {
            l10.f();
          }
          var p10 = X8(s10, c10), f10 = X8(u10, c10), d10 = null == t10 ? null : X8(t10, c10), v10 = null == n10 ? null : X8(n10, c10);
          return [ife(e10, p10, f10, v10, d10, a10), s10, u10];
        });
      }
      afe.className = "AlphaDropout", Kre(afe);
      var ufe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), null == e11 && (e11 = {}), (r10 = t10.call(this, e11)).supportsMasking = true, r10.axis = null == e11.axis ? -1 : e11.axis, r10.momentum = null == e11.momentum ? 0.99 : e11.momentum, r10.epsilon = null == e11.epsilon ? 1e-3 : e11.epsilon, r10.center = null == e11.center || e11.center, r10.scale = null == e11.scale || e11.scale, r10.betaInitializer = sce(e11.betaInitializer || "zeros"), r10.gammaInitializer = sce(e11.gammaInitializer || "ones"), r10.movingMeanInitializer = sce(e11.movingMeanInitializer || "zeros"), r10.movingVarianceInitializer = sce(e11.movingVarianceInitializer || "ones"), r10.betaConstraint = Vce(e11.betaConstraint), r10.gammaConstraint = Vce(e11.gammaConstraint), r10.betaRegularizer = Xhe(e11.betaRegularizer), r10.gammaRegularizer = Xhe(e11.gammaRegularizer), r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          e11 = hce(e11);
          var t11 = this.axis >= 0 ? this.axis : this.axis + e11.length, n11 = e11[t11];
          if (null == n11) throw new Cse("Axis ".concat(t11, " of input tensor should have a defined dimension but ") + "the layer received an input with shape " + "".concat(JSON.stringify(e11), "."));
          this.inputSpec = [new gce({ ndim: e11.length, axes: f({}, t11, n11) })];
          var r10 = [n11];
          this.scale && (this.gamma = this.addWeight("gamma", r10, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", r10, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", r10, null, this.movingMeanInitializer, null, false), this.movingVariance = this.addWeight("moving_variance", r10, null, this.movingVarianceInitializer, null, false), this.built = true;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var r10 = null != t11.training && t11.training, a10 = lce(e11), i10 = a10.shape, o10 = i10.length, s10 = xue(0, o10), u10 = n11.axis >= 0 ? n11.axis : n11.axis + o10;
            s10.splice(u10, 1);
            var c10 = Ose(1, o10);
            c10[u10] = i10[u10];
            var l10 = s10.slice();
            l10.sort();
            var h10 = !P$(l10, xue(0, o10).slice(0, o10 - 1));
            if (!r10) return function() {
              if (h10) {
                var e12 = X8(n11.movingMean.read(), c10), t12 = X8(n11.movingVariance.read(), c10), r11 = n11.center ? X8(n11.beta.read(), c10) : null, i11 = n11.scale ? X8(n11.gamma.read(), c10) : null;
                return ife(a10, e12, t12, r11, i11, n11.epsilon);
              }
              return ife(a10, n11.movingMean.read(), n11.movingVariance.read(), null == n11.beta ? null : n11.beta.read(), null == n11.gamma ? null : n11.gamma.read(), n11.epsilon);
            }();
            var p10 = function(e12, t12, n12, r11) {
              var a11 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e-3;
              return P$(r11.slice().sort(), xue(0, e12.rank - 1)) ? ofe(e12, t12, n12, r11, a11) : sfe(e12, t12, n12, r11, a11);
            }(a10, n11.gamma.read(), n11.beta.read(), s10, n11.epsilon), f10 = S(p10, 3), d10 = f10[0], v10 = f10[1], m10 = f10[2], g10 = function(e12, t12, n12) {
              X5(function() {
                var r11 = 1 - n12, a11 = e12.read(), i11 = g8(P9(a11, t12), r11);
                e12.write(P9(a11, i11));
              });
            };
            return g10(n11.movingMean, v10, n11.momentum), g10(n11.movingVariance, m10, n11.momentum), d10;
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { axis: this.axis, momentum: this.momentum, epsilon: this.epsilon, center: this.center, scale: this.scale, betaInitializer: oce(this.betaInitializer), gammaInitializer: oce(this.gammaInitializer), movingMeanInitializer: oce(this.movingMeanInitializer), movingVarianceInitializer: oce(this.movingVarianceInitializer), betaRegularizer: qhe(this.betaRegularizer), gammaRegularizer: qhe(this.gammaRegularizer), betaConstraint: Wce(this.betaConstraint), gammaConstraint: Wce(this.gammaConstraint) }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      ufe.className = "BatchNormalization", Kre(ufe);
      var cfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), null == e11 && (e11 = {}), (r10 = t10.call(this, e11)).axis = null == e11.axis ? -1 : e11.axis, "number" == typeof r10.axis) {
            if (!Number.isInteger(r10.axis)) throw new Error("Expected axis to be an integer, but received ".concat(r10.axis));
          } else {
            if (!Array.isArray(r10.axis)) throw new Error("Expected axis to be an integer or an array of integers, " + "but received ".concat(JSON.stringify(r10.axis)));
            var a10, i10 = O(r10.axis);
            try {
              for (i10.s(); !(a10 = i10.n()).done; ) {
                var o10 = a10.value;
                if (!Number.isInteger(o10)) throw new Error("Expected axis to be an array of integers, " + "but received ".concat(JSON.stringify(r10.axis)));
              }
            } catch (e12) {
              i10.e(e12);
            } finally {
              i10.f();
            }
          }
          return r10.epsilon = null == e11.epsilon ? 1e-3 : e11.epsilon, r10.center = null == e11.center || e11.center, r10.scale = null == e11.scale || e11.scale, r10.betaInitializer = sce(e11.betaInitializer || "zeros"), r10.gammaInitializer = sce(e11.gammaInitializer || "ones"), r10.betaRegularizer = Xhe(e11.betaRegularizer), r10.gammaRegularizer = Xhe(e11.gammaRegularizer), r10.supportsMasking = true, r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          var t11 = (e11 = hce(e11)).length;
          "number" == typeof this.axis && (this.axis = [this.axis]);
          for (var n11 = 0; n11 < this.axis.length; ++n11) this.axis[n11] < 0 && (this.axis[n11] += t11);
          var r10, a10 = O(this.axis);
          try {
            for (a10.s(); !(r10 = a10.n()).done; ) {
              var i10 = r10.value;
              if (i10 < 0 || i10 >= t11) throw new Error("Invalid axis: ".concat(i10));
            }
          } catch (e12) {
            a10.e(e12);
          } finally {
            a10.f();
          }
          if (this.axis.length !== jse(this.axis).length) throw new Error("Found duplicate axes in: ".concat(this.axis));
          var o10 = this.axis.map(function(t12) {
            return e11[t12];
          });
          this.scale ? this.gamma = this.addWeight("gamma", o10, "float32", this.gammaInitializer, this.gammaRegularizer, true) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", o10, "float32", this.betaInitializer, this.betaRegularizer, true) : this.beta = null, this.built = true;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this, r10 = lce(e11), a10 = r10.shape, i10 = a10.length;
          return X5(function() {
            var e12, t12 = iee(r10, n11.axis, true), o10 = t12.mean, s10 = t12.variance, u10 = Ose(1, i10), c10 = O(n11.axis);
            try {
              for (c10.s(); !(e12 = c10.n()).done; ) {
                var l10 = e12.value;
                u10[l10] = a10[l10];
              }
            } catch (e13) {
              c10.e(e13);
            } finally {
              c10.f();
            }
            for (var h10 = function(e13) {
              return null != e13 && e13.shape.length !== i10 ? X8(e13, u10) : e13;
            }, p10 = n11.scale ? h10(n11.gamma.read()) : null, f10 = n11.center ? h10(n11.beta.read()) : null, d10 = [], v10 = [], m10 = 0; m10 < i10; ++m10) -1 !== n11.axis.indexOf(m10) ? (d10.push(a10[m10]), v10.push(1)) : (d10.push(1), v10.push(a10[m10]));
            return o10 = v9(o10, d10), s10 = v9(s10, d10), null != p10 && (p10 = v9(p10, v10)), null != f10 && (f10 = v9(f10, v10)), ife(r10, o10, s10, f10, p10, n11.epsilon);
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { axis: this.axis, epsilon: this.epsilon, center: this.center, scale: this.scale, betaInitializer: oce(this.betaInitializer), gammaInitializer: oce(this.gammaInitializer), betaRegularizer: qhe(this.betaRegularizer), gammaRegularizer: qhe(this.gammaRegularizer) }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      cfe.className = "LayerNormalization", Kre(cfe);
      var lfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), null == e11 && (e11 = {}), (r10 = t10.call(this, e11)).dataFormat = null == e11.dataFormat ? "channelsLast" : e11.dataFormat, null == e11.padding) r10.padding = [[1, 1], [1, 1]];
          else if ("number" == typeof e11.padding) r10.padding = [[e11.padding, e11.padding], [e11.padding, e11.padding]];
          else {
            if (e11.padding = e11.padding, 2 !== e11.padding.length) throw new Cse("ZeroPadding2D expects padding to be a length-2 array, but " + "received a length-".concat(e11.padding.length, " array."));
            var a10, i10;
            if ("number" == typeof e11.padding[0]) a10 = [e11.padding[0], e11.padding[0]], i10 = [e11.padding[1], e11.padding[1]];
            else {
              if (e11.padding = e11.padding, 2 !== e11.padding[0].length) throw new Cse("ZeroPadding2D expects height padding to be a length-2 array, " + "but received a length-".concat(e11.padding[0].length, " array."));
              if (a10 = e11.padding[0], 2 !== e11.padding[1].length) throw new Cse("ZeroPadding2D expects width padding to be a length-2 array, " + "but received a length-".concat(e11.padding[1].length, " array."));
              i10 = e11.padding[1];
            }
            r10.padding = [a10, i10];
          }
          return r10.inputSpec = [new gce({ ndim: 4 })], r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          var t11, n11;
          return e11 = hce(e11), "channelsFirst" === this.dataFormat ? (t11 = null != e11[2] && e11[2] >= 0 ? e11[2] + this.padding[0][0] + this.padding[0][1] : null, n11 = null != e11[3] && e11[3] >= 0 ? e11[3] + this.padding[1][0] + this.padding[1][1] : null, [e11[0], e11[1], t11, n11]) : (t11 = null != e11[1] && e11[1] >= 0 ? e11[1] + this.padding[0][0] + this.padding[0][1] : null, n11 = null != e11[2] && e11[2] >= 0 ? e11[2] + this.padding[1][0] + this.padding[1][1] : null, [e11[0], t11, n11, e11[3]]);
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            return t12 = lce(e11), r10 = n11.padding, a10 = n11.dataFormat, X5(function() {
              if (4 !== t12.rank) throw new Cse("temporalPadding expects input tensor to be 4-D, but received a " + "".concat(t12.rank, "-D tensor."));
              if (null == r10 && (r10 = [[1, 1], [1, 1]]), 2 !== r10.length || 2 !== r10[0].length || 2 !== r10[1].length) throw new Cse("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
              if (null == a10 && (a10 = "channelsLast"), "channelsLast" !== a10 && "channelsFirst" !== a10) throw new Cse("Unknown data format: ".concat(a10, ". ") + "Supported data formats are 'channelsLast' and 'channelsFirst.");
              var e12;
              return e12 = "channelsFirst" === a10 ? [[0, 0], [0, 0], r10[0], r10[1]] : [[0, 0], r10[0], r10[1], [0, 0]], pee(t12, e12);
            });
            var t12, r10, a10;
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { padding: this.padding, dataFormat: this.dataFormat }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      function hfe(e10, t10, n10, r10, a10, i10) {
        return X5(function() {
          var o10;
          sue(a10), cue(i10), uue(r10), null == n10 && (n10 = [1, 1]), null == r10 && (r10 = "valid"), null == a10 && (a10 = "channelsLast"), null == i10 && (i10 = "max"), e10 = ape(e10, a10);
          var s10 = "same" === r10 ? "same" : "valid";
          return o10 = "max" === i10 ? X9(e10, t10, n10, s10) : Y8(e10, t10, n10, s10), "channelsFirst" === a10 && (o10 = hne(o10, [0, 3, 1, 2])), o10;
        });
      }
      function pfe(e10, t10, n10, r10, a10, i10) {
        return X5(function() {
          var o10;
          sue(a10), cue(i10), uue(r10), null == n10 && (n10 = [1, 1, 1]), null == r10 && (r10 = "valid"), null == a10 && (a10 = "channelsLast"), null == i10 && (i10 = "max"), e10 = ipe(e10, a10);
          var s10 = "same" === r10 ? "same" : "valid";
          return o10 = "max" === i10 ? Y9(e10, t10, n10, s10) : J8(e10, t10, n10, s10), "channelsFirst" === a10 && (o10 = hne(o10, [0, 4, 1, 2, 3])), o10;
        });
      }
      lfe.className = "ZeroPadding2D", Kre(lfe);
      var ffe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), null == e11.poolSize && (e11.poolSize = 2), r10 = t10.call(this, e11), "number" == typeof e11.poolSize) r10.poolSize = [e11.poolSize];
          else {
            if (!Array.isArray(e11.poolSize) || 1 !== e11.poolSize.length || "number" != typeof e11.poolSize[0]) throw new Cse("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received " + "".concat(JSON.stringify(e11.poolSize)));
            r10.poolSize = e11.poolSize;
          }
          if (Xse(r10.poolSize, "poolSize"), null == e11.strides) r10.strides = r10.poolSize;
          else if ("number" == typeof e11.strides) r10.strides = [e11.strides];
          else {
            if (!Array.isArray(e11.strides) || 1 !== e11.strides.length || "number" != typeof e11.strides[0]) throw new Cse("strides for 1D convolutional layer must be a number or an Array of a single number, but received " + "".concat(JSON.stringify(e11.strides)));
            r10.strides = e11.strides;
          }
          return Xse(r10.strides, "strides"), r10.padding = null == e11.padding ? "valid" : e11.padding, uue(r10.padding), r10.inputSpec = [new gce({ ndim: 3 })], r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          var t11 = npe((e11 = hce(e11))[1], this.poolSize[0], this.padding, this.strides[0]);
          return [e11[0], t11, e11[2]];
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            n11.invokeCallHook(e11, t11), e11 = Iue(lce(e11), 2);
            var r10 = n11.poolingFunction(lce(e11), [n11.poolSize[0], 1], [n11.strides[0], 1], n11.padding, "channelsLast");
            return zte(r10, [2]);
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { poolSize: this.poolSize, padding: this.padding, strides: this.strides }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce), dfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, e11);
        }
        return p(n10, [{ key: "poolingFunction", value: function(e11, t11, n11, r10, a10) {
          return sue(a10), uue(r10), hfe(e11, t11, n11, r10, a10, "max");
        } }]), n10;
      }(ffe);
      dfe.className = "MaxPooling1D", Kre(dfe);
      var vfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, e11);
        }
        return p(n10, [{ key: "poolingFunction", value: function(e11, t11, n11, r10, a10) {
          return sue(a10), uue(r10), hfe(e11, t11, n11, r10, a10, "avg");
        } }]), n10;
      }(ffe);
      vfe.className = "AveragePooling1D", Kre(vfe);
      var mfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), null == e11.poolSize && (e11.poolSize = [2, 2]), (r10 = t10.call(this, e11)).poolSize = Array.isArray(e11.poolSize) ? e11.poolSize : [e11.poolSize, e11.poolSize], null == e11.strides) r10.strides = r10.poolSize;
          else if (Array.isArray(e11.strides)) {
            if (2 !== e11.strides.length) throw new Cse("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length " + "".concat(e11.strides.length, "."));
            r10.strides = e11.strides;
          } else r10.strides = [e11.strides, e11.strides];
          return Xse(r10.poolSize, "poolSize"), Xse(r10.strides, "strides"), r10.padding = null == e11.padding ? "valid" : e11.padding, r10.dataFormat = null == e11.dataFormat ? "channelsLast" : e11.dataFormat, sue(r10.dataFormat), uue(r10.padding), r10.inputSpec = [new gce({ ndim: 4 })], r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          e11 = hce(e11);
          var t11 = "channelsFirst" === this.dataFormat ? e11[2] : e11[1], n11 = "channelsFirst" === this.dataFormat ? e11[3] : e11[2];
          return t11 = npe(t11, this.poolSize[0], this.padding, this.strides[0]), n11 = npe(n11, this.poolSize[1], this.padding, this.strides[1]), "channelsFirst" === this.dataFormat ? [e11[0], e11[1], t11, n11] : [e11[0], t11, n11, e11[3]];
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            return n11.invokeCallHook(e11, t11), n11.poolingFunction(lce(e11), n11.poolSize, n11.strides, n11.padding, n11.dataFormat);
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { poolSize: this.poolSize, padding: this.padding, strides: this.strides, dataFormat: this.dataFormat }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce), gfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, e11);
        }
        return p(n10, [{ key: "poolingFunction", value: function(e11, t11, n11, r10, a10) {
          return sue(a10), uue(r10), hfe(e11, t11, n11, r10, a10, "max");
        } }]), n10;
      }(mfe);
      gfe.className = "MaxPooling2D", Kre(gfe);
      var yfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, e11);
        }
        return p(n10, [{ key: "poolingFunction", value: function(e11, t11, n11, r10, a10) {
          return sue(a10), uue(r10), hfe(e11, t11, n11, r10, a10, "avg");
        } }]), n10;
      }(mfe);
      yfe.className = "AveragePooling2D", Kre(yfe);
      var bfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), null == e11.poolSize && (e11.poolSize = [2, 2, 2]), (r10 = t10.call(this, e11)).poolSize = Array.isArray(e11.poolSize) ? e11.poolSize : [e11.poolSize, e11.poolSize, e11.poolSize], null == e11.strides) r10.strides = r10.poolSize;
          else if (Array.isArray(e11.strides)) {
            if (3 !== e11.strides.length) throw new Cse("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length " + "".concat(e11.strides.length, "."));
            r10.strides = e11.strides;
          } else r10.strides = [e11.strides, e11.strides, e11.strides];
          return Xse(r10.poolSize, "poolSize"), Xse(r10.strides, "strides"), r10.padding = null == e11.padding ? "valid" : e11.padding, r10.dataFormat = null == e11.dataFormat ? "channelsLast" : e11.dataFormat, sue(r10.dataFormat), uue(r10.padding), r10.inputSpec = [new gce({ ndim: 5 })], r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          e11 = hce(e11);
          var t11 = "channelsFirst" === this.dataFormat ? e11[2] : e11[1], n11 = "channelsFirst" === this.dataFormat ? e11[3] : e11[2], r10 = "channelsFirst" === this.dataFormat ? e11[4] : e11[3];
          return t11 = npe(t11, this.poolSize[0], this.padding, this.strides[0]), n11 = npe(n11, this.poolSize[1], this.padding, this.strides[1]), r10 = npe(r10, this.poolSize[2], this.padding, this.strides[2]), "channelsFirst" === this.dataFormat ? [e11[0], e11[1], t11, n11, r10] : [e11[0], t11, n11, r10, e11[4]];
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            return n11.invokeCallHook(e11, t11), n11.poolingFunction(lce(e11), n11.poolSize, n11.strides, n11.padding, n11.dataFormat);
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { poolSize: this.poolSize, padding: this.padding, strides: this.strides, dataFormat: this.dataFormat }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce), xfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, e11);
        }
        return p(n10, [{ key: "poolingFunction", value: function(e11, t11, n11, r10, a10) {
          return sue(a10), uue(r10), pfe(e11, t11, n11, r10, a10, "max");
        } }]), n10;
      }(bfe);
      xfe.className = "MaxPooling3D", Kre(xfe);
      var kfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, e11);
        }
        return p(n10, [{ key: "poolingFunction", value: function(e11, t11, n11, r10, a10) {
          return sue(a10), uue(r10), pfe(e11, t11, n11, r10, a10, "avg");
        } }]), n10;
      }(bfe);
      kfe.className = "AveragePooling3D", Kre(kfe);
      var wfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).inputSpec = [new gce({ ndim: 3 })], r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          return [e11[0], e11[2]];
        } }, { key: "call", value: function(e11, t11) {
          throw new Ase();
        } }]), n10;
      }(wce), Ife = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, e11 || {});
        }
        return p(n10, [{ key: "call", value: function(e11, t11) {
          return X5(function() {
            var t12 = lce(e11);
            return Q9(t12, 1);
          });
        } }]), n10;
      }(wfe);
      Ife.className = "GlobalAveragePooling1D", Kre(Ife);
      var Nfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, e11 || {});
        }
        return p(n10, [{ key: "call", value: function(e11, t11) {
          return X5(function() {
            var t12 = lce(e11);
            return n9(t12, 1);
          });
        } }]), n10;
      }(wfe);
      Nfe.className = "GlobalMaxPooling1D", Kre(Nfe);
      var Sfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).dataFormat = null == e11.dataFormat ? "channelsLast" : e11.dataFormat, sue(r10.dataFormat), r10.inputSpec = [new gce({ ndim: 4 })], r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          return "channelsLast" === this.dataFormat ? [e11[0], e11[3]] : [e11[0], e11[1]];
        } }, { key: "call", value: function(e11, t11) {
          throw new Ase();
        } }, { key: "getConfig", value: function() {
          var e11 = { dataFormat: this.dataFormat }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce), Tfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var t12 = lce(e11);
            return "channelsLast" === n11.dataFormat ? Q9(t12, [1, 2]) : Q9(t12, [2, 3]);
          });
        } }]), n10;
      }(Sfe);
      Tfe.className = "GlobalAveragePooling2D", Kre(Tfe);
      var Efe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var t12 = lce(e11);
            return "channelsLast" === n11.dataFormat ? n9(t12, [1, 2]) : n9(t12, [2, 3]);
          });
        } }]), n10;
      }(Sfe);
      Efe.className = "GlobalMaxPooling2D", Kre(Efe);
      var Cfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).layer = e11.layer, r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          this.built = true;
        } }, { key: "trainable", get: function() {
          return null != this.layer && this.layer.trainable;
        }, set: function(e11) {
          null != this.layer && (this.layer.trainable = e11);
        } }, { key: "trainableWeights", get: function() {
          return this.layer.trainableWeights;
        } }, { key: "nonTrainableWeights", get: function() {
          return this.layer.nonTrainableWeights;
        } }, { key: "updates", get: function() {
          return this.layer._updates;
        } }, { key: "losses", get: function() {
          return this.layer.losses;
        } }, { key: "getWeights", value: function() {
          return this.layer.getWeights();
        } }, { key: "setWeights", value: function(e11) {
          this.layer.setWeights(e11);
        } }, { key: "getConfig", value: function() {
          var e11 = { layer: { className: this.layer.getClassName(), config: this.layer.getConfig() } }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }, { key: "setFastWeightInitDuringBuild", value: function(e11) {
          N(v(n10.prototype), "setFastWeightInitDuringBuild", this).call(this, e11), null != this.layer && this.layer.setFastWeightInitDuringBuild(e11);
        } }], [{ key: "fromConfig", value: function(e11, t11) {
          var n11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r10 = t11.layer, a10 = rle(r10, n11);
          delete t11.layer;
          var i10 = { layer: a10 };
          return Object.assign(i10, t11), new e11(i10);
        } }]), n10;
      }(wce), Afe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).supportsMasking = true, r10;
        }
        return p(n10, [{ key: "build", value: function(e11) {
          if ((e11 = hce(e11)).length < 3) throw new Cse("TimeDistributed layer expects an input shape >= 3D, but received " + "input shape ".concat(JSON.stringify(e11)));
          this.inputSpec = [{ shape: e11 }];
          var t11 = [e11[0]].concat(e11.slice(2));
          this.layer.built || (this.layer.build(t11), this.layer.built = true), N(v(n10.prototype), "build", this).call(this, e11);
        } }, { key: "computeOutputShape", value: function(e11) {
          var t11 = [(e11 = hce(e11))[0]].concat(e11.slice(2)), n11 = this.layer.computeOutputShape(t11), r10 = e11[1];
          return [n11[0], r10].concat(n11.slice(1));
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            return wpe(function(e12, r10) {
              return [lce(n11.layer.call(e12, t11)), []];
            }, e11 = lce(e11), [], false, null, null, false, true)[1];
          });
        } }]), n10;
      }(Cfe);
      Afe.className = "TimeDistributed", Kre(Afe);
      var Rfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          l(this, n10), r10 = t10.call(this, e11);
          var a10 = e11.layer.getConfig(), i10 = {};
          i10.className = e11.layer.getClassName(), i10.config = a10, r10.forwardLayer = rle(i10), a10.goBackwards = true !== a10.goBackwards;
          var o10, s10 = {};
          if (s10.className = e11.layer.getClassName(), s10.config = a10, r10.backwardLayer = rle(s10), r10.forwardLayer.name = "forward_" + r10.forwardLayer.name, r10.backwardLayer.name = "backward_" + r10.backwardLayer.name, r10.mergeMode = void 0 === e11.mergeMode ? "concat" : e11.mergeMode, o10 = r10.mergeMode, qse(iue, "BidirectionalMergeMode", o10), e11.weights) throw new Ase("weights support is not implemented for Bidirectional layer yet.");
          return r10._stateful = e11.layer.stateful, r10.returnSequences = e11.layer.returnSequences, r10.returnState = e11.layer.returnState, r10.supportsMasking = true, r10._trainable = true, r10.inputSpec = e11.layer.inputSpec, r10.numConstants = null, r10;
        }
        return p(n10, [{ key: "trainable", get: function() {
          return this._trainable;
        }, set: function(e11) {
          this._trainable = e11, null != this.forwardLayer && (this.forwardLayer.trainable = e11), null != this.backwardLayer && (this.backwardLayer.trainable = e11);
        } }, { key: "getWeights", value: function() {
          return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
        } }, { key: "setWeights", value: function(e11) {
          var t11 = e11.length, n11 = Math.floor(t11 / 2);
          this.forwardLayer.setWeights(e11.slice(0, n11)), this.backwardLayer.setWeights(e11.slice(n11));
        } }, { key: "computeOutputShape", value: function(e11) {
          var t11, n11, r10, a10 = this.forwardLayer.computeOutputShape(e11);
          return Array.isArray(a10) && Array.isArray(a10[0]) || (a10 = [a10]), this.returnState ? (r10 = a10.slice(1), t11 = a10[0]) : t11 = a10[0], "concat" === this.mergeMode ? (t11[t11.length - 1] *= 2, n11 = [t11]) : n11 = null == this.mergeMode ? [t11, t11.slice()] : [t11], this.returnState ? null == this.mergeMode ? n11.concat(r10).concat(r10.slice()) : [t11].concat(r10).concat(r10.slice()) : Mse(n11);
        } }, { key: "apply", value: function(e11, t11) {
          var r10 = null == t11 ? null : t11.initialState, a10 = null == t11 ? null : t11.constants;
          null == t11 && (t11 = {});
          var i10 = kpe(e11, r10, a10, this.numConstants);
          if (e11 = i10.inputs, r10 = i10.initialState, a10 = i10.constants, Array.isArray(e11) && (r10 = e11.slice(1), e11 = e11[0]), (null == r10 || 0 === r10.length) && null == a10) return N(v(n10.prototype), "apply", this).call(this, e11, t11);
          var o10 = [], s10 = [];
          if (null != r10) {
            var u10 = r10.length;
            if (u10 % 2 > 0) throw new Cse("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
            t11.initialState = r10, o10.push.apply(o10, T(r10));
            var c10 = r10.map(function(e12) {
              return new gce({ shape: e12.shape });
            });
            this.forwardLayer.stateSpec = c10.slice(0, u10 / 2), this.backwardLayer.stateSpec = c10.slice(u10 / 2), s10.push.apply(s10, T(c10));
          }
          if (null != a10) throw new Ase("Support for constants in Bidirectional layers is not implemented yet.");
          for (var l10 = o10[0] instanceof yce, h10 = 0, p10 = o10; h10 < p10.length; h10++) {
            if (p10[h10] instanceof yce !== l10) throw new Cse("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
          }
          if (l10) {
            var f10 = [e11].concat(o10), d10 = this.inputSpec.concat(s10), m10 = this.inputSpec;
            this.inputSpec = d10;
            var g10 = N(v(n10.prototype), "apply", this).call(this, f10, t11);
            return this.inputSpec = m10, g10;
          }
          return N(v(n10.prototype), "apply", this).call(this, e11, t11);
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var r10, a10, i10, o10, s10 = t11.initialState;
            if (null == s10) r10 = n11.forwardLayer.call(e11, t11), a10 = n11.backwardLayer.call(e11, t11);
            else {
              var u10 = s10.slice(0, s10.length / 2), c10 = s10.slice(s10.length / 2);
              r10 = n11.forwardLayer.call(e11, Object.assign(t11, { initialState: u10 })), a10 = n11.backwardLayer.call(e11, Object.assign(t11, { initialState: c10 }));
            }
            return n11.returnState && (Array.isArray(r10) && (i10 = r10.slice(1).concat(a10.slice(1))), r10 = r10[0], a10 = a10[0]), n11.returnSequences && (a10 = pte(a10, 1)), "concat" === n11.mergeMode ? o10 = Cue([r10, a10]) : "sum" === n11.mergeMode ? o10 = d8(r10, a10) : "ave" === n11.mergeMode ? o10 = g8(0.5, d8(r10, a10)) : "mul" === n11.mergeMode ? o10 = g8(r10, a10) : null == n11.mergeMode && (o10 = [r10, a10]), n11.returnState ? null == n11.mergeMode ? o10.concat(i10) : [o10].concat(i10) : o10;
          });
        } }, { key: "resetStates", value: function(e11) {
          this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
        } }, { key: "build", value: function(e11) {
          var t11 = this;
          hue(this.forwardLayer.name, function() {
            t11.forwardLayer.build(e11);
          }), hue(this.backwardLayer.name, function() {
            t11.backwardLayer.build(e11);
          }), this.built = true;
        } }, { key: "computeMask", value: function(e11, t11) {
          var n11;
          if (Array.isArray(t11) && (t11 = t11[0]), n11 = this.returnSequences ? null == this.mergeMode ? [t11, t11] : t11 : null == this.mergeMode ? [null, null] : null, this.returnState) {
            var r10 = this.forwardLayer.states.map(function(e12) {
              return null;
            });
            return Array.isArray(n11) ? n11.concat(r10).concat(r10) : [n11].concat(r10).concat(r10);
          }
          return n11;
        } }, { key: "trainableWeights", get: function() {
          return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
        } }, { key: "nonTrainableWeights", get: function() {
          return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
        } }, { key: "setFastWeightInitDuringBuild", value: function(e11) {
          N(v(n10.prototype), "setFastWeightInitDuringBuild", this).call(this, e11), null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(e11), null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(e11);
        } }, { key: "getConfig", value: function() {
          var e11 = { mergeMode: this.mergeMode }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }], [{ key: "fromConfig", value: function(e11, t11) {
          var n11 = rle(t11.layer);
          if (delete t11.layer, null != t11.numConstants) throw new Ase("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
          var r10 = t11;
          return r10.layer = n11, new e11(r10);
        } }]), n10;
      }(Cfe);
      Rfe.className = "Bidirectional", Kre(Rfe);
      var _fe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).scale = e11.scale, e11.offset ? r10.offset = e11.offset : r10.offset = 0, r10;
        }
        return p(n10, [{ key: "getConfig", value: function() {
          var e11 = { scale: this.scale, offset: this.offset }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            return "float32" !== (e11 = lce(e11)).dtype && (e11 = wue(e11, "float32")), d8(g8(e11, n11.scale), n11.offset);
          });
        } }]), n10;
      }(wce);
      _fe.className = "Rescaling", Kre(_fe);
      var Ofe = Pre.resizeBilinear, Ffe = Pre.cropAndResize, Dfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).height = e11.height, r10.width = e11.width, r10;
        }
        return p(n10, [{ key: "centerCrop", value: function(e11, t11, n11, r10, a10, i10, o10, s10) {
          return X5(function() {
            var u10, c10 = false, l10 = [t11 / i10, n11 / o10, (r10 + t11) / i10, (a10 + n11) / o10], h10 = [];
            3 === e11.rank ? (c10 = true, u10 = Pte([e11])) : u10 = e11;
            for (var p10 = 0; p10 < u10.shape[0]; p10++) h10.push(l10);
            var f10 = V5(h10, [h10.length, 4]), d10 = ste(0, h10.length, 1, "int32"), v10 = Ffe(u10, f10, d10, [r10, a10], "nearest");
            return wue(c10 ? lce(rne(v10)) : v10, s10);
          });
        } }, { key: "upsize", value: function(e11, t11, n11, r10) {
          return X5(function() {
            return wue(Ofe(e11, [t11, n11]), r10);
          });
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var t12 = lce(e11), r10 = t12.dtype, a10 = t12.shape, i10 = a10[a10.length - 3], o10 = a10[a10.length - 2], s10 = 0;
            i10 !== n11.height && (s10 = Math.floor((i10 - n11.height) / 2));
            var u10 = 0;
            return o10 !== n11.width && 0 === (u10 = Math.floor((o10 - n11.width) / 2)) && (u10 = 1), s10 >= 0 && u10 >= 0 ? n11.centerCrop(t12, s10, u10, n11.height, n11.width, i10, o10, r10) : n11.upsize(e11, n11.height, n11.width, r10);
          });
        } }, { key: "getConfig", value: function() {
          var e11 = { height: this.height, width: this.width }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }, { key: "computeOutputShape", value: function(e11) {
          var t11 = (e11 = hce(e11)).length - 3, n11 = e11.length - 2;
          return e11[t11] = this.height, e11[n11] = this.width, e11;
        } }]), n10;
      }(wce);
      Dfe.className = "CenterCrop", Kre(Dfe);
      var Mfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).numTokens = e11.numTokens, e11.outputMode ? r10.outputMode = e11.outputMode : r10.outputMode = "multiHot", r10;
        }
        return p(n10, [{ key: "getConfig", value: function() {
          var e11 = { numTokens: this.numTokens, outputMode: this.outputMode }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }, { key: "computeOutputShape", value: function(e11) {
          return null == (e11 = hce(e11)) ? [this.numTokens] : "oneHot" === this.outputMode && 1 !== e11[e11.length - 1] ? (e11.push(this.numTokens), e11) : (e11[e11.length - 1] = this.numTokens, e11);
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var r10;
            if ("int32" !== (e11 = lce(e11)).dtype && (e11 = wue(e11, "int32")), void 0 !== t11.countWeights) {
              if ("count" !== n11.outputMode) throw new Cse("countWeights is not used when outputMode !== count.\n              Received countWeights=".concat(t11.countWeights));
              r10 = lce(t11.countWeights);
            }
            var a10 = n9(e11), i10 = r9(e11), o10 = b9(n11.numTokens, a10).bufferSync().get(0), s10 = x9(i10, 0).bufferSync().get(0);
            if (!o10 || !s10) throw new Cse("Input values must be between 0 < values <=" + " numTokens with numTokens=".concat(n11.numTokens));
            return function(e12, t12, n12, r11) {
              var a11 = lce(e12);
              if ("int32" !== a11.dtype && (a11 = wue(a11, "int32")), "int" === t12) return a11;
              var i11 = a11.shape;
              if (0 === a11.rank && (a11 = f9(a11, -1)), "oneHot" === t12 && 1 !== a11.shape[a11.shape.length - 1] && (a11 = f9(a11, -1)), a11.rank > 2) throw new Cse("When outputMode is not int, maximum output rank is 2" + " Received outputMode ".concat(t12, " and input shape ").concat(i11) + " which would result in output rank ".concat(a11.rank, "."));
              var o11, s11 = ["multiHot", "oneHot"].includes(t12);
              if (o11 = R7(a11, void 0 !== r11 && "count" === t12 ? r11 : [], n12, s11), "tfIdf" !== t12) return o11;
              if (r11) return g8(o11, r11);
              throw new Cse("When outputMode is 'tfIdf', weights must be provided.");
            }(e11, n11.outputMode, n11.numTokens, r10);
          });
        } }]), n10;
      }(wce);
      Mfe.className = "CategoryEncoding", Kre(Mfe);
      var Lfe = /* @__PURE__ */ new Set(["bilinear", "nearest"]), zfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          if (l(this, n10), (r10 = t10.call(this, e11)).height = e11.height, r10.width = e11.width, e11.interpolation) {
            if (!Lfe.has(e11.interpolation)) throw new Cse("Invalid interpolation parameter: ".concat(e11.interpolation, " is not implemented"));
            r10.interpolation = e11.interpolation;
          } else r10.interpolation = "bilinear";
          return r10.cropToAspectRatio = Boolean(e11.cropToAspectRatio), r10;
        }
        return p(n10, [{ key: "computeOutputShape", value: function(e11) {
          var t11 = (e11 = hce(e11))[2];
          return [this.height, this.width, t11];
        } }, { key: "getConfig", value: function() {
          var e11 = { height: this.height, width: this.width, interpolation: this.interpolation, cropToAspectRatio: this.cropToAspectRatio }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var t12 = [n11.height, n11.width];
            if ("bilinear" === n11.interpolation) return Pre.resizeBilinear(e11, t12, !n11.cropToAspectRatio);
            if ("nearest" === n11.interpolation) return Pre.resizeNearestNeighbor(e11, t12, !n11.cropToAspectRatio);
            throw new Error("Interpolation is ".concat(n11.interpolation, " but only ").concat(T(Lfe), " are supported"));
          });
        } }]), n10;
      }(wce);
      zfe.className = "Resizing", Kre(zfe);
      var Pfe = function() {
        function e10(t10) {
          l(this, e10), this.seed = t10;
        }
        return p(e10, [{ key: "next", value: function() {
          if (void 0 !== this.seed) return this.seed++;
        } }]), e10;
      }();
      Pfe.className = "RandomSeed";
      var Bfe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          return l(this, n10), (r10 = t10.call(this, e11)).randomGenerator = new Pfe(e11.seed), r10;
        }
        return p(n10, [{ key: "getConfig", value: function() {
          var e11 = { seed: this.randomGenerator.seed }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }]), n10;
      }(wce);
      Bfe.className = "BaseRandomLayer";
      var Wfe = /* @__PURE__ */ new Set(["bilinear", "nearest"]), Ufe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          var r10;
          l(this, n10), r10 = t10.call(this, e11);
          var a10 = e11.factor, i10 = e11.interpolation, o10 = void 0 === i10 ? "bilinear" : i10;
          if (r10.factor = a10, Array.isArray(r10.factor) && 2 === r10.factor.length) r10.widthLower = r10.factor[0], r10.widthUpper = r10.factor[1];
          else {
            if (Array.isArray(r10.factor) || !(r10.factor > 0)) throw new Cse("Invalid factor: ".concat(r10.factor, ". Must be positive number or tuple of 2 numbers"));
            r10.widthLower = -r10.factor, r10.widthUpper = r10.factor;
          }
          if (r10.widthLower < -1 || r10.widthUpper < -1) throw new Cse("factor must have values larger than -1. Got: ".concat(r10.factor));
          if (r10.widthUpper < r10.widthLower) throw new Cse("factor cannot have upper bound less than lower bound.\n        Got upper bound: ".concat(r10.widthUpper, ".\n        Got lower bound: ").concat(r10.widthLower, "\n      "));
          if (o10) {
            if (!Wfe.has(o10)) throw new Cse("Invalid interpolation parameter: ".concat(o10, " is not implemented"));
            r10.interpolation = o10;
          }
          return r10;
        }
        return p(n10, [{ key: "getConfig", value: function() {
          var e11 = { factor: this.factor, interpolation: this.interpolation }, t11 = N(v(n10.prototype), "getConfig", this).call(this);
          return Object.assign(e11, t11), e11;
        } }, { key: "computeOutputShape", value: function(e11) {
          var t11 = (e11 = hce(e11))[2];
          return [this.imgHeight, -1, t11];
        } }, { key: "call", value: function(e11, t11) {
          var n11 = this;
          return X5(function() {
            var t12 = lce(e11);
            n11.imgHeight = t12.shape[t12.shape.length - 3];
            var r10 = t12.shape[t12.shape.length - 2];
            n11.widthFactor = ite([1], 1 + n11.widthLower, 1 + n11.widthUpper, "float32", n11.randomGenerator.next());
            var a10 = n11.widthFactor.dataSync()[0] * r10;
            a10 = Math.round(a10);
            var i10 = [n11.imgHeight, a10];
            switch (n11.interpolation) {
              case "bilinear":
                return Pre.resizeBilinear(e11, i10);
              case "nearest":
                return Pre.resizeNearestNeighbor(e11, i10);
              default:
                throw new Error("Interpolation is ".concat(n11.interpolation, "\n          but only ").concat(T(Wfe), " are supported"));
            }
          });
        } }]), n10;
      }(Bfe);
      function Vfe(e10) {
        return new vfe(e10);
      }
      function Gfe(e10) {
        return new yfe(e10);
      }
      function jfe(e10) {
        return new kfe(e10);
      }
      function Hfe(e10) {
        return new Nfe(e10);
      }
      function qfe(e10) {
        return new Efe(e10);
      }
      function Kfe(e10) {
        return new dfe(e10);
      }
      function Xfe(e10) {
        return new gfe(e10);
      }
      Ufe.className = "RandomWidth", Kre(Ufe);
      var Yfe = { __proto__: null, Layer: wce, RNN: Ipe, RNNCell: Npe, activation: function(e10) {
        return new Upe(e10);
      }, add: function(e10) {
        return new Xpe(e10);
      }, alphaDropout: function(e10) {
        return new afe(e10);
      }, average: function(e10) {
        return new Jpe(e10);
      }, averagePooling1d: Vfe, averagePooling2d: Gfe, averagePooling3d: jfe, avgPool1d: function(e10) {
        return Vfe(e10);
      }, avgPool2d: function(e10) {
        return Gfe(e10);
      }, avgPool3d: function(e10) {
        return jfe(e10);
      }, avgPooling1d: function(e10) {
        return Vfe(e10);
      }, avgPooling2d: function(e10) {
        return Gfe(e10);
      }, avgPooling3d: function(e10) {
        return jfe(e10);
      }, batchNormalization: function(e10) {
        return new ufe(e10);
      }, bidirectional: function(e10) {
        return new Rfe(e10);
      }, categoryEncoding: function(e10) {
        return new Mfe(e10);
      }, centerCrop: function(e10) {
        return new Dfe(e10);
      }, concatenate: function(e10) {
        return new $pe(e10);
      }, conv1d: function(e10) {
        return new gpe(e10);
      }, conv2d: function(e10) {
        return new hpe(e10);
      }, conv2dTranspose: function(e10) {
        return new fpe(e10);
      }, conv3d: function(e10) {
        return new ppe(e10);
      }, conv3dTranspose: function(e10) {
        return new dpe(e10);
      }, convLstm2d: function(e10) {
        return new Lpe(e10);
      }, convLstm2dCell: function(e10) {
        return new Mpe(e10);
      }, cropping2D: function(e10) {
        return new ype(e10);
      }, dense: function(e10) {
        return new Bpe(e10);
      }, depthwiseConv2d: function(e10) {
        return new xpe(e10);
      }, dot: function(e10) {
        return new tfe(e10);
      }, dropout: function(e10) {
        return new zpe(e10);
      }, elu: function(e10) {
        return new Qhe(e10);
      }, embedding: function(e10) {
        return new qpe(e10);
      }, flatten: function(e10) {
        return new Wpe(e10);
      }, gaussianDropout: function(e10) {
        return new rfe(e10);
      }, gaussianNoise: function(e10) {
        return new nfe(e10);
      }, globalAveragePooling1d: function(e10) {
        return new Ife(e10);
      }, globalAveragePooling2d: function(e10) {
        return new Tfe(e10);
      }, globalMaxPool1d: Hfe, globalMaxPool2d: qfe, globalMaxPooling1d: Hfe, globalMaxPooling2d: qfe, gru: function(e10) {
        return new Cpe(e10);
      }, gruCell: function(e10) {
        return new Epe(e10);
      }, input: Ihe, inputLayer: function(e10) {
        return new Nce(e10);
      }, layerNormalization: function(e10) {
        return new cfe(e10);
      }, leakyReLU: function(e10) {
        return new Jhe(e10);
      }, lstm: function(e10) {
        return new Rpe(e10);
      }, lstmCell: function(e10) {
        return new Ape(e10);
      }, masking: function(e10) {
        return new Hpe(e10);
      }, maxPool1d: Kfe, maxPool2d: Xfe, maxPooling1d: Kfe, maxPooling2d: Xfe, maxPooling3d: function(e10) {
        return new xfe(e10);
      }, maximum: function(e10) {
        return new Zpe(e10);
      }, minimum: function(e10) {
        return new Qpe(e10);
      }, multiply: function(e10) {
        return new Ype(e10);
      }, permute: function(e10) {
        return new jpe(e10);
      }, prelu: function(e10) {
        return new Zhe(e10);
      }, randomWidth: function(e10) {
        return new Ufe(e10);
      }, reLU: function(e10) {
        return new Yhe(e10);
      }, repeatVector: function(e10) {
        return new Vpe(e10);
      }, rescaling: function(e10) {
        return new _fe(e10);
      }, reshape: function(e10) {
        return new Gpe(e10);
      }, resizing: function(e10) {
        return new zfe(e10);
      }, rnn: function(e10) {
        return new Ipe(e10);
      }, separableConv2d: function(e10) {
        return new mpe(e10);
      }, simpleRNN: function(e10) {
        return new Tpe(e10);
      }, simpleRNNCell: function(e10) {
        return new Spe(e10);
      }, softmax: function(e10) {
        return new epe(e10);
      }, spatialDropout1d: function(e10) {
        return new Ppe(e10);
      }, stackedRNNCells: function(e10) {
        return new _pe(e10);
      }, thresholdedReLU: function(e10) {
        return new $he(e10);
      }, timeDistributed: function(e10) {
        return new Afe(e10);
      }, upSampling2d: function(e10) {
        return new bpe(e10);
      }, zeroPadding2d: function(e10) {
        return new lfe(e10);
      } };
      var Jfe = { __proto__: null, MAPE: function(e10, t10) {
        return sle(e10, t10);
      }, MSE: function(e10, t10) {
        return ile(e10, t10);
      }, binaryAccuracy: function(e10, t10) {
        return mle(e10, t10);
      }, binaryCrossentropy: function(e10, t10) {
        return kle(e10, t10);
      }, categoricalAccuracy: function(e10, t10) {
        return gle(e10, t10);
      }, categoricalCrossentropy: function(e10, t10) {
        return Ile(e10, t10);
      }, cosineProximity: function(e10, t10) {
        return fle(e10, t10);
      }, mape: function(e10, t10) {
        return sle(e10, t10);
      }, meanAbsoluteError: function(e10, t10) {
        return ole(e10, t10);
      }, meanAbsolutePercentageError: function(e10, t10) {
        return sle(e10, t10);
      }, meanSquaredError: function(e10, t10) {
        return ile(e10, t10);
      }, mse: function(e10, t10) {
        return ile(e10, t10);
      }, precision: function(e10, t10) {
        return ble(e10, t10);
      }, recall: function(e10, t10) {
        return xle(e10, t10);
      }, sparseCategoricalAccuracy: function(e10, t10) {
        return wle(e10, t10);
      } }, Zfe = { __proto__: null, modelFromJSON: function(e10, t10) {
        return ghe.apply(this, arguments);
      } };
      var Qfe = { __proto__: null, l1: function(e10) {
        return Vhe(t10 = e10), new jhe({ l1: null != t10 ? t10.l1 : null, l2: 0 });
        var t10;
      }, l1l2: function(e10) {
        return new jhe(e10);
      }, l2: function(e10) {
        return Vhe(t10 = e10), new jhe({ l2: null != t10 ? t10.l2 : null, l1: 0 });
        var t10;
      } }, $fe = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          var e11;
          return l(this, n10), (e11 = t10.apply(this, arguments)).model = null, e11;
        }
        return p(n10, [{ key: "setModel", value: function(e11) {
          if (!(e11 instanceof vhe)) throw new Error("model must be a LayersModel, not some other Container");
          this.model = e11;
        } }]), n10;
      }(Yce);
      function ede(e10, t10) {
        return e10 < t10;
      }
      function tde(e10, t10) {
        return e10 > t10;
      }
      var nde = function(e10) {
        d(i10, e10);
        var t10, n10, r10, a10 = w(i10);
        function i10(e11) {
          var t11;
          if (l(this, i10), t11 = a10.call(this), null == e11 && (e11 = {}), e11.restoreBestWeights) throw new Ase("restoreBestWeights = True is not implemented in EarlyStopping yet.");
          return t11.monitor = e11.monitor || "val_loss", t11.minDelta = Math.abs(e11.minDelta || 0), t11.patience = e11.patience || 0, t11.verbose = e11.verbose || 0, t11.mode = e11.mode || "auto", t11.baseline = e11.baseline, -1 === ["auto", "min", "max"].indexOf(t11.mode) && (console.warn("EarlyStopping mode '".concat(t11.mode, "' is invalid. ") + "Falling back to mode 'auto'."), t11.mode = "auto"), "min" === t11.mode ? t11.monitorFunc = ede : "max" === t11.mode || -1 !== t11.monitor.indexOf("acc") ? t11.monitorFunc = tde : t11.monitorFunc = ede, t11.monitorFunc === ede && (t11.minDelta *= -1), t11;
        }
        return p(i10, [{ key: "onTrainBegin", value: (r10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                this.wait = 0, this.stoppedEpoch = 0, null != this.baseline ? this.best = this.baseline : this.best = this.monitorFunc === ede ? 1 / 0 : -1 / 0;
              case 3:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return r10.apply(this, arguments);
        }) }, { key: "onEpochEnd", value: (n10 = c(o().mark(function e11(t11, n11) {
          var r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, qce(n11);
              case 2:
                if (null != (r11 = this.getMonitorValue(n11))) {
                  e12.next = 5;
                  break;
                }
                return e12.abrupt("return");
              case 5:
                this.monitorFunc(r11 - this.minDelta, this.best) ? (this.best = r11, this.wait = 0) : (this.wait++, this.wait >= this.patience && (this.stoppedEpoch = t11, this.model.stopTraining = true));
              case 6:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return n10.apply(this, arguments);
        }) }, { key: "onTrainEnd", value: (t10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                this.stoppedEpoch > 0 && this.verbose && console.log("Epoch ".concat(this.stoppedEpoch, ": early stopping."));
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "getMonitorValue", value: function(e11) {
          null == e11 && (e11 = {});
          var t11 = e11[this.monitor];
          return null == t11 && console.warn("Metric for EarlyStopping ".concat(this.monitor, " is not available. ") + "Available metrics are: ".concat(Object.keys(e11))), t11;
        } }]), i10;
      }($fe);
      var rde, ade, ide = { earlyStopping: function(e10) {
        return new nde(e10);
      } };
      k0().registerFlag("KEEP_INTERMEDIATE_TENSORS", function() {
        return false;
      }, function(e10) {
        e10 && console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
      }), function(e10) {
        e10[e10.DT_INVALID = 0] = "DT_INVALID", e10[e10.DT_FLOAT = 1] = "DT_FLOAT", e10[e10.DT_DOUBLE = 2] = "DT_DOUBLE", e10[e10.DT_INT32 = 3] = "DT_INT32", e10[e10.DT_UINT8 = 4] = "DT_UINT8", e10[e10.DT_INT16 = 5] = "DT_INT16", e10[e10.DT_INT8 = 6] = "DT_INT8", e10[e10.DT_STRING = 7] = "DT_STRING", e10[e10.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e10[e10.DT_INT64 = 9] = "DT_INT64", e10[e10.DT_BOOL = 10] = "DT_BOOL", e10[e10.DT_QINT8 = 11] = "DT_QINT8", e10[e10.DT_QUINT8 = 12] = "DT_QUINT8", e10[e10.DT_QINT32 = 13] = "DT_QINT32", e10[e10.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e10[e10.DT_QINT16 = 15] = "DT_QINT16", e10[e10.DT_QUINT16 = 16] = "DT_QUINT16", e10[e10.DT_UINT16 = 17] = "DT_UINT16", e10[e10.DT_COMPLEX128 = 18] = "DT_COMPLEX128", e10[e10.DT_HALF = 19] = "DT_HALF", e10[e10.DT_RESOURCE = 20] = "DT_RESOURCE", e10[e10.DT_VARIANT = 21] = "DT_VARIANT", e10[e10.DT_UINT32 = 22] = "DT_UINT32", e10[e10.DT_UINT64 = 23] = "DT_UINT64", e10[e10.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e10[e10.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e10[e10.DT_INT32_REF = 103] = "DT_INT32_REF", e10[e10.DT_UINT8_REF = 104] = "DT_UINT8_REF", e10[e10.DT_INT16_REF = 105] = "DT_INT16_REF", e10[e10.DT_INT8_REF = 106] = "DT_INT8_REF", e10[e10.DT_STRING_REF = 107] = "DT_STRING_REF", e10[e10.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e10[e10.DT_INT64_REF = 109] = "DT_INT64_REF", e10[e10.DT_BOOL_REF = 110] = "DT_BOOL_REF", e10[e10.DT_QINT8_REF = 111] = "DT_QINT8_REF", e10[e10.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e10[e10.DT_QINT32_REF = 113] = "DT_QINT32_REF", e10[e10.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF", e10[e10.DT_QINT16_REF = 115] = "DT_QINT16_REF", e10[e10.DT_QUINT16_REF = 116] = "DT_QUINT16_REF", e10[e10.DT_UINT16_REF = 117] = "DT_UINT16_REF", e10[e10.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF", e10[e10.DT_HALF_REF = 119] = "DT_HALF_REF", e10[e10.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF", e10[e10.DT_VARIANT_REF = 121] = "DT_VARIANT_REF", e10[e10.DT_UINT32_REF = 122] = "DT_UINT32_REF", e10[e10.DT_UINT64_REF = 123] = "DT_UINT64_REF";
      }(rde || (rde = {})), function(e10) {
        !function(e11) {
          e11[e11.LEGACY = 0] = "LEGACY", e11[e11.V1 = 1] = "V1", e11[e11.V2 = 2] = "V2";
        }(e10.CheckpointFormatVersion || (e10.CheckpointFormatVersion = {}));
      }(ade || (ade = {}));
      var ode = {};
      function sde(e10) {
        return ode[e10];
      }
      function ude(e10, t10, n10, r10, a10) {
        var i10 = t10.inputParams[e10];
        if (i10 && void 0 !== i10.inputIndexStart) {
          var o10 = i10.inputIndexStart, s10 = 0 === i10.inputIndexEnd ? void 0 : void 0 === i10.inputIndexEnd ? o10 + 1 : i10.inputIndexEnd, u10 = o10 < 0 ? t10.inputNames.length + o10 : o10;
          if ("tensor" === i10.type) return cde(t10.inputNames[u10], n10, r10, a10);
          if ("tensors" === i10.type) {
            var c10 = t10.inputs.slice(o10, s10), l10 = t10.inputNames.slice(o10, s10).filter(function(e11, t11) {
              var n11;
              return "NoOp" !== (null === (n11 = c10[t11]) || void 0 === n11 ? void 0 : n11.op);
            });
            return l10.map(function(e11) {
              return cde(e11, n10, r10, a10);
            });
          }
          var h10 = cde(t10.inputNames[u10], n10, r10, a10), p10 = h10.dataSync();
          return "number" === i10.type ? p10[0] : s0(h10.shape, p10);
        }
        var f10 = t10.attrParams[e10];
        return f10 && f10.value;
      }
      function cde(e10, t10, n10, r10) {
        var a10 = S(fde(e10, n10), 2), i10 = a10[0], o10 = a10[1];
        if (null != r10) {
          var s10 = r10.getHashTableHandleByName(i10);
          if (null != s10) return s10;
        }
        var u10 = n10.currentContextIds.find(function(e11) {
          return !!t10[pde(i10, e11)];
        });
        return void 0 !== u10 ? t10[pde(i10, u10)][o10] : void 0;
      }
      function lde(e10, t10, n10) {
        return t10[pde(e10, n10.currentContextId)];
      }
      function hde(e10, t10) {
        var n10 = S(fde(e10, t10), 3), r10 = n10[0], a10 = n10[1], i10 = n10[2];
        return [pde(r10, t10 && t10.currentContextId), a10, i10];
      }
      function pde(e10, t10) {
        return t10 ? "".concat(e10, "-").concat(t10) : e10;
      }
      function fde(e10, t10) {
        if ("" === e10) return ["", 0, void 0];
        var n10 = null != t10 && null != t10.parseNodeNameCache;
        if (n10) {
          var r10 = t10.parseNodeNameCache.get(e10);
          if (null != r10) return r10;
        }
        var a10, i10 = e10.split(":");
        if (1 === i10.length) a10 = [e10, 0, void 0];
        else {
          var o10 = i10[0], s10 = 3 === i10.length ? i10[1] : void 0;
          a10 = [o10, Number(i10[i10.length - 1]), s10];
        }
        return n10 && t10.parseNodeNameCache.set(e10, a10), a10;
      }
      function dde(e10, t10, n10) {
        var r10 = ude("pad", e10, t10, n10);
        if ("explicit" === r10) {
          r10 = ude("explicitPaddings", e10, t10, n10);
          for (var a10 = [[0, 0], [0, 0], [0, 0], [0, 0]], i10 = 0; i10 < 4; i10++) a10[i10][0] = r10[2 * i10], a10[i10][1] = r10[2 * i10 + 1];
          return a10;
        }
        return r10;
      }
      function vde(e10) {
        return e10.kept ? e10 : p8(e10);
      }
      var mde = { __proto__: null, json: [{ tfOpName: "Add", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AddV2", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AddN", category: "arithmetic", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }] }, { tfOpName: "BiasAdd", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "Sub", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "RealDiv", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Div", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "DivNoNan", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "FloorDiv", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Mul", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Maximum", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Minimum", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Pow", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "SquaredDifference", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Mod", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "FloorMod", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }] }, gde = { __proto__: null, json: [{ tfOpName: "Abs", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Acos", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Asin", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atan2", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Ceil", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ClipByValue", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "clipValueMin", type: "number" }, { start: 2, name: "clipValueMax", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Complex", category: "basic_math", inputs: [{ start: 0, name: "real", type: "tensor" }, { start: 1, name: "imag", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ComplexAbs", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Cos", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Cosh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Elu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Exp", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Floor", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Log", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Imag", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "Tout", name: "outputType", type: "dtype", notSupported: true }] }, { tfOpName: "Neg", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Real", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "Tout", name: "outputType", type: "dtype", notSupported: true }] }, { tfOpName: "Prelu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "alpha", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Relu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Relu6", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Selu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sigmoid", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sin", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sinh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sqrt", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Rsqrt", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Square", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Tan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Tanh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sign", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Round", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Expm1", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Log1p", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Reciprocal", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Softplus", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Asinh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Acosh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atanh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Erf", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LeakyRelu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "alpha", name: "alpha", type: "number", defaultValue: 0.2 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "IsNan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "IsFinite", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "IsInf", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }] }, yde = { __proto__: null, json: [{ tfOpName: "EmptyTensorList", category: "control", inputs: [{ start: 0, name: "elementShape", type: "shape" }, { start: 1, name: "maxNumElements", type: "number" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "LoopCond", category: "control", inputs: [{ start: 0, name: "pred", type: "tensor" }] }, { tfOpName: "Switch", category: "control", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "pred", type: "tensor" }] }, { tfOpName: "Merge", category: "control", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }] }, { tfOpName: "Enter", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "frame_name", name: "frameName", type: "string" }, { tfName: "is_constant", name: "isConstant", type: "bool" }] }, { tfOpName: "Exit", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "NextIteration", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayV3", category: "control", inputs: [{ start: 0, name: "size", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape", name: "elementShape", type: "shape" }, { tfName: "dynamic_size", name: "dynamicSize", type: "bool" }, { tfName: "clear_after_read", name: "clearAfterRead", type: "bool" }, { tfName: "identical_element_shapes", name: "identicalElementShapes", type: "bool" }, { tfName: "tensor_array_name", name: "name", type: "string" }] }, { tfOpName: "TensorArrayWriteV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "tensor", type: "tensor" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayReadV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayGatherV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape", name: "elementShape", type: "shape" }] }, { tfOpName: "TensorArrayScatterV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "tensor", type: "tensor" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "TensorArrayConcatV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape_except0", name: "elementShapeExcept0", type: "shape", notSupported: true }] }, { tfOpName: "TensorArraySplitV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "tensor", type: "tensor" }, { start: 2, name: "lengths", type: "number[]" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "TensorArraySizeV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "flowIn", type: "number" }] }, { tfOpName: "TensorArrayCloseV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }] }, { tfOpName: "StatelessIf", category: "control", inputs: [{ start: 0, name: "cond", type: "tensor" }, { start: 1, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "then_branch", name: "thenBranch", type: "func" }, { tfName: "else_branch", name: "elseBranch", type: "func" }] }, { tfOpName: "If", category: "control", inputs: [{ start: 0, name: "cond", type: "tensor" }, { start: 1, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "then_branch", name: "thenBranch", type: "func" }, { tfName: "else_branch", name: "elseBranch", type: "func" }] }, { tfOpName: "StatelessWhile", category: "control", inputs: [{ start: 0, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "cond", name: "cond", type: "func" }, { tfName: "body", name: "body", type: "func" }] }, { tfOpName: "While", category: "control", inputs: [{ start: 0, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "cond", name: "cond", type: "func" }, { tfName: "body", name: "body", type: "func" }] }, { tfOpName: "TensorListScatter", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListScatterV2", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "elementShape", type: "shape" }, { start: 3, name: "numElements", type: "number" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListGather", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListGetItem", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListSetItem", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "tensor", type: "tensor" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListReserve", category: "control", inputs: [{ start: 0, name: "elementShape", type: "shape" }, { start: 1, name: "numElements", type: "number" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListFromTensor", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListStack", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }, { tfName: "num_elements", name: "numElements", type: "dtype" }] }, { tfOpName: "TensorListSplit", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }, { start: 2, name: "lengths", type: "number[]" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListConcat", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }], attrs: [{ tfName: "element_shape", name: "elementShape", type: "shape" }, { tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListConcatV2", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }], attrs: [{ tfName: "element_shape", name: "elementShape", type: "shape" }, { tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListPopBack", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListPushBack", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "tensor", type: "tensor" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListLength", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }] }, { tfOpName: "TensorListResize", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "size", type: "number" }] }] }, bde = { __proto__: null, json: [{ tfOpName: "AvgPool", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MaxPool", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [], notSupported: true }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MaxPoolWithArgmax", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "include_batch_in_index", name: "includeBatchInIndex", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AvgPool3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MaxPool3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Conv1D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "stride", name: "stride", type: "number" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NWC" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "dilation", name: "dilation", type: "number", defaultValue: 1 }] }, { tfOpName: "Conv2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "useCudnnOnGpu", name: "useCudnnOnGpu", type: "bool" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "_FusedConv2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "use_cudnn_on_gpu", name: "useCudnnOnGpu", type: "bool", defaultValue: true }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1] }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4 }, { tfName: "leakyrelu_alpha", name: "leakyreluAlpha", type: "number", defaultValue: 0.2 }] }, { tfOpName: "Conv2DBackpropInput", category: "convolution", inputs: [{ start: 2, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 0, name: "outputShape", type: "number[]" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]", notSupported: true }] }, { tfOpName: "DepthwiseConv2d", category: "convolution", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "DepthwiseConv2dNative", category: "convolution", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "FusedDepthwiseConv2dNative", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1] }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }] }, { tfOpName: "Conv3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "Dilation2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "rates", name: "dilations", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }] }] }, xde = { __proto__: null, json: [{ tfOpName: "Fill", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }, { start: 1, name: "value", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "LinSpace", category: "creation", inputs: [{ start: 0, name: "start", type: "number" }, { start: 1, name: "stop", type: "number" }, { start: 2, name: "num", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "OneHot", category: "creation", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "depth", type: "number" }, { start: 2, name: "onValue", type: "number", defaultValue: 1 }, { start: 3, name: "offValue", type: "number", defaultValue: 0 }], attrs: [{ tfName: "axis", name: "axis", type: "number", notSupported: true }, { tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "Ones", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "OnesLike", category: "creation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "RandomStandardNormal", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "seed", name: "seed", type: "number", defaultValue: 0 }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "T", name: "T", type: "number", notSupported: true }] }, { tfOpName: "RandomUniform", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "minval", name: "minval", type: "number", defaultValue: 0 }, { tfName: "maxval", name: "maxval", type: "number", defaultValue: 1 }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "seed", name: "seed", type: "number", defaultValue: 0 }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }, { tfName: "T", name: "T", type: "number", notSupported: true }] }, { tfOpName: "RandomUniformInt", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "minval", name: "minval", type: "number" }, { tfName: "maxval", name: "maxval", type: "number" }, { tfName: "seed", name: "seed", type: "number", defaultValue: 0 }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }] }, { tfOpName: "Range", category: "creation", inputs: [{ start: 0, name: "start", type: "number" }, { start: 1, name: "stop", type: "number" }, { start: 2, name: "step", type: "number", defaultValue: 0 }], attrs: [{ tfName: "Tidx", name: "dtype", type: "dtype" }] }, { tfOpName: "TruncatedNormal", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "means", name: "mean", type: "number", defaultValue: 0 }, { tfName: "stddev", name: "stdDev", type: "number", defaultValue: 1 }, { tfName: "seed", name: "seed", type: "number" }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "T", name: "T", type: "number", notSupported: true }] }, { tfOpName: "Zeros", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "ZerosLike", category: "creation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "Multinomial", category: "creation", inputs: [{ start: 0, name: "logits", type: "tensor" }, { start: 1, name: "numSamples", type: "number" }], attrs: [{ tfName: "seed", name: "seed", type: "number" }, { tfName: "seed2", name: "seed2", type: "number" }, { tfName: "T", name: "dtype", type: "dtype" }, { tfName: "output_dtype", name: "output_dtype", type: "dtype" }] }] }, kde = { __proto__: null, json: [{ tfOpName: "NonMaxSuppressionV2", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }] }, { tfOpName: "NonMaxSuppressionV3", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }] }, { tfOpName: "NonMaxSuppressionV4", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "T_threshold", name: "threshold", type: "dtype", notSupported: true }, { tfName: "pad_to_max_output_size", name: "padToMaxOutputSize", type: "bool" }] }, { tfOpName: "NonMaxSuppressionV5", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }, { start: 5, name: "softNmsSigma", type: "number" }] }, { tfOpName: "Where", category: "dynamic", inputs: [{ start: 0, name: "condition", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ListDiff", category: "dynamic", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }] }, wde = { __proto__: null, json: [{ tfOpName: "LowerBound", category: "evaluation", inputs: [{ start: 0, name: "sortedSequence", type: "tensor" }, { start: 1, name: "values", type: "tensor" }] }, { tfOpName: "TopKV2", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "k", type: "number" }], attrs: [{ tfName: "sorted", name: "sorted", type: "bool" }] }, { tfOpName: "UpperBound", category: "evaluation", inputs: [{ start: 0, name: "sortedSequence", type: "tensor" }, { start: 1, name: "values", type: "tensor" }] }, { tfOpName: "Unique", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "UniqueV2", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }] }, Ide = { __proto__: null, json: [{ tfOpName: "PlaceholderWithDefault", category: "graph", inputs: [{ start: 0, name: "default", type: "tensor" }], attrs: [{ tfName: "shape", name: "shape", type: "shape" }, { tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "Placeholder", category: "graph", attrs: [{ tfName: "shape", name: "shape", type: "shape" }, { tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "Const", category: "graph" }, { tfOpName: "Identity", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "IdentityN", category: "graph", inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }] }, { tfOpName: "Snapshot", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Rank", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Size", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Shape", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "ShapeN", category: "graph", inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }] }, { tfOpName: "Print", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "data", type: "tensors" }], attrs: [{ tfName: "message", name: "message", type: "string" }, { tfName: "first_n", name: "firstN", type: "number", notSupported: true }, { tfName: "summarize", name: "summarize", type: "number", defaultValue: 3 }] }, { tfOpName: "NoOp", category: "graph", inputs: [] }, { tfOpName: "StopGradient", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "FakeQuantWithMinMaxVars", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "min", name: "min", type: "number" }, { tfName: "max", name: "max", type: "number" }] }] }, Nde = { __proto__: null, json: [{ tfOpName: "HashTable", category: "hash_table", inputs: [], attrs: [{ tfName: "shared_name", name: "sharedName", type: "string" }, { tfName: "use_node_name_sharing", name: "useNodeNameSharing", type: "bool" }, { tfName: "key_dtype", name: "keyDType", type: "dtype" }, { tfName: "value_dtype", name: "valueDType", type: "dtype" }] }, { tfOpName: "HashTableV2", category: "hash_table", inputs: [], attrs: [{ tfName: "shared_name", name: "sharedName", type: "string" }, { tfName: "use_node_name_sharing", name: "useNodeNameSharing", type: "bool" }, { tfName: "key_dtype", name: "keyDType", type: "dtype" }, { tfName: "value_dtype", name: "valueDType", type: "dtype" }] }, { tfOpName: "LookupTableImport", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "values", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableImportV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "values", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableFind", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableFindV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableSize", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }] }, { tfOpName: "LookupTableSizeV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }] }, { tfOpName: "InitializeTable", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "values", type: "tensor" }] }, { tfOpName: "InitializeTableV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "values", type: "tensor" }] }] }, Sde = { __proto__: null, json: [{ tfOpName: "ResizeBilinear", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "size", type: "number[]" }], attrs: [{ tfName: "align_corners", name: "alignCorners", type: "bool" }, { tfName: "half_pixel_centers", name: "halfPixelCenters", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ResizeNearestNeighbor", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "size", type: "number[]" }], attrs: [{ tfName: "align_corners", name: "alignCorners", type: "bool" }, { tfName: "half_pixel_centers", name: "halfPixelCenters", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "CropAndResize", category: "image", inputs: [{ start: 0, name: "image", type: "tensor" }, { start: 1, name: "boxes", type: "tensor" }, { start: 2, name: "boxInd", type: "tensor" }, { start: 3, name: "cropSize", type: "number[]" }], attrs: [{ tfName: "method", name: "method", type: "string" }, { tfName: "extrapolation_value", name: "extrapolationValue", type: "number" }] }, { tfOpName: "ImageProjectiveTransformV3", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "transforms", type: "tensor" }, { start: 2, name: "outputShape", type: "number[]" }, { start: 3, name: "fillValue", type: "number" }], attrs: [{ tfName: "interpolation", name: "interpolation", type: "string" }, { tfName: "fill_mode", name: "fillMode", type: "string" }] }] }, Tde = { __proto__: null, json: [{ tfOpName: "Equal", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "NotEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Greater", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "GreaterEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Less", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LessEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalAnd", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalNot", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalOr", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Select", category: "logical", inputs: [{ start: 0, name: "condition", type: "tensor" }, { start: 1, name: "a", type: "tensor" }, { start: 2, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "SelectV2", category: "logical", inputs: [{ start: 0, name: "condition", type: "tensor" }, { start: 1, name: "a", type: "tensor" }, { start: 2, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "BitwiseAnd", category: "logical", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }] }] }, Ede = { __proto__: null, json: [{ tfOpName: "_FusedMatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4 }, { tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "leakyrelu_alpha", name: "leakyreluAlpha", type: "number", defaultValue: 0.2 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "BatchMatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "BatchMatMulV2", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Transpose", category: "matrices", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "perm", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Einsum", category: "matrices", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }], attrs: [{ tfName: "equation", name: "equation", type: "string" }, { tfName: "N", name: "n", type: "number", defaultValue: 2 }, { tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "MatrixBandPart", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "numLower", type: "tensor" }, { start: 1, name: "numUpper", type: "tensor" }] }] }, Cde = { __proto__: null, json: [{ tfOpName: "EuclideanNorm", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool", defaultValue: false }] }, { tfOpName: "FusedBatchNorm", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "FusedBatchNormV2", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "FusedBatchNormV3", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "LRN", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "depth_radius", name: "radius", type: "number", defaultValue: 5 }, { tfName: "bias", name: "bias", type: "number", defaultValue: 1 }, { tfName: "alpha", name: "alpha", type: "number", defaultValue: 1 }, { tfName: "beta", name: "beta", type: "number", defaultValue: 0.5 }] }, { tfOpName: "Softmax", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "LogSoftmax", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }] }] }, Ade = { __proto__: null, json: [{ tfOpName: "Bincount", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "size", type: "number" }, { start: 2, name: "weights", type: "tensor" }] }, { tfOpName: "DenseBincount", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "size", type: "number" }, { start: 2, name: "weights", type: "tensor" }], attrs: [{ tfName: "binary_output", name: "binaryOutput", type: "bool" }] }, { tfOpName: "Max", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Mean", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Min", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Sum", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "All", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Any", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "ArgMax", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "ArgMin", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "Prod", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Cumprod", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }], attrs: [{ tfName: "exclusive", name: "exclusive", type: "bool" }, { tfName: "reverse", name: "reverse", type: "bool" }] }, { tfOpName: "Cumsum", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }], attrs: [{ tfName: "exclusive", name: "exclusive", type: "bool" }, { tfName: "reverse", name: "reverse", type: "bool" }] }] }, Rde = { __proto__: null, json: [{ tfOpName: "ConcatV2", category: "slice_join", inputs: [{ start: 0, end: -1, name: "tensors", type: "tensors" }, { start: -1, name: "axis", type: "number" }], attrs: [{ tfName: "N", name: "n", type: "number", defaultValue: 2 }] }, { tfOpName: "Concat", category: "slice_join", inputs: [{ start: 1, end: 0, name: "tensors", type: "tensors" }, { start: 0, name: "axis", type: "number" }], attrs: [{ tfName: "N", name: "n", type: "number", defaultValue: 2 }] }, { tfOpName: "GatherV2", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "axis", type: "number", defaultValue: 0 }], attrs: [{ tfName: "batch_dims", name: "batchDims", type: "number", defaultValue: 0 }] }, { tfOpName: "Gather", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }], attrs: [{ tfName: "validate_indices", name: "validateIndices", type: "bool", notSupported: true }] }, { tfOpName: "Reverse", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "dims", type: "bool[]" }] }, { tfOpName: "ReverseV2", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }] }, { tfOpName: "Slice", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "begin", type: "number[]" }, { start: 2, name: "size", type: "number[]" }] }, { tfOpName: "StridedSlice", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "begin", type: "number[]" }, { start: 2, name: "end", type: "number[]" }, { start: 3, name: "strides", type: "number[]" }], attrs: [{ tfName: "begin_mask", name: "beginMask", type: "number", defaultValue: 0 }, { tfName: "end_mask", name: "endMask", type: "number", defaultValue: 0 }, { tfName: "new_axis_mask", name: "newAxisMask", type: "number", defaultValue: 0 }, { tfName: "ellipsis_mask", name: "ellipsisMask", type: "number", defaultValue: 0 }, { tfName: "shrink_axis_mask", name: "shrinkAxisMask", type: "number", defaultValue: 0 }] }, { tfOpName: "Pack", category: "slice_join", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }], attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }] }, { tfOpName: "Unpack", category: "slice_join", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }, { tfName: "num", name: "num", type: "number", defaultValue: 0, notSupported: true }] }, { tfOpName: "Tile", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "reps", type: "number[]" }] }, { tfOpName: "Split", category: "slice_join", inputs: [{ start: 0, name: "axis", type: "number", defaultValue: 0 }, { start: 1, name: "x", type: "tensor" }], attrs: [{ tfName: "num_split", name: "numOrSizeSplits", type: "number", defaultValue: 1 }] }, { tfOpName: "SplitV", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "numOrSizeSplits", type: "number[]" }, { start: 2, name: "axis", type: "number", defaultValue: 0 }] }, { tfOpName: "ScatterNd", category: "slice_join", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "values", type: "tensor" }, { start: 2, name: "shape", type: "number[]" }] }, { tfOpName: "GatherNd", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }] }, { tfOpName: "SparseToDense", category: "slice_join", inputs: [{ start: 0, name: "sparseIndices", type: "tensor" }, { start: 1, name: "outputShape", type: "number[]" }, { start: 2, name: "sparseValues", type: "tensor" }, { start: 3, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "validate_indices", name: "validateIndices", type: "bool", defaultValue: false, notSupported: true }] }, { tfOpName: "TensorScatterUpdate", category: "slice_join", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "values", type: "tensor" }] }] }, _de = { __proto__: null, json: [{ tfOpName: "SparseFillEmptyRows", category: "sparse", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "values", type: "tensor" }, { start: 2, name: "denseShape", type: "tensor" }, { start: 3, name: "defaultValue", type: "tensor" }] }, { tfOpName: "SparseReshape", category: "sparse", inputs: [{ start: 0, name: "inputIndices", type: "tensor" }, { start: 1, name: "inputShape", type: "tensor" }, { start: 2, name: "newShape", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "SparseSegmentMean", category: "sparse", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "segmentIds", type: "tensor" }] }, { tfOpName: "SparseSegmentSum", category: "sparse", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "segmentIds", type: "tensor" }] }] }, Ode = { __proto__: null, json: [{ tfOpName: "FFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "IFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "RFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "fft_length", type: "number", notSupported: true }] }, { tfOpName: "IRFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "fft_length", type: "number", notSupported: true }] }] }, Fde = { __proto__: null, json: [{ tfOpName: "StaticRegexReplace", category: "string", inputs: [{ start: 0, name: "input", type: "tensor" }], attrs: [{ tfName: "pattern", name: "pattern", type: "string" }, { tfName: "rewrite", name: "rewrite", type: "string" }, { tfName: "replace_global", name: "replaceGlobal", type: "bool" }] }, { tfOpName: "StringNGrams", category: "string", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "dataSplits", type: "tensor" }], attrs: [{ tfName: "separator", name: "separator", type: "string" }, { tfName: "ngram_widths", name: "nGramWidths", type: "number[]" }, { tfName: "left_pad", name: "leftPad", type: "string" }, { tfName: "right_pad", name: "rightPad", type: "string" }, { tfName: "pad_width", name: "padWidth", type: "number" }, { tfName: "preserve_short_sequences", name: "preserveShortSequences", type: "bool" }], outputs: ["ngrams", "ngrams_splits"] }, { tfOpName: "StringSplit", category: "string", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "delimiter", type: "tensor" }], attrs: [{ tfName: "skip_empty", name: "skipEmpty", type: "bool" }], outputs: ["indices", "values", "shape"] }, { tfOpName: "StringToHashBucketFast", category: "string", inputs: [{ start: 0, name: "input", type: "tensor" }], attrs: [{ tfName: "num_buckets", name: "numBuckets", type: "number" }] }] }, Dde = { __proto__: null, json: [{ tfOpName: "Cast", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "SrcT", name: "sdtype", type: "dtype", notSupported: true }, { tfName: "DstT", name: "dtype", type: "dtype" }] }, { tfOpName: "ExpandDims", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "MirrorPad", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }], attrs: [{ tfName: "mode", name: "mode", type: "string" }] }, { tfOpName: "Pad", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }], attrs: [{ tfName: "constant_value", name: "constantValue", type: "number", defaultValue: 0 }] }, { tfOpName: "PadV2", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }, { start: 2, name: "constantValue", type: "number", defaultValue: 0 }] }, { tfOpName: "Reshape", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "shape", type: "number[]" }] }, { tfOpName: "EnsureShape", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "shape", type: "number[]" }] }, { tfOpName: "Squeeze", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "axis", tfDeprecatedName: "squeeze_dims", name: "axis", type: "number[]" }] }, { tfOpName: "SpaceToBatchND", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "blockShape", type: "number[]" }, { start: 2, name: "paddings", type: "number[]" }] }, { tfOpName: "BatchToSpaceND", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "blockShape", type: "number[]" }, { start: 2, name: "crops", type: "number[]" }] }, { tfOpName: "DepthToSpace", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "block_size", name: "blockSize", type: "number" }, { tfName: "data_format", name: "dataFormat", type: "string" }] }, { tfOpName: "BroadcastTo", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "shape", type: "number[]" }], attrs: [] }, { tfOpName: "BroadcastArgs", category: "transformation", inputs: [{ start: 0, name: "s0", type: "tensor" }, { start: 1, name: "s1", type: "tensor" }], attrs: [] }] }, Mde = function() {
        function e10() {
          var t10;
          l(this, e10);
          var n10 = [mde, gde, yde, bde, xde, kde, wde, Ide, Nde, Sde, Tde, Ede, Cde, Ade, Rde, _de, Ode, Fde, Dde], r10 = (t10 = []).concat.apply(t10, T(n10.map(function(e11) {
            return e11.json;
          })));
          this.opMappers = r10.reduce(function(e11, t11) {
            return e11[t11.tfOpName] = t11, e11;
          }, {});
        }
        return p(e10, [{ key: "transformGraph", value: function(e11) {
          var t10 = this, n10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r10 = e11.node, a10 = [], i10 = [], o10 = [], s10 = r10.reduce(function(e12, n11) {
            return e12[n11.name] = t10.mapNode(n11), n11.op.startsWith("Placeholder") ? a10.push(e12[n11.name]) : "Const" === n11.op ? i10.push(e12[n11.name]) : null != n11.input && 0 !== n11.input.length || o10.push(e12[n11.name]), e12;
          }, {}), u10 = [], c10 = [], l10 = {}, h10 = {};
          null != n10 && (l10 = this.mapSignatureEntries(n10.inputs), h10 = this.mapSignatureEntries(n10.outputs));
          var p10 = Object.keys(s10);
          p10.forEach(function(e12) {
            var t11 = s10[e12];
            t11.inputNames.forEach(function(e13, n11) {
              var r11 = S(hde(e13), 3), a11 = r11[0], i11 = r11[2], o11 = s10[a11];
              if (null != o11.outputs) {
                var u11 = o11.outputs.indexOf(i11);
                if (-1 !== u11) {
                  var c11 = "".concat(a11, ":").concat(u11);
                  t11.inputNames[n11] = c11;
                }
              }
              t11.inputs.push(o11), o11.children.push(t11);
            });
          }), 0 === Object.keys(h10).length ? p10.forEach(function(e12) {
            var t11 = s10[e12];
            0 === t11.children.length && c10.push(t11);
          }) : Object.keys(h10).forEach(function(e12) {
            var t11 = S(hde(e12), 1)[0], n11 = s10[t11];
            null != n11 && (n11.signatureKey = h10[e12], c10.push(n11));
          }), Object.keys(l10).length > 0 ? Object.keys(l10).forEach(function(e12) {
            var t11 = S(hde(e12), 1)[0], n11 = s10[t11];
            n11 && (n11.signatureKey = l10[e12], u10.push(n11));
          }) : u10 = a10;
          var f10 = {};
          null != e11.library && null != e11.library.function && (f10 = e11.library.function.reduce(function(e12, n11) {
            return e12[n11.signature.name] = t10.mapFunction(n11), e12;
          }, {}));
          var d10 = { nodes: s10, inputs: u10, outputs: c10, weights: i10, placeholders: a10, signature: n10, functions: f10 };
          return o10.length > 0 && (d10.initNodes = o10), d10;
        } }, { key: "mapSignatureEntries", value: function(e11) {
          return Object.keys(e11 || {}).reduce(function(t10, n10) {
            return t10[e11[n10].name] = n10, t10;
          }, {});
        } }, { key: "mapNode", value: function(e11) {
          var t10 = sde(e11.op) || this.opMappers[e11.op] || {};
          null == e11.attr && (e11.attr = {});
          var n10 = { name: e11.name, op: e11.op, category: t10.category, inputNames: (e11.input || []).map(function(e12) {
            return e12.startsWith("^") ? e12.slice(1) : e12;
          }), inputs: [], children: [], inputParams: {}, attrParams: {}, rawAttrs: e11.attr, outputs: t10.outputs };
          return null != t10.inputs && (n10.inputParams = t10.inputs.reduce(function(e12, t11) {
            return e12[t11.name] = { type: t11.type, inputIndexStart: t11.start, inputIndexEnd: t11.end }, e12;
          }, {})), null != t10.attrs && (n10.attrParams = t10.attrs.reduce(function(t11, n11) {
            var r10 = n11.type, a10 = void 0;
            switch (n11.type) {
              case "string":
                void 0 === (a10 = zde(e11.attr, n11.tfName, n11.defaultValue)) && n11.tfDeprecatedName && (a10 = zde(e11.attr, n11.tfDeprecatedName, n11.defaultValue));
                break;
              case "string[]":
                void 0 === (a10 = Kde(e11.attr, n11.tfName, n11.defaultValue)) && n11.tfDeprecatedName && (a10 = Kde(e11.attr, n11.tfDeprecatedName, n11.defaultValue));
                break;
              case "number":
                void 0 === (a10 = Bde(e11.attr, n11.tfName, n11.defaultValue || 0)) && n11.tfDeprecatedName && (a10 = Bde(e11.attr, n11.tfDeprecatedName, n11.defaultValue));
                break;
              case "number[]":
                void 0 === (a10 = qde(e11.attr, n11.tfName, n11.defaultValue)) && n11.tfDeprecatedName && (a10 = qde(e11.attr, n11.tfDeprecatedName, n11.defaultValue));
                break;
              case "bool":
                void 0 === (a10 = Pde(e11.attr, n11.tfName, n11.defaultValue)) && n11.tfDeprecatedName && (a10 = Pde(e11.attr, n11.tfDeprecatedName, n11.defaultValue));
                break;
              case "bool[]":
                void 0 === (a10 = Yde(e11.attr, n11.tfName, n11.defaultValue)) && n11.tfDeprecatedName && (a10 = Yde(e11.attr, n11.tfDeprecatedName, n11.defaultValue));
                break;
              case "shape":
                void 0 === (a10 = Hde(e11.attr, n11.tfName, n11.defaultValue)) && n11.tfDeprecatedName && (a10 = Hde(e11.attr, n11.tfDeprecatedName, n11.defaultValue));
                break;
              case "shape[]":
                void 0 === (a10 = Xde(e11.attr, n11.tfName, n11.defaultValue)) && n11.tfDeprecatedName && (a10 = Xde(e11.attr, n11.tfDeprecatedName, n11.defaultValue));
                break;
              case "dtype":
                void 0 === (a10 = Vde(e11.attr, n11.tfName, n11.defaultValue)) && n11.tfDeprecatedName && (a10 = Vde(e11.attr, n11.tfDeprecatedName, n11.defaultValue));
                break;
              case "dtype[]":
                void 0 === (a10 = Gde(e11.attr, n11.tfName, n11.defaultValue)) && n11.tfDeprecatedName && (a10 = Gde(e11.attr, n11.tfDeprecatedName, n11.defaultValue));
                break;
              case "func":
                void 0 === (a10 = Ude(e11.attr, n11.tfName, n11.defaultValue)) && n11.tfDeprecatedName && (a10 = Ude(e11.attr, n11.tfDeprecatedName, n11.defaultValue));
                break;
              case "tensor":
              case "tensors":
                break;
              default:
                throw new Error("Unsupported param type: ".concat(n11.type, " for op: ").concat(e11.op));
            }
            return t11[n11.name] = { value: a10, type: r10 }, t11;
          }, {})), n10;
        } }, { key: "mapFunction", value: function(e11) {
          var t10 = this, n10 = e11.nodeDef, r10 = [], a10 = {};
          null != n10 && (a10 = n10.reduce(function(e12, n11) {
            return e12[n11.name] = t10.mapNode(n11), "Const" === n11.op && r10.push(e12[n11.name]), e12;
          }, {}));
          var i10 = [], o10 = [];
          e11.signature.inputArg.forEach(function(e12) {
            var t11 = S(hde(e12.name), 1)[0], n11 = { name: t11, op: "Placeholder", inputs: [], inputNames: [], category: "graph", inputParams: {}, attrParams: { dtype: { value: Wde(e12.type), type: "dtype" } }, children: [] };
            n11.signatureKey = e12.name, i10.push(n11), a10[t11] = n11;
          }), Object.keys(a10).forEach(function(e12) {
            var t11 = a10[e12];
            t11.inputNames.forEach(function(e13, n11) {
              var r11 = S(hde(e13), 3), i11 = r11[0], o11 = r11[2], s11 = a10[i11];
              if (null != s11.outputs) {
                var u11 = s11.outputs.indexOf(o11);
                if (-1 !== u11) {
                  var c10 = "".concat(i11, ":").concat(u11);
                  t11.inputNames[n11] = c10;
                }
              }
              t11.inputs.push(s11), s11.children.push(t11);
            });
          });
          var s10 = e11.ret;
          e11.signature.outputArg.forEach(function(e12) {
            var t11 = S(hde(s10[e12.name]), 2), n11 = t11[0], r11 = t11[1], i11 = a10[n11];
            null != i11 && (i11.defaultOutput = r11, o10.push(i11));
          });
          var u10 = this.mapArgsToSignature(e11);
          return { nodes: a10, inputs: i10, outputs: o10, weights: r10, placeholders: [], signature: u10 };
        } }, { key: "mapArgsToSignature", value: function(e11) {
          var t10 = this;
          return { methodName: e11.signature.name, inputs: e11.signature.inputArg.reduce(function(e12, n10) {
            return e12[n10.name] = t10.mapArgToTensorInfo(n10), e12;
          }, {}), outputs: e11.signature.outputArg.reduce(function(n10, r10) {
            return n10[r10.name] = t10.mapArgToTensorInfo(r10, e11.ret), n10;
          }, {}) };
        } }, { key: "mapArgToTensorInfo", value: function(e11, t10) {
          var n10 = e11.name;
          return null != t10 && (n10 = t10[n10]), { name: n10, dtype: e11.type };
        } }], [{ key: "Instance", get: function() {
          return this._instance || (this._instance = new this());
        } }]), e10;
      }();
      function Lde(e10, t10) {
        var n10 = Array.isArray(e10) ? String.fromCharCode.apply(null, e10) : function(e11) {
          var t11 = k0().global;
          if (void 0 !== t11.atob) return t11.atob(e11);
          if ("undefined" != typeof Buffer) return new Buffer(e11, "base64").toString();
          throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
        }(e10);
        return t10 ? n10 : n10.toLowerCase();
      }
      function zde(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a10 = e10[t10];
        return null != a10 ? Lde(a10.s, r10) : n10;
      }
      function Pde(e10, t10, n10) {
        var r10 = e10[t10];
        return r10 ? r10.b : n10;
      }
      function Bde(e10, t10, n10) {
        var r10 = e10[t10] || {}, a10 = null != r10.i ? r10.i : null != r10.f ? r10.f : n10;
        return "number" == typeof a10 ? a10 : parseInt(a10, 10);
      }
      function Wde(e10) {
        switch ("string" == typeof e10 && (e10 = rde[e10]), e10) {
          case rde.DT_FLOAT:
          case rde.DT_HALF:
            return "float32";
          case rde.DT_INT32:
          case rde.DT_INT64:
          case rde.DT_INT8:
          case rde.DT_UINT8:
            return "int32";
          case rde.DT_BOOL:
            return "bool";
          case rde.DT_DOUBLE:
            return "float32";
          case rde.DT_STRING:
            return "string";
          case rde.DT_COMPLEX64:
          case rde.DT_COMPLEX128:
            return "complex64";
          default:
            return null;
        }
      }
      function Ude(e10, t10, n10) {
        var r10 = e10[t10];
        return r10 && r10.func ? r10.func.name : n10;
      }
      function Vde(e10, t10, n10) {
        var r10 = e10[t10];
        return r10 && r10.type ? Wde(r10.type) : n10;
      }
      function Gde(e10, t10, n10) {
        var r10 = e10[t10];
        return r10 && r10.list && r10.list.type ? r10.list.type.map(function(e11) {
          return Wde(e11);
        }) : n10;
      }
      function jde(e10) {
        if (!e10.unknownRank) return null != e10.dim ? e10.dim.map(function(e11) {
          return "number" == typeof e11.size ? e11.size : parseInt(e11.size, 10);
        }) : [];
      }
      function Hde(e10, t10, n10) {
        var r10 = e10[t10];
        return r10 && r10.shape ? jde(r10.shape) : n10;
      }
      function qde(e10, t10, n10) {
        var r10 = e10[t10];
        return r10 ? ((r10.list.f && r10.list.f.length ? r10.list.f : r10.list.i) || []).map(function(e11) {
          return "number" == typeof e11 ? e11 : parseInt(e11, 10);
        }) : n10;
      }
      function Kde(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a10 = e10[t10];
        return a10 && a10.list && a10.list.s ? a10.list.s.map(function(e11) {
          return Lde(e11, r10);
        }) : n10;
      }
      function Xde(e10, t10, n10) {
        var r10 = e10[t10];
        return r10 && r10.list && r10.list.shape ? r10.list.shape.map(function(e11) {
          return jde(e11);
        }) : n10;
      }
      function Yde(e10, t10, n10) {
        var r10 = e10[t10];
        return r10 && r10.list && r10.list.b ? r10.list.b : n10;
      }
      var Jde = function() {
        function e10(t10, n10, r10) {
          var a10 = this;
          l(this, e10), this.node = t10, this.tensorMap = n10, this.context = r10, this.inputs = [], this.attrs = {}, this.inputs = t10.inputNames.map(function(e11) {
            return a10.getInput(e11);
          }), null != t10.rawAttrs && (this.attrs = Object.keys(t10.rawAttrs).reduce(function(e11, t11) {
            return e11[t11] = a10.getAttr(t11), e11;
          }, {}));
        }
        return p(e10, [{ key: "getInput", value: function(e11) {
          return cde(e11, this.tensorMap, this.context);
        } }, { key: "getAttr", value: function(e11, t10) {
          var n10 = this.node.rawAttrs[e11];
          if (null != n10.tensor) return cde(e11, this.tensorMap, this.context);
          if (null != n10.i || null != n10.f) return Bde(this.node.rawAttrs, e11, t10);
          if (null != n10.s) return zde(this.node.rawAttrs, e11, t10);
          if (null != n10.b) return Pde(this.node.rawAttrs, e11, t10);
          if (null != n10.shape) return Hde(this.node.rawAttrs, e11, t10);
          if (null != n10.type) return Vde(this.node.rawAttrs, e11, t10);
          if (null != n10.list) {
            if (null != n10.list.i || null != n10.list.f) return qde(this.node.rawAttrs, e11, t10);
            if (null != n10.list.s) return Kde(this.node.rawAttrs, e11, t10);
            if (null != n10.list.shape) return Xde(this.node.rawAttrs, e11, t10);
            if (null != n10.list.b) return Yde(this.node.rawAttrs, e11, t10);
            if (null != n10.list.type) return Gde(this.node.rawAttrs, e11, t10);
          }
          return t10;
        } }]), e10;
      }(), Zde = { __proto__: null, OP_SCOPE_SUFFIX: P5, abs: y8, acos: b8, acosh: x8, add: d8, addN: k8, all: w8, any: I8, argMax: N8, argMin: S8, asin: T8, asinh: E8, atan: C8, atan2: A8, atanh: R8, avgPool: Y8, avgPool3d: J8, basicLSTMCell: n7, batchNorm: a7, batchNorm2d: i7, batchNorm3d: o7, batchNorm4d: s7, batchToSpaceND: r7, bincount: u7, bitwiseAnd: c7, booleanMaskAsync: lne, broadcastArgs: l7, broadcastTo: h7, buffer: l8, cast: h8, ceil: p7, clipByValue: d7, clone: p8, complex: W5, concat: Z8, concat1d: v7, concat2d: m7, concat3d: g7, concat4d: y7, conv1d: x7, conv2d: b7, conv2dTranspose: w7, conv3d: I7, conv3dTranspose: S7, cos: T7, cosh: E7, cosineWindow: bne, cumprod: C7, cumsum: A7, denseBincount: R7, depthToSpace: _7, depthwiseConv2d: O7, diag: F7, dilation2d: D7, div: m8, divNoNan: V7, dot: G7, dropout: gne, einsum: j7, elu: H7, enclosingPowerOfTwo: yne, ensureShape: q7, equal: B7, erf: K7, euclideanNorm: h9, exp: p9, expandDims: f9, expm1: d9, eye: m9, fft: _te, fill: f7, floor: g9, floorDiv: v8, fused: One, gather: y9, gatherND: mne, greater: b9, greaterEqual: x9, ifft: Ote, imag: k9, image: Pre, inTopKAsync: kne, irfft: Fte, isFinite: w9, isInf: I9, isNaN: N9, leakyRelu: S9, less: T9, lessEqual: E9, linalg: Bre, linspace: C9, localResponseNormalization: A9, log: R9, log1p: _9, logSigmoid: z9, logSoftmax: B9, logSumExp: W9, logicalAnd: U9, logicalNot: V9, logicalOr: G9, logicalXor: j9, losses: Wre, lowerBound: K9, matMul: Q8, max: n9, maxPool: X9, maxPool3d: Y9, maxPoolWithArgmax: J9, maximum: Z9, mean: Q9, meshgrid: tee, min: r9, minimum: nee, mirrorPad: ree, mod: aee, moments: iee, movingAverage: pne, mul: g8, multiRNNCell: oee, multinomial: see, neg: M9, norm: l9, notEqual: uee, oneHot: cee, ones: eee, onesLike: lee, op: B5, outerProduct: hee, pad: pee, pad1d: fee, pad2d: dee, pad3d: vee, pad4d: mee, pool: yee, pow: a9, prelu: bee, print: f8, prod: xee, raggedGather: kee, raggedRange: wee, raggedTensorToTensor: Iee, rand: Nee, randomGamma: nte, randomNormal: rte, randomStandardNormal: ate, randomUniform: ite, randomUniformInt: ote, range: ste, real: ute, reciprocal: cte, relu: lte, relu6: hte, reshape: X8, reverse: pte, reverse1d: fte, reverse2d: dte, reverse3d: vte, reverse4d: mte, rfft: Mte, round: gte, rsqrt: yte, scalar: i9, scatterND: fne, searchSorted: q9, selu: bte, separableConv2d: xte, setdiff1dAsync: wte, sigmoid: $8, sign: Ite, signal: zre, sin: Nte, sinh: Ste, slice: e7, slice1d: Tte, slice2d: Ete, slice3d: Cte, slice4d: Ate, softmax: Rte, softplus: L9, spaceToBatchND: gee, sparse: Ure, sparseToDense: vne, spectral: Lre, split: Dte, sqrt: o9, square: s9, squaredDifference: Lte, squeeze: zte, stack: Pte, step: Bte, stridedSlice: Wte, string: Vre, sub: P9, sum: u9, tan: Ute, tanh: t7, tensor: V5, tensor1d: Vte, tensor2d: Gte, tensor3d: jte, tensor4d: Hte, tensor5d: qte, tensor6d: Kte, tensorScatterUpdate: Qte, tile: v9, topk: $te, transpose: hne, truncatedNormal: ene, unique: tne, unsortedSegmentSum: nne, unstack: rne, upperBound: ane, variable: ine, where: W7, whereAsync: une, zeros: $9, zerosLike: U7 }, Qde = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "BiasAdd":
          case "AddV2":
          case "Add":
            return [r10.add(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "AddN":
            return [r10.addN(ude("tensors", e10, t10, n10))];
          case "FloorMod":
          case "Mod":
            return [r10.mod(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "Mul":
            return [r10.mul(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "RealDiv":
          case "Div":
            return [r10.div(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "DivNoNan":
            return [r10.divNoNan(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "FloorDiv":
            return [r10.floorDiv(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "Sub":
            return [r10.sub(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "Minimum":
            return [r10.minimum(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "Maximum":
            return [r10.maximum(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "Pow":
            return [r10.pow(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "SquaredDifference":
            return [r10.squaredDifference(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      }, $de = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "Abs":
          case "ComplexAbs":
            return [r10.abs(ude("x", e10, t10, n10))];
          case "Acos":
            return [r10.acos(ude("x", e10, t10, n10))];
          case "Acosh":
            return [r10.acosh(ude("x", e10, t10, n10))];
          case "Asin":
            return [r10.asin(ude("x", e10, t10, n10))];
          case "Asinh":
            return [r10.asinh(ude("x", e10, t10, n10))];
          case "Atan":
            return [r10.atan(ude("x", e10, t10, n10))];
          case "Atan2":
            return [r10.atan2(ude("x", e10, t10, n10), ude("y", e10, t10, n10))];
          case "Atanh":
            return [r10.atanh(ude("x", e10, t10, n10))];
          case "Ceil":
            return [r10.ceil(ude("x", e10, t10, n10))];
          case "Complex":
            return [r10.complex(ude("real", e10, t10, n10), ude("imag", e10, t10, n10))];
          case "Cos":
            return [r10.cos(ude("x", e10, t10, n10))];
          case "Cosh":
            return [r10.cosh(ude("x", e10, t10, n10))];
          case "Elu":
            return [r10.elu(ude("x", e10, t10, n10))];
          case "Erf":
            return [r10.erf(ude("x", e10, t10, n10))];
          case "Exp":
            return [r10.exp(ude("x", e10, t10, n10))];
          case "Expm1":
            return [r10.expm1(ude("x", e10, t10, n10))];
          case "Floor":
            return [r10.floor(ude("x", e10, t10, n10))];
          case "Log":
            return [r10.log(ude("x", e10, t10, n10))];
          case "Log1p":
            return [r10.log1p(ude("x", e10, t10, n10))];
          case "Imag":
            return [r10.imag(ude("x", e10, t10, n10))];
          case "Neg":
            return [r10.neg(ude("x", e10, t10, n10))];
          case "Reciprocal":
            return [r10.reciprocal(ude("x", e10, t10, n10))];
          case "Real":
            return [r10.real(ude("x", e10, t10, n10))];
          case "Relu":
            return [r10.relu(ude("x", e10, t10, n10))];
          case "Round":
            return [r10.round(ude("x", e10, t10, n10))];
          case "Selu":
            return [r10.selu(ude("x", e10, t10, n10))];
          case "Sigmoid":
            return [r10.sigmoid(ude("x", e10, t10, n10))];
          case "Sin":
            return [r10.sin(ude("x", e10, t10, n10))];
          case "Sign":
            return [r10.sign(ude("x", e10, t10, n10))];
          case "Sinh":
            return [r10.sinh(ude("x", e10, t10, n10))];
          case "Softplus":
            return [r10.softplus(ude("x", e10, t10, n10))];
          case "Sqrt":
            return [r10.sqrt(ude("x", e10, t10, n10))];
          case "Square":
            return [r10.square(ude("x", e10, t10, n10))];
          case "Tanh":
            return [r10.tanh(ude("x", e10, t10, n10))];
          case "Tan":
            return [r10.tan(ude("x", e10, t10, n10))];
          case "ClipByValue":
            return [r10.clipByValue(ude("x", e10, t10, n10), ude("clipValueMin", e10, t10, n10), ude("clipValueMax", e10, t10, n10))];
          case "Relu6":
            return [r10.relu6(ude("x", e10, t10, n10))];
          case "Rsqrt":
            return [r10.rsqrt(cde(e10.inputNames[0], t10, n10))];
          case "LeakyRelu":
            return [r10.leakyRelu(ude("x", e10, t10, n10), ude("alpha", e10, t10, n10))];
          case "Prelu":
            return [r10.prelu(ude("x", e10, t10, n10), ude("alpha", e10, t10, n10))];
          case "IsNan":
            return [r10.isNaN(cde(e10.inputNames[0], t10, n10))];
          case "IsInf":
            return [r10.isInf(cde(e10.inputNames[0], t10, n10))];
          case "IsFinite":
            return [r10.isFinite(cde(e10.inputNames[0], t10, n10))];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      };
      function eve(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
        if ("number" != typeof e10 && "number" != typeof t10) {
          F$(e10.length === t10.length, function() {
            return n10 + " Shapes ".concat(e10, " and ").concat(t10, " must match");
          });
          for (var r10 = 0; r10 < e10.length; r10++) {
            var a10 = e10[r10], i10 = t10[r10];
            F$(a10 < 0 || i10 < 0 || a10 === i10, function() {
              return n10 + " Shapes ".concat(e10, " and ").concat(t10, " must match");
            });
          }
        }
      }
      function tve(e10) {
        return "number" != typeof e10 && !e10.some(function(e11) {
          return e11 < 0;
        });
      }
      function nve(e10, t10, n10) {
        var r10 = rve(e10, n10), a10 = !tve(r10);
        if (a10 && 0 === t10.length) throw new Error("Tried to calculate elements of an empty list" + " with non-fully-defined elementShape: ".concat(r10));
        if (a10 && t10.forEach(function(e11) {
          r10 = rve(e11.shape, r10);
        }), !tve(r10)) throw new Error("Non-fully-defined elementShape: ".concat(r10));
        return r10;
      }
      function rve(e10, t10) {
        if ("number" == typeof e10) return t10;
        if ("number" == typeof t10) return e10;
        if (e10.length !== t10.length) throw new Error("Incompatible ranks during merge: ".concat(e10, " vs. ").concat(t10));
        for (var n10 = [], r10 = 0; r10 < e10.length; ++r10) {
          var a10 = e10[r10], i10 = t10[r10];
          if (a10 >= 0 && i10 >= 0 && a10 !== i10) throw new Error("Incompatible shape during merge: ".concat(e10, " vs. ").concat(t10));
          n10[r10] = a10 >= 0 ? a10 : i10;
        }
        return n10;
      }
      var ave = function() {
        function e10(t10, n10, r10, a10, i10, o10, s10) {
          l(this, e10), this.name = t10, this.dtype = n10, this.maxSize = r10, this.elementShape = a10, this.identicalElementShapes = i10, this.dynamicSize = o10, this.clearAfterRead = s10, this.tensors = [], this.closed_ = false, this.idTensor = i9(0), J5(this.idTensor);
        }
        return p(e10, [{ key: "id", get: function() {
          return this.idTensor.id;
        } }, { key: "closed", get: function() {
          return this.closed_;
        } }, { key: "clearAndClose", value: function(e11) {
          this.tensors.forEach(function(t10) {
            null != e11 && e11.has(t10.tensor.id) || t10.tensor.dispose();
          }), this.tensors = [], this.closed_ = true, this.idTensor.dispose();
        } }, { key: "size", value: function() {
          return this.tensors.length;
        } }, { key: "read", value: function(e11) {
          if (this.closed_) throw new Error("TensorArray ".concat(this.name, " has already been closed."));
          if (e11 < 0 || e11 >= this.size()) throw new Error("Tried to read from index ".concat(e11, ", but array size is: ").concat(this.size()));
          var t10 = this.tensors[e11];
          if (t10.cleared) throw new Error("TensorArray ".concat(this.name, ": Could not read index ").concat(e11, " twice because it was cleared after a previous read ") + "(perhaps try setting clear_after_read = false?).");
          return this.clearAfterRead && (t10.cleared = true), t10.read = true, t10.tensor;
        } }, { key: "readMany", value: function(e11) {
          var t10 = this;
          return e11.map(function(e12) {
            return t10.read(e12);
          });
        } }, { key: "write", value: function(e11, t10) {
          if (this.closed_) throw new Error("TensorArray ".concat(this.name, " has already been closed."));
          if (e11 < 0 || !this.dynamicSize && e11 >= this.maxSize) throw new Error("Tried to write to index ".concat(e11, ", but array is not resizeable and size is: ").concat(this.maxSize));
          var n10 = this.tensors[e11] || {};
          if (t10.dtype !== this.dtype) throw new Error("TensorArray ".concat(this.name, ": Could not write to TensorArray index ").concat(e11, ",\n          because the value dtype is ").concat(t10.dtype, ", but TensorArray dtype is ").concat(this.dtype, "."));
          if (0 !== this.size() || null != this.elementShape && 0 !== this.elementShape.length || (this.elementShape = t10.shape), eve(this.elementShape, t10.shape, "TensorArray ".concat(this.name, ": Could not write to TensorArray index ").concat(e11, ".")), n10.read) throw new Error("TensorArray ".concat(this.name, ": Could not write to TensorArray index ").concat(e11, ", because it has already been read."));
          if (n10.written) throw new Error("TensorArray ".concat(this.name, ": Could not write to TensorArray index ").concat(e11, ", because it has already been written."));
          n10.tensor = t10, J5(t10), n10.written = true, this.tensors[e11] = n10;
        } }, { key: "writeMany", value: function(e11, t10) {
          var n10 = this;
          if (e11.length !== t10.length) throw new Error("TensorArray ".concat(this.name, ": could not write multiple tensors,") + "because the index size: ".concat(e11.length, " is not the same as tensors size: ").concat(t10.length, "."));
          e11.forEach(function(e12, r10) {
            return n10.write(e12, t10[r10]);
          });
        } }, { key: "gather", value: function(e11, t10) {
          if (t10 && t10 !== this.dtype) throw new Error("TensorArray dtype is ".concat(this.dtype, " but gather requested dtype ").concat(t10));
          if (e11) e11 = e11.slice(0, this.size());
          else {
            e11 = [];
            for (var n10 = 0; n10 < this.size(); n10++) e11.push(n10);
          }
          if (0 === e11.length) return V5([], [0].concat(this.elementShape));
          var r10 = this.readMany(e11);
          return eve(this.elementShape, r10[0].shape, "TensorArray shape mismatch: "), Pte(r10, 0);
        } }, { key: "concat", value: function(e11) {
          if (e11 && e11 !== this.dtype) throw new Error("TensorArray dtype is ".concat(this.dtype, " but concat requested dtype ").concat(e11));
          if (0 === this.size()) return V5([], [0].concat(this.elementShape));
          for (var t10 = [], n10 = 0; n10 < this.size(); n10++) t10.push(n10);
          var r10 = this.readMany(t10);
          return eve(this.elementShape, r10[0].shape, "TensorArray shape mismatch: tensor array shape (".concat(this.elementShape, ") vs first tensor shape (").concat(r10[0].shape, ")")), Z8(r10, 0);
        } }, { key: "scatter", value: function(e11, t10) {
          if (t10.dtype !== this.dtype) throw new Error("TensorArray dtype is ".concat(this.dtype, " but tensor has dtype ").concat(t10.dtype));
          if (e11.length !== t10.shape[0]) throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(e11.length, " vs. ").concat(t10.shape[0]));
          var n10 = Math.max.apply(Math, T(e11));
          if (!this.dynamicSize && n10 >= this.maxSize) throw new Error("Max index must be < array size (".concat(n10, "  vs. ").concat(this.maxSize, ")"));
          this.writeMany(e11, rne(t10, 0));
        } }, { key: "split", value: function(e11, t10) {
          var n10 = this;
          if (t10.dtype !== this.dtype) throw new Error("TensorArray dtype is ".concat(this.dtype, " but tensor has dtype ").concat(t10.dtype));
          var r10 = 0, a10 = e11.map(function(e12) {
            return r10 += e12;
          });
          if (r10 !== t10.shape[0]) throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(r10, ", and tensor's shape is: ").concat(t10.shape));
          if (!this.dynamicSize && e11.length !== this.maxSize) throw new Error("TensorArray's size is not equal to the size of lengths (".concat(this.maxSize, " vs. ").concat(e11.length, "), ") + "and the TensorArray is not marked as dynamically resizeable");
          var i10 = 0 === r10 ? 0 : t10.size / r10, o10 = [];
          X5(function() {
            t10 = X8(t10, [1, r10, i10]);
            for (var s11 = 0; s11 < e11.length; ++s11) {
              var u11 = [0, 0 === s11 ? 0 : a10[s11 - 1], 0], c10 = [1, e11[s11], i10];
              o10[s11] = X8(e7(t10, u11, c10), n10.elementShape);
            }
            return o10;
          });
          for (var s10 = [], u10 = 0; u10 < e11.length; u10++) s10[u10] = u10;
          this.writeMany(s10, o10);
        } }]), e10;
      }(), ive = function() {
        function e10(t10, n10, r10) {
          var a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1;
          l(this, e10), this.tensors = t10, this.elementShape = n10, this.elementDtype = r10, null != t10 && t10.forEach(function(e11) {
            if (r10 !== e11.dtype) throw new Error("Invalid data types; op elements ".concat(r10, ", but list elements ").concat(e11.dtype));
            eve(n10, e11.shape, "TensorList shape mismatch: "), J5(e11);
          }), this.idTensor = i9(0), this.maxNumElements = a10, J5(this.idTensor);
        }
        return p(e10, [{ key: "id", get: function() {
          return this.idTensor.id;
        } }, { key: "copy", value: function() {
          return new e10(T(this.tensors), this.elementShape, this.elementDtype);
        } }, { key: "clearAndClose", value: function(e11) {
          this.tensors.forEach(function(t10) {
            null != e11 && e11.has(t10.id) || t10.dispose();
          }), this.tensors.length = 0, this.idTensor.dispose();
        } }, { key: "size", value: function() {
          return this.tensors.length;
        } }, { key: "stack", value: function(e11, t10) {
          var n10 = this, r10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1;
          if (t10 !== this.elementDtype) throw new Error("Invalid data types; op elements ".concat(t10, ", but list elements ").concat(this.elementDtype));
          if (-1 !== r10 && this.tensors.length !== r10) throw new Error("Operation expected a list with ".concat(r10, " elements but got a list with ").concat(this.tensors.length, " elements."));
          eve(e11, this.elementShape, "TensorList shape mismatch: ");
          var a10 = nve(this.elementShape, this.tensors, e11);
          return X5(function() {
            var e12 = n10.tensors.map(function(e13) {
              return X8(e13, a10);
            });
            return Pte(e12, 0);
          });
        } }, { key: "popBack", value: function(e11, t10) {
          if (t10 !== this.elementDtype) throw new Error("Invalid data types; op elements ".concat(t10, ", but list elements ").concat(this.elementDtype));
          if (0 === this.size()) throw new Error("Trying to pop from an empty list.");
          var n10 = nve(this.elementShape, this.tensors, e11), r10 = this.tensors.pop();
          return r10.kept = false, eve(r10.shape, e11, "TensorList shape mismatch: "), X8(r10, n10);
        } }, { key: "pushBack", value: function(e11) {
          if (e11.dtype !== this.elementDtype) throw new Error("Invalid data types; op elements ".concat(e11.dtype, ", but list elements ").concat(this.elementDtype));
          if (eve(e11.shape, this.elementShape, "TensorList shape mismatch: "), this.maxNumElements === this.size()) throw new Error("Trying to push element into a full list.");
          J5(e11), this.tensors.push(e11);
        } }, { key: "resize", value: function(t10) {
          if (t10 < 0) throw new Error("TensorListResize expects size to be non-negative. Got: ".concat(t10));
          if (-1 !== this.maxNumElements && t10 > this.maxNumElements) throw new Error("TensorListResize input size ".concat(t10, " is greater maxNumElement ").concat(this.maxNumElements, "."));
          var n10 = new e10([], this.elementShape, this.elementDtype, this.maxNumElements);
          n10.tensors.length = t10;
          for (var r10 = 0; r10 < Math.min(this.tensors.length, t10); ++r10) n10.tensors[r10] = this.tensors[r10];
          return n10;
        } }, { key: "getItem", value: function(e11, t10, n10) {
          if (n10 !== this.elementDtype) throw new Error("Invalid data types; op elements ".concat(n10, ", but list elements ").concat(this.elementDtype));
          if (e11 < 0 || e11 > this.tensors.length) throw new Error("Trying to access element ".concat(e11, " in a list with ").concat(this.tensors.length, " elements."));
          if (null == this.tensors[e11]) throw new Error("element at index ".concat(e11, " is null."));
          eve(this.tensors[e11].shape, t10, "TensorList shape mismatch: ");
          var r10 = nve(this.elementShape, this.tensors, t10);
          return X8(this.tensors[e11], r10);
        } }, { key: "setItem", value: function(e11, t10) {
          if (t10.dtype !== this.elementDtype) throw new Error("Invalid data types; op elements ".concat(t10.dtype, ", but list elements ").concat(this.elementDtype));
          if (e11 < 0 || -1 !== this.maxNumElements && e11 >= this.maxNumElements) throw new Error("Trying to set element ".concat(e11, " in a list with max ").concat(this.maxNumElements, " elements."));
          eve(this.elementShape, t10.shape, "TensorList shape mismatch: "), J5(t10), null != this.tensors[e11] && (this.tensors[e11].kept = false), this.tensors[e11] = t10;
        } }, { key: "gather", value: function(e11, t10, n10) {
          var r10 = this;
          if (t10 !== this.elementDtype) throw new Error("Invalid data types; op elements ".concat(t10, ", but list elements ").concat(this.elementDtype));
          eve(this.elementShape, n10, "TensorList shape mismatch: "), e11 = e11.slice(0, this.size());
          var a10 = nve(this.elementShape, this.tensors, n10);
          return 0 === e11.length ? V5([], [0].concat(a10)) : X5(function() {
            var t11 = e11.map(function(e12) {
              return X8(r10.tensors[e12], a10);
            });
            return Pte(t11, 0);
          });
        } }, { key: "concat", value: function(e11, t10) {
          var n10 = this;
          if (e11 && e11 !== this.elementDtype) throw new Error("TensorList dtype is ".concat(this.elementDtype, " but concat requested dtype ").concat(e11));
          eve(this.elementShape, t10, "TensorList shape mismatch: ");
          var r10 = nve(this.elementShape, this.tensors, t10);
          return 0 === this.size() ? V5([], [0].concat(r10)) : X5(function() {
            var e12 = n10.tensors.map(function(e13) {
              return X8(e13, r10);
            });
            return Z8(e12, 0);
          });
        } }]), e10;
      }();
      function ove(e10, t10, n10) {
        var r10 = e10.dtype;
        if (e10.shape.length < 1) throw new Error("Tensor must be at least a vector, but saw shape: ".concat(e10.shape));
        if (e10.dtype !== n10) throw new Error("Invalid data types; op elements ".concat(e10.dtype, ", but list elements ").concat(n10));
        eve(e10.shape.slice(1), t10, "TensorList shape mismatch: ");
        var a10 = rne(e10);
        return new ive(a10, t10, r10);
      }
      function sve(e10, t10, n10, r10) {
        return new ive([], e10, t10, r10);
      }
      function uve(e10, t10, n10, r10) {
        if (t10.length !== e10.shape[0]) throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(t10.length, " vs. ").concat(e10.shape[0]));
        var a10 = Math.max.apply(Math, T(t10));
        if (null != r10 && -1 !== r10 && a10 >= r10) throw new Error("Max index must be < array size (".concat(a10, "  vs. ").concat(r10, ")"));
        var i10 = new ive([], n10, e10.dtype, r10), o10 = rne(e10, 0);
        return t10.forEach(function(e11, t11) {
          i10.setItem(e11, o10[t11]);
        }), i10;
      }
      function cve(e10, t10, n10) {
        var r10 = 0, a10 = t10.map(function(e11) {
          return r10 += e11;
        });
        if (r10 !== e10.shape[0]) throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(r10, ", and tensor's shape is: ").concat(e10.shape));
        for (var i10 = rve(e10.shape.slice(1), n10), o10 = 0 === r10 ? 0 : e10.size / r10, s10 = X5(function() {
          var n11 = [];
          e10 = X8(e10, [1, r10, o10]);
          for (var s11 = 0; s11 < t10.length; ++s11) {
            var u11 = [0, 0 === s11 ? 0 : a10[s11 - 1], 0], c11 = [1, t10[s11], o10];
            n11[s11] = X8(e7(e10, u11, c11), i10);
          }
          return e10.dispose(), n11;
        }), u10 = new ive([], n10, e10.dtype, t10.length), c10 = 0; c10 < s10.length; c10++) u10.setItem(c10, s10[c10]);
        return u10;
      }
      var lve = function() {
        var e10 = c(o().mark(function e11(t10, n10, r10) {
          var a10, i10, s10, u10, c10, l10, h10, p10, f10, d10, v10, m10, g10, y10, b10, x10, k10, w10, I10, N10, S10, T10, E10, C10, A10, R10, _10, O10, F10, D10, M10, L10, z10, P10, B10, W10, U10, V10, G10, j10, H10, q10, K10, X10, Y10, J10, Z10, Q10, $10, ee2, te2, ne2, re2, ae2, ie2, oe2, se2, ue2, ce2, le2, he2, pe2, fe2, de2, ve2, me2, ge2, ye2, be2, xe2, ke2, we2, Ie2, Ne2, Se2, Te2, Ee2, Ce2, Ae2, Re2, _e2, Oe2, Fe2, De2, Me2, Le2, ze2, Pe2, Be2, We2, Ue2, Ve2, Ge2, je2, He2, qe2, Ke2, Xe2, Ye2, Je2, Ze2, Qe2, $e2, et2, tt2, nt2, rt2, at2, it2, ot2;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                e12.t0 = t10.op, e12.next = "If" === e12.t0 || "StatelessIf" === e12.t0 ? 3 : "While" === e12.t0 || "StatelessWhile" === e12.t0 ? 15 : "LoopCond" === e12.t0 ? 33 : "Switch" === e12.t0 ? 35 : "Merge" === e12.t0 ? 46 : "Enter" === e12.t0 ? 51 : "Exit" === e12.t0 ? 55 : "NextIteration" === e12.t0 ? 58 : "TensorArrayV3" === e12.t0 ? 61 : "TensorArrayWriteV3" === e12.t0 ? 71 : "TensorArrayReadV3" === e12.t0 ? 77 : "TensorArrayGatherV3" === e12.t0 ? 81 : "TensorArrayScatterV3" === e12.t0 ? 86 : "TensorArrayConcatV3" === e12.t0 ? 92 : "TensorArraySplitV3" === e12.t0 ? 96 : "TensorArraySizeV3" === e12.t0 ? 102 : "TensorArrayCloseV3" === e12.t0 ? 105 : "TensorListSetItem" === e12.t0 ? 109 : "TensorListGetItem" === e12.t0 ? 115 : "TensorListScatterV2" === e12.t0 || "TensorListScatter" === e12.t0 ? 121 : "TensorListReserve" === e12.t0 || "EmptyTensorList" === e12.t0 ? 128 : "TensorListGather" === e12.t0 ? 136 : "TensorListStack" === e12.t0 ? 142 : "TensorListFromTensor" === e12.t0 ? 148 : "TensorListConcat" === e12.t0 || "TensorListConcatV2" === e12.t0 ? 154 : "TensorListPushBack" === e12.t0 ? 159 : "TensorListPopBack" === e12.t0 ? 164 : "TensorListSplit" === e12.t0 ? 169 : "TensorListLength" === e12.t0 ? 175 : "TensorListResize" === e12.t0 ? 178 : 184;
                break;
              case 3:
                return a10 = ude("thenBranch", t10, n10, r10), i10 = ude("elseBranch", t10, n10, r10), s10 = ude("cond", t10, n10, r10), u10 = ude("args", t10, n10, r10), e12.next = 9, s10.data();
              case 9:
                if (!e12.sent[0]) {
                  e12.next = 14;
                  break;
                }
                return e12.abrupt("return", r10.functionMap[a10].executeFunctionAsync(u10, r10.tensorArrayMap, r10.tensorListMap));
              case 14:
                return e12.abrupt("return", r10.functionMap[i10].executeFunctionAsync(u10, r10.tensorArrayMap, r10.tensorListMap));
              case 15:
                return c10 = ude("body", t10, n10, r10), l10 = ude("cond", t10, n10, r10), h10 = ude("args", t10, n10, r10), e12.next = 20, r10.functionMap[l10].executeFunctionAsync(h10, r10.tensorArrayMap, r10.tensorListMap);
              case 20:
                return p10 = e12.sent, f10 = h10.map(function(e13) {
                  return e13.id;
                }), e12.next = 24, p10[0].data();
              case 24:
                d10 = e12.sent, p10.forEach(function(e13) {
                  e13.kept || -1 !== f10.indexOf(e13.id) || e13.dispose();
                }), v10 = h10, m10 = o().mark(function e13() {
                  var t11, n11, a11;
                  return o().wrap(function(e14) {
                    for (; ; ) switch (e14.prev = e14.next) {
                      case 0:
                        return t11 = v10, e14.next = 3, r10.functionMap[c10].executeFunctionAsync(v10, r10.tensorArrayMap, r10.tensorListMap);
                      case 3:
                        return v10 = e14.sent, n11 = v10.map(function(e15) {
                          return e15.id;
                        }), t11.forEach(function(e15) {
                          e15.kept || -1 !== f10.indexOf(e15.id) || -1 !== n11.indexOf(e15.id) || e15.dispose();
                        }), e14.next = 8, r10.functionMap[l10].executeFunctionAsync(v10, r10.tensorArrayMap, r10.tensorListMap);
                      case 8:
                        return a11 = e14.sent, e14.next = 11, a11[0].data();
                      case 11:
                        d10 = e14.sent, a11.forEach(function(e15) {
                          e15.kept || -1 !== f10.indexOf(e15.id) || -1 !== n11.indexOf(e15.id) || e15.dispose();
                        });
                      case 13:
                      case "end":
                        return e14.stop();
                    }
                  }, e13);
                });
              case 28:
                if (!d10[0]) {
                  e12.next = 32;
                  break;
                }
                return e12.delegateYield(m10(), "t1", 30);
              case 30:
                e12.next = 28;
                break;
              case 32:
                return e12.abrupt("return", v10);
              case 33:
                return g10 = ude("pred", t10, n10, r10), e12.abrupt("return", [vde(g10)]);
              case 35:
                return y10 = ude("pred", t10, n10, r10), (b10 = ude("data", t10, n10, r10)).kept || (b10 = vde(b10)), e12.next = 40, y10.data();
              case 40:
                if (!e12.sent[0]) {
                  e12.next = 44;
                  break;
                }
                e12.t2 = [void 0, b10], e12.next = 45;
                break;
              case 44:
                e12.t2 = [b10, void 0];
              case 45:
                return e12.abrupt("return", e12.t2);
              case 46:
                if (x10 = t10.inputNames.find(function(e13) {
                  return void 0 !== cde(e13, n10, r10);
                }), !x10) {
                  e12.next = 50;
                  break;
                }
                return k10 = cde(x10, n10, r10), e12.abrupt("return", [vde(k10)]);
              case 50:
                return e12.abrupt("return", void 0);
              case 51:
                return w10 = ude("frameName", t10, n10, r10), I10 = ude("tensor", t10, n10, r10), r10.enterFrame(w10), e12.abrupt("return", [vde(I10)]);
              case 55:
                return N10 = ude("tensor", t10, n10, r10), r10.exitFrame(), e12.abrupt("return", [vde(N10)]);
              case 58:
                return S10 = ude("tensor", t10, n10, r10), r10.nextIteration(), e12.abrupt("return", [vde(S10)]);
              case 61:
                return T10 = ude("size", t10, n10, r10), E10 = ude("dtype", t10, n10, r10), C10 = ude("elementShape", t10, n10, r10), A10 = ude("dynamicSize", t10, n10, r10), R10 = ude("clearAfterRead", t10, n10, r10), _10 = ude("identicalElementShapes", t10, n10, r10), O10 = ude("name", t10, n10, r10), F10 = new ave(O10, E10, T10, C10, _10, A10, R10), r10.addTensorArray(F10), e12.abrupt("return", [F10.idTensor, i9(1)]);
              case 71:
                return D10 = ude("tensorArrayId", t10, n10, r10), M10 = ude("index", t10, n10, r10), L10 = ude("tensor", t10, n10, r10), (z10 = r10.getTensorArray(D10.id)).write(M10, L10), e12.abrupt("return", [z10.idTensor]);
              case 77:
                return P10 = ude("tensorArrayId", t10, n10, r10), B10 = ude("index", t10, n10, r10), W10 = r10.getTensorArray(P10.id), e12.abrupt("return", [W10.read(B10)]);
              case 81:
                return U10 = ude("tensorArrayId", t10, n10, r10), V10 = ude("indices", t10, n10, r10), G10 = ude("dtype", t10, n10, r10), j10 = r10.getTensorArray(U10.id), e12.abrupt("return", [j10.gather(V10, G10)]);
              case 86:
                return H10 = ude("tensorArrayId", t10, n10, r10), q10 = ude("indices", t10, n10, r10), K10 = ude("tensor", t10, n10, r10), (X10 = r10.getTensorArray(H10.id)).scatter(q10, K10), e12.abrupt("return", [X10.idTensor]);
              case 92:
                return Y10 = ude("tensorArrayId", t10, n10, r10), J10 = r10.getTensorArray(Y10.id), Z10 = ude("dtype", t10, n10, r10), e12.abrupt("return", [J10.concat(Z10)]);
              case 96:
                return Q10 = ude("tensorArrayId", t10, n10, r10), $10 = ude("tensor", t10, n10, r10), ee2 = ude("lengths", t10, n10, r10), (te2 = r10.getTensorArray(Q10.id)).split(ee2, $10), e12.abrupt("return", [te2.idTensor]);
              case 102:
                return ne2 = ude("tensorArrayId", t10, n10, r10), re2 = r10.getTensorArray(ne2.id), e12.abrupt("return", [i9(re2.size(), "int32")]);
              case 105:
                return ae2 = ude("tensorArrayId", t10, n10, r10), (ie2 = r10.getTensorArray(ae2.id)).clearAndClose(), e12.abrupt("return", [ie2.idTensor]);
              case 109:
                return oe2 = ude("tensorListId", t10, n10, r10), se2 = ude("index", t10, n10, r10), ue2 = ude("tensor", t10, n10, r10), (ce2 = r10.getTensorList(oe2.id)).setItem(se2, ue2), e12.abrupt("return", [ce2.idTensor]);
              case 115:
                return le2 = ude("tensorListId", t10, n10, r10), he2 = ude("index", t10, n10, r10), pe2 = ude("elementShape", t10, n10, r10), fe2 = ude("elementDType", t10, n10, r10), de2 = r10.getTensorList(le2.id), e12.abrupt("return", [de2.getItem(he2, pe2, fe2)]);
              case 121:
                return ve2 = ude("indices", t10, n10, r10), me2 = ude("tensor", t10, n10, r10), ge2 = ude("elementShape", t10, n10, r10), ye2 = ude("numElements", t10, n10, r10), be2 = uve(me2, ve2, ge2, ye2), r10.addTensorList(be2), e12.abrupt("return", [be2.idTensor]);
              case 128:
                return xe2 = ude("elementShape", t10, n10, r10), ke2 = ude("elementDType", t10, n10, r10), we2 = "TensorListReserve" === t10.op ? "numElements" : "maxNumElements", Ie2 = ude(we2, t10, n10, r10), Ne2 = "TensorListReserve" === t10.op ? -1 : Ie2, Se2 = sve(xe2, ke2, 0, Ne2), r10.addTensorList(Se2), e12.abrupt("return", [Se2.idTensor]);
              case 136:
                return Te2 = ude("tensorListId", t10, n10, r10), Ee2 = ude("indices", t10, n10, r10), Ce2 = ude("elementShape", t10, n10, r10), Ae2 = ude("elementDType", t10, n10, r10), Re2 = r10.getTensorList(Te2.id), e12.abrupt("return", [Re2.gather(Ee2, Ae2, Ce2)]);
              case 142:
                return _e2 = ude("tensorListId", t10, n10, r10), Oe2 = ude("elementShape", t10, n10, r10), Fe2 = ude("elementDType", t10, n10, r10), De2 = ude("numElements", t10, n10, r10), Me2 = r10.getTensorList(_e2.id), e12.abrupt("return", [Me2.stack(Oe2, Fe2, De2)]);
              case 148:
                return Le2 = ude("tensor", t10, n10, r10), ze2 = ude("elementShape", t10, n10, r10), Pe2 = ude("elementDType", t10, n10, r10), Be2 = ove(Le2, ze2, Pe2), r10.addTensorList(Be2), e12.abrupt("return", [Be2.idTensor]);
              case 154:
                return We2 = ude("tensorListId", t10, n10, r10), Ue2 = r10.getTensorList(We2.id), Ve2 = ude("dtype", t10, n10, r10), Ge2 = ude("elementShape", t10, n10, r10), e12.abrupt("return", [Ue2.concat(Ve2, Ge2)]);
              case 159:
                return je2 = ude("tensorListId", t10, n10, r10), He2 = ude("tensor", t10, n10, r10), (qe2 = r10.getTensorList(je2.id)).pushBack(He2), e12.abrupt("return", [qe2.idTensor]);
              case 164:
                return Ke2 = ude("tensorListId", t10, n10, r10), Xe2 = ude("elementShape", t10, n10, r10), Ye2 = ude("elementDType", t10, n10, r10), Je2 = r10.getTensorList(Ke2.id), e12.abrupt("return", [Je2.popBack(Xe2, Ye2)]);
              case 169:
                return Ze2 = ude("tensor", t10, n10, r10), Qe2 = ude("elementShape", t10, n10, r10), $e2 = ude("lengths", t10, n10, r10), et2 = cve(Ze2, $e2, Qe2), r10.addTensorList(et2), e12.abrupt("return", [et2.idTensor]);
              case 175:
                return tt2 = ude("tensorListId", t10, n10, r10), nt2 = r10.getTensorList(tt2.id), e12.abrupt("return", [i9(nt2.size(), "int32")]);
              case 178:
                return rt2 = ude("tensorListId", t10, n10, r10), at2 = ude("size", t10, n10, r10), it2 = r10.getTensorList(rt2.id), ot2 = it2.resize(at2), r10.addTensorList(ot2), e12.abrupt("return", [ot2.idTensor]);
              case 184:
                throw TypeError("Node type ".concat(t10.op, " is not implemented"));
              case 185:
              case "end":
                return e12.stop();
            }
          }, e11);
        }));
        return function(t10, n10, r10) {
          return e10.apply(this, arguments);
        };
      }();
      function hve(e10, t10, n10) {
        var r10 = S(ude("fusedOps", e10, t10, n10), 2), a10 = r10[0], i10 = r10[1], o10 = "biasadd" === a10, s10 = !o10, u10 = "prelu" === i10, c10 = "fusedbatchnorm" === a10, l10 = ude("numArgs", e10, t10, n10);
        if (o10) {
          if (u10 && 2 !== l10) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
          if (!u10 && o10 && 1 !== l10) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
        }
        if (c10) throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
        var h10 = ude("strides", e10, t10, n10), p10 = dde(e10, t10, n10), f10 = ude("dataFormat", e10, t10, n10).toUpperCase(), d10 = ude("dilations", e10, t10, n10), v10 = S(ude("args", e10, t10, n10), 2), m10 = v10[0], g10 = v10[1];
        return s10 && (g10 = m10, m10 = void 0), { stride: h10, pad: p10, dataFormat: f10, dilations: d10, biasArg: m10, preluArg: g10, activationFunc: i10, leakyreluAlpha: ude("leakyreluAlpha", e10, t10, n10) };
      }
      var pve = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "Conv1D":
            var a10 = ude("stride", e10, t10, n10), i10 = ude("pad", e10, t10, n10), o10 = ude("dataFormat", e10, t10, n10).toUpperCase(), s10 = ude("dilation", e10, t10, n10);
            return [r10.conv1d(ude("x", e10, t10, n10), ude("filter", e10, t10, n10), a10, i10, o10, s10)];
          case "Conv2D":
            var u10 = ude("strides", e10, t10, n10), c10 = dde(e10, t10, n10), l10 = ude("dataFormat", e10, t10, n10).toUpperCase(), h10 = ude("dilations", e10, t10, n10);
            return [r10.conv2d(ude("x", e10, t10, n10), ude("filter", e10, t10, n10), [u10[1], u10[2]], c10, l10, [h10[1], h10[2]])];
          case "_FusedConv2D":
            var p10 = hve(e10, t10, n10), f10 = p10.stride, d10 = p10.pad, v10 = p10.dataFormat, m10 = p10.dilations, g10 = p10.biasArg, y10 = p10.preluArg, b10 = p10.activationFunc, x10 = p10.leakyreluAlpha;
            return [r10.fused.conv2d({ x: ude("x", e10, t10, n10), filter: ude("filter", e10, t10, n10), strides: [f10[1], f10[2]], pad: d10, dataFormat: v10, dilations: [m10[1], m10[2]], bias: g10, activation: b10, preluActivationWeights: y10, leakyreluAlpha: x10 })];
          case "FusedDepthwiseConv2dNative":
            var k10 = hve(e10, t10, n10), w10 = k10.stride, I10 = k10.pad, N10 = k10.dataFormat, S10 = k10.dilations, T10 = k10.biasArg, E10 = k10.preluArg, C10 = k10.activationFunc, A10 = k10.leakyreluAlpha;
            return [r10.fused.depthwiseConv2d({ x: ude("x", e10, t10, n10), filter: ude("filter", e10, t10, n10), strides: [w10[1], w10[2]], pad: I10, dataFormat: N10, dilations: [S10[1], S10[2]], bias: T10, activation: C10, preluActivationWeights: E10, leakyreluAlpha: A10 })];
          case "Conv2DBackpropInput":
          case "Conv2dTranspose":
            var R10 = ude("outputShape", e10, t10, n10), _10 = ude("strides", e10, t10, n10), O10 = dde(e10, t10, n10);
            return [r10.conv2dTranspose(ude("x", e10, t10, n10), ude("filter", e10, t10, n10), R10, [_10[1], _10[2]], O10)];
          case "DepthwiseConv2dNative":
          case "DepthwiseConv2d":
            var F10 = ude("strides", e10, t10, n10), D10 = dde(e10, t10, n10), M10 = ude("dilations", e10, t10, n10), L10 = ude("dataFormat", e10, t10, n10).toUpperCase();
            return [r10.depthwiseConv2d(ude("input", e10, t10, n10), ude("filter", e10, t10, n10), [F10[1], F10[2]], D10, L10, [M10[1], M10[2]])];
          case "Conv3D":
            var z10 = ude("strides", e10, t10, n10), P10 = ude("pad", e10, t10, n10), B10 = ude("dataFormat", e10, t10, n10).toUpperCase(), W10 = ude("dilations", e10, t10, n10);
            return [r10.conv3d(ude("x", e10, t10, n10), ude("filter", e10, t10, n10), [z10[1], z10[2], z10[3]], P10, B10, [W10[1], W10[2], W10[3]])];
          case "AvgPool":
            var U10 = ude("strides", e10, t10, n10), V10 = ude("pad", e10, t10, n10), G10 = ude("kernelSize", e10, t10, n10);
            return [r10.avgPool(ude("x", e10, t10, n10), [G10[1], G10[2]], [U10[1], U10[2]], V10)];
          case "MaxPool":
            var j10 = ude("strides", e10, t10, n10), H10 = ude("pad", e10, t10, n10), q10 = ude("kernelSize", e10, t10, n10);
            return [r10.maxPool(ude("x", e10, t10, n10), [q10[1], q10[2]], [j10[1], j10[2]], H10)];
          case "MaxPoolWithArgmax":
            var K10 = ude("strides", e10, t10, n10), X10 = ude("pad", e10, t10, n10), Y10 = ude("kernelSize", e10, t10, n10), J10 = ude("includeBatchInIndex", e10, t10, n10), Z10 = r10.maxPoolWithArgmax(ude("x", e10, t10, n10), [Y10[1], Y10[2]], [K10[1], K10[2]], X10, J10), Q10 = Z10.result, $10 = Z10.indexes;
            return [Q10, $10];
          case "AvgPool3D":
            var ee2 = ude("strides", e10, t10, n10), te2 = ude("pad", e10, t10, n10), ne2 = ude("kernelSize", e10, t10, n10);
            return [r10.avgPool3d(ude("x", e10, t10, n10), [ne2[1], ne2[2], ne2[3]], [ee2[1], ee2[2], ee2[3]], te2)];
          case "MaxPool3D":
            var re2 = ude("strides", e10, t10, n10), ae2 = ude("pad", e10, t10, n10), ie2 = ude("kernelSize", e10, t10, n10);
            return [r10.maxPool3d(ude("x", e10, t10, n10), [ie2[1], ie2[2], ie2[3]], [re2[1], re2[2], re2[3]], ae2)];
          case "Dilation2D":
            var oe2 = ude("strides", e10, t10, n10), se2 = ude("pad", e10, t10, n10), ue2 = ude("dilations", e10, t10, n10), ce2 = oe2[1], le2 = oe2[2], he2 = ue2[1], pe2 = ue2[2];
            return [r10.dilation2d(ude("x", e10, t10, n10), ude("filter", e10, t10, n10), [ce2, le2], se2, [he2, pe2], "NHWC")];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      }, fve = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "Fill":
            var a10 = ude("shape", e10, t10, n10), i10 = ude("dtype", e10, t10, n10), o10 = ude("value", e10, t10, n10);
            return [r10.fill(a10, o10, i10)];
          case "LinSpace":
            var s10 = ude("start", e10, t10, n10), u10 = ude("stop", e10, t10, n10), c10 = ude("num", e10, t10, n10);
            return [r10.linspace(s10, u10, c10)];
          case "Multinomial":
            var l10 = ude("logits", e10, t10, n10), h10 = ude("numSamples", e10, t10, n10), p10 = ude("seed", e10, t10, n10);
            return [r10.multinomial(l10, h10, p10)];
          case "OneHot":
            var f10 = ude("indices", e10, t10, n10), d10 = ude("depth", e10, t10, n10), v10 = ude("onValue", e10, t10, n10), m10 = ude("offValue", e10, t10, n10), g10 = ude("dtype", e10, t10, n10);
            return [r10.oneHot(f10, d10, v10, m10, g10)];
          case "Ones":
            return [r10.ones(ude("shape", e10, t10, n10), ude("dtype", e10, t10, n10))];
          case "OnesLike":
            return [r10.onesLike(ude("x", e10, t10, n10))];
          case "RandomStandardNormal":
            return [r10.randomStandardNormal(ude("shape", e10, t10, n10), ude("dtype", e10, t10, n10), ude("seed", e10, t10, n10))];
          case "RandomUniform":
            return [r10.randomUniform(ude("shape", e10, t10, n10), ude("minval", e10, t10, n10), ude("maxval", e10, t10, n10), ude("dtype", e10, t10, n10))];
          case "RandomUniformInt":
            return [r10.randomUniformInt(ude("shape", e10, t10, n10), ude("minval", e10, t10, n10), ude("maxval", e10, t10, n10), ude("seed", e10, t10, n10))];
          case "Range":
            var y10 = ude("start", e10, t10, n10), b10 = ude("stop", e10, t10, n10), x10 = ude("step", e10, t10, n10);
            return [r10.range(y10, b10, x10, ude("dtype", e10, t10, n10))];
          case "TruncatedNormal":
            var k10 = ude("shape", e10, t10, n10), w10 = ude("mean", e10, t10, n10), I10 = ude("stdDev", e10, t10, n10), N10 = ude("seed", e10, t10, n10);
            return [r10.truncatedNormal(k10, w10, I10, ude("dtype", e10, t10, n10), N10)];
          case "Zeros":
            return [r10.zeros(ude("shape", e10, t10, n10), ude("dtype", e10, t10, n10))];
          case "ZerosLike":
            return [r10.zerosLike(ude("x", e10, t10, n10))];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      };
      function dve(e10, t10, n10) {
        return { boxes: ude("boxes", e10, t10, n10), scores: ude("scores", e10, t10, n10), maxOutputSize: ude("maxOutputSize", e10, t10, n10), iouThreshold: ude("iouThreshold", e10, t10, n10), scoreThreshold: ude("scoreThreshold", e10, t10, n10), softNmsSigma: ude("softNmsSigma", e10, t10, n10) };
      }
      var vve = function() {
        var e10 = c(o().mark(function e11(t10, n10, r10, a10) {
          var i10, s10, u10, c10, l10, h10, p10, f10, d10, v10, m10, g10, y10, b10, x10, k10, w10, I10, N10, S10, T10, E10, C10, A10, R10, _10 = arguments;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                i10 = _10.length > 4 && void 0 !== _10[4] ? _10[4] : Zde, e12.t0 = t10.op, e12.next = "NonMaxSuppressionV5" === e12.t0 ? 4 : "NonMaxSuppressionV4" === e12.t0 ? 9 : "NonMaxSuppressionV3" === e12.t0 || "NonMaxSuppressionV2" === e12.t0 ? 15 : "Where" === e12.t0 ? 20 : "ListDiff" === e12.t0 ? 27 : 28;
                break;
              case 4:
                return s10 = dve(t10, n10, r10), u10 = s10.boxes, c10 = s10.scores, l10 = s10.maxOutputSize, h10 = s10.iouThreshold, p10 = s10.scoreThreshold, f10 = s10.softNmsSigma, e12.next = 7, i10.image.nonMaxSuppressionWithScoreAsync(u10, c10, l10, h10, p10, f10);
              case 7:
                return d10 = e12.sent, e12.abrupt("return", [d10.selectedIndices, d10.selectedScores]);
              case 9:
                return v10 = dve(t10, n10, r10), m10 = v10.boxes, g10 = v10.scores, y10 = v10.maxOutputSize, b10 = v10.iouThreshold, x10 = v10.scoreThreshold, k10 = ude("padToMaxOutputSize", t10, n10, r10), e12.next = 13, i10.image.nonMaxSuppressionPaddedAsync(m10, g10, y10, b10, x10, k10);
              case 13:
                return w10 = e12.sent, e12.abrupt("return", [w10.selectedIndices, w10.validOutputs]);
              case 15:
                return I10 = dve(t10, n10, r10), N10 = I10.boxes, S10 = I10.scores, T10 = I10.maxOutputSize, E10 = I10.iouThreshold, C10 = I10.scoreThreshold, e12.next = 18, i10.image.nonMaxSuppressionAsync(N10, S10, T10, E10, C10);
              case 18:
                return e12.t1 = e12.sent, e12.abrupt("return", [e12.t1]);
              case 20:
                return A10 = i10.cast(ude("condition", t10, n10, r10), "bool"), e12.next = 23, i10.whereAsync(A10);
              case 23:
                return e12.t2 = e12.sent, R10 = [e12.t2], A10.dispose(), e12.abrupt("return", R10);
              case 27:
                return e12.abrupt("return", i10.setdiff1dAsync(ude("x", t10, n10, r10), ude("y", t10, n10, r10)));
              case 28:
                throw TypeError("Node type ".concat(t10.op, " is not implemented"));
              case 29:
              case "end":
                return e12.stop();
            }
          }, e11);
        }));
        return function(t10, n10, r10, a10) {
          return e10.apply(this, arguments);
        };
      }(), mve = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "LowerBound":
            var a10 = ude("sortedSequence", e10, t10, n10), i10 = ude("values", e10, t10, n10);
            return [r10.lowerBound(a10, i10)];
          case "TopKV2":
            var o10 = ude("x", e10, t10, n10), s10 = ude("k", e10, t10, n10), u10 = ude("sorted", e10, t10, n10), c10 = r10.topk(o10, s10, u10);
            return [c10.values, c10.indices];
          case "UpperBound":
            var l10 = ude("sortedSequence", e10, t10, n10), h10 = ude("values", e10, t10, n10);
            return [r10.upperBound(l10, h10)];
          case "Unique":
            var p10 = ude("x", e10, t10, n10), f10 = r10.unique(p10);
            return [f10.values, f10.indices];
          case "UniqueV2":
            var d10 = ude("x", e10, t10, n10), v10 = ude("axis", e10, t10, n10), m10 = r10.unique(d10, v10);
            return [m10.values, m10.indices];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      }, gve = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "Const":
            return t10[e10.name];
          case "PlaceholderWithDefault":
            var a10 = ude("default", e10, t10, n10);
            return [cde(e10.name, t10, n10) || a10];
          case "Placeholder":
            return [cde(e10.name, t10, n10)];
          case "Identity":
          case "StopGradient":
          case "FakeQuantWithMinMaxVars":
            var i10 = ude("x", e10, t10, n10);
            return [vde(i10)];
          case "IdentityN":
            return ude("x", e10, t10, n10).map(function(e11) {
              return vde(e11);
            });
          case "Snapshot":
            var o10 = ude("x", e10, t10, n10);
            return [vde(o10)];
          case "Shape":
            return [r10.tensor1d(ude("x", e10, t10, n10).shape, "int32")];
          case "ShapeN":
            return ude("x", e10, t10, n10).map(function(e11) {
              return r10.tensor1d(e11.shape);
            });
          case "Size":
            return [r10.scalar(ude("x", e10, t10, n10).size, "int32")];
          case "Rank":
            return [r10.scalar(ude("x", e10, t10, n10).rank, "int32")];
          case "NoOp":
            return [r10.scalar(1)];
          case "Print":
            var s10 = ude("x", e10, t10, n10), u10 = ude("data", e10, t10, n10), c10 = ude("message", e10, t10, n10), l10 = ude("summarize", e10, t10, n10);
            console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(c10);
            for (var h10 = 0; h10 < u10.length; h10++) console.log(Array.prototype.slice.call(u10[h10].dataSync()).slice(0, l10));
            return [s10];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      }, yve = function() {
        function e10(t11, n11) {
          l(this, e10), this.keyDType = t11, this.valueDType = n11, this.handle = i9(0), this.tensorMap = /* @__PURE__ */ new Map(), J5(this.handle);
        }
        var t10, n10;
        return p(e10, [{ key: "id", get: function() {
          return this.handle.id;
        } }, { key: "clearAndClose", value: function() {
          this.tensorMap.forEach(function(e11) {
            return e11.dispose();
          }), this.tensorMap.clear(), this.handle.dispose();
        } }, { key: "size", value: function() {
          return this.tensorMap.size;
        } }, { key: "tensorSize", value: function() {
          return i9(this.size(), "int32");
        } }, { key: "import", value: (n10 = c(o().mark(function e11(t11, n11) {
          var r10, a10 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.checkKeyAndValueTensor(t11, n11), e12.next = 3, t11.data();
              case 3:
                return r10 = e12.sent, this.tensorMap.forEach(function(e13) {
                  return e13.dispose();
                }), this.tensorMap.clear(), e12.abrupt("return", X5(function() {
                  var e13 = rne(n11), t12 = r10.length, i10 = e13.length;
                  F$(t12 === i10, function() {
                    return "The number of elements doesn't match, keys has " + "".concat(t12, " elements, the values has ").concat(i10, " ") + "elements.";
                  });
                  for (var o10 = 0; o10 < t12; o10++) {
                    var s10 = r10[o10], u10 = e13[o10];
                    J5(u10), a10.tensorMap.set(s10, u10);
                  }
                  return a10.handle;
                }));
              case 7:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return n10.apply(this, arguments);
        }) }, { key: "find", value: (t10 = c(o().mark(function e11(t11, n11) {
          var r10, a10 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.checkKeyAndValueTensor(t11, n11), e12.next = 3, t11.data();
              case 3:
                return r10 = e12.sent, e12.abrupt("return", X5(function() {
                  for (var e13 = [], t12 = 0; t12 < r10.length; t12++) {
                    var i10 = r10[t12], o10 = a10.findWithDefault(i10, n11);
                    e13.push(o10);
                  }
                  return Pte(e13);
                }));
              case 5:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, n11) {
          return t10.apply(this, arguments);
        }) }, { key: "findWithDefault", value: function(e11, t11) {
          var n11 = this.tensorMap.get(e11);
          return null != n11 ? n11 : t11;
        } }, { key: "checkKeyAndValueTensor", value: function(e11, t11) {
          if (e11.dtype !== this.keyDType) throw new Error("Expect key dtype ".concat(this.keyDType, ", but got ") + "".concat(e11.dtype));
          if (t11.dtype !== this.valueDType) throw new Error("Expect value dtype ".concat(this.valueDType, ", but got ") + "".concat(t11.dtype));
        } }]), e10;
      }(), bve = function() {
        var e10 = c(o().mark(function e11(t10, n10, r10, a10) {
          var i10, s10, u10, c10, l10, h10, p10, f10, d10, v10, m10, g10, y10, b10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                e12.t0 = t10.op, e12.next = "HashTable" === e12.t0 || "HashTableV2" === e12.t0 ? 3 : "InitializeTable" === e12.t0 || "InitializeTableV2" === e12.t0 || "LookupTableImport" === e12.t0 || "LookupTableImportV2" === e12.t0 ? 13 : "LookupTableFind" === e12.t0 || "LookupTableFindV2" === e12.t0 ? 21 : "LookupTableSize" === e12.t0 || "LookupTableSizeV2" === e12.t0 ? 29 : 32;
                break;
              case 3:
                if (null == (i10 = a10.getHashTableHandleByName(t10.name))) {
                  e12.next = 8;
                  break;
                }
                return e12.abrupt("return", [i10]);
              case 8:
                return s10 = ude("keyDType", t10, n10, r10), u10 = ude("valueDType", t10, n10, r10), c10 = new yve(s10, u10), a10.addHashTable(t10.name, c10), e12.abrupt("return", [c10.handle]);
              case 13:
                return l10 = ude("tableHandle", t10, n10, r10, a10), h10 = ude("keys", t10, n10, r10), p10 = ude("values", t10, n10, r10), f10 = a10.getHashTableById(l10.id), e12.next = 19, f10.import(h10, p10);
              case 19:
                return e12.t1 = e12.sent, e12.abrupt("return", [e12.t1]);
              case 21:
                return d10 = ude("tableHandle", t10, n10, r10, a10), v10 = ude("keys", t10, n10, r10), m10 = ude("defaultValue", t10, n10, r10), g10 = a10.getHashTableById(d10.id), e12.next = 27, g10.find(v10, m10);
              case 27:
                return e12.t2 = e12.sent, e12.abrupt("return", [e12.t2]);
              case 29:
                return y10 = ude("tableHandle", t10, n10, r10, a10), b10 = a10.getHashTableById(y10.id), e12.abrupt("return", [b10.tensorSize()]);
              case 32:
                throw TypeError("Node type ".concat(t10.op, " is not implemented"));
              case 33:
              case "end":
                return e12.stop();
            }
          }, e11);
        }));
        return function(t10, n10, r10, a10) {
          return e10.apply(this, arguments);
        };
      }(), xve = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "ResizeBilinear":
            var a10 = ude("images", e10, t10, n10), i10 = ude("size", e10, t10, n10), o10 = ude("alignCorners", e10, t10, n10), s10 = ude("halfPixelCenters", e10, t10, n10);
            return [r10.image.resizeBilinear(a10, [i10[0], i10[1]], o10, s10)];
          case "ResizeNearestNeighbor":
            var u10 = ude("images", e10, t10, n10), c10 = ude("size", e10, t10, n10), l10 = ude("alignCorners", e10, t10, n10), h10 = ude("halfPixelCenters", e10, t10, n10);
            return [r10.image.resizeNearestNeighbor(u10, [c10[0], c10[1]], l10, h10)];
          case "CropAndResize":
            var p10 = ude("image", e10, t10, n10), f10 = ude("boxes", e10, t10, n10), d10 = ude("boxInd", e10, t10, n10), v10 = ude("cropSize", e10, t10, n10), m10 = ude("method", e10, t10, n10), g10 = ude("extrapolationValue", e10, t10, n10);
            return [r10.image.cropAndResize(p10, f10, d10, v10, m10, g10)];
          case "ImageProjectiveTransformV3":
            var y10 = ude("images", e10, t10, n10), b10 = ude("transforms", e10, t10, n10), x10 = ude("outputShape", e10, t10, n10), k10 = ude("fillValue", e10, t10, n10), w10 = ude("interpolation", e10, t10, n10), I10 = ude("fillMode", e10, t10, n10);
            return [r10.image.transform(y10, b10, w10.toLowerCase(), I10.toLowerCase(), k10, x10)];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      }, kve = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "Equal":
            return [r10.equal(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "NotEqual":
            return [r10.notEqual(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "Greater":
            return [r10.greater(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "GreaterEqual":
            return [r10.greaterEqual(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "Less":
            return [r10.less(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "LessEqual":
            return [r10.lessEqual(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "LogicalAnd":
            return [r10.logicalAnd(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "LogicalNot":
            return [r10.logicalNot(ude("a", e10, t10, n10))];
          case "LogicalOr":
            return [r10.logicalOr(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "Select":
          case "SelectV2":
            return [r10.where(ude("condition", e10, t10, n10), ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          case "BitwiseAnd":
            return [r10.bitwiseAnd(ude("a", e10, t10, n10), ude("b", e10, t10, n10))];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      }, wve = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "BatchMatMul":
          case "BatchMatMulV2":
          case "MatMul":
            return [r10.matMul(ude("a", e10, t10, n10), ude("b", e10, t10, n10), ude("transposeA", e10, t10, n10), ude("transposeB", e10, t10, n10))];
          case "Einsum":
            return [r10.einsum.apply(r10, [ude("equation", e10, t10, n10)].concat(T(ude("tensors", e10, t10, n10))))];
          case "Transpose":
            return [r10.transpose(ude("x", e10, t10, n10), ude("perm", e10, t10, n10))];
          case "_FusedMatMul":
            var a10 = ude("fusedOps", e10, t10, n10), i10 = S(a10, 2), o10 = i10[0], s10 = i10[1], u10 = "biasadd" === o10, c10 = "prelu" === s10, l10 = ude("numArgs", e10, t10, n10), h10 = ude("leakyreluAlpha", e10, t10, n10);
            if (u10) {
              if (c10 && 2 !== l10) throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
              if (!c10 && 1 !== l10) throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
            }
            var p10 = ude("args", e10, t10, n10), f10 = S(p10, 2), d10 = f10[0], v10 = f10[1];
            return [r10.fused.matMul({ a: ude("a", e10, t10, n10), b: ude("b", e10, t10, n10), transposeA: ude("transposeA", e10, t10, n10), transposeB: ude("transposeB", e10, t10, n10), bias: d10, activation: s10, preluActivationWeights: v10, leakyreluAlpha: h10 })];
          case "MatrixBandPart":
            return [r10.linalg.bandPart(ude("a", e10, t10, n10), ude("numLower", e10, t10, n10), ude("numUpper", e10, t10, n10))];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      }, Ive = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "EuclideanNorm":
            return [r10.euclideanNorm(ude("x", e10, t10, n10), ude("axis", e10, t10, n10), ude("keepDims", e10, t10, n10))];
          case "FusedBatchNorm":
          case "FusedBatchNormV2":
          case "FusedBatchNormV3":
            return [r10.batchNorm(ude("x", e10, t10, n10), ude("mean", e10, t10, n10), ude("variance", e10, t10, n10), ude("offset", e10, t10, n10), ude("scale", e10, t10, n10), ude("epsilon", e10, t10, n10))];
          case "LRN":
            return [r10.localResponseNormalization(ude("x", e10, t10, n10), ude("radius", e10, t10, n10), ude("bias", e10, t10, n10), ude("alpha", e10, t10, n10), ude("beta", e10, t10, n10))];
          case "Softmax":
            return [r10.softmax(ude("x", e10, t10, n10))];
          case "LogSoftmax":
            return [r10.logSoftmax(ude("x", e10, t10, n10))];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      }, Nve = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "RaggedGather":
            var a10 = r10.raggedGather(ude("paramsNestedSplits", e10, t10, n10), ude("paramsDenseValues", e10, t10, n10), ude("indices", e10, t10, n10), ude("outputRaggedRank", e10, t10, n10)), i10 = a10.outputNestedSplits, o10 = a10.outputDenseValues;
            return i10.concat(o10);
          case "RaggedRange":
            var s10 = r10.raggedRange(ude("starts", e10, t10, n10), ude("limits", e10, t10, n10), ude("splits", e10, t10, n10)), u10 = s10.rtNestedSplits, c10 = s10.rtDenseValues;
            return [u10, c10];
          case "RaggedTensorToTensor":
            return [r10.raggedTensorToTensor(ude("shape", e10, t10, n10), ude("values", e10, t10, n10), ude("defaultValue", e10, t10, n10), ude("rowPartitionTensors", e10, t10, n10), ude("rowPartitionTypes", e10, t10, n10))];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      }, Sve = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "Max":
            var a10 = ude("axis", e10, t10, n10), i10 = ude("keepDims", e10, t10, n10);
            return [r10.max(ude("x", e10, t10, n10), a10, i10)];
          case "Mean":
            var o10 = ude("axis", e10, t10, n10), s10 = ude("keepDims", e10, t10, n10);
            return [r10.mean(ude("x", e10, t10, n10), o10, s10)];
          case "Min":
            var u10 = ude("axis", e10, t10, n10), c10 = ude("keepDims", e10, t10, n10);
            return [r10.min(ude("x", e10, t10, n10), u10, c10)];
          case "Sum":
            var l10 = ude("axis", e10, t10, n10), h10 = ude("keepDims", e10, t10, n10);
            return [r10.sum(ude("x", e10, t10, n10), l10, h10)];
          case "All":
            var p10 = ude("axis", e10, t10, n10), f10 = ude("keepDims", e10, t10, n10);
            return [r10.all(ude("x", e10, t10, n10), p10, f10)];
          case "Any":
            var d10 = ude("axis", e10, t10, n10), v10 = ude("keepDims", e10, t10, n10);
            return [r10.any(ude("x", e10, t10, n10), d10, v10)];
          case "ArgMax":
            var m10 = ude("axis", e10, t10, n10);
            return [r10.argMax(ude("x", e10, t10, n10), m10)];
          case "ArgMin":
            var g10 = ude("axis", e10, t10, n10);
            return [r10.argMin(ude("x", e10, t10, n10), g10)];
          case "Prod":
            var y10 = ude("axis", e10, t10, n10), b10 = ude("keepDims", e10, t10, n10);
            return [r10.prod(ude("x", e10, t10, n10), y10, b10)];
          case "Cumprod":
            var x10 = ude("axis", e10, t10, n10), k10 = ude("exclusive", e10, t10, n10), w10 = ude("reverse", e10, t10, n10);
            return [r10.cumprod(ude("x", e10, t10, n10), x10, k10, w10)];
          case "Cumsum":
            var I10 = ude("axis", e10, t10, n10), N10 = ude("exclusive", e10, t10, n10), S10 = ude("reverse", e10, t10, n10);
            return [r10.cumsum(ude("x", e10, t10, n10), I10, N10, S10)];
          case "Bincount":
            var T10 = ude("x", e10, t10, n10), E10 = ude("weights", e10, t10, n10), C10 = ude("size", e10, t10, n10);
            return [r10.bincount(T10, E10, C10)];
          case "DenseBincount":
            var A10 = ude("x", e10, t10, n10), R10 = ude("weights", e10, t10, n10), _10 = ude("size", e10, t10, n10), O10 = ude("binaryOutput", e10, t10, n10);
            return [r10.denseBincount(A10, R10, _10, O10)];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      }, Tve = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "ConcatV2":
          case "Concat":
            var a10 = ude("n", e10, t10, n10), i10 = ude("axis", e10, t10, n10), o10 = ude("tensors", e10, t10, n10);
            return o10 = o10.slice(0, a10), [r10.concat(o10, i10)];
          case "Gather":
            var s10 = ude("x", e10, t10, n10), u10 = ude("indices", e10, t10, n10);
            return [r10.gather(s10, r10.cast(u10, "int32"), 0)];
          case "GatherV2":
            var c10 = ude("axis", e10, t10, n10), l10 = ude("batchDims", e10, t10, n10), h10 = ude("x", e10, t10, n10), p10 = ude("indices", e10, t10, n10);
            return [r10.gather(h10, r10.cast(p10, "int32"), c10, l10)];
          case "Reverse":
            for (var f10 = ude("dims", e10, t10, n10), d10 = [], v10 = 0; v10 < f10.length; v10++) f10[v10] && d10.push(v10);
            var m10 = ude("x", e10, t10, n10);
            return [r10.reverse(m10, d10)];
          case "ReverseV2":
            var g10 = ude("axis", e10, t10, n10), y10 = ude("x", e10, t10, n10);
            return [r10.reverse(y10, g10)];
          case "Slice":
            var b10 = ude("begin", e10, t10, n10), x10 = ude("size", e10, t10, n10);
            return [r10.slice(ude("x", e10, t10, n10), b10, x10)];
          case "StridedSlice":
            var k10 = ude("begin", e10, t10, n10), w10 = ude("end", e10, t10, n10), I10 = ude("strides", e10, t10, n10), N10 = ude("beginMask", e10, t10, n10), S10 = ude("endMask", e10, t10, n10), T10 = ude("ellipsisMask", e10, t10, n10), E10 = ude("newAxisMask", e10, t10, n10), C10 = ude("shrinkAxisMask", e10, t10, n10), A10 = ude("x", e10, t10, n10);
            return [r10.stridedSlice(A10, k10, w10, I10, N10, S10, T10, E10, C10)];
          case "Pack":
            return X5(function() {
              var a11 = ude("axis", e10, t10, n10), i11 = ude("tensors", e10, t10, n10), o11 = i11[0].shape, s11 = r10.squeeze(i11[0]).shape, u11 = i11.map(function(e11) {
                var t11 = P$(e11.shape, o11);
                if (!t11 && !P$(r10.squeeze(e11).shape, s11)) throw new Error("the input tensors shape does not match");
                return t11 ? e11 : r10.reshape(e11, o11);
              });
              return [r10.stack(u11, a11)];
            });
          case "Unpack":
            var R10 = ude("axis", e10, t10, n10), _10 = ude("tensor", e10, t10, n10);
            return r10.unstack(_10, R10);
          case "Tile":
            var O10 = ude("reps", e10, t10, n10);
            return [r10.tile(ude("x", e10, t10, n10), O10)];
          case "Split":
          case "SplitV":
            var F10 = ude("axis", e10, t10, n10), D10 = ude("numOrSizeSplits", e10, t10, n10), M10 = ude("x", e10, t10, n10);
            return r10.split(M10, D10, F10);
          case "ScatterNd":
            var L10 = ude("indices", e10, t10, n10), z10 = ude("values", e10, t10, n10), P10 = ude("shape", e10, t10, n10);
            return [r10.scatterND(L10, z10, P10)];
          case "GatherNd":
            var B10 = ude("x", e10, t10, n10), W10 = ude("indices", e10, t10, n10);
            return [r10.gatherND(B10, W10)];
          case "SparseToDense":
            var U10 = ude("sparseIndices", e10, t10, n10), V10 = ude("outputShape", e10, t10, n10), G10 = ude("sparseValues", e10, t10, n10), j10 = ude("defaultValue", e10, t10, n10);
            return [r10.sparseToDense(U10, G10, V10, G10.dtype === j10.dtype ? j10 : r10.cast(j10, G10.dtype))];
          case "TensorScatterUpdate":
            var H10 = ude("indices", e10, t10, n10), q10 = ude("values", e10, t10, n10), K10 = ude("tensor", e10, t10, n10);
            return [r10.tensorScatterUpdate(K10, H10, q10)];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      }, Eve = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "SparseFillEmptyRows":
            var a10 = r10.sparse.sparseFillEmptyRows(ude("indices", e10, t10, n10), ude("values", e10, t10, n10), ude("denseShape", e10, t10, n10), ude("defaultValue", e10, t10, n10)), i10 = a10.outputIndices, o10 = a10.outputValues, s10 = a10.emptyRowIndicator, u10 = a10.reverseIndexMap;
            return [i10, o10, s10, u10];
          case "SparseReshape":
            var c10 = r10.sparse.sparseReshape(ude("inputIndices", e10, t10, n10), ude("inputShape", e10, t10, n10), ude("newShape", e10, t10, n10)), l10 = c10.outputIndices, h10 = c10.outputShape;
            return [l10, h10];
          case "SparseSegmentMean":
            var p10 = r10.sparse.sparseSegmentMean(ude("data", e10, t10, n10), ude("indices", e10, t10, n10), ude("segmentIds", e10, t10, n10));
            return [p10];
          case "SparseSegmentSum":
            var f10 = r10.sparse.sparseSegmentSum(ude("data", e10, t10, n10), ude("indices", e10, t10, n10), ude("segmentIds", e10, t10, n10));
            return [f10];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      }, Cve = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "FFT":
            return [r10.fft(ude("x", e10, t10, n10))];
          case "IFFT":
            return [r10.ifft(ude("x", e10, t10, n10))];
          case "RFFT":
            return [r10.rfft(ude("x", e10, t10, n10))];
          case "IRFFT":
            return [r10.irfft(ude("x", e10, t10, n10))];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      }, Ave = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "StaticRegexReplace":
            return [r10.string.staticRegexReplace(ude("input", e10, t10, n10), ude("pattern", e10, t10, n10), ude("rewrite", e10, t10, n10), ude("replaceGlobal", e10, t10, n10))];
          case "StringNGrams":
            var a10 = r10.string.stringNGrams(ude("data", e10, t10, n10), ude("dataSplits", e10, t10, n10), ude("separator", e10, t10, n10), ude("nGramWidths", e10, t10, n10), ude("leftPad", e10, t10, n10), ude("rightPad", e10, t10, n10), ude("padWidth", e10, t10, n10), ude("preserveShortSequences", e10, t10, n10)), i10 = a10.nGrams, o10 = a10.nGramsSplits;
            return [i10, o10];
          case "StringSplit":
            var s10 = r10.string.stringSplit(ude("input", e10, t10, n10), ude("delimiter", e10, t10, n10), ude("skipEmpty", e10, t10, n10)), u10 = s10.indices, c10 = s10.values, l10 = s10.shape;
            return [u10, c10, l10];
          case "StringToHashBucketFast":
            var h10 = r10.string.stringToHashBucketFast(ude("input", e10, t10, n10), ude("numBuckets", e10, t10, n10));
            return [h10];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      }, Rve = function(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Zde;
        switch (e10.op) {
          case "Cast":
            return [r10.cast(ude("x", e10, t10, n10), ude("dtype", e10, t10, n10))];
          case "ExpandDims":
            var a10 = ude("axis", e10, t10, n10);
            return [r10.expandDims(ude("x", e10, t10, n10), a10)];
          case "Squeeze":
            var i10 = ude("axis", e10, t10, n10);
            return [r10.squeeze(ude("x", e10, t10, n10), i10)];
          case "Reshape":
            return [r10.reshape(ude("x", e10, t10, n10), ude("shape", e10, t10, n10))];
          case "EnsureShape":
            return [r10.ensureShape(ude("x", e10, t10, n10), ude("shape", e10, t10, n10))];
          case "MirrorPad":
            return [r10.mirrorPad(ude("x", e10, t10, n10), ude("padding", e10, t10, n10), ude("mode", e10, t10, n10))];
          case "PadV2":
          case "Pad":
            return [r10.pad(ude("x", e10, t10, n10), ude("padding", e10, t10, n10), ude("constantValue", e10, t10, n10))];
          case "SpaceToBatchND":
            var o10 = ude("blockShape", e10, t10, n10), s10 = ude("paddings", e10, t10, n10);
            return [r10.spaceToBatchND(ude("x", e10, t10, n10), o10, s10)];
          case "BatchToSpaceND":
            var u10 = ude("blockShape", e10, t10, n10), c10 = ude("crops", e10, t10, n10);
            return [r10.batchToSpaceND(ude("x", e10, t10, n10), u10, c10)];
          case "DepthToSpace":
            var l10 = ude("blockSize", e10, t10, n10), h10 = ude("dataFormat", e10, t10, n10).toUpperCase();
            return [r10.depthToSpace(ude("x", e10, t10, n10), l10, h10)];
          case "BroadcastTo":
            return [r10.broadcastTo(ude("x", e10, t10, n10), ude("shape", e10, t10, n10))];
          case "BroadcastArgs":
            return [r10.broadcastArgs(ude("s0", e10, t10, n10), ude("s1", e10, t10, n10))];
          default:
            throw TypeError("Node type ".concat(e10.op, " is not implemented"));
        }
      };
      function _ve(e10, t10, n10, r10) {
        var a10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : X5, i10 = function(e11, t11, n11) {
          switch (e11.category) {
            case "arithmetic":
              return a10(function() {
                return Qde(e11, t11, n11);
              });
            case "basic_math":
              return a10(function() {
                return $de(e11, t11, n11);
              });
            case "control":
              return lve(e11, t11, n11);
            case "convolution":
              return a10(function() {
                return pve(e11, t11, n11);
              });
            case "creation":
              return a10(function() {
                return fve(e11, t11, n11);
              });
            case "dynamic":
              return vve(e11, t11, n11);
            case "evaluation":
              return a10(function() {
                return mve(e11, t11, n11);
              });
            case "image":
              return a10(function() {
                return xve(e11, t11, n11);
              });
            case "graph":
              return a10(function() {
                return gve(e11, t11, n11);
              });
            case "logical":
              return a10(function() {
                return kve(e11, t11, n11);
              });
            case "matrices":
              return a10(function() {
                return wve(e11, t11, n11);
              });
            case "normalization":
              return a10(function() {
                return Ive(e11, t11, n11);
              });
            case "ragged":
              return a10(function() {
                return Nve(e11, t11, n11);
              });
            case "reduction":
              return a10(function() {
                return Sve(e11, t11, n11);
              });
            case "slice_join":
              return a10(function() {
                return Tve(e11, t11, n11);
              });
            case "sparse":
              return a10(function() {
                return Eve(e11, t11, n11);
              });
            case "spectral":
              return a10(function() {
                return Cve(e11, t11, n11);
              });
            case "string":
              return a10(function() {
                return Ave(e11, t11, n11);
              });
            case "transformation":
              return a10(function() {
                return Rve(e11, t11, n11);
              });
            case "hash_table":
              return bve(e11, t11, n11, r10);
            case "custom":
              var i11 = sde(e11.op);
              if (i11 && i11.customExecutor) return i11.customExecutor(new Jde(e11, t11, n11));
              throw TypeError("Custom op ".concat(e11.op, " is not registered."));
            default:
              throw TypeError("Unknown op '".concat(e11.op, "'. File an issue at ") + "https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()");
          }
        }(e10, t10, n10);
        return v0(i10) ? i10.then(function(e11) {
          return [].concat(e11);
        }) : [].concat(i10);
      }
      var Ove = function() {
        function e10() {
          var t10 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, a10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, i10 = arguments.length > 4 ? arguments[4] : void 0;
          l(this, e10), this.weightMap = t10, this.tensorArrayMap = n10, this.tensorListMap = r10, this.functionMap = a10, this.parseNodeNameCache = i10, this.rootContext = { id: 0, frameName: "", iterationId: 0 }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds();
        }
        return p(e10, [{ key: "newFrame", value: function(e11, t10) {
          return { id: e11, frameName: t10, iterationId: 0 };
        } }, { key: "currentContext", get: function() {
          return this.contexts;
        }, set: function(e11) {
          this.contexts !== e11 && (this.contexts = e11, this.generateCurrentContextIds());
        } }, { key: "currentContextId", get: function() {
          return this._currentContextIds[0];
        } }, { key: "currentContextIds", get: function() {
          return this._currentContextIds;
        } }, { key: "generateCurrentContextIds", value: function() {
          for (var e11 = [], t10 = 0; t10 < this.contexts.length - 1; t10++) {
            var n10 = this.contexts.slice(0, this.contexts.length - t10);
            e11.push(this.contextIdforContexts(n10));
          }
          e11.push(""), this._currentContextIds = e11;
        } }, { key: "contextIdforContexts", value: function(e11) {
          return e11 ? e11.map(function(e12) {
            return 0 === e12.id && 0 === e12.iterationId ? "" : "".concat(e12.frameName, "-").concat(e12.iterationId);
          }).join("/") : "";
        } }, { key: "enterFrame", value: function(e11) {
          this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e11)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
        } }, { key: "exitFrame", value: function() {
          if (!(this.contexts && this.contexts.length > 1)) throw new Error("Cannot exit frame, the context is empty");
          this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
        } }, { key: "nextIteration", value: function() {
          if (!(this.contexts && this.contexts.length > 0)) throw new Error("Cannot increase frame iteration, the context is empty");
          this.contexts = this.contexts.slice(), this.lastId++;
          var e11 = Object.assign({}, this.contexts[this.contexts.length - 1]);
          e11.iterationId += 1, e11.id = this.lastId, this.contexts.splice(-1, 1, e11), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
        } }, { key: "getWeight", value: function(e11) {
          return this.weightMap[e11];
        } }, { key: "addTensorArray", value: function(e11) {
          this.tensorArrayMap[e11.id] = e11;
        } }, { key: "getTensorArray", value: function(e11) {
          return this.tensorArrayMap[e11];
        } }, { key: "addTensorList", value: function(e11) {
          this.tensorListMap[e11.id] = e11;
        } }, { key: "getTensorList", value: function(e11) {
          return this.tensorListMap[e11];
        } }, { key: "dispose", value: function(e11) {
          for (var t10 in this.tensorArrayMap) this.tensorArrayMap[t10].clearAndClose(e11);
          for (var n10 in this.tensorListMap) this.tensorListMap[n10].clearAndClose(e11);
        } }]), e10;
      }();
      function Fve(e10, t10, n10, r10) {
        var a10 = /* @__PURE__ */ new Set(), i10 = [], o10 = null, s10 = null, u10 = /* @__PURE__ */ new Set(), c10 = new Set(Object.keys(e10).map(function(e11) {
          return fde(e11)[0];
        }));
        r10 = r10 || [];
        for (var l10 = new Set(r10.map(function(e11) {
          return fde(e11.name)[0];
        })), h10 = T(t10); h10.length > 0; ) {
          var p10 = h10.pop();
          (Bve(p10) || Wve(p10) || Uve(p10)) && null == o10 && (s10 = (o10 = p10).children.map(function(e11) {
            return e11.name;
          }).filter(function(e11) {
            return a10.has(e11);
          })), a10.add(p10.name), null == n10[p10.name] && (c10.has(p10.name) || l10.has(p10.name) || (0 !== p10.inputs.length ? p10.inputs.forEach(function(e11) {
            u10.has(e11.name) || (u10.add(e11.name), h10.push(e11));
          }) : i10.push(p10.name)));
        }
        return { inputs: e10, outputs: t10, usedNodes: a10, missingInputs: i10, dynamicNode: o10, syncInputs: s10 };
      }
      function Dve(e10, t10) {
        var n10 = t10.usedNodes, r10 = t10.inputs, a10 = Object.keys(r10).map(function(e11) {
          return fde(e11)[0];
        }).map(function(t11) {
          return e10.nodes[t11];
        }), i10 = e10.initNodes || [], o10 = function(e11) {
          return n10.has("string" == typeof e11 ? e11 : e11.name);
        };
        function s10(e11) {
          return T(new Map(e11.map(function(e12) {
            return [e12.name, e12];
          })).values());
        }
        var u10, c10 = s10([].concat(T(a10), T(e10.weights), T(i10))).filter(o10), l10 = s10([].concat(T(c10), T(Object.values(e10.nodes)))).filter(o10), h10 = new Map(l10.map(function(e11) {
          return [e11.name, e11];
        })), p10 = {}, f10 = O(l10);
        try {
          for (f10.s(); !(u10 = f10.n()).done; ) {
            var d10 = u10.value;
            p10[d10.name] = p10[d10.name] || 0;
            var v10, m10 = O(d10.children);
            try {
              for (m10.s(); !(v10 = m10.n()).done; ) {
                var g10 = v10.value;
                o10(g10) || (p10[g10.name] = Number.POSITIVE_INFINITY), p10[g10.name] = (p10[g10.name] || 0) + 1;
              }
            } catch (e11) {
              m10.e(e11);
            } finally {
              m10.f();
            }
          }
        } catch (e11) {
          f10.e(e11);
        } finally {
          f10.f();
        }
        for (var y10 = Object.entries(p10).filter(function(e11) {
          return 0 === S(e11, 2)[1];
        }).map(function(e11) {
          return S(e11, 1)[0];
        }), b10 = T(y10); y10.length > 0; ) {
          var x10, k10 = y10.pop(), w10 = O(h10.get(k10).children.filter(o10));
          try {
            for (w10.s(); !(x10 = w10.n()).done; ) {
              var I10 = x10.value;
              0 == --p10[I10.name] && (b10.push(I10.name), y10.push(I10.name));
            }
          } catch (e11) {
            w10.e(e11);
          } finally {
            w10.f();
          }
        }
        var N10 = function(e11, t11) {
          var n11 = new Map(e11.map(function(e12) {
            return [e12.name, e12];
          })), r11 = t11.map(function(e12) {
            return e12.name;
          }), a11 = new Set(r11);
          for (; r11.length > 0; ) {
            var i11, o11 = r11.pop(), s11 = O(n11.get(o11).children);
            try {
              for (s11.s(); !(i11 = s11.n()).done; ) {
                var u11 = i11.value;
                n11.has(u11.name) && !a11.has(u11.name) && (a11.add(u11.name), r11.push(u11.name));
              }
            } catch (e12) {
              s11.e(e12);
            } finally {
              s11.f();
            }
          }
          var c11 = e11.filter(function(e12) {
            return a11.has(e12.name);
          });
          return c11;
        }(b10.map(function(e11) {
          return h10.get(e11);
        }), c10);
        return function(e11, t11) {
          var n11, r11 = new Map(e11.map(function(e12, t12) {
            return [e12.name, t12];
          })), a11 = new Set(t11.map(function(e12) {
            return e12.name;
          })), i11 = function(e12) {
            return a11.has("string" == typeof e12 ? e12 : e12.name);
          }, o11 = new Set(e11.map(function(e12) {
            return e12.name;
          })), s11 = function(e12) {
            return o11.has("string" == typeof e12 ? e12 : e12.name);
          }, u11 = O(e11);
          try {
            for (u11.s(); !(n11 = u11.n()).done; ) {
              var c11, l11 = n11.value, h11 = O(l11.children.filter(s11));
              try {
                for (h11.s(); !(c11 = h11.n()).done; ) {
                  var p11 = c11.value;
                  if (!r11.has(p11.name)) throw new Mve("Child ".concat(p11.name, " of node ").concat(l11.name, " is unreachable."));
                  if (r11.get(l11.name) > r11.get(p11.name)) throw new Mve("Node ".concat(l11.name, " is scheduled to run after its child ").concat(p11.name, "."));
                }
              } catch (e12) {
                h11.e(e12);
              } finally {
                h11.f();
              }
              if (!i11(l11)) {
                var f11, d11 = O(l11.inputs);
                try {
                  for (d11.s(); !(f11 = d11.n()).done; ) {
                    var v11 = f11.value;
                    if (!r11.has(v11.name)) throw new Mve("Input ".concat(v11.name, " of node ").concat(l11.name, " is unreachable."));
                    if (r11.get(v11.name) > r11.get(l11.name)) throw new Mve("Node ".concat(l11.name, " is scheduled to run before its input ").concat(v11.name, "."));
                  }
                } catch (e12) {
                  d11.e(e12);
                } finally {
                  d11.f();
                }
              }
            }
          } catch (e12) {
            u11.e(e12);
          } finally {
            u11.f();
          }
        }(N10, c10), N10;
      }
      var Mve = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11) {
          return l(this, n10), t10.call(this, "NodesExecutionOrderError: ".concat(e11));
        }
        return p(n10);
      }(b(Error));
      var Lve = /* @__PURE__ */ new Set(["Switch", "Merge", "Enter", "Exit", "NextIteration", "StatelessIf", "StatelessWhile", "if", "While"]), zve = /* @__PURE__ */ new Set(["NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where"]), Pve = /* @__PURE__ */ new Set(["HashTable", "HashTableV2", "LookupTableImport", "LookupTableImportV2", "LookupTableFind", "LookupTableFindV2", "LookupTableSize", "LookupTableSizeV2"]);
      function Bve(e10) {
        return Lve.has(e10.op);
      }
      function Wve(e10) {
        return zve.has(e10.op);
      }
      function Uve(e10) {
        return Pve.has(e10.op);
      }
      var Vve = function() {
        function e10(t11, n11) {
          var r11 = this;
          l(this, e10), this.graph = t11, this.parent = n11, this.compiledMap = /* @__PURE__ */ new Map(), this.parseNodeNameCache = /* @__PURE__ */ new Map(), this._weightMap = {}, this.SEPARATOR = ",", this._functions = {}, this._functionExecutorMap = {}, this.keepIntermediateTensors = false, this._outputs = t11.outputs, this._inputs = t11.inputs, this._initNodes = t11.initNodes, this._signature = t11.signature, this._functions = t11.functions, null != t11.functions && Object.keys(t11.functions).forEach(function(n12) {
            r11._functionExecutorMap[n12] = new e10(t11.functions[n12], r11);
          });
        }
        var t10, n10, r10, a10;
        return p(e10, [{ key: "weightIds", get: function() {
          return this.parent ? this.parent.weightIds : this._weightIds;
        } }, { key: "functionExecutorMap", get: function() {
          return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
        } }, { key: "weightMap", get: function() {
          return this.parent ? this.parent.weightMap : this._weightMap;
        }, set: function(e11) {
          var t11, n11 = Object.keys(e11).map(function(t12) {
            return e11[t12].map(function(e12) {
              return e12.id;
            });
          });
          this._weightIds = (t11 = []).concat.apply(t11, T(n11)), this._weightMap = e11;
        } }, { key: "resourceManager", set: function(e11) {
          this._resourceManager = e11;
        } }, { key: "inputs", get: function() {
          return this._inputs.map(function(e11) {
            return { name: e11.name, shape: e11.attrParams.shape ? e11.attrParams.shape.value : void 0, dtype: e11.attrParams.dtype ? e11.attrParams.dtype.value : void 0 };
          });
        } }, { key: "outputs", get: function() {
          return this._outputs.map(function(e11) {
            return { name: e11.name, shape: e11.attrParams.shape ? e11.attrParams.shape.value : void 0, dtype: e11.attrParams.dtype ? e11.attrParams.dtype.value : void 0 };
          });
        } }, { key: "inputNodes", get: function() {
          return this._inputs.map(function(e11) {
            return e11.signatureKey || e11.name;
          });
        } }, { key: "outputNodes", get: function() {
          return this._outputs.map(function(e11) {
            var t11 = e11.signatureKey || e11.name;
            return e11.defaultOutput ? "".concat(t11, ":").concat(e11.defaultOutput) : t11;
          });
        } }, { key: "functions", get: function() {
          var e11 = this;
          return Object.keys(this._functions).reduce(function(t11, n11) {
            return t11[n11] = e11._functions[n11].signature, t11;
          }, {});
        } }, { key: "getCompilationKey", value: function(e11, t11) {
          var n11 = e11.map(function(e12) {
            return e12.name;
          }).sort(), r11 = t11.map(function(e12) {
            return e12.name;
          }).sort();
          return n11.join(this.SEPARATOR) + "--" + r11.join(this.SEPARATOR);
        } }, { key: "compile", value: function(e11, t11) {
          var n11 = Fve(e11, t11, this.weightMap, this._initNodes), r11 = n11.missingInputs, a11 = n11.dynamicNode, i10 = n11.syncInputs;
          if (null != a11) throw new Error("This execution contains the node '".concat(a11.name, "', which has ") + "the dynamic op '".concat(a11.op, "'. Please use ") + "model.executeAsync() instead. Alternatively, to avoid the " + "dynamic ops, specify the inputs [".concat(i10, "]"));
          if (r11.length > 0) {
            var o10 = t11.map(function(e12) {
              return e12.name;
            }), s10 = Object.keys(e11);
            throw new Error("Cannot compute the outputs [".concat(o10, "] from the provided inputs ") + "[".concat(s10, "]. Missing the following inputs: [").concat(r11, "]"));
          }
          var u10 = Dve(this.graph, n11), c10 = function(e12) {
            for (var t12 = new Map(e12.map(function(e13, t13) {
              return [e13.name, t13];
            })), n12 = Number.MAX_SAFE_INTEGER, r12 = e12.map(function(e13, t13) {
              return Bve(e13) ? n12 : t13;
            }), a12 = function(e13) {
              var n13 = r12[t12.get(e13.name)];
              return null == n13 ? -1 : n13;
            }, i11 = e12.map(function(e13, t13) {
              return e13.children.map(a12).reduce(function(e14, t14) {
                return Math.max(e14, t14);
              }, r12[t13]);
            }), o11 = /* @__PURE__ */ new Map(), s11 = 0; s11 < e12.length; ++s11) {
              var u11 = i11[s11];
              if (u11 !== n12) {
                var c11 = e12[s11], l10 = e12[u11];
                o11.has(l10.name) || o11.set(l10.name, []), o11.get(l10.name).push(c11);
              }
            }
            return o11;
          }(u10);
          return { orderedNodes: u10, nodeLiveUntilMap: c10 };
        } }, { key: "cloneAndKeepTensor", value: function(e11) {
          if (null == e11) return null;
          var t11 = e11.clone();
          return J5(t11), t11;
        } }, { key: "cloneTensorList", value: function(e11) {
          var t11 = this;
          if (!e11) return null;
          var n11 = e11.map(function(e12) {
            return t11.cloneAndKeepTensor(e12);
          });
          return n11;
        } }, { key: "cloneTensorMap", value: function(e11) {
          var t11 = this;
          return Object.fromEntries(Object.entries(e11).map(function(e12) {
            var n11 = S(e12, 2), r11 = n11[0], a11 = n11[1];
            return [r11, t11.cloneTensorList(a11)];
          }));
        } }, { key: "execute", value: function(e11, t11) {
          var n11 = this;
          this.disposeIntermediateTensors(), e11 = this.mapInputs(e11);
          var r11 = Object.keys(e11).sort();
          this.checkInputs(e11), this.checkInputShapeAndType(e11), t11 = this.mapOutputs(t11), this.checkOutputs(t11);
          var a11 = r11.map(function(e12) {
            return n11.graph.nodes[fde(e12)[0]];
          }), i10 = t11.map(function(e12) {
            return fde(e12)[0];
          }), o10 = new Set(i10), s10 = i10.map(function(e12) {
            return n11.graph.nodes[e12];
          });
          0 === s10.length && (s10 = this._outputs);
          var u10 = this.getCompilationKey(a11, s10), c10 = this.compiledMap.get(u10);
          null == c10 && (c10 = this.compile(e11, s10), this.compiledMap.set(u10, c10));
          try {
            this.keepIntermediateTensors = k0().getBool("KEEP_INTERMEDIATE_TENSORS");
          } catch (e12) {
            this.keepIntermediateTensors = false, console.warn(e12.message);
          }
          var l10 = {}, h10 = {};
          return X5(function() {
            var r12 = new Ove(n11.weightMap, l10, h10, n11.functionExecutorMap, n11.parseNodeNameCache), a12 = Object.assign({}, n11.weightMap);
            n11.keepIntermediateTensors && (n11.clonedTensorsMap = n11.cloneTensorMap(n11.weightMap)), Object.keys(e11).forEach(function(t12) {
              var i12 = S(fde(t12, r12), 2), o11 = i12[0], s12 = [];
              s12[i12[1]] = e11[t12], a12[o11] = s12, n11.keepIntermediateTensors && (n11.clonedTensorsMap[o11] = n11.cloneTensorList(s12));
            });
            var i11, s11 = n11.getFrozenTensorIds(a12), u11 = c10, p10 = u11.orderedNodes, f10 = u11.nodeLiveUntilMap, d10 = O(p10);
            try {
              for (d10.s(); !(i11 = d10.n()).done; ) {
                var v10 = i11.value;
                if (!a12[v10.name]) {
                  var m10 = _ve(v10, a12, r12, n11._resourceManager);
                  if (v0(m10)) throw new Error("The execution of the op '".concat(v10.op, "' returned a promise. ") + "Please use model.executeAsync() instead.");
                  a12[v10.name] = m10, n11.keepIntermediateTensors && (n11.clonedTensorsMap[v10.name] = n11.cloneTensorList(m10)), n11.checkTensorForDisposalWithNodeLiveUntilInfo(v10, a12, r12, s11, o10, f10.get(v10.name));
                }
              }
            } catch (e12) {
              d10.e(e12);
            } finally {
              d10.f();
            }
            return null == n11.parent && r12.dispose(s11), t11.map(function(e12) {
              return cde(e12, a12, r12);
            });
          });
        } }, { key: "getFrozenTensorIds", value: function(e11) {
          var t11 = [].concat.apply([], Object.keys(e11).map(function(t12) {
            return e11[t12];
          }).map(function(e12) {
            return e12.map(function(e13) {
              return e13.id;
            });
          }));
          return new Set(t11);
        } }, { key: "checkTensorForDisposal", value: function(e11, t11, n11, r11, a11, i10, o10) {
          if (!Bve(t11) && !i10.has(e11)) {
            var s10, u10 = O(n11[e11]);
            try {
              for (u10.s(); !(s10 = u10.n()).done; ) {
                var c10 = s10.value;
                null != c10 && (o10[c10.id] = (o10[c10.id] || 0) + t11.children.length);
              }
            } catch (e12) {
              u10.e(e12);
            } finally {
              u10.f();
            }
            var l10, h10 = O(t11.inputs);
            try {
              for (h10.s(); !(l10 = h10.n()).done; ) {
                var p10 = l10.value;
                if (!Bve(p10)) {
                  var f10 = lde(p10.name, n11, r11);
                  if (null != f10) {
                    var d10, v10 = O(f10);
                    try {
                      for (v10.s(); !(d10 = v10.n()).done; ) {
                        var m10 = d10.value;
                        if (m10 && !m10.kept && !a11.has(m10.id)) {
                          var g10 = o10[m10.id];
                          1 === g10 ? (m10.dispose(), delete o10[m10.id]) : null != g10 && o10[m10.id]--;
                        }
                      }
                    } catch (e12) {
                      v10.e(e12);
                    } finally {
                      v10.f();
                    }
                  }
                }
              }
            } catch (e12) {
              h10.e(e12);
            } finally {
              h10.f();
            }
          }
        } }, { key: "checkTensorForDisposalWithNodeLiveUntilInfo", value: function(e11, t11, n11, r11, a11, i10) {
          function o10(e12) {
            return Bve(e12) || a11.has(e12.name);
          }
          if (!Bve(e11) && null != i10) {
            var s10, u10 = O(i10);
            try {
              for (u10.s(); !(s10 = u10.n()).done; ) {
                var c10 = s10.value;
                if (!o10(c10)) {
                  var l10, h10 = O(lde(c10.name, t11, n11));
                  try {
                    for (h10.s(); !(l10 = h10.n()).done; ) {
                      var p10 = l10.value;
                      !p10 || p10.kept || r11.has(p10.id) || p10.dispose();
                    }
                  } catch (e12) {
                    h10.e(e12);
                  } finally {
                    h10.f();
                  }
                }
              }
            } catch (e12) {
              u10.e(e12);
            } finally {
              u10.f();
            }
          }
        } }, { key: "executeAsync", value: (a10 = c(o().mark(function e11(t11, n11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.abrupt("return", this._executeAsync(t11, n11));
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return a10.apply(this, arguments);
        }) }, { key: "disposeIntermediateTensors", value: function() {
          this.clonedTensorsMap && (Object.values(this.clonedTensorsMap).forEach(function(e11) {
            var t11, n11 = O(e11);
            try {
              for (n11.s(); !(t11 = n11.n()).done; ) {
                var r11 = t11.value;
                r11 && !r11.isDisposed && r11.dispose();
              }
            } catch (e12) {
              n11.e(e12);
            } finally {
              n11.f();
            }
          }), this.clonedTensorsMap = null);
        } }, { key: "getIntermediateTensors", value: function() {
          return this.clonedTensorsMap;
        } }, { key: "_executeAsync", value: (r10 = c(o().mark(function e11(t11, n11) {
          var r11, a11, i10, s10, u10, c10, l10, h10, p10, f10 = arguments;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                r11 = f10.length > 2 && void 0 !== f10[2] && f10[2], a11 = f10.length > 3 && void 0 !== f10[3] ? f10[3] : {}, i10 = f10.length > 4 && void 0 !== f10[4] ? f10[4] : {}, this.disposeIntermediateTensors(), r11 || (t11 = this.mapInputs(t11), this.checkInputs(t11), this.checkInputShapeAndType(t11), n11 = this.mapOutputs(n11), this.checkOutputs(n11));
                try {
                  this.keepIntermediateTensors = k0().getBool("KEEP_INTERMEDIATE_TENSORS");
                } catch (e13) {
                  this.keepIntermediateTensors = false, console.warn(e13.message);
                }
                return s10 = new Ove(this.weightMap, a11, i10, this.functionExecutorMap, this.parseNodeNameCache), this.keepIntermediateTensors && (this.clonedTensorsMap = this.cloneTensorMap(this.weightMap)), e12.next = 10, this.executeWithControlFlow(t11, s10, n11, r11);
              case 10:
                return u10 = e12.sent, c10 = n11.map(function(e13) {
                  return cde(e13, u10, s10);
                }), l10 = c10.map(function(e13) {
                  return e13.id;
                }), h10 = Object.keys(t11).map(function(e13) {
                  return t11[e13].id;
                }), p10 = new Set([].concat(T(l10), T(h10), T(this.weightIds))), Object.values(u10).forEach(function(e13) {
                  e13.forEach(function(e14) {
                    !e14 || e14.isDisposed || p10.has(e14.id) || e14.dispose();
                  });
                }), null == this.parent && s10.dispose(p10), e12.abrupt("return", c10);
              case 18:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return r10.apply(this, arguments);
        }) }, { key: "executeFunctionAsync", value: (n10 = c(o().mark(function e11(t11, n11, r11) {
          var a11, i10 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return a11 = t11.reduce(function(e13, t12, n12) {
                  return e13[i10.inputs[n12].name] = t12, e13;
                }, {}), e12.abrupt("return", this._executeAsync(a11, this.outputNodes, true, n11, r11));
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11, r11) {
          return n10.apply(this, arguments);
        }) }, { key: "executeWithControlFlow", value: (t10 = c(o().mark(function e11(t11, n11, r11, a11) {
          var i10, s10, u10, c10, l10, h10, p10, f10, d10, v10, m10, g10, y10, b10, x10, k10, w10, I10, N10 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                i10 = Object.keys(t11), s10 = i10.map(function(e13) {
                  return N10.graph.nodes[fde(e13)[0]];
                }), u10 = r11.map(function(e13) {
                  return fde(e13)[0];
                }), c10 = new Set(u10), 0 === (l10 = u10.map(function(e13) {
                  return N10.graph.nodes[e13];
                })).length && (l10 = this._outputs), h10 = Fve(t11, l10, this.weightMap, this._initNodes), p10 = h10.usedNodes, f10 = h10.missingInputs, d10 = h10.dynamicNode, v10 = h10.syncInputs, m10 = [].concat(T(s10), T(this.graph.weights), T(this._initNodes || [])).map(function(e13) {
                  return { node: e13, contexts: n11.currentContext };
                }), g10 = Object.assign({}, this.weightMap), Object.keys(t11).forEach(function(e13) {
                  var n12 = S(fde(e13), 2), r12 = n12[0], a12 = [];
                  a12[n12[1]] = t11[e13], g10[r12] = a12;
                }), y10 = {}, b10 = this.getFrozenTensorIds(g10), x10 = {};
              case 13:
                if (!(m10.length > 0)) {
                  e12.next = 19;
                  break;
                }
                return k10 = this.processStack(s10, m10, n11, g10, x10, b10, c10, y10, p10), e12.next = 17, Promise.all(k10);
              case 17:
                e12.next = 13;
                break;
              case 19:
                if (null != d10 || a11 || console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."), w10 = l10.filter(function(e13) {
                  return !Bve(e13) && !cde(e13.name, g10, n11);
                }).map(function(e13) {
                  return e13.name;
                }), !(w10.length > 0)) {
                  e12.next = 25;
                  break;
                }
                throw I10 = "", null != d10 && (I10 = "Alternatively, to avoid the dynamic ops, use model.execute() " + "and specify the inputs [".concat(v10, "]")), new Error("Cannot compute the outputs [".concat(w10, "] from the provided ") + "inputs [".concat(i10, "]. Consider providing the following inputs: ") + "[".concat(f10, "]. ").concat(I10));
              case 25:
                return e12.abrupt("return", g10);
              case 26:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, n11, r11, a11) {
          return t10.apply(this, arguments);
        }) }, { key: "processStack", value: function(e11, t11, n11, r11, a11, i10, o10, s10, u10) {
          for (var c10 = this, l10 = [], h10 = function() {
            var e12 = t11.pop();
            n11.currentContext = e12.contexts;
            var h11 = "";
            if ("Enter" === e12.node.op && ude("isConstant", e12.node, r11, n11)) {
              var p10 = S(hde(e12.node.name, n11), 1);
              h11 = p10[0];
            }
            if (null == r11[e12.node.name]) {
              var f10 = _ve(e12.node, r11, n11, c10._resourceManager);
              if (!h11) {
                var d10 = S(hde(e12.node.name, n11), 1);
                h11 = d10[0];
              }
              var v10 = n11.currentContext;
              v0(f10) ? l10.push(f10.then(function(l11) {
                return r11[h11] = l11, c10.keepIntermediateTensors && (c10.clonedTensorsMap[h11] = c10.cloneTensorList(l11)), n11.currentContext = v10, c10.checkTensorForDisposal(h11, e12.node, r11, n11, i10, o10, s10), c10.processChildNodes(e12.node, t11, n11, r11, a11, u10), l11;
              })) : (r11[h11] = f10, c10.keepIntermediateTensors && (c10.clonedTensorsMap[h11] = c10.cloneTensorList(f10)), c10.checkTensorForDisposal(h11, e12.node, r11, n11, i10, o10, s10), c10.processChildNodes(e12.node, t11, n11, r11, a11, u10));
            } else c10.processChildNodes(e12.node, t11, n11, r11, a11, u10);
          }; t11.length > 0; ) h10();
          return l10;
        } }, { key: "processChildNodes", value: function(e11, t11, n11, r11, a11, i10) {
          e11.children.forEach(function(e12) {
            var o10 = S(hde(e12.name, n11), 1)[0];
            !a11[o10] && i10.has(e12.name) && ("Merge" === e12.op ? e12.inputNames.some(function(e13) {
              return !!cde(e13, r11, n11);
            }) && (a11[o10] = true, t11.push({ contexts: n11.currentContext, node: e12 })) : e12.inputNames.every(function(e13) {
              return !!cde(e13, r11, n11);
            }) && (a11[o10] = true, t11.push({ contexts: n11.currentContext, node: e12 })));
          });
        } }, { key: "dispose", value: function() {
          var e11 = this;
          Object.keys(this.weightMap).forEach(function(t11) {
            return e11.weightMap[t11].forEach(function(e12) {
              return e12.dispose();
            });
          });
        } }, { key: "checkInputShapeAndType", value: function(e11) {
          var t11 = this;
          Object.keys(e11).forEach(function(n11) {
            var r11 = e11[n11], a11 = S(fde(n11), 1)[0], i10 = t11.graph.nodes[a11];
            if (i10.attrParams.shape && i10.attrParams.shape.value) {
              var o10 = i10.attrParams.shape.value, s10 = o10.length === r11.shape.length && r11.shape.every(function(e12, t12) {
                return -1 === o10[t12] || o10[t12] === e12;
              });
              F$(s10, function() {
                return "The shape of dict['".concat(i10.name, "'] provided in ") + "model.execute(dict) must be [".concat(o10, "], but was ") + "[".concat(r11.shape, "]");
              });
            }
            i10.attrParams.dtype && i10.attrParams.dtype.value && F$(r11.dtype === i10.attrParams.dtype.value, function() {
              return "The dtype of dict['".concat(i10.name, "'] provided in ") + "model.execute(dict) must be " + "".concat(i10.attrParams.dtype.value, ", but was ").concat(r11.dtype);
            });
          });
        } }, { key: "mapInputs", value: function(e11) {
          var t11, n11, r11 = {};
          for (var a11 in e11) {
            var i10 = null === (n11 = null === (t11 = this._signature) || void 0 === t11 ? void 0 : t11.inputs) || void 0 === n11 ? void 0 : n11[a11];
            null != i10 ? r11[i10.name] = e11[a11] : r11[a11] = e11[a11];
          }
          return r11;
        } }, { key: "checkInputs", value: function(e11) {
          var t11 = this, n11 = Object.keys(e11).filter(function(e12) {
            var n12 = S(fde(e12), 1)[0];
            return null == t11.graph.nodes[n12];
          });
          if (n11.length > 0) throw new Error("The dict provided in model.execute(dict) has " + "keys: [".concat(n11, "] that are not part of graph"));
        } }, { key: "mapOutputs", value: function(e11) {
          var t11 = this;
          return e11.map(function(e12) {
            var n11, r11, a11 = null === (r11 = null === (n11 = t11._signature) || void 0 === n11 ? void 0 : n11.outputs) || void 0 === r11 ? void 0 : r11[e12];
            return null != a11 ? a11.name : e12;
          }, {});
        } }, { key: "checkOutputs", value: function(e11) {
          var t11 = this;
          e11.forEach(function(e12) {
            var n11 = S(fde(e12), 1)[0];
            if (!t11.graph.nodes[n11]) throw new Error("The output '".concat(e12, "' is not found in the graph"));
          });
        } }]), e10;
      }(), Gve = function() {
        function e10() {
          var t10 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          l(this, e10), this.hashTableNameToHandle = t10, this.hashTableMap = n10;
        }
        return p(e10, [{ key: "addHashTable", value: function(e11, t10) {
          this.hashTableNameToHandle[e11] = t10.handle, this.hashTableMap[t10.id] = t10;
        } }, { key: "getHashTableHandleByName", value: function(e11) {
          return this.hashTableNameToHandle[e11];
        } }, { key: "getHashTableById", value: function(e11) {
          return this.hashTableMap[e11];
        } }, { key: "dispose", value: function() {
          for (var e11 in this.hashTableMap) this.hashTableMap[e11].clearAndClose(), delete this.hashTableMap[e11];
          for (var t10 in this.hashTableNameToHandle) this.hashTableNameToHandle[t10].dispose(), delete this.hashTableNameToHandle[t10];
        } }]), e10;
      }(), jve = function() {
        function e10(t11) {
          var n11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Nae;
          l(this, e10), this.modelUrl = t11, this.loadOptions = n11, this.version = "n/a", this.io = r11, null == n11 && (this.loadOptions = {}), this.resourceManager = new Gve();
        }
        var t10, n10, r10, a10, i10;
        return p(e10, [{ key: "modelVersion", get: function() {
          return this.version;
        } }, { key: "inputNodes", get: function() {
          return this.executor.inputNodes;
        } }, { key: "outputNodes", get: function() {
          return this.executor.outputNodes;
        } }, { key: "inputs", get: function() {
          return this.executor.inputs;
        } }, { key: "outputs", get: function() {
          return this.executor.outputs;
        } }, { key: "weights", get: function() {
          return this.executor.weightMap;
        } }, { key: "metadata", get: function() {
          return this.artifacts.userDefinedMetadata;
        } }, { key: "modelSignature", get: function() {
          return this.signature;
        } }, { key: "modelStructuredOutputKeys", get: function() {
          return this.structuredOutputKeys;
        } }, { key: "findIOHandler", value: function() {
          var e11 = this.modelUrl;
          if (null != e11.load) this.handler = e11;
          else if (null != this.loadOptions.requestInit) this.handler = this.io.browserHTTPRequest(e11, this.loadOptions);
          else {
            var t11 = this.io.getLoadHandlers(e11, this.loadOptions);
            if (0 === t11.length) t11.push(this.io.browserHTTPRequest(e11, this.loadOptions));
            else if (t11.length > 1) throw new Error("Found more than one (".concat(t11.length, ") load handlers for ") + "URL '".concat([e11], "'"));
            this.handler = t11[0];
          }
        } }, { key: "load", value: function() {
          var e11 = this;
          if (this.findIOHandler(), null == this.handler.load) throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
          var t11 = this.handler.load();
          return v0(t11) ? t11.then(function(t12) {
            return null == t12.getWeightStream ? e11.loadSync(t12) : e11.loadStreaming(t12);
          }) : this.loadSync(t11);
        } }, { key: "loadSync", value: function(e11) {
          var t11 = this.io.decodeWeights(e11.weightData, e11.weightSpecs);
          return this.loadWithWeightMap(e11, t11);
        } }, { key: "loadStreaming", value: (i10 = c(o().mark(function e11(t11) {
          var n11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (null != t11.getWeightStream) {
                  e12.next = 2;
                  break;
                }
                throw new Error("Model artifacts missing streamWeights function");
              case 2:
                return e12.next = 4, l6(t11.getWeightStream(), t11.weightSpecs);
              case 4:
                return n11 = e12.sent, e12.abrupt("return", this.loadWithWeightMap(t11, n11));
              case 6:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return i10.apply(this, arguments);
        }) }, { key: "loadWithWeightMap", value: function(e11, t11) {
          this.artifacts = e11;
          var n11 = this.artifacts.modelTopology, r11 = this.artifacts.signature;
          if (null != this.artifacts.userDefinedMetadata) {
            var a11 = this.artifacts.userDefinedMetadata;
            null != a11.signature && (r11 = a11.signature), null != a11.structuredOutputKeys && (this.structuredOutputKeys = a11.structuredOutputKeys);
          }
          if (this.signature = r11, this.version = "".concat(n11.versions.producer, ".").concat(n11.versions.minConsumer), this.executor = new Vve(Mde.Instance.transformGraph(n11, this.signature)), this.executor.weightMap = this.convertTensorMapToTensorsMap(t11), this.executor.resourceManager = this.resourceManager, null != e11.modelInitializer && null != e11.modelInitializer.node) {
            var i11 = Mde.Instance.transformGraph(e11.modelInitializer);
            this.initializer = new Vve(i11), this.initializer.weightMap = this.executor.weightMap, this.initializer.resourceManager = this.resourceManager, this.initializerSignature = e11.initializerSignature;
          }
          return true;
        } }, { key: "save", value: (a10 = c(o().mark(function e11(t11, n11) {
          var r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if ("string" != typeof t11) {
                  e12.next = 9;
                  break;
                }
                if (0 !== (r11 = this.io.getSaveHandlers(t11)).length) {
                  e12.next = 6;
                  break;
                }
                throw new Error("Cannot find any save handlers for URL '".concat(t11, "'"));
              case 6:
                if (!(r11.length > 1)) {
                  e12.next = 8;
                  break;
                }
                throw new Error("Found more than one (".concat(r11.length, ") save handlers for ") + "URL '".concat(t11, "'"));
              case 8:
                t11 = r11[0];
              case 9:
                if (null != t11.save) {
                  e12.next = 11;
                  break;
                }
                throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
              case 11:
                return e12.abrupt("return", t11.save(this.artifacts));
              case 12:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return a10.apply(this, arguments);
        }) }, { key: "addStructuredOutputNames", value: function(e11) {
          var t11 = this;
          if (this.structuredOutputKeys) {
            var n11 = {};
            return (e11 instanceof n5 ? [e11] : e11).forEach(function(e12, r11) {
              return n11[t11.structuredOutputKeys[r11]] = e12;
            }), n11;
          }
          return e11;
        } }, { key: "predict", value: function(e11, t11) {
          var n11 = this.execute(e11, this.outputNodes);
          return this.addStructuredOutputNames(n11);
        } }, { key: "predictAsync", value: (r10 = c(o().mark(function e11(t11, n11) {
          var r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.executeAsync(t11, this.outputNodes);
              case 2:
                return r11 = e12.sent, e12.abrupt("return", this.addStructuredOutputNames(r11));
              case 4:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, t11) {
          return r10.apply(this, arguments);
        }) }, { key: "normalizeInputs", value: function(e11) {
          var t11, n11 = this;
          if (!(e11 instanceof n5 || Array.isArray(e11))) {
            var r11 = null === (t11 = this.signature) || void 0 === t11 ? void 0 : t11.inputs;
            if (null != r11) for (var a11 in r11) {
              var i11 = r11[a11];
              null != i11.resourceId && (e11[a11] = this.resourceIdToCapturedInput[i11.resourceId]);
            }
            return e11;
          }
          e11 = Array.isArray(e11) ? e11 : [e11];
          var o10 = Object.keys(this.resourceIdToCapturedInput).length;
          if (e11.length + o10 !== this.inputNodes.length) throw new Error("Input tensor count mismatch, the graph model has ".concat(this.inputNodes.length - o10, " non-resource placeholders, while there are ").concat(e11.length, " input tensors provided."));
          var s10 = 0;
          return this.inputNodes.reduce(function(t12, r12) {
            var a12, i12, o11, u10 = null === (o11 = null === (i12 = null === (a12 = n11.signature) || void 0 === a12 ? void 0 : a12.inputs) || void 0 === i12 ? void 0 : i12[r12]) || void 0 === o11 ? void 0 : o11.resourceId;
            return t12[r12] = null != u10 ? n11.resourceIdToCapturedInput[u10] : e11[s10++], t12;
          }, {});
        } }, { key: "normalizeOutputs", value: function(e11) {
          return e11 = e11 || this.outputNodes, Array.isArray(e11) ? e11 : [e11];
        } }, { key: "executeInitializerGraph", value: function() {
          return null == this.initializer ? [] : null == this.initializerSignature ? this.initializer.execute({}, []) : this.initializer.execute({}, Object.keys(this.initializerSignature.outputs));
        } }, { key: "executeInitializerGraphAsync", value: (n10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (null != this.initializer) {
                  e12.next = 2;
                  break;
                }
                return e12.abrupt("return", []);
              case 2:
                if (null != this.initializerSignature) {
                  e12.next = 6;
                  break;
                }
                return e12.abrupt("return", this.initializer.executeAsync({}, []));
              case 6:
                return e12.abrupt("return", this.initializer.executeAsync({}, Object.keys(this.initializerSignature.outputs)));
              case 7:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "setResourceIdToCapturedInput", value: function(e11) {
          if (this.resourceIdToCapturedInput = {}, this.initializerSignature) for (var t11 = this.initializerSignature.outputs, n11 = Object.keys(t11), r11 = 0; r11 < n11.length; r11++) {
            var a11 = t11[n11[r11]];
            this.resourceIdToCapturedInput[a11.resourceId] = e11[r11];
          }
        } }, { key: "execute", value: function(e11, t11) {
          null == this.resourceIdToCapturedInput && this.setResourceIdToCapturedInput(this.executeInitializerGraph()), e11 = this.normalizeInputs(e11), t11 = this.normalizeOutputs(t11);
          var n11 = this.executor.execute(e11, t11);
          return n11.length > 1 ? n11 : n11[0];
        } }, { key: "executeAsync", value: (t10 = c(o().mark(function e11(t11, n11) {
          var r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (null != this.resourceIdToCapturedInput) {
                  e12.next = 6;
                  break;
                }
                return e12.t0 = this, e12.next = 4, this.executeInitializerGraphAsync();
              case 4:
                e12.t1 = e12.sent, e12.t0.setResourceIdToCapturedInput.call(e12.t0, e12.t1);
              case 6:
                return t11 = this.normalizeInputs(t11), n11 = this.normalizeOutputs(n11), e12.next = 10, this.executor.executeAsync(t11, n11);
              case 10:
                return r11 = e12.sent, e12.abrupt("return", r11.length > 1 ? r11 : r11[0]);
              case 12:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11, n11) {
          return t10.apply(this, arguments);
        }) }, { key: "getIntermediateTensors", value: function() {
          return this.executor.getIntermediateTensors();
        } }, { key: "disposeIntermediateTensors", value: function() {
          this.executor.disposeIntermediateTensors();
        } }, { key: "convertTensorMapToTensorsMap", value: function(e11) {
          return Object.keys(e11).reduce(function(t11, n11) {
            return t11[n11] = [e11[n11]], t11;
          }, {});
        } }, { key: "dispose", value: function() {
          this.executor.dispose(), this.initializer && (this.initializer.dispose(), this.resourceIdToCapturedInput && Y5(this.resourceIdToCapturedInput)), this.resourceManager.dispose();
        } }]), e10;
      }();
      function Hve() {
        return Hve = c(o().mark(function e10(t10) {
          var n10, r10, a10, i10 = arguments;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                if (n10 = i10.length > 1 && void 0 !== i10[1] ? i10[1] : {}, r10 = i10.length > 2 && void 0 !== i10[2] ? i10[2] : Nae, null != t10) {
                  e11.next = 4;
                  break;
                }
                throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
              case 4:
                return null == n10 && (n10 = {}), n10.fromTFHub && "string" == typeof t10 && (t10 = qve(t10)), a10 = new jve(t10, n10, r10), e11.next = 9, a10.load();
              case 9:
                return e11.abrupt("return", a10);
              case 10:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), Hve.apply(this, arguments);
      }
      function qve(e10) {
        return e10.endsWith("/") || (e10 += "/"), "".concat(e10).concat("model.json").concat("?tfjs-format=file");
      }
      var Kve = "4.17.0";
      function Xve(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : /* @__PURE__ */ new Map(), r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : /* @__PURE__ */ new Set();
        if (null == e10) return null;
        if ("function" == typeof Blob && e10 instanceof Blob) return e10.slice();
        if (r10.has(e10)) throw new Error("Circular references are not supported.");
        if (n10.has(e10)) return n10.get(e10);
        var a10 = t10(e10);
        if (a10.recurse && null !== a10.value) throw new Error("A deep map function may not return both a value and recurse=true.");
        if (a10.recurse) {
          if (eme(e10)) {
            var i10 = Array.isArray(e10) ? [] : {};
            for (var o10 in r10.add(e10), e10) {
              var s10 = e10[o10], u10 = Xve(s10, t10, n10, r10);
              i10[o10] = u10;
            }
            return r10.delete(e10), e10.__proto__ && (i10.__proto__ = e10.__proto__), i10;
          }
          throw new Error("Can't recurse into non-iterable type: ".concat(e10));
        }
        return n10.set(e10, a10.value), a10.value;
      }
      function Yve(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Zve;
        return Jve(e10, t10);
      }
      function Jve(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : /* @__PURE__ */ new Set(), r10 = e10[0];
        if (n10.has(r10)) throw new Error("Circular references are not supported.");
        var a10 = t10(e10);
        if (a10.recurse && null !== a10.value) throw new Error("A deep zip function may not return both a value and recurse=true.");
        if (a10.recurse) {
          if (eme(r10)) {
            var i10 = Array.isArray(r10) ? [] : {};
            n10.add(r10);
            var o10 = function(r11) {
              var a11 = Jve(e10.map(function(e11) {
                return e11[r11];
              }), t10, n10);
              i10[r11] = a11;
            };
            for (var s10 in r10) o10(s10);
            return n10.delete(r10), i10;
          }
          throw new Error("Can't recurse into non-iterable type: ".concat(r10));
        }
        return a10.value;
      }
      function Zve(e10) {
        return null === e10 ? null : eme(e10[0]) ? { value: null, recurse: true } : { value: e10, recurse: false };
      }
      function Qve(e10, t10) {
        return $ve.apply(this, arguments);
      }
      function $ve() {
        return $ve = c(o().mark(function e10(t10, n10) {
          var r10, a10, i10, s10, u10, c10, l10;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                r10 = /* @__PURE__ */ new Map(), Xve(t10, n10, r10), a10 = 0, i10 = Array.from(r10.keys());
              case 3:
                if (!(a10 < i10.length)) {
                  e11.next = 14;
                  break;
                }
                if (s10 = i10[a10], !v0(u10 = r10.get(s10))) {
                  e11.next = 11;
                  break;
                }
                return e11.next = 9, u10;
              case 9:
                c10 = e11.sent, r10.set(s10, c10);
              case 11:
                a10++, e11.next = 3;
                break;
              case 14:
                return l10 = Xve(t10, n10, r10), e11.abrupt("return", l10);
              case 16:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), $ve.apply(this, arguments);
      }
      function eme(e10) {
        var t10 = false;
        k0().get("IS_BROWSER") ? t10 = e10 instanceof TextDecoder : t10 = e10 instanceof require_string_decoder().StringDecoder;
        return null != e10 && !ArrayBuffer.isView(e10) && (Array.isArray(e10) || "object" === s(e10) && !(e10 instanceof n5) && !(e10 instanceof Promise) && !t10);
      }
      function tme(e10) {
        return null == e10 || (null === (t10 = e10) || "object" !== s(t10) && "function" != typeof t10) || Array.isArray(e10) || "object" === s(e10) && e10 instanceof n5 || U4(e10);
        var t10;
      }
      function nme(e10) {
        return function(e11, t10) {
          return Xve(e11, t10);
        }(e10, rme);
      }
      function rme(e10) {
        return e10 instanceof n5 ? { value: e10.clone(), recurse: false } : eme(e10) ? { value: null, recurse: true } : { value: e10, recurse: false };
      }
      var ame = function() {
        function e10(t10) {
          if (l(this, e10), this.capacity = t10, this.begin = 0, this.end = 0, null == t10) throw new RangeError("Can't create a ring buffer of unknown capacity.");
          if (t10 < 1) throw new RangeError("Can't create ring buffer of capacity < 1.");
          this.data = new Array(t10), this.doubledCapacity = 2 * t10;
        }
        return p(e10, [{ key: "wrap", value: function(e11) {
          for (; e11 < 0; ) e11 += this.doubledCapacity;
          return e11 % this.doubledCapacity;
        } }, { key: "get", value: function(e11) {
          if (e11 < 0) throw new RangeError("Can't get item at a negative index.");
          return this.data[e11 % this.capacity];
        } }, { key: "set", value: function(e11, t10) {
          if (e11 < 0) throw new RangeError("Can't set item at a negative index.");
          this.data[e11 % this.capacity] = t10;
        } }, { key: "length", value: function() {
          var e11 = this.end - this.begin;
          return e11 < 0 && (e11 = this.doubledCapacity + e11), e11;
        } }, { key: "isFull", value: function() {
          return this.length() === this.capacity;
        } }, { key: "isEmpty", value: function() {
          return 0 === this.length();
        } }, { key: "push", value: function(e11) {
          if (this.isFull()) throw new RangeError("Ring buffer is full.");
          this.set(this.end, e11), this.end = this.wrap(this.end + 1);
        } }, { key: "pushAll", value: function(e11) {
          var t10, n10 = O(e11);
          try {
            for (n10.s(); !(t10 = n10.n()).done; ) {
              var r10 = t10.value;
              this.push(r10);
            }
          } catch (e12) {
            n10.e(e12);
          } finally {
            n10.f();
          }
        } }, { key: "pop", value: function() {
          if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
          this.end = this.wrap(this.end - 1);
          var e11 = this.get(this.end);
          return this.set(this.end, void 0), e11;
        } }, { key: "unshift", value: function(e11) {
          if (this.isFull()) throw new RangeError("Ring buffer is full.");
          this.begin = this.wrap(this.begin - 1), this.set(this.begin, e11);
        } }, { key: "shift", value: function() {
          if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
          var e11 = this.get(this.begin);
          return this.set(this.begin, void 0), this.begin = this.wrap(this.begin + 1), e11;
        } }, { key: "shuffleExcise", value: function(e11) {
          if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
          var t10 = this.wrap(this.begin + e11), n10 = this.get(t10);
          return this.set(t10, this.pop()), n10;
        } }]), e10;
      }(), ime = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.call(this, n10.INITIAL_CAPACITY);
        }
        return p(n10, [{ key: "isFull", value: function() {
          return false;
        } }, { key: "push", value: function(e11) {
          N(v(n10.prototype), "isFull", this).call(this) && this.expand(), N(v(n10.prototype), "push", this).call(this, e11);
        } }, { key: "unshift", value: function(e11) {
          N(v(n10.prototype), "isFull", this).call(this) && this.expand(), N(v(n10.prototype), "unshift", this).call(this, e11);
        } }, { key: "expand", value: function() {
          for (var e11 = 2 * this.capacity, t11 = new Array(e11), n11 = this.length(), r10 = 0; r10 < n11; r10++) t11[r10] = this.get(this.wrap(this.begin + r10));
          this.data = t11, this.capacity = e11, this.doubledCapacity = 2 * this.capacity, this.begin = 0, this.end = n11;
        } }]), n10;
      }(ame);
      function ome(e10) {
        return new pme(e10);
      }
      function sme(e10) {
        return new fme(e10);
      }
      function ume(e10, t10) {
        return new Nme(e10, t10);
      }
      function cme(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : lme.FAIL;
        return new Sme(e10, t10);
      }
      ime.INITIAL_CAPACITY = 32;
      var lme, hme = function() {
        function e10() {
          l(this, e10);
        }
        var t10, n10, r10, a10, i10;
        return p(e10, [{ key: "toArray", value: function() {
          var e11 = c(o().mark(function e12() {
            var t11, n11;
            return o().wrap(function(e13) {
              for (; ; ) switch (e13.prev = e13.next) {
                case 0:
                  return t11 = [], e13.next = 3, this.next();
                case 3:
                  n11 = e13.sent;
                case 4:
                  if (n11.done) {
                    e13.next = 11;
                    break;
                  }
                  return t11.push(n11.value), e13.next = 8, this.next();
                case 8:
                  n11 = e13.sent, e13.next = 4;
                  break;
                case 11:
                  return e13.abrupt("return", t11);
                case 12:
                case "end":
                  return e13.stop();
              }
            }, e12, this);
          }));
          return function() {
            return e11.apply(this, arguments);
          };
        }() }, { key: "toArrayForTest", value: (i10 = c(o().mark(function e11() {
          var t11, n11, r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return t11 = this.prefetch(100), n11 = [], e12.next = 4, t11.next();
              case 4:
                r11 = e12.sent;
              case 5:
                if (r11.done) {
                  e12.next = 12;
                  break;
                }
                return n11.push(r11.value), e12.next = 9, t11.next();
              case 9:
                r11 = e12.sent, e12.next = 5;
                break;
              case 12:
                return e12.abrupt("return", n11);
              case 13:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return i10.apply(this, arguments);
        }) }, { key: "resolveFully", value: (a10 = c(o().mark(function e11() {
          var t11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.next();
              case 2:
                t11 = e12.sent;
              case 3:
                if (t11.done) {
                  e12.next = 9;
                  break;
                }
                return e12.next = 6, this.next();
              case 6:
                t11 = e12.sent, e12.next = 3;
                break;
              case 9:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return a10.apply(this, arguments);
        }) }, { key: "resolveWhile", value: (r10 = c(o().mark(function e11(t11) {
          var n11, r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.next();
              case 2:
                n11 = e12.sent, r11 = t11(n11.value);
              case 4:
                if (n11.done || !r11) {
                  e12.next = 11;
                  break;
                }
                return e12.next = 7, this.next();
              case 7:
                n11 = e12.sent, r11 = t11(n11.value), e12.next = 4;
                break;
              case 11:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return r10.apply(this, arguments);
        }) }, { key: "handleErrors", value: function(e11) {
          return new xme(this, e11);
        } }, { key: "filter", value: function(e11) {
          return new yme(this, e11);
        } }, { key: "map", value: function(e11) {
          return new bme(this, e11);
        } }, { key: "mapAsync", value: function(e11) {
          return new kme(this, e11);
        } }, { key: "serialMapAsync", value: function(e11) {
          return new kme(this, e11).serial();
        } }, { key: "flatmap", value: function(e11) {
          return new Ime(this, e11);
        } }, { key: "forEachAsync", value: (n10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.abrupt("return", this.map(t11).resolveFully());
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return n10.apply(this, arguments);
        }) }, { key: "serialForEach", value: (t10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.abrupt("return", this.serialMapAsync(t11).resolveWhile(function(e13) {
                  return true === e13;
                }));
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "rowMajorBatch", value: function(e11) {
          var t11 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          return new gme(this, e11, t11);
        } }, { key: "columnMajorBatch", value: function(e11) {
          var t11 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Zve, r11 = this.rowMajorBatch(e11, t11);
          return r11.map(function(e12) {
            return Yve(e12, n11);
          });
        } }, { key: "concatenate", value: function(e11, t11) {
          return new Nme(ome([this, e11]), t11);
        } }, { key: "take", value: function(e11) {
          return e11 < 0 || null == e11 ? this : new mme(this, e11);
        } }, { key: "skip", value: function(e11) {
          return e11 < 0 || null == e11 ? this : new vme(this, e11);
        } }, { key: "prefetch", value: function(e11) {
          return new Tme(this, e11);
        } }, { key: "shuffle", value: function(e11, t11) {
          return new Eme(this, e11, t11);
        } }, { key: "serial", value: function() {
          return new dme(this);
        } }]), e10;
      }(), pme = function(e10) {
        d(r10, e10);
        var t10, n10 = w(r10);
        function r10(e11) {
          var t11;
          return l(this, r10), (t11 = n10.call(this)).items = e11, t11.trav = 0, t11;
        }
        return p(r10, [{ key: "summary", value: function() {
          return "Array of ".concat(this.items.length, " items");
        } }, { key: "next", value: (t10 = c(o().mark(function e11() {
          var t11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!(this.trav >= this.items.length)) {
                  e12.next = 2;
                  break;
                }
                return e12.abrupt("return", { value: null, done: true });
              case 2:
                return t11 = this.items[this.trav], this.trav++, e12.abrupt("return", { value: nme(t11), done: false });
              case 5:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), r10;
      }(hme), fme = function(e10) {
        d(r10, e10);
        var t10, n10 = w(r10);
        function r10(e11) {
          var t11;
          return l(this, r10), (t11 = n10.call(this)).nextFn = e11, t11;
        }
        return p(r10, [{ key: "summary", value: function() {
          return "Function call";
        } }, { key: "next", value: (t10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.prev = 0, e12.abrupt("return", this.nextFn());
              case 4:
                throw e12.prev = 4, e12.t0 = e12.catch(0), e12.t0.message = "Error thrown while iterating through a dataset: ".concat(e12.t0.message), e12.t0;
              case 8:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[0, 4]]);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), r10;
      }(hme), dme = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11) {
          var t11;
          return l(this, a10), (t11 = r10.call(this)).upstream = e11, t11.lastRead = Promise.resolve({ value: null, done: false }), t11;
        }
        return p(a10, [{ key: "summary", value: function() {
          return "".concat(this.upstream.summary(), " -> Serial");
        } }, { key: "next", value: (n10 = c(o().mark(function e11() {
          var t11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.lastRead = this.lastRead.then(function() {
                  return t11.serialNext();
                }), e12.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "serialNext", value: (t10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.abrupt("return", this.upstream.next());
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), a10;
      }(hme), vme = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11, t11) {
          var n11;
          return l(this, a10), (n11 = r10.call(this)).upstream = e11, n11.maxCount = t11, n11.count = 0, n11.lastRead = Promise.resolve({ value: null, done: false }), n11;
        }
        return p(a10, [{ key: "summary", value: function() {
          return "".concat(this.upstream.summary(), " -> Skip");
        } }, { key: "next", value: (n10 = c(o().mark(function e11() {
          var t11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.lastRead = this.lastRead.then(function() {
                  return t11.serialNext();
                }), e12.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "serialNext", value: (t10 = c(o().mark(function e11() {
          var t11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!(this.count++ < this.maxCount)) {
                  e12.next = 9;
                  break;
                }
                return e12.next = 3, this.upstream.next();
              case 3:
                if (!(t11 = e12.sent).done) {
                  e12.next = 6;
                  break;
                }
                return e12.abrupt("return", t11);
              case 6:
                Y5(t11.value), e12.next = 0;
                break;
              case 9:
                return e12.abrupt("return", this.upstream.next());
              case 10:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), a10;
      }(hme), mme = function(e10) {
        d(r10, e10);
        var t10, n10 = w(r10);
        function r10(e11, t11) {
          var a10;
          return l(this, r10), (a10 = n10.call(this)).upstream = e11, a10.maxCount = t11, a10.count = 0, a10;
        }
        return p(r10, [{ key: "summary", value: function() {
          return "".concat(this.upstream.summary(), " -> Take");
        } }, { key: "next", value: (t10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!(this.count++ >= this.maxCount)) {
                  e12.next = 2;
                  break;
                }
                return e12.abrupt("return", { value: null, done: true });
              case 2:
                return e12.abrupt("return", this.upstream.next());
              case 3:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), r10;
      }(hme), gme = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11, t11) {
          var n11, i10 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
          return l(this, a10), (n11 = r10.call(this)).upstream = e11, n11.batchSize = t11, n11.enableSmallLastBatch = i10, n11.lastRead = Promise.resolve({ value: null, done: false }), n11;
        }
        return p(a10, [{ key: "summary", value: function() {
          return "".concat(this.upstream.summary(), " -> RowMajorBatch");
        } }, { key: "next", value: (n10 = c(o().mark(function e11() {
          var t11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.lastRead = this.lastRead.then(function() {
                  return t11.serialNext();
                }), e12.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "serialNext", value: (t10 = c(o().mark(function e11() {
          var t11, n11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                t11 = [];
              case 1:
                if (!(t11.length < this.batchSize)) {
                  e12.next = 12;
                  break;
                }
                return e12.next = 4, this.upstream.next();
              case 4:
                if (!(n11 = e12.sent).done) {
                  e12.next = 9;
                  break;
                }
                if (!(this.enableSmallLastBatch && t11.length > 0)) {
                  e12.next = 8;
                  break;
                }
                return e12.abrupt("return", { value: t11, done: false });
              case 8:
                return e12.abrupt("return", { value: null, done: true });
              case 9:
                t11.push(n11.value), e12.next = 1;
                break;
              case 12:
                return e12.abrupt("return", { value: t11, done: false });
              case 13:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), a10;
      }(hme), yme = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11, t11) {
          var n11;
          return l(this, a10), (n11 = r10.call(this)).upstream = e11, n11.predicate = t11, n11.lastRead = Promise.resolve({ value: null, done: false }), n11;
        }
        return p(a10, [{ key: "summary", value: function() {
          return "".concat(this.upstream.summary(), " -> Filter");
        } }, { key: "next", value: (n10 = c(o().mark(function e11() {
          var t11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.lastRead = this.lastRead.then(function() {
                  return t11.serialNext();
                }), e12.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "serialNext", value: (t10 = c(o().mark(function e11() {
          var t11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 3, this.upstream.next();
              case 3:
                if (!(t11 = e12.sent).done && !this.predicate(t11.value)) {
                  e12.next = 6;
                  break;
                }
                return e12.abrupt("return", t11);
              case 6:
                Y5(t11.value), e12.next = 0;
                break;
              case 9:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), a10;
      }(hme), bme = function(e10) {
        d(r10, e10);
        var t10, n10 = w(r10);
        function r10(e11, t11) {
          var a10;
          return l(this, r10), (a10 = n10.call(this)).upstream = e11, a10.transform = t11, a10;
        }
        return p(r10, [{ key: "summary", value: function() {
          return "".concat(this.upstream.summary(), " -> Map");
        } }, { key: "next", value: (t10 = c(o().mark(function e11() {
          var t11, n11, r11, a10, i10, s10, u10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.upstream.next();
              case 2:
                if (!(t11 = e12.sent).done) {
                  e12.next = 5;
                  break;
                }
                return e12.abrupt("return", { value: null, done: true });
              case 5:
                n11 = y5(t11.value), r11 = this.transform(t11.value), a10 = y5(r11), i10 = O(n11);
                try {
                  for (i10.s(); !(s10 = i10.n()).done; ) g5(u10 = s10.value, a10) || u10.dispose();
                } catch (e13) {
                  i10.e(e13);
                } finally {
                  i10.f();
                }
                return e12.abrupt("return", { value: r11, done: false });
              case 11:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), r10;
      }(hme), xme = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11, t11) {
          var n11;
          return l(this, a10), (n11 = r10.call(this)).upstream = e11, n11.handler = t11, n11.count = 0, n11.lastRead = Promise.resolve({ value: null, done: false }), n11;
        }
        return p(a10, [{ key: "summary", value: function() {
          return "".concat(this.upstream.summary(), " -> handleErrors");
        } }, { key: "next", value: (n10 = c(o().mark(function e11() {
          var t11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.lastRead = this.lastRead.then(function() {
                  return t11.serialNext();
                }), e12.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "serialNext", value: (t10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.prev = 1, e12.next = 4, this.upstream.next();
              case 4:
                return e12.abrupt("return", e12.sent);
              case 7:
                if (e12.prev = 7, e12.t0 = e12.catch(1), this.handler(e12.t0)) {
                  e12.next = 11;
                  break;
                }
                return e12.abrupt("return", { value: null, done: true });
              case 11:
                e12.next = 0;
                break;
              case 13:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[1, 7]]);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), a10;
      }(hme), kme = function(e10) {
        d(r10, e10);
        var t10, n10 = w(r10);
        function r10(e11, t11) {
          var a10;
          return l(this, r10), (a10 = n10.call(this)).upstream = e11, a10.transform = t11, a10;
        }
        return p(r10, [{ key: "summary", value: function() {
          return "".concat(this.upstream.summary(), " -> AsyncMap");
        } }, { key: "next", value: (t10 = c(o().mark(function e11() {
          var t11, n11, r11, a10, i10, s10, u10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.upstream.next();
              case 2:
                if (!(t11 = e12.sent).done) {
                  e12.next = 5;
                  break;
                }
                return e12.abrupt("return", { value: null, done: true });
              case 5:
                return n11 = y5(t11.value), e12.next = 8, this.transform(t11.value);
              case 8:
                r11 = e12.sent, a10 = y5(r11), i10 = O(n11);
                try {
                  for (i10.s(); !(s10 = i10.n()).done; ) g5(u10 = s10.value, a10) || u10.dispose();
                } catch (e13) {
                  i10.e(e13);
                } finally {
                  i10.f();
                }
                return e12.abrupt("return", { value: r11, done: false });
              case 13:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), r10;
      }(hme), wme = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10() {
          var e11;
          return l(this, a10), (e11 = r10.call(this)).outputQueue = new ime(), e11.lastRead = Promise.resolve({ value: null, done: false }), e11;
        }
        return p(a10, [{ key: "next", value: (n10 = c(o().mark(function e11() {
          var t11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.lastRead = this.lastRead.then(function() {
                  return t11.serialNext();
                }), e12.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "serialNext", value: (t10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (0 !== this.outputQueue.length()) {
                  e12.next = 7;
                  break;
                }
                return e12.next = 3, this.pump();
              case 3:
                if (e12.sent) {
                  e12.next = 5;
                  break;
                }
                return e12.abrupt("return", { value: null, done: true });
              case 5:
                e12.next = 0;
                break;
              case 7:
                return e12.abrupt("return", { value: this.outputQueue.shift(), done: false });
              case 8:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), a10;
      }(hme), Ime = function(e10) {
        d(r10, e10);
        var t10, n10 = w(r10);
        function r10(e11, t11) {
          var a10;
          return l(this, r10), (a10 = n10.call(this)).upstream = e11, a10.transform = t11, a10;
        }
        return p(r10, [{ key: "summary", value: function() {
          return "".concat(this.upstream.summary(), " -> Flatmap");
        } }, { key: "pump", value: (t10 = c(o().mark(function e11() {
          var t11, n11, r11, a10, i10, s10, u10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.upstream.next();
              case 2:
                if (!(t11 = e12.sent).done) {
                  e12.next = 5;
                  break;
                }
                return e12.abrupt("return", false);
              case 5:
                n11 = y5(t11.value), r11 = this.transform(t11.value), a10 = y5(r11), this.outputQueue.pushAll(r11), i10 = O(n11);
                try {
                  for (i10.s(); !(s10 = i10.n()).done; ) g5(u10 = s10.value, a10) || u10.dispose();
                } catch (e13) {
                  i10.e(e13);
                } finally {
                  i10.f();
                }
                return e12.abrupt("return", true);
              case 12:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), r10;
      }(wme), Nme = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11, t11) {
          var n11;
          return l(this, a10), (n11 = r10.call(this)).baseErrorHandler = t11, n11.lastRead = null, n11.iterator = null, n11.moreIterators = e11, n11;
        }
        return p(a10, [{ key: "summary", value: function() {
          return "".concat("TODO: fill in upstream of chained summaries", " -> Chained");
        } }, { key: "next", value: (n10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.lastRead = this.readFromChain(this.lastRead), e12.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "readFromChain", value: (t10 = c(o().mark(function e11(t11) {
          var n11, r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, t11;
              case 2:
                if (null != this.iterator) {
                  e12.next = 10;
                  break;
                }
                return e12.next = 5, this.moreIterators.next();
              case 5:
                if (!(n11 = e12.sent).done) {
                  e12.next = 8;
                  break;
                }
                return e12.abrupt("return", { value: null, done: true });
              case 8:
                this.iterator = n11.value, null != this.baseErrorHandler && (this.iterator = this.iterator.handleErrors(this.baseErrorHandler));
              case 10:
                return e12.next = 12, this.iterator.next();
              case 12:
                if (!(r11 = e12.sent).done) {
                  e12.next = 16;
                  break;
                }
                return this.iterator = null, e12.abrupt("return", this.readFromChain(t11));
              case 16:
                return e12.abrupt("return", r11);
              case 17:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }]), a10;
      }(hme);
      !function(e10) {
        e10[e10.FAIL = 0] = "FAIL", e10[e10.SHORTEST = 1] = "SHORTEST", e10[e10.LONGEST = 2] = "LONGEST";
      }(lme || (lme = {}));
      var Sme = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11) {
          var t11, n11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : lme.FAIL;
          return l(this, a10), (t11 = r10.call(this)).iterators = e11, t11.mismatchMode = n11, t11.count = 0, t11.currentPromise = null, t11;
        }
        return p(a10, [{ key: "summary", value: function() {
          return "{".concat("TODO: fill in upstream of zip summaries", "} -> Zip");
        } }, { key: "nextState", value: (n10 = c(o().mark(function e11(t11) {
          var n11, r11, a11, i10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return a11 = function(e13) {
                  return e13 instanceof hme ? { value: e13.next().then(function(e14) {
                    return n11++, e14.done && r11++, e14.value;
                  }), recurse: false } : { value: null, recurse: true };
                }, e12.next = 3, t11;
              case 3:
                return n11 = 0, r11 = 0, e12.next = 7, Qve(this.iterators, a11);
              case 7:
                if (i10 = e12.sent, n11 !== r11) {
                  e12.next = 10;
                  break;
                }
                return e12.abrupt("return", { value: null, done: true });
              case 10:
                if (!(r11 > 0)) {
                  e12.next = 16;
                  break;
                }
                e12.t0 = this.mismatchMode, e12.next = e12.t0 === lme.FAIL ? 14 : e12.t0 === lme.SHORTEST ? 15 : (e12.t0, lme.LONGEST, 16);
                break;
              case 14:
                throw new Error("Zipped streams should have the same length. " + "Mismatched at element ".concat(this.count, "."));
              case 15:
                return e12.abrupt("return", { value: null, done: true });
              case 16:
                return this.count++, e12.abrupt("return", { value: i10, done: false });
              case 18:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return n10.apply(this, arguments);
        }) }, { key: "next", value: (t10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.currentPromise = this.nextState(this.currentPromise), e12.abrupt("return", this.currentPromise);
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), a10;
      }(hme), Tme = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10(e11, r10) {
          var a10;
          return l(this, n10), (a10 = t10.call(this)).upstream = e11, a10.bufferSize = r10, a10.buffer = new ame(r10), a10;
        }
        return p(n10, [{ key: "summary", value: function() {
          return "".concat(this.upstream.summary(), " -> Prefetch");
        } }, { key: "refill", value: function() {
          for (; !this.buffer.isFull(); ) {
            var e11 = this.upstream.next();
            this.buffer.push(e11);
          }
        } }, { key: "next", value: function() {
          return this.refill(), this.buffer.shift();
        } }]), n10;
      }(hme), Eme = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10(e11, t11, n11) {
          var i10;
          return l(this, a10), (i10 = r10.call(this, e11, t11)).upstream = e11, i10.windowSize = t11, i10.upstreamExhausted = false, i10.random = qee.alea(n11 || z4().toString()), i10.lastRead = Promise.resolve({ value: null, done: false }), i10;
        }
        return p(a10, [{ key: "next", value: (n10 = c(o().mark(function e11() {
          var t11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.lastRead = this.lastRead.then(function() {
                  return t11.serialNext();
                }), e12.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "randomInt", value: function(e11) {
          return Math.floor(this.random() * e11);
        } }, { key: "chooseIndex", value: function() {
          return this.randomInt(this.buffer.length());
        } }, { key: "serialNext", value: (t10 = c(o().mark(function e11() {
          var t11, n11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                this.upstreamExhausted || this.refill();
              case 1:
                if (this.buffer.isEmpty()) {
                  e12.next = 14;
                  break;
                }
                return t11 = this.chooseIndex(), e12.next = 5, this.buffer.shuffleExcise(t11);
              case 5:
                if (!(n11 = e12.sent).done) {
                  e12.next = 10;
                  break;
                }
                this.upstreamExhausted = true, e12.next = 12;
                break;
              case 10:
                return this.refill(), e12.abrupt("return", n11);
              case 12:
                e12.next = 1;
                break;
              case 14:
                return e12.abrupt("return", { value: null, done: true });
              case 15:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), a10;
      }(Tme), Cme = function() {
        function e10() {
          l(this, e10), this.size = null;
        }
        var t10, n10;
        return p(e10, [{ key: "batch", value: function(e11) {
          var t11, n11 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], r10 = this;
          return F$(e11 > 0, function() {
            return "batchSize needs to be positive, but it is\n      ".concat(e11);
          }), t11 = this.size === 1 / 0 || null == this.size ? this.size : n11 ? Math.ceil(this.size / e11) : Math.floor(this.size / e11), Ame(c(o().mark(function t12() {
            return o().wrap(function(t13) {
              for (; ; ) switch (t13.prev = t13.next) {
                case 0:
                  return t13.next = 2, r10.iterator();
                case 2:
                  return t13.abrupt("return", t13.sent.columnMajorBatch(e11, n11, Rme));
                case 3:
                case "end":
                  return t13.stop();
              }
            }, t12);
          })), t11);
        } }, { key: "concatenate", value: function(e11) {
          var t11, n11 = this;
          return t11 = this.size === 1 / 0 || e11.size === 1 / 0 ? 1 / 0 : null != this.size && null != e11.size ? this.size + e11.size : null, Ame(c(o().mark(function t12() {
            return o().wrap(function(t13) {
              for (; ; ) switch (t13.prev = t13.next) {
                case 0:
                  return t13.next = 2, n11.iterator();
                case 2:
                  return t13.t0 = t13.sent, t13.next = 5, e11.iterator();
                case 5:
                  return t13.t1 = t13.sent, t13.abrupt("return", t13.t0.concatenate.call(t13.t0, t13.t1));
                case 7:
                case "end":
                  return t13.stop();
              }
            }, t12);
          })), t11);
        } }, { key: "filter", value: function(e11) {
          var t11, n11 = this;
          return t11 = this.size === 1 / 0 ? 1 / 0 : null, Ame(c(o().mark(function t12() {
            return o().wrap(function(t13) {
              for (; ; ) switch (t13.prev = t13.next) {
                case 0:
                  return t13.next = 2, n11.iterator();
                case 2:
                  return t13.abrupt("return", t13.sent.filter(function(t14) {
                    return X5(function() {
                      return e11(t14);
                    });
                  }));
                case 3:
                case "end":
                  return t13.stop();
              }
            }, t12);
          })), t11);
        } }, { key: "forEachAsync", value: (n10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.iterator();
              case 2:
                return e12.abrupt("return", e12.sent.forEachAsync(t11));
              case 3:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return n10.apply(this, arguments);
        }) }, { key: "map", value: function(e11) {
          var t11 = this;
          return Ame(c(o().mark(function n11() {
            return o().wrap(function(n12) {
              for (; ; ) switch (n12.prev = n12.next) {
                case 0:
                  return n12.next = 2, t11.iterator();
                case 2:
                  return n12.abrupt("return", n12.sent.map(function(t12) {
                    return X5(function() {
                      return e11(t12);
                    });
                  }));
                case 3:
                case "end":
                  return n12.stop();
              }
            }, n11);
          })), this.size);
        } }, { key: "mapAsync", value: function(e11) {
          var t11 = this;
          return Ame(c(o().mark(function n11() {
            return o().wrap(function(n12) {
              for (; ; ) switch (n12.prev = n12.next) {
                case 0:
                  return n12.next = 2, t11.iterator();
                case 2:
                  return n12.abrupt("return", n12.sent.mapAsync(e11));
                case 3:
                case "end":
                  return n12.stop();
              }
            }, n11);
          })), this.size);
        } }, { key: "prefetch", value: function(e11) {
          if (null == e11) throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
          var t11 = this;
          return Ame(c(o().mark(function n11() {
            return o().wrap(function(n12) {
              for (; ; ) switch (n12.prev = n12.next) {
                case 0:
                  return n12.next = 2, t11.iterator();
                case 2:
                  return n12.abrupt("return", n12.sent.prefetch(e11));
                case 3:
                case "end":
                  return n12.stop();
              }
            }, n11);
          })), this.size);
        } }, { key: "repeat", value: function(e11) {
          var t11, n11 = this;
          return t11 = null != this.size && e11 > 0 ? this.size * e11 : 0 === e11 ? 0 : null != this.size && (void 0 === e11 || e11 < 0) ? 1 / 0 : null, Ame(c(o().mark(function t12() {
            var r10;
            return o().wrap(function(t13) {
              for (; ; ) switch (t13.prev = t13.next) {
                case 0:
                  return r10 = sme(c(o().mark(function e12() {
                    return o().wrap(function(e13) {
                      for (; ; ) switch (e13.prev = e13.next) {
                        case 0:
                          return e13.next = 2, n11.iterator();
                        case 2:
                          return e13.t0 = e13.sent, e13.abrupt("return", { value: e13.t0, done: false });
                        case 4:
                        case "end":
                          return e13.stop();
                      }
                    }, e12);
                  }))), t13.abrupt("return", ume(r10.take(e11)));
                case 2:
                case "end":
                  return t13.stop();
              }
            }, t12);
          })), t11);
        } }, { key: "skip", value: function(e11) {
          var t11, n11 = this;
          return t11 = null != this.size && e11 >= 0 && this.size >= e11 ? this.size - e11 : null != this.size && (this.size < e11 || void 0 === e11 || e11 < 0) ? 0 : null, Ame(c(o().mark(function t12() {
            return o().wrap(function(t13) {
              for (; ; ) switch (t13.prev = t13.next) {
                case 0:
                  return t13.next = 2, n11.iterator();
                case 2:
                  return t13.abrupt("return", t13.sent.skip(e11));
                case 3:
                case "end":
                  return t13.stop();
              }
            }, t12);
          })), t11);
        } }, { key: "shuffle", value: function(e11, t11) {
          var n11 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
          if (null == e11 || e11 < 0) throw null == this.size ? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.") : new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting " + "bufferSize to the dataset size (".concat(this.size, " elements)"));
          var r10 = this, a10 = qee.alea(t11 || z4().toString());
          return Ame(c(o().mark(function t12() {
            var i10;
            return o().wrap(function(t13) {
              for (; ; ) switch (t13.prev = t13.next) {
                case 0:
                  return i10 = a10.int32(), n11 && (i10 += a10.int32()), t13.next = 4, r10.iterator();
                case 4:
                  return t13.abrupt("return", t13.sent.shuffle(e11, i10.toString()));
                case 5:
                case "end":
                  return t13.stop();
              }
            }, t12);
          })), this.size);
        } }, { key: "take", value: function(e11) {
          var t11, n11 = this;
          return t11 = null != this.size && this.size > e11 ? e11 : null != this.size && this.size <= e11 ? this.size : null, Ame(c(o().mark(function t12() {
            return o().wrap(function(t13) {
              for (; ; ) switch (t13.prev = t13.next) {
                case 0:
                  return t13.next = 2, n11.iterator();
                case 2:
                  return t13.abrupt("return", t13.sent.take(e11));
                case 3:
                case "end":
                  return t13.stop();
              }
            }, t12);
          })), t11);
        } }, { key: "toArray", value: function() {
          var e11 = c(o().mark(function e12() {
            return o().wrap(function(e13) {
              for (; ; ) switch (e13.prev = e13.next) {
                case 0:
                  if (this.size !== 1 / 0) {
                    e13.next = 2;
                    break;
                  }
                  throw new Error("Can not convert infinite data stream to array.");
                case 2:
                  return e13.next = 4, this.iterator();
                case 4:
                  return e13.abrupt("return", e13.sent.toArray());
                case 5:
                case "end":
                  return e13.stop();
              }
            }, e12, this);
          }));
          return function() {
            return e11.apply(this, arguments);
          };
        }() }, { key: "toArrayForTest", value: (t10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (this.size !== 1 / 0) {
                  e12.next = 2;
                  break;
                }
                throw new Error("Can not convert infinite data stream to array.");
              case 2:
                return e12.next = 4, this.iterator();
              case 4:
                return e12.abrupt("return", e12.sent.toArrayForTest());
              case 5:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), e10;
      }();
      function Ame(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        return new (function(n10) {
          d(i10, n10);
          var r10, a10 = w(i10);
          function i10() {
            var e11;
            return l(this, i10), (e11 = a10.apply(this, arguments)).size = t10, e11;
          }
          return p(i10, [{ key: "iterator", value: (r10 = c(o().mark(function t11() {
            return o().wrap(function(t12) {
              for (; ; ) switch (t12.prev = t12.next) {
                case 0:
                  return t12.abrupt("return", e10());
                case 1:
                case "end":
                  return t12.stop();
              }
            }, t11);
          })), function() {
            return r10.apply(this, arguments);
          }) }]), i10;
        }(Cme))();
      }
      function Rme(e10) {
        return null === e10 ? null : tme(e10[0]) ? { value: function(e11) {
          if (0 === e11.length) throw new Error("Can't make a batch of zero elements.");
          return e11[0] instanceof n5 ? Pte(e11) : V5(e11);
        }(e10), recurse: false } : { value: null, recurse: true };
      }
      Cme.MAX_BUFFER_SIZE = 1e4;
      var _me = function(e10) {
        d(r10, e10);
        var t10, n10 = w(r10);
        function r10(e11) {
          var t11;
          return l(this, r10), (t11 = n10.call(this)).input = e11, t11;
        }
        return p(r10, [{ key: "iterator", value: (t10 = c(o().mark(function e11() {
          var t11, n11, r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.input.iterator();
              case 2:
                return t11 = e12.sent, n11 = t11.decodeUTF8(), r11 = n11.split("\n").map(function(e13) {
                  return e13.endsWith("\r") && (e13 = e13.slice(0, -1)), e13;
                }), e12.abrupt("return", r11);
              case 6:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), r10;
      }(Cme), Ome = '"', Fme = Symbol("out"), Dme = Symbol("field"), Mme = Symbol("quote"), Lme = Symbol("quoteafterquote"), zme = Symbol("quoteinquote"), Pme = function(e10) {
        d(s10, e10);
        var t10, n10, r10, a10, i10 = w(s10);
        function s10(e11, t11) {
          var n11;
          return l(this, s10), (n11 = i10.call(this)).input = e11, n11.hasHeader = true, n11.fullColumnNames = null, n11.columnNamesValidated = false, n11.columnConfigs = null, n11.configuredColumnsOnly = false, n11.delimiter = ",", n11.delimWhitespace = false, n11.base = new _me(e11), t11 || (t11 = {}), n11.hasHeader = false !== t11.hasHeader, n11.fullColumnNames = t11.columnNames, n11.columnConfigs = t11.columnConfigs, n11.configuredColumnsOnly = t11.configuredColumnsOnly, t11.delimWhitespace ? (F$(null == t11.delimiter, function() {
            return "Delimiter should not be provided when delimWhitespace is true.";
          }), n11.delimWhitespace = true, n11.delimiter = " ") : n11.delimiter = t11.delimiter ? t11.delimiter : ",", n11;
        }
        return p(s10, [{ key: "columnNames", value: (a10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (this.columnNamesValidated) {
                  e12.next = 3;
                  break;
                }
                return e12.next = 3, this.setColumnNames();
              case 3:
                return e12.abrupt("return", this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames);
              case 4:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return a10.apply(this, arguments);
        }) }, { key: "setColumnNames", value: (r10 = c(o().mark(function e11() {
          var t11, n11, r11, a11, i11, s11, u10 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.maybeReadHeaderLine();
              case 2:
                if (t11 = e12.sent, this.fullColumnNames || t11) {
                  e12.next = 7;
                  break;
                }
                throw new Error("Column names must be provided if there is no header line.");
              case 7:
                this.fullColumnNames && t11 && F$(t11.length === this.fullColumnNames.length, function() {
                  return "The length of provided columnNames (" + u10.fullColumnNames.length.toString() + ") does not match the length of the header line read from file (" + t11.length.toString() + ").";
                });
              case 8:
                if (this.fullColumnNames || (this.fullColumnNames = t11), n11 = this.fullColumnNames.reduce(function(e13, t12) {
                  return e13[t12] = e13[t12] + 1 || 1, e13;
                }, {}), F$(0 === (r11 = Object.keys(n11).filter(function(e13) {
                  return n11[e13] > 1;
                })).length, function() {
                  return "Duplicate column names found: " + r11.toString();
                }), !this.columnConfigs) {
                  e12.next = 22;
                  break;
                }
                a11 = 0, i11 = Object.keys(this.columnConfigs);
              case 14:
                if (!(a11 < i11.length)) {
                  e12.next = 22;
                  break;
                }
                if (s11 = i11[a11], -1 !== this.fullColumnNames.indexOf(s11)) {
                  e12.next = 19;
                  break;
                }
                throw new Error('The key "' + s11 + '" provided in columnConfigs does not match any of the column names (' + this.fullColumnNames.toString() + ").");
              case 19:
                a11++, e12.next = 14;
                break;
              case 22:
                this.columnNamesValidated = true;
              case 23:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return r10.apply(this, arguments);
        }) }, { key: "maybeReadHeaderLine", value: (n10 = c(o().mark(function e11() {
          var t11, n11, r11, a11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!this.hasHeader) {
                  e12.next = 14;
                  break;
                }
                return e12.next = 3, this.base.iterator();
              case 3:
                return t11 = e12.sent, e12.next = 6, t11.next();
              case 6:
                if (!(n11 = e12.sent).done) {
                  e12.next = 9;
                  break;
                }
                throw new Error("No data was found for CSV parsing.");
              case 9:
                return r11 = n11.value, a11 = this.parseRow(r11, false), e12.abrupt("return", a11);
              case 14:
                return e12.abrupt("return", null);
              case 15:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "iterator", value: (t10 = c(o().mark(function e11() {
          var t11, n11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (this.columnNamesValidated) {
                  e12.next = 3;
                  break;
                }
                return e12.next = 3, this.setColumnNames();
              case 3:
                return e12.next = 5, this.base.iterator();
              case 5:
                return t11 = e12.sent, this.hasHeader && (t11 = t11.skip(1)), e12.abrupt("return", t11.map(function(e13) {
                  return n11.makeDataElement(e13);
                }));
              case 8:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }, { key: "makeDataElement", value: function(e11) {
          for (var t11 = this.parseRow(e11), n11 = {}, r11 = {}, a11 = 0; a11 < this.fullColumnNames.length; a11++) {
            var i11 = this.fullColumnNames[a11], o10 = this.columnConfigs ? this.columnConfigs[i11] : null;
            if (!this.configuredColumnsOnly || o10) {
              var s11 = t11[a11], u10 = null;
              if ("" === s11) if (o10 && void 0 !== o10.default) u10 = o10.default;
              else {
                if (o10 && (o10.required || o10.isLabel)) throw new Error("Required column ".concat(i11, " is empty in this line: ").concat(e11));
                u10 = void 0;
              }
              else {
                var c10 = Number(s11);
                if (isNaN(c10)) u10 = o10 && "bool" === o10.dtype ? this.getBoolean(s11) : s11;
                else if (o10 && o10.dtype) switch (o10.dtype) {
                  case "float32":
                  default:
                    u10 = c10;
                    break;
                  case "int32":
                    u10 = Math.floor(c10);
                    break;
                  case "bool":
                    u10 = this.getBoolean(s11);
                }
                else u10 = c10;
              }
              o10 && o10.isLabel ? r11[i11] = u10 : n11[i11] = u10;
            }
          }
          return 0 === Object.keys(r11).length ? n11 : { xs: n11, ys: r11 };
        } }, { key: "getBoolean", value: function(e11) {
          return "1" === e11 || "true" === e11.toLowerCase() ? 1 : 0;
        } }, { key: "parseRow", value: function(e11) {
          for (var t11 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n11 = [], r11 = 0, a11 = e11.length, i11 = Fme, o10 = 0; o10 < a11; o10++) switch (i11) {
            case Fme:
              switch (e11.charAt(o10)) {
                case Ome:
                  r11 = o10 + 1, i11 = Mme;
                  break;
                case this.delimiter:
                  if (r11 = o10 + 1, " " === this.delimiter && this.delimWhitespace) break;
                  n11.push(""), i11 = Fme;
                  break;
                default:
                  i11 = Dme, r11 = o10;
              }
              break;
            case Dme:
              if (e11.charAt(o10) === this.delimiter) n11.push(e11.substring(r11, o10)), i11 = Fme, r11 = o10 + 1;
              break;
            case Mme:
              if (e11.charAt(o10) === Ome) i11 = Lme;
              break;
            case Lme:
              switch (e11.charAt(o10)) {
                case this.delimiter:
                  n11.push(e11.substring(r11, o10 - 1)), i11 = Fme, r11 = o10 + 1;
                  break;
                case Ome:
                  i11 = Mme;
                  break;
                default:
                  i11 = zme;
              }
              break;
            case zme:
              if (e11.charAt(o10) === Ome) i11 = Mme;
          }
          if (i11 === Lme ? n11.push(e11.substring(r11, a11 - 1)) : n11.push(e11.substring(r11)), t11 && n11.length !== this.fullColumnNames.length) throw new Error("Invalid row in csv file. Should have ".concat(this.fullColumnNames.length, " elements in a row, but got ").concat(n11));
          return n11;
        } }]), s10;
      }(Cme), Bme = function(e10) {
        d(u10, e10);
        var t10, n10, r10, a10, i10, s10 = w(u10);
        function u10(e11) {
          var t11;
          l(this, u10), (t11 = s10.call(this)).microphoneConfig = e11, t11.isClosed = false, t11.fftSize = e11.fftSize || 1024;
          var n11 = Math.log2(t11.fftSize);
          if (t11.fftSize < 0 || n11 < 4 || n11 > 14 || !Number.isInteger(n11)) throw new Error("Invalid fftSize: it must be a power of 2 between " + "2 to 4 and 2 to 14, but got ".concat(t11.fftSize));
          if (t11.numFrames = e11.numFramesPerSpectrogram || 43, t11.sampleRateHz = e11.sampleRateHz, t11.columnTruncateLength = e11.columnTruncateLength || t11.fftSize, t11.audioTrackConstraints = e11.audioTrackConstraints, t11.smoothingTimeConstant = e11.smoothingTimeConstant || 0, t11.includeSpectrogram = false !== e11.includeSpectrogram, t11.includeWaveform = true === e11.includeWaveform, !t11.includeSpectrogram && !t11.includeWaveform) throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
          return t11;
        }
        return p(u10, [{ key: "summary", value: function() {
          return "microphone";
        } }, { key: "start", value: (i10 = c(o().mark(function e11() {
          var t11, n11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.prev = 0, e12.next = 3, navigator.mediaDevices.getUserMedia({ audio: null == this.audioTrackConstraints || this.audioTrackConstraints, video: false });
              case 3:
                this.stream = e12.sent, e12.next = 9;
                break;
              case 6:
                throw e12.prev = 6, e12.t0 = e12.catch(0), new Error("Error thrown while initializing video stream: ".concat(e12.t0.message));
              case 9:
                if (this.stream) {
                  e12.next = 11;
                  break;
                }
                throw new Error("Could not obtain audio from microphone.");
              case 11:
                if (t11 = window.AudioContext || window.webkitAudioContext, this.audioContext = new t11(), this.sampleRateHz) {
                  e12.next = 17;
                  break;
                }
                this.sampleRateHz = this.audioContext.sampleRate, e12.next = 19;
                break;
              case 17:
                if (this.audioContext.sampleRate === this.sampleRateHz) {
                  e12.next = 19;
                  break;
                }
                throw new Error("Mismatch in sampling rate: " + "Expected: ".concat(this.sampleRateHz, "; ") + "Actual: ".concat(this.audioContext.sampleRate));
              case 19:
                return n11 = this.audioContext.createMediaStreamSource(this.stream), this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 2 * this.fftSize, this.analyser.smoothingTimeConstant = this.smoothingTimeConstant, n11.connect(this.analyser), this.freqData = new Float32Array(this.fftSize), this.timeData = new Float32Array(this.fftSize), e12.abrupt("return");
              case 27:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[0, 6]]);
        })), function() {
          return i10.apply(this, arguments);
        }) }, { key: "next", value: (a10 = c(o().mark(function e11() {
          var t11, n11, r11, a11, i11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!this.isClosed) {
                  e12.next = 2;
                  break;
                }
                return e12.abrupt("return", { value: null, done: true });
              case 2:
                return e12.next = 4, this.getAudioData();
              case 4:
                return r11 = e12.sent, this.includeSpectrogram && (a11 = this.flattenQueue(r11.freqDataQueue), t11 = this.getTensorFromAudioDataArray(a11, [this.numFrames, this.columnTruncateLength, 1])), this.includeWaveform && (i11 = this.flattenQueue(r11.timeDataQueue), n11 = this.getTensorFromAudioDataArray(i11, [this.numFrames * this.fftSize, 1])), e12.abrupt("return", { value: { spectrogram: t11, waveform: n11 }, done: false });
              case 8:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return a10.apply(this, arguments);
        }) }, { key: "capture", value: (r10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.next();
              case 2:
                return e12.abrupt("return", e12.sent.value);
              case 3:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return r10.apply(this, arguments);
        }) }, { key: "getAudioData", value: (n10 = c(o().mark(function e11() {
          var t11, n11, r11, a11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return t11 = [], n11 = [], r11 = 0, e12.abrupt("return", new Promise(function(e13) {
                  var i11 = setInterval(function() {
                    a11.includeSpectrogram && (a11.analyser.getFloatFrequencyData(a11.freqData), a11.freqData[0] === -1 / 0 && e13({ freqDataQueue: t11, timeDataQueue: n11 }), t11.push(a11.freqData.slice(0, a11.columnTruncateLength))), a11.includeWaveform && (a11.analyser.getFloatTimeDomainData(a11.timeData), n11.push(a11.timeData.slice())), ++r11 === a11.numFrames && (clearInterval(i11), e13({ freqDataQueue: t11, timeDataQueue: n11 }));
                  }, a11.fftSize / a11.sampleRateHz * 1e3);
                }));
              case 4:
              case "end":
                return e12.stop();
            }
          }, e11);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "stop", value: function() {
          this.isClosed || (this.isClosed = true, this.analyser.disconnect(), this.audioContext.close(), null != this.stream && this.stream.getTracks().length > 0 && this.stream.getTracks()[0].stop());
        } }, { key: "toArray", value: function() {
          throw new Error("Can not convert infinite audio stream to array.");
        } }, { key: "getSampleRate", value: function() {
          return this.sampleRateHz;
        } }, { key: "flattenQueue", value: function(e11) {
          var t11 = e11[0].length, n11 = new Float32Array(e11.length * t11);
          return e11.forEach(function(e12, r11) {
            return n11.set(e12, r11 * t11);
          }), n11;
        } }, { key: "getTensorFromAudioDataArray", value: function(e11, t11) {
          var n11 = new Float32Array(L$(t11));
          return n11.set(e11, n11.length - e11.length), V5(n11, t11);
        } }], [{ key: "create", value: (t10 = c(o().mark(function e11() {
          var t11, n11, r11 = arguments;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (t11 = r11.length > 0 && void 0 !== r11[0] ? r11[0] : {}, k0().get("IS_BROWSER")) {
                  e12.next = 3;
                  break;
                }
                throw new Error("microphone API is only supported in browser environment.");
              case 3:
                return n11 = new u10(t11), e12.next = 6, n11.start();
              case 6:
                return e12.abrupt("return", n11);
              case 7:
              case "end":
                return e12.stop();
            }
          }, e11);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), u10;
      }(hme), Wme = function(e10) {
        d(s10, e10);
        var t10, n10, r10, a10, i10 = w(s10);
        function s10(e11, t11) {
          var n11;
          if (l(this, s10), (n11 = i10.call(this)).webcamVideoElement = e11, n11.webcamConfig = t11, n11.isClosed = true, n11.resize = false, n11.needToResize()) if (n11.resize = true, n11.cropSize = [n11.webcamConfig.resizeHeight, n11.webcamConfig.resizeWidth], n11.cropBoxInd = Vte([0], "int32"), n11.webcamConfig.centerCrop) {
            var r11 = 1 * n11.webcamConfig.resizeWidth / n11.webcamVideoElement.width, a11 = 1 * n11.webcamConfig.resizeHeight / n11.webcamVideoElement.height, o10 = (1 - r11) / 2, u10 = (1 - a11) / 2, c10 = o10 + r11, h10 = a11 + u10;
            n11.cropBox = Gte([u10, o10, h10, c10], [1, 4]);
          } else n11.cropBox = Gte([0, 0, 1, 1], [1, 4]);
          return n11;
        }
        return p(s10, [{ key: "summary", value: function() {
          return "webcam";
        } }, { key: "start", value: (a10 = c(o().mark(function e11() {
          var t11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return this.webcamConfig.facingMode && F$("user" === this.webcamConfig.facingMode || "environment" === this.webcamConfig.facingMode, function() {
                  return "Invalid webcam facing mode: ".concat(t11.webcamConfig.facingMode, ". ") + "Please provide 'user' or 'environment'";
                }), e12.prev = 1, e12.next = 4, navigator.mediaDevices.getUserMedia({ video: { deviceId: this.webcamConfig.deviceId, facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user", width: this.webcamVideoElement.width, height: this.webcamVideoElement.height } });
              case 4:
                this.stream = e12.sent, e12.next = 11;
                break;
              case 7:
                throw e12.prev = 7, e12.t0 = e12.catch(1), e12.t0.message = "Error thrown while initializing video stream: ".concat(e12.t0.message), e12.t0;
              case 11:
                if (this.stream) {
                  e12.next = 13;
                  break;
                }
                throw new Error("Could not obtain video from webcam.");
              case 13:
                try {
                  this.webcamVideoElement.srcObject = this.stream;
                } catch (e13) {
                  console.log(e13), this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);
                }
                return this.webcamVideoElement.play(), this.isClosed = false, e12.abrupt("return", new Promise(function(e13) {
                  t11.webcamVideoElement.onloadedmetadata = function() {
                    e13();
                  };
                }));
              case 17:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[1, 7]]);
        })), function() {
          return a10.apply(this, arguments);
        }) }, { key: "next", value: (r10 = c(o().mark(function e11() {
          var t11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!this.isClosed) {
                  e12.next = 2;
                  break;
                }
                return e12.abrupt("return", { value: null, done: true });
              case 2:
                e12.prev = 2, t11 = Fae(this.webcamVideoElement), e12.next = 9;
                break;
              case 6:
                throw e12.prev = 6, e12.t0 = e12.catch(2), new Error("Error thrown converting video to pixels: ".concat(JSON.stringify(e12.t0)));
              case 9:
                if (!this.resize) {
                  e12.next = 22;
                  break;
                }
                return e12.prev = 10, e12.abrupt("return", { value: this.cropAndResizeFrame(t11), done: false });
              case 14:
                throw e12.prev = 14, e12.t1 = e12.catch(10), new Error("Error thrown cropping the video: ".concat(e12.t1.message));
              case 17:
                return e12.prev = 17, t11.dispose(), e12.finish(17);
              case 20:
                e12.next = 23;
                break;
              case 22:
                return e12.abrupt("return", { value: t11, done: false });
              case 23:
              case "end":
                return e12.stop();
            }
          }, e11, this, [[2, 6], [10, 14, 17, 20]]);
        })), function() {
          return r10.apply(this, arguments);
        }) }, { key: "needToResize", value: function() {
          return !(!this.webcamConfig.resizeWidth || !this.webcamConfig.resizeHeight || this.webcamVideoElement.width === this.webcamConfig.resizeWidth && this.webcamVideoElement.height === this.webcamConfig.resizeHeight);
        } }, { key: "cropAndResizeFrame", value: function(e11) {
          var t11 = this;
          return X5(function() {
            var n11, r11 = f9(h8(e11, "float32"), 0), a11 = (n11 = Pre.cropAndResize(r11, t11.cropBox, t11.cropBoxInd, t11.cropSize, "bilinear")).shape;
            return X8(n11, a11.slice(1));
          });
        } }, { key: "capture", value: (n10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.next();
              case 2:
                return e12.abrupt("return", e12.sent.value);
              case 3:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "stop", value: function() {
          this.stream.getTracks().forEach(function(e11) {
            return e11.stop();
          });
          try {
            this.webcamVideoElement.srcObject = null;
          } catch (e11) {
            console.log(e11), this.webcamVideoElement.src = null;
          }
          this.isClosed = true;
        } }, { key: "toArray", value: function() {
          throw new Error("Can not convert infinite video stream to array.");
        } }], [{ key: "create", value: (t10 = c(o().mark(function e11(t11) {
          var n11, r11, a11 = arguments;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (n11 = a11.length > 1 && void 0 !== a11[1] ? a11[1] : {}, k0().get("IS_BROWSER")) {
                  e12.next = 3;
                  break;
                }
                throw new Error("tf.data.webcam is only supported in browser environment.");
              case 3:
                if (t11) {
                  e12.next = 9;
                  break;
                }
                if (t11 = document.createElement("video"), n11.resizeWidth && n11.resizeHeight) {
                  e12.next = 7;
                  break;
                }
                throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
              case 7:
                t11.width = n11.resizeWidth, t11.height = n11.resizeHeight;
              case 9:
                return r11 = new s10(t11, n11), e12.next = 12, r11.start();
              case 12:
                return e12.abrupt("return", r11);
              case 13:
              case "end":
                return e12.stop();
            }
          }, e11);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }]), s10;
      }(hme), Ume = p(function e10() {
        l(this, e10);
      }), Vme = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "split", value: function(e11) {
          return new Gme(this, e11);
        } }]), n10;
      }(hme), Gme = function(e10) {
        d(r10, e10);
        var t10, n10 = w(r10);
        function r10(e11, t11) {
          var a10;
          return l(this, r10), (a10 = n10.call(this)).upstream = e11, a10.impl = new jme(e11, t11), a10;
        }
        return p(r10, [{ key: "summary", value: function() {
          return this.impl.summary();
        } }, { key: "next", value: (t10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.abrupt("return", this.impl.next());
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), r10;
      }(Vme), jme = function(e10) {
        d(r10, e10);
        var t10, n10 = w(r10);
        function r10(e11, t11) {
          var a10;
          return l(this, r10), (a10 = n10.call(this)).upstream = e11, a10.separator = t11, a10.carryover = "", a10;
        }
        return p(r10, [{ key: "summary", value: function() {
          return "".concat(this.upstream.summary(), " -> Split('").concat(this.separator, "')");
        } }, { key: "pump", value: (t10 = c(o().mark(function e11() {
          var t11, n11, r11, a10, i10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.upstream.next();
              case 2:
                if (!(t11 = e12.sent).done) {
                  e12.next = 9;
                  break;
                }
                if ("" !== this.carryover) {
                  e12.next = 6;
                  break;
                }
                return e12.abrupt("return", false);
              case 6:
                return this.outputQueue.push(this.carryover), this.carryover = "", e12.abrupt("return", true);
              case 9:
                (n11 = t11.value.split(this.separator))[0] = this.carryover + n11[0], r11 = O(n11.slice(0, -1));
                try {
                  for (r11.s(); !(a10 = r11.n()).done; ) i10 = a10.value, this.outputQueue.push(i10);
                } catch (e13) {
                  r11.e(e13);
                } finally {
                  r11.f();
                }
                return this.carryover = n11[n11.length - 1], e12.abrupt("return", true);
              case 15:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), r10;
      }(wme), Hme = function(e10) {
        d(n10, e10);
        var t10 = w(n10);
        function n10() {
          return l(this, n10), t10.apply(this, arguments);
        }
        return p(n10, [{ key: "decodeUTF8", value: function() {
          return new qme(this);
        } }]), n10;
      }(hme), qme = function(e10) {
        d(r10, e10);
        var t10, n10 = w(r10);
        function r10(e11) {
          var t11;
          return l(this, r10), (t11 = n10.call(this)).upstream = e11, t11.impl = new Kme(e11), t11;
        }
        return p(r10, [{ key: "summary", value: function() {
          return this.impl.summary();
        } }, { key: "next", value: (t10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.abrupt("return", this.impl.next());
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), r10;
      }(Vme), Kme = function(e10) {
        d(r10, e10);
        var t10, n10 = w(r10);
        function r10(e11) {
          var t11;
          if (l(this, r10), (t11 = n10.call(this)).upstream = e11, k0().get("IS_BROWSER")) t11.decoder = new TextDecoder("utf-8");
          else {
            var a10 = require_string_decoder().StringDecoder;
            t11.decoder = new a10("utf8");
          }
          return t11;
        }
        return p(r10, [{ key: "summary", value: function() {
          return "".concat(this.upstream.summary(), " -> Utf8");
        } }, { key: "pump", value: (t10 = c(o().mark(function e11() {
          var t11, n11, r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, this.upstream.next();
              case 2:
                if (!(t11 = e12.sent).done) {
                  e12.next = 7;
                  break;
                }
                return e12.abrupt("return", false);
              case 7:
                n11 = t11.value;
              case 8:
                return r11 = k0().get("IS_BROWSER") ? this.decoder.decode(n11, { stream: true }) : this.decoder.write(Buffer.from(n11.buffer)), this.outputQueue.push(r11), e12.abrupt("return", true);
              case 11:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), r10;
      }(wme), Xme = function(e10) {
        d(r10, e10);
        var t10, n10 = w(r10);
        function r10(e11) {
          var t11, a10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          return l(this, r10), (t11 = n10.call(this)).file = e11, t11.options = a10, F$(e11 instanceof Uint8Array || !!k0().get("IS_BROWSER") && (e11 instanceof File || e11 instanceof Blob), function() {
            return "FileChunkIterator only supports File, Blob and Uint8Array right now.";
          }), t11.offset = a10.offset || 0, t11.chunkSize = a10.chunkSize || 1048576, t11;
        }
        return p(r10, [{ key: "summary", value: function() {
          return "FileChunks ".concat(this.file);
        } }, { key: "next", value: (t10 = c(o().mark(function e11() {
          var t11, n11 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!(this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size))) {
                  e12.next = 2;
                  break;
                }
                return e12.abrupt("return", { value: null, done: true });
              case 2:
                return t11 = new Promise(function(e13, t12) {
                  var r11 = n11.offset + n11.chunkSize;
                  if (n11.file instanceof Uint8Array) e13(new Uint8Array(n11.file.slice(n11.offset, r11)));
                  else {
                    var a10 = new FileReader();
                    a10.onload = function(n12) {
                      var r12 = a10.result;
                      if (r12 instanceof ArrayBuffer && (r12 = new Uint8Array(r12)), !(r12 instanceof Uint8Array)) return t12(new TypeError("FileReader returned unknown type."));
                      e13(r12);
                    }, a10.onabort = function(e14) {
                      return t12(new Error("Aborted"));
                    }, a10.onerror = function(e14) {
                      return t12(new Error(e14.type));
                    };
                    var i10 = n11.file.slice(n11.offset, r11);
                    a10.readAsArrayBuffer(i10);
                  }
                  n11.offset = r11;
                }), e12.next = 5, t11;
              case 5:
                return e12.t0 = e12.sent, e12.abrupt("return", { value: e12.t0, done: false });
              case 7:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), r10;
      }(Hme);
      function Yme(e10) {
        return Jme.apply(this, arguments);
      }
      function Jme() {
        return Jme = c(o().mark(function e10(t10) {
          var n10, r10, a10, i10, s10, u10, c10 = arguments;
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return n10 = c10.length > 1 && void 0 !== c10[1] ? c10[1] : {}, r10 = c10.length > 2 ? c10[2] : void 0, "string" == typeof t10 ? a10 = t10 : (a10 = t10.url, i10 = Zme(t10)), e11.next = 5, (r10 || P4)(a10, i10);
              case 5:
                if (!(s10 = e11.sent).ok) {
                  e11.next = 15;
                  break;
                }
                return e11.t0 = Uint8Array, e11.next = 10, s10.arrayBuffer();
              case 10:
                return e11.t1 = e11.sent, u10 = new e11.t0(e11.t1), e11.abrupt("return", new Xme(u10, n10));
              case 15:
                throw new Error(s10.statusText);
              case 16:
              case "end":
                return e11.stop();
            }
          }, e10);
        })), Jme.apply(this, arguments);
      }
      var Zme = function(e10) {
        return { method: e10.method, headers: e10.headers, body: e10.body, mode: e10.mode, credentials: e10.credentials, cache: e10.cache, redirect: e10.redirect, referrer: e10.referrer, integrity: e10.integrity };
      };
      function Qme(e10) {
        return "string" == typeof e10 && "file://" === e10.slice(0, 7);
      }
      var $me = function(e10) {
        d(r10, e10);
        var t10, n10 = w(r10);
        function r10(e11) {
          var t11, a10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          return l(this, r10), (t11 = n10.call(this)).input = e11, t11.options = a10, t11;
        }
        return p(r10, [{ key: "iterator", value: (t10 = c(o().mark(function e11() {
          var t11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return Qme(this.input) && k0().get("IS_NODE") && (t11 = require_fs(), this.input = t11.readFileSync(this.input.slice(7))), e12.abrupt("return", new Xme(this.input, this.options));
              case 2:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), r10;
      }(Ume), ege = function(e10) {
        d(r10, e10);
        var t10, n10 = w(r10);
        function r10(e11) {
          var t11, a10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          return l(this, r10), (t11 = n10.call(this)).url = e11, t11.fileOptions = a10, t11;
        }
        return p(r10, [{ key: "iterator", value: (t10 = c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!Qme(this.url)) {
                  e12.next = 4;
                  break;
                }
                return e12.abrupt("return", new $me(this.url, this.fileOptions).iterator());
              case 4:
                return e12.abrupt("return", Yme(this.url, this.fileOptions));
              case 5:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return t10.apply(this, arguments);
        }) }]), r10;
      }(Ume);
      function tge() {
        return (tge = c(o().mark(function e10(t10, n10) {
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return e11.abrupt("return", Wme.create(t10, n10));
              case 1:
              case "end":
                return e11.stop();
            }
          }, e10);
        }))).apply(this, arguments);
      }
      function nge() {
        return (nge = c(o().mark(function e10(t10) {
          return o().wrap(function(e11) {
            for (; ; ) switch (e11.prev = e11.next) {
              case 0:
                return e11.abrupt("return", Bme.create(t10));
              case 1:
              case "end":
                return e11.stop();
            }
          }, e10);
        }))).apply(this, arguments);
      }
      var rge = "4.17.0", age = { __proto__: null, CSVDataset: Pme, Dataset: Cme, FileDataSource: $me, TextLineDataset: _me, URLDataSource: ege, array: function(e10) {
        return Ame(c(o().mark(function t10() {
          return o().wrap(function(t11) {
            for (; ; ) switch (t11.prev = t11.next) {
              case 0:
                return t11.abrupt("return", ome(e10));
              case 1:
              case "end":
                return t11.stop();
            }
          }, t10);
        })), e10.length);
      }, csv: function(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return new Pme(new ege(e10), t10);
      }, func: function(e10) {
        var t10 = sme(e10);
        return Ame(c(o().mark(function e11() {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.abrupt("return", t10);
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11);
        })));
      }, generator: function(e10) {
        return Ame(c(o().mark(function t10() {
          var n10;
          return o().wrap(function(t11) {
            for (; ; ) switch (t11.prev = t11.next) {
              case 0:
                return t11.next = 2, e10();
              case 2:
                return n10 = t11.sent, t11.abrupt("return", sme(function() {
                  return n10.next();
                }));
              case 4:
              case "end":
                return t11.stop();
            }
          }, t10);
        })));
      }, microphone: function(e10) {
        return nge.apply(this, arguments);
      }, version_data: rge, webcam: function(e10, t10) {
        return tge.apply(this, arguments);
      }, zip: function(e10) {
        if (!eme(e10)) throw new Error("The argument to zip() must be an object or array.");
        var t10;
        if (Array.isArray(e10)) for (var n10 = 0; n10 < e10.length; n10++) t10 = null == t10 ? e10[n10].size : Math.min(t10, e10[n10].size);
        else if (e10 instanceof Object) for (var r10 in e10) t10 = null == t10 ? e10[r10].size : Math.min(t10, e10[r10].size);
        return Ame(c(o().mark(function t11() {
          var n11;
          return o().wrap(function(t12) {
            for (; ; ) switch (t12.prev = t12.next) {
              case 0:
                return t12.next = 2, Qve(e10, function(e11) {
                  if (e11 instanceof Cme) return { value: e11.iterator(), recurse: false };
                  if (eme(e11)) return { value: null, recurse: true };
                  throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.");
                });
              case 2:
                return n11 = t12.sent, t12.abrupt("return", cme(n11, lme.SHORTEST));
              case 4:
              case "end":
                return t12.stop();
            }
          }, t11);
        })), t10);
      } };
      function ige(e10, t10) {
        Array.isArray(e10) || (e10 = [e10]), e10.forEach(function(e11) {
          null != e11 && F$("complex64" !== e11.dtype, function() {
            return "".concat(t10, " does not support complex64 tensors in the CPU backend.");
          });
        });
      }
      var oge = one, sge = function(e10) {
        d(a10, e10);
        var t10, n10, r10 = w(a10);
        function a10() {
          var e11;
          return l(this, a10), (e11 = r10.call(this)).blockSize = 48, e11.firstUse = true, e11.data = new S$(x(e11), q5()), e11;
        }
        return p(a10, [{ key: "nextDataId", value: function() {
          return a10.nextDataId++;
        } }, { key: "write", value: function(e11, t11, n11) {
          this.firstUse && (this.firstUse = false, k0().get("IS_NODE") && z3("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));
          var r11 = { id: this.nextDataId() };
          return this.data.set(r11, { values: e11, dtype: n11, refCount: 1 }), r11;
        } }, { key: "makeTensorInfo", value: function(e11, t11, n11) {
          var r11;
          if ("string" === t11 && null != n11 && n11.length > 0 && $$(n11[0])) {
            var a11 = n11.map(function(e12) {
              return B4(e12);
            });
            r11 = this.write(a11, e11, t11);
          } else r11 = this.write(n11, e11, t11);
          return { dataId: r11, shape: e11, dtype: t11 };
        } }, { key: "refCount", value: function(e11) {
          return this.data.has(e11) ? this.data.get(e11).refCount : 0;
        } }, { key: "incRef", value: function(e11) {
          this.data.get(e11).refCount++;
        } }, { key: "decRef", value: function(e11) {
          this.data.has(e11) && this.data.get(e11).refCount--;
        } }, { key: "move", value: function(e11, t11, n11, r11, a11) {
          this.data.set(e11, { values: t11, dtype: r11, refCount: a11 });
        } }, { key: "numDataIds", value: function() {
          return this.data.numDataIds();
        } }, { key: "read", value: (n10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.abrupt("return", this.readSync(t11));
              case 1:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return n10.apply(this, arguments);
        }) }, { key: "readSync", value: function(e11) {
          var t11 = this.data.get(e11), n11 = t11.dtype, r11 = t11.complexTensorInfos;
          return "complex64" === n11 ? Tie(this.readSync(r11.real.dataId), this.readSync(r11.imag.dataId)) : u0(this.data.get(e11).values, n11);
        } }, { key: "bufferSync", value: function(e11) {
          var t11 = this.readSync(e11.dataId);
          if ("string" === e11.dtype) try {
            var n11 = t11.map(function(e12) {
              return W4(e12);
            });
            return l8(e11.shape, e11.dtype, n11);
          } catch (e12) {
            throw new Error("Failed to decode encoded string bytes into utf-8");
          }
          return l8(e11.shape, e11.dtype, t11);
        } }, { key: "makeOutput", value: function(e11, t11, n11) {
          return q5().makeTensorFromTensorInfo(this.makeTensorInfo(t11, n11, e11), this);
        } }, { key: "disposeData", value: function(e11) {
          var t11 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          if (this.data.has(e11)) {
            if (this.data.get(e11).refCount--, !t11 && this.data.get(e11).refCount > 0) return false;
            var n11 = this.data.get(e11), r11 = n11.complexTensorInfos;
            null != r11 && (this.disposeData(r11.real.dataId, true), this.disposeData(r11.imag.dataId, true)), this.data.delete(e11);
          }
          return true;
        } }, { key: "disposeIntermediateTensorInfo", value: function(e11) {
          this.disposeData(e11.dataId);
        } }, { key: "time", value: (t10 = c(o().mark(function e11(t11) {
          var n11, r11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return n11 = z4(), t11(), r11 = z4() - n11, e12.abrupt("return", { kernelMs: r11 });
              case 4:
              case "end":
                return e12.stop();
            }
          }, e11);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "memory", value: function() {
          return { unreliable: true, reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."] };
        } }, { key: "where", value: function(e11) {
          ige([e11], "where");
          var t11 = this.readSync(e11.dataId);
          return oge(e11.shape, t11);
        } }, { key: "dispose", value: function() {
        } }, { key: "floatPrecision", value: function() {
          return 32;
        } }, { key: "epsilon", value: function() {
          return N(v(a10.prototype), "epsilon", this).call(this);
        } }]), a10;
      }(T$);
      function uge(e10) {
        for (var t10 = new Float32Array(e10.length), n10 = 0; n10 < e10.length; ++n10) t10[n10] = Math.abs(e10[n10]);
        return t10;
      }
      sge.nextDataId = 0;
      var cge = { kernelName: N0, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs.x, n10 = e10.backend;
        ige(t10, "abs");
        var r10 = new Float32Array(L$(t10.shape));
        return r10 = uge(n10.data.get(t10.dataId).values), n10.makeOutput(r10, t10.shape, t10.dtype);
      } };
      function lge(e10) {
        return function(t10, n10, r10, a10, i10) {
          var o10 = z7(t10, n10), s10 = o10.length, u10 = i0(o10), c10 = q$(i10, L$(o10)), l10 = t10.length, h10 = n10.length, p10 = i0(t10), f10 = i0(n10), d10 = M7(t10, o10), v10 = M7(n10, o10);
          if (d10.length + v10.length === 0) for (var m10 = 0; m10 < c10.length; ++m10) c10[m10] = e10(r10[m10 % r10.length], a10[m10 % a10.length]);
          else for (var g10 = function() {
            var t11 = d0(y10, s10, u10), n11 = t11.slice(-l10);
            d10.forEach(function(e11) {
              return n11[e11] = 0;
            });
            var i11 = f0(n11, l10, p10), o11 = t11.slice(-h10);
            v10.forEach(function(e11) {
              return o11[e11] = 0;
            });
            var m11 = f0(o11, h10, f10);
            c10[y10] = e10(r10[i11], a10[m11]);
          }, y10 = 0; y10 < c10.length; ++y10) g10();
          return [c10, o10];
        };
      }
      function hge(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.real, a10 = t10.imag, i10 = n10.data.get(r10.dataId).values, o10 = n10.data.get(a10.dataId).values, s10 = n10.makeTensorInfo(r10.shape, "complex64");
        return n10.data.get(s10.dataId).complexTensorInfos = { real: n10.makeTensorInfo(r10.shape, "float32", i10), imag: n10.makeTensorInfo(a10.shape, "float32", o10) }, s10;
      }
      var pge = { kernelName: Z0, backendName: "cpu", kernelFunc: hge };
      function fge(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "float32";
        if ("complex64" === n10) {
          var r10 = fge(e10, t10, "float32"), a10 = fge(e10, t10, "float32");
          return hge({ inputs: { real: r10, imag: a10 }, backend: e10 });
        }
        var i10 = l0(L$(t10), n10);
        return e10.makeTensorInfo(t10, n10, i10);
      }
      function dge(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.x;
        return n10.incRef(r10.dataId), { dataId: r10.dataId, shape: r10.shape, dtype: r10.dtype };
      }
      var vge = { kernelName: W1, backendName: "cpu", kernelFunc: dge };
      function mge(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.input, a10 = n10.data.get(r10.dataId).complexTensorInfos.real, i10 = n10.data.get(a10.dataId).values;
        return n10.makeTensorInfo(a10.shape, a10.dtype, i10);
      }
      var gge = { kernelName: D2, backendName: "cpu", kernelFunc: mge };
      function yge(e10, t10, n10, r10) {
        if ("int32" === r10) return [t10, "int32", Int32Array.from(e10)];
        if ("bool" === r10) {
          var a10 = L4([0], n10), i10 = S(lge(function(e11, t11) {
            return e11 !== t11 ? 1 : 0;
          })(t10, [], e10, a10, "bool"), 2), o10 = i10[0];
          return [i10[1], "bool", o10];
        }
        throw new Error("Error in Cast: failed to cast ".concat(n10, " to ").concat(r10));
      }
      function bge(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.dtype;
        if ("complex64" === i10) {
          if ("complex64" === a10.dtype) return dge({ inputs: { x: a10 }, backend: n10 });
          var o10 = fge(n10, a10.shape, a10.dtype), s10 = bge({ inputs: { x: a10 }, backend: n10, attrs: { dtype: "float32" } }), u10 = hge({ inputs: { real: s10, imag: o10 }, backend: n10 });
          return n10.disposeIntermediateTensorInfo(o10), n10.disposeIntermediateTensorInfo(s10), u10;
        }
        if ("complex64" === a10.dtype) {
          var c10 = mge({ inputs: { input: a10 }, backend: n10 }), l10 = bge({ inputs: { x: c10 }, backend: n10, attrs: { dtype: i10 } });
          return n10.disposeIntermediateTensorInfo(c10), l10;
        }
        if (!J$(a10.dtype, i10)) {
          var h10 = dge({ inputs: { x: a10 }, backend: n10 });
          return { dataId: h10.dataId, shape: h10.shape, dtype: i10 };
        }
        var p10 = S(yge(n10.data.get(a10.dataId).values, a10.shape, a10.dtype, i10), 3), f10 = p10[0], d10 = p10[1], v10 = p10[2];
        return n10.makeTensorInfo(f10, d10, v10);
      }
      var xge = { kernelName: X0, backendName: "cpu", kernelFunc: bge };
      function kge(e10, t10, n10, r10) {
        return null == n10 ? function(n11) {
          var a10 = n11.inputs, i10 = n11.backend, o10 = a10.a, s10 = a10.b, u10 = i10;
          ige([o10, s10], e10);
          var c10 = u10.data.get(o10.dataId).values, l10 = u10.data.get(s10.dataId).values, h10 = "string" === o10.dtype ? aoe(c10) : c10, p10 = "string" === o10.dtype ? aoe(l10) : l10, f10 = r10 || o10.dtype, d10 = S(t10(o10.shape, s10.shape, h10, p10, f10), 2), v10 = d10[0], m10 = d10[1];
          return u10.makeTensorInfo(m10, f10, v10);
        } : function(e11) {
          var a10 = e11.inputs, i10 = e11.backend, o10 = a10.a, s10 = a10.b, u10 = i10;
          if ("complex64" === o10.dtype || "complex64" === s10.dtype) {
            var c10 = bge({ inputs: { x: o10 }, backend: u10, attrs: { dtype: "complex64" } }), l10 = u10.data.get(c10.dataId), h10 = l10.complexTensorInfos.real, p10 = l10.complexTensorInfos.imag, f10 = u10.data.get(h10.dataId).values, d10 = u10.data.get(p10.dataId).values, v10 = bge({ inputs: { x: s10 }, backend: u10, attrs: { dtype: "complex64" } }), m10 = u10.data.get(v10.dataId), g10 = m10.complexTensorInfos.real, y10 = m10.complexTensorInfos.imag, b10 = u10.data.get(g10.dataId).values, x10 = u10.data.get(y10.dataId).values, k10 = S(n10(o10.shape, s10.shape, f10, d10, b10, x10), 3), w10 = k10[0], I10 = k10[1], N10 = k10[2], T10 = u10.makeTensorInfo(N10, "float32", w10), E10 = u10.makeTensorInfo(N10, "float32", I10), C10 = hge({ inputs: { real: T10, imag: E10 }, backend: u10 });
            return u10.disposeIntermediateTensorInfo(c10), u10.disposeIntermediateTensorInfo(v10), u10.disposeIntermediateTensorInfo(T10), u10.disposeIntermediateTensorInfo(E10), C10;
          }
          var A10 = u10.data.get(o10.dataId).values, R10 = u10.data.get(s10.dataId).values, _10 = r10 || o10.dtype, O10 = S(t10(o10.shape, s10.shape, A10, R10, _10), 2), F10 = O10[0], D10 = O10[1];
          return u10.makeTensorInfo(D10, _10, F10);
        };
      }
      function wge(e10) {
        return function(t10, n10, r10, a10, i10, o10) {
          var s10 = z7(t10, n10), u10 = L$(s10), c10 = s10.length, l10 = i0(s10), h10 = q$("float32", u10), p10 = q$("float32", u10), f10 = M7(t10, s10), d10 = M7(n10, s10), v10 = Tie(r10, a10), m10 = Tie(i10, o10), g10 = t10.length, y10 = i0(t10), b10 = n10.length, x10 = i0(n10);
          if (f10.length + d10.length === 0) for (var k10 = 0; k10 < h10.length; k10++) {
            var w10 = k10 % v10.length, I10 = k10 % m10.length, N10 = e10(v10[2 * w10], v10[2 * w10 + 1], m10[2 * I10], m10[2 * I10 + 1]);
            h10[k10] = N10.real, p10[k10] = N10.imag;
          }
          else for (var S10 = function() {
            var t11 = d0(T10, c10, l10), n11 = t11.slice(-g10);
            f10.forEach(function(e11) {
              return n11[e11] = 0;
            });
            var r11 = f0(n11, g10, y10), a11 = t11.slice(-b10);
            d10.forEach(function(e11) {
              return a11[e11] = 0;
            });
            var i11 = f0(a11, b10, x10), o11 = e10(v10[2 * r11], v10[2 * r11 + 1], m10[2 * i11], m10[2 * i11 + 1]);
            h10[T10] = o11.real, p10[T10] = o11.imag;
          }, T10 = 0; T10 < h10.length; T10++) S10();
          return [h10, p10, s10];
        };
      }
      var Ige = lge(function(e10, t10) {
        return e10 + t10;
      }), Nge = wge(function(e10, t10, n10, r10) {
        return { real: e10 + n10, imag: t10 + r10 };
      }), Sge = kge(E0, Ige, Nge), Tge = { kernelName: E0, backendName: "cpu", kernelFunc: Sge };
      function Ege(e10, t10, n10, r10, a10) {
        for (var i10 = L$(r10), o10 = l0(a10, n10), s10 = 0; s10 < e10.length; s10++) {
          var u10 = e10[s10];
          if (u10 < 0) throw new Error("Input x must be non-negative!");
          u10 >= a10 || (o10[u10] += i10 > 0 ? t10[s10] : 1);
        }
        return o10;
      }
      function Cge(e10, t10, n10) {
        for (var r10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a10 = e10.shape[0], i10 = e10.shape[1], o10 = l8([a10, n10], t10.dtype), s10 = 0; s10 < a10; s10++) for (var u10 = 0; u10 < i10; u10++) {
          var c10 = e10.get(s10, u10);
          if (c10 < 0) throw new Error("Input x must be non-negative!");
          c10 >= n10 || (r10 ? o10.set(1, s10, c10) : t10.size > 0 ? o10.set(o10.get(s10, c10) + t10.get(s10, u10), s10, c10) : o10.set(o10.get(s10, c10) + 1, s10, c10));
        }
        return o10;
      }
      var Age = lge(function(e10, t10) {
        return e10 & t10;
      }), Rge = kge(H0, Age), _ge = { kernelName: H0, backendName: "cpu", kernelFunc: Rge };
      function Oge(e10) {
        return function(t10, n10, r10) {
          for (var a10 = K$(n10, t10.length), i10 = 0; i10 < t10.length; ++i10) a10[i10] = e10(t10[i10], r10);
          return a10;
        };
      }
      function Fge(e10, t10, n10) {
        return Dge(e10, Oge(t10), n10);
      }
      function Dge(e10, t10, n10) {
        return function(r10) {
          var a10 = r10.inputs, i10 = r10.attrs, o10 = r10.backend, s10 = a10.x;
          ige(s10, e10);
          var u10, c10 = o10, l10 = c10.data.get(s10.dataId).values;
          if ("string" === s10.dtype) {
            if (!Array.isArray(l10)) throw new Error("String tensor's value was not an instance of Array");
            u10 = aoe(l10);
          } else u10 = l10;
          var h10 = n10 || s10.dtype, p10 = t10(u10, h10, i10);
          return c10.makeTensorInfo(s10.shape, h10, p10);
        };
      }
      var Mge = Oge(function(e10) {
        return Math.ceil(e10);
      }), Lge = Dge(Y0, Mge), zge = { kernelName: Y0, backendName: "cpu", kernelFunc: Lge };
      function Pge(e10, t10, n10, r10) {
        var a10 = K$(n10, L$(t10));
        if (r10 && "string" !== n10) {
          var i10 = 0;
          e10.forEach(function(e11) {
            var t11 = L$(e11.shape);
            a10.set(e11.vals, i10), i10 += t11;
          });
        } else {
          var o10 = 0;
          e10.forEach(function(e11) {
            for (var r11 = "string" === n10 ? aoe(e11.vals) : e11.vals, i11 = 0, s10 = 0; s10 < e11.shape[0]; ++s10) for (var u10 = s10 * t10[1] + o10, c10 = 0; c10 < e11.shape[1]; ++c10) a10[u10 + c10] = r11[i11++];
            o10 += e11.shape[1];
          });
        }
        return a10;
      }
      var Bge = lge(function(e10, t10) {
        return e10 === t10 ? 1 : 0;
      }), Wge = kge(T1, Bge, null, "bool"), Uge = { kernelName: T1, backendName: "cpu", kernelFunc: Wge }, Vge = Oge(function(e10) {
        return Math.exp(e10);
      }), Gge = Dge(E1, Vge, "float32"), jge = { kernelName: E1, backendName: "cpu", kernelFunc: Gge }, Hge = Oge(function(e10) {
        return Math.expm1(e10);
      }), qge = Dge(A1, Hge), Kge = { kernelName: A1, backendName: "cpu", kernelFunc: qge }, Xge = Oge(function(e10) {
        return Math.floor(e10);
      }), Yge = Dge(F1, Xge), Jge = { kernelName: F1, backendName: "cpu", kernelFunc: Yge }, Zge = lge(function(e10, t10) {
        return Math.floor(e10 / t10);
      }), Qge = kge(D1, Zge, null, "int32"), $ge = { kernelName: D1, backendName: "cpu", kernelFunc: Qge };
      function eye(e10, t10, n10, r10, a10, i10, o10, s10, u10) {
        for (var c10 = l8([r10, i10], n10), l10 = 0; l10 < r10; l10++) {
          for (var h10 = [], p10 = 0, f10 = 0; f10 < a10; f10++) {
            var d10 = e10[l10 * a10 + f10];
            p10 += d10 * o10[f10], h10.push(d10);
          }
          if (p10 < 0 || p10 >= u10 / i10) throw new Error("Invalid indices: ".concat(h10, " does not index into ").concat(s10));
          for (var v10 = 0; v10 < i10; v10++) c10.values[l10 * i10 + v10] = t10.get.apply(t10, T(t10.indexToLoc(p10 * i10 + v10)));
        }
        return c10;
      }
      function tye(e10, t10, n10) {
        for (var r10 = l8(n10, e10.dtype), a10 = 0; a10 < r10.size; ++a10) {
          var i10 = r10.indexToLoc(a10).slice(), o10 = i10[0], s10 = i10[2], u10 = t10.locToIndex([o10, s10]);
          i10[2] = t10.values[u10];
          var c10 = e10.locToIndex(i10);
          0 <= c10 && c10 < e10.values.length && (r10.values[a10] = e10.values[c10]);
        }
        return r10;
      }
      var nye = lge(function(e10, t10) {
        return e10 > t10 ? 1 : 0;
      }), rye = kge(P1, nye, null, "bool"), aye = { kernelName: P1, backendName: "cpu", kernelFunc: rye }, iye = lge(function(e10, t10) {
        return e10 >= t10 ? 1 : 0;
      }), oye = kge(B1, iye, null, "bool"), sye = { kernelName: B1, backendName: "cpu", kernelFunc: oye }, uye = lge(function(e10, t10) {
        return e10 < t10 ? 1 : 0;
      }), cye = kge(K1, uye, null, "bool"), lye = { kernelName: K1, backendName: "cpu", kernelFunc: cye }, hye = lge(function(e10, t10) {
        return e10 <= t10 ? 1 : 0;
      }), pye = kge(X1, hye, null, "bool"), fye = { kernelName: X1, backendName: "cpu", kernelFunc: pye };
      function dye(e10, t10, n10) {
        var r10 = (t10 - e10) / (n10 - 1), a10 = l0(n10, "float32");
        a10[0] = e10;
        for (var i10 = 1; i10 < a10.length; i10++) a10[i10] = a10[i10 - 1] + r10;
        return a10;
      }
      var vye = Oge(function(e10) {
        return Math.log(e10);
      }), mye = Dge(J1, vye), gye = { kernelName: J1, backendName: "cpu", kernelFunc: mye };
      function yye(e10, t10, n10, r10) {
        for (var a10 = q$(r10, L$(n10)), i10 = 0; i10 < a10.length; ++i10) {
          for (var o10 = i10 * t10, s10 = e10[o10], u10 = 0; u10 < t10; ++u10) {
            var c10 = e10[o10 + u10];
            (Number.isNaN(c10) || c10 > s10) && (s10 = c10);
          }
          a10[i10] = s10;
        }
        return a10;
      }
      var bye = lge(function(e10, t10) {
        return Math.max(e10, t10);
      }), xye = kge(i2, bye), kye = { kernelName: i2, backendName: "cpu", kernelFunc: xye }, wye = lge(function(e10, t10) {
        return Math.min(e10, t10);
      }), Iye = kge(f2, wye), Nye = { kernelName: f2, backendName: "cpu", kernelFunc: Iye }, Sye = lge(function(e10, t10) {
        return e10 * t10;
      }), Tye = wge(function(e10, t10, n10, r10) {
        return { real: e10 * n10 - t10 * r10, imag: e10 * r10 + t10 * n10 };
      }), Eye = kge(g2, Sye, Tye), Cye = { kernelName: g2, backendName: "cpu", kernelFunc: Eye };
      function Aye(e10, t10, n10) {
        var r10 = M4(-1, n10);
        return Sye([], t10, r10, e10, n10);
      }
      var Rye = { kernelName: y2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.x;
        ige(r10, "neg");
        var a10 = S(Aye(n10.data.get(r10.dataId).values, r10.shape, r10.dtype), 2), i10 = a10[0], o10 = a10[1];
        return n10.makeTensorInfo(o10, r10.dtype, i10);
      } }, _ye = lge(function(e10, t10) {
        return e10 !== t10 ? 1 : 0;
      }), Oye = kge(b2, _ye, null, "bool"), Fye = { kernelName: b2, backendName: "cpu", kernelFunc: Oye };
      function Dye(e10, t10, n10, r10, a10) {
        for (var i10 = t10.length, o10 = L$(t10), s10 = i0(t10), u10 = i0(a10), c10 = q$(n10, L$(a10)), l10 = 0; l10 < o10; ++l10) {
          for (var h10 = d0(l10, i10, s10), p10 = new Array(h10.length), f10 = 0; f10 < p10.length; f10++) p10[f10] = h10[r10[f10]];
          c10[f0(p10, i10, u10)] = e10[l10];
        }
        return c10;
      }
      function Mye(e10) {
        var t10 = e10.inputs, n10 = e10.attrs, r10 = e10.backend, a10 = t10.x, i10 = n10.perm;
        ige(a10, "transpose");
        for (var o10 = a10.shape.length, s10 = new Array(o10), u10 = 0; u10 < s10.length; u10++) s10[u10] = a10.shape[i10[u10]];
        var c10 = Dye(r10.data.get(a10.dataId).values, a10.shape, a10.dtype, i10, s10);
        return { dataId: r10.write(c10, s10, a10.dtype), shape: s10, dtype: a10.dtype };
      }
      var Lye = { kernelName: T3, backendName: "cpu", kernelFunc: Mye };
      function zye(e10, t10, n10, r10) {
        for (var a10 = S(J7(e10, r10), 2), i10 = a10[0], o10 = a10[1], s10 = h5(t10, "int32"), u10 = l0(L$(i10), s10), c10 = L$(o10), l10 = 0; l10 < u10.length; ++l10) {
          for (var h10 = l10 * c10, p10 = 1, f10 = 0; f10 < c10; ++f10) p10 *= n10[h10 + f10];
          u10[l10] = p10;
        }
        return { outVals: u10, outShape: i10, outDtype: s10 };
      }
      var Pye = { kernelName: A2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.axis, o10 = r10.keepDims;
        ige(a10, "prod");
        var s10 = a10.shape.length, u10 = j$(i10, a10.shape), c10 = $7(u10, s10), l10 = u10, h10 = a10, p10 = [];
        null != c10 && (h10 = Mye({ inputs: { x: a10 }, backend: n10, attrs: { perm: c10 } }), p10.push(h10), l10 = t9(l10.length, s10));
        var f10 = n10.data.get(h10.dataId).values, d10 = zye(h10.shape, h10.dtype, f10, l10), v10 = d10.outVals, m10 = d10.outShape, g10 = d10.outDtype, y10 = m10;
        return o10 && (y10 = Z7(m10, u10)), p10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), n10.makeTensorInfo(y10, g10, v10);
      } };
      function Bye(e10, t10, n10, r10) {
        var a10 = [], i10 = 0, o10 = t10.length - 1 + n10.length, s10 = new Array(o10).fill(null).map(function() {
          return [0];
        });
        !function(e11, t11) {
          for (var n11 = 0; n11 < e11.length; ++n11) {
            var r11 = e11[n11], a11 = n11 === e11.length - 1 ? t11 : e11[n11 + 1].length;
            if (0 === r11.length) throw new Error("Ragged splits may not be empty");
            if (r11[0] < 0) throw new Error("Ragged splits must be non-negative");
            if (r11[r11.length - 1] > a11) throw new Error("Ragged splits must not point past values");
            for (var i11 = 1; i11 < r11.length; ++i11) if (r11[i11 - 1] > r11[i11]) throw new Error("Ragged splits must be sorted in ascending order");
          }
        }(n10, r10);
        for (var u10 = 1, c10 = 0; c10 < t10.length - 1; ++c10) {
          u10 *= t10[c10];
          for (var l10 = t10[c10 + 1], h10 = 1; h10 < u10 + 1; ++h10) s10[c10].push(h10 * l10);
        }
        for (var p10 = 0; p10 < e10.length; ++p10) {
          for (var f10 = e10[p10], d10 = e10[p10] + 1, v10 = 0; v10 < n10.length; ++v10) {
            var m10 = n10[v10], g10 = v10 + t10.length - 1;
            if (g10 >= 0) for (var y10 = s10[g10], b10 = y10[y10.length - 1] - m10[f10], x10 = f10; x10 < d10; ++x10) s10[g10].push(m10[x10 + 1] + b10);
            f10 = m10[f10], d10 = m10[d10];
          }
          d10 !== f10 && (a10.push([f10, d10]), i10 += d10 - f10);
        }
        return { outSplits: s10, valueSlices: a10, numValues: i10 };
      }
      function Wye(e10, t10) {
        for (var n10 = e10.slice(0, t10); n10.length < t10; ) n10.push(1);
        for (var r10 = t10; r10 < e10.length; r10++) n10[t10 - 1] *= e10[r10];
        return n10;
      }
      function Uye(e10, t10, n10, r10, a10) {
        var i10 = t10.slice();
        i10[0] = a10;
        var o10 = K$(n10, L$(i10)), s10 = e10.length;
        return function(e11, t11, n11, r11, a11, i11) {
          var o11, s11 = Wye(t11, 2)[1], u10 = Wye(i11, 2)[1], c10 = 0, l10 = O(n11);
          try {
            for (l10.s(); !(o11 = l10.n()).done; ) for (var h10 = o11.value, p10 = h10[0]; p10 < h10[1]; ++p10) {
              for (var f10 = 0; f10 < r11; ++f10) a11[c10 * u10 + f10] = e11[p10 * s11 + f10];
              ++c10;
            }
          } catch (e12) {
            l10.e(e12);
          } finally {
            l10.f();
          }
        }(e10, t10, r10, 0 === s10 ? 0 : s10 / t10[0], o10, i10), [o10, i10];
      }
      function Vye(e10, t10, n10, r10, a10, i10, o10, s10) {
        if (0 === e10.length) throw new Error("paramsNestedSplits must be non empty");
        if (0 === t10[0].length) throw new Error("Split tensors must not be scalars");
        if (function(e11, t11, n11) {
          e11.forEach(function(e12, r11) {
            if (e12 < 0 || e12 >= n11) {
              var a11 = d0(r11, t11.length, i0(t11)).join(",");
              throw new Error("indices[".concat(a11, "] = ").concat(e12, " is not in [0, ").concat(n11, ")"));
            }
          });
        }(i10, o10, t10[0][0] - 1), 0 === r10.length) throw new Error("params.rank must be nonzero");
        var u10 = Bye(i10, o10, e10, r10[0]), c10 = u10.outSplits, l10 = u10.valueSlices, h10 = u10.numValues, p10 = function(e11) {
          for (var t11 = [], n11 = function() {
            var n12 = K$("int32", e11[r11].length);
            t11.push(n12), e11[r11].forEach(function(e12, t12) {
              return n12[t12] = e12;
            });
          }, r11 = 0; r11 < e11.length; ++r11) n11();
          return t11;
        }(c10), f10 = Uye(n10, r10, a10, l10, h10);
        return [p10, f10[0], f10[1]];
      }
      var Gye = 2147483647;
      function jye(e10, t10, n10, r10, a10, i10, o10) {
        if (t10.length > 1) throw new Error("starts must be a scalar or vector");
        if (a10.length > 1) throw new Error("limits must be a scalar or vector");
        if (o10.length > 1) throw new Error("deltas must be a scalar or vector");
        var s10 = 0 === t10.length, u10 = 0 === a10.length, c10 = 0 === o10.length, l10 = [];
        s10 || l10.push(t10[0]), u10 || l10.push(a10[0]), c10 || l10.push(o10[0]);
        for (var h10 = 1; h10 < l10.length; ++h10) if (l10[h10] !== l10[h10 - 1]) throw new Error("starts, limits, and deltas must have the same shape");
        var p10 = 0 === l10.length ? 1 : l10[0], f10 = K$("int32", p10 + 1);
        f10[0] = 0;
        for (var d10 = 0; d10 < p10; ++d10) {
          var v10 = s10 ? e10[0] : e10[d10], m10 = u10 ? r10[0] : r10[d10], g10 = c10 ? i10[0] : i10[d10];
          if (0 === g10) throw new Error("Requires delta != 0");
          var y10 = void 0;
          if (g10 > 0 && m10 < v10 || g10 < 0 && m10 > v10) y10 = 0;
          else if ((y10 = Math.ceil(Math.abs((m10 - v10) / g10))) > Gye) throw new Error("Requires ((limit - start) / delta) <= ".concat(Gye));
          f10[d10 + 1] = f10[d10] + y10;
        }
        for (var b10 = K$(n10, f10[p10]), x10 = 0, k10 = 0; k10 < p10; ++k10) for (var w10 = f10[k10 + 1] - f10[k10], I10 = s10 ? e10[0] : e10[k10], N10 = c10 ? i10[0] : i10[k10], S10 = 0; S10 < w10; ++S10) b10[x10++] = I10, I10 += N10;
        return [f10, b10];
      }
      var Hye = Qae, qye = function() {
        function e10(t10, n10, r10, a10, i10, o10, s10, u10, c10, h10) {
          l(this, e10), this.shape = t10, this.shapeShape = n10, this.values = r10, this.valuesShape = a10, this.valuesDType = i10, this.defaultValue = o10, this.defaultValueShape = s10, this.rowPartitionValues = u10, this.rowPartitionValuesShapes = c10, this.rowPartitionTypes = uie(h10), this.raggedRank = cie(this.rowPartitionTypes);
        }
        return p(e10, [{ key: "getRowPartitionTypeByDimension", value: function(e11) {
          return this.rowPartitionTypes[0] === Hye.FIRST_DIM_SIZE ? this.rowPartitionTypes[e11 + 1] : this.rowPartitionTypes[e11];
        } }, { key: "getRowPartitionTensor", value: function(e11) {
          return this.rowPartitionTypes[0] === Hye.FIRST_DIM_SIZE ? this.rowPartitionValues[e11 + 1] : this.rowPartitionValues[e11];
        } }, { key: "getMaxWidth", value: function(t10) {
          var n10 = this.getRowPartitionTensor(t10 - 1);
          switch (this.getRowPartitionTypeByDimension(t10 - 1)) {
            case Hye.VALUE_ROWIDS:
              return e10.getMaxWidthValueRowID(n10);
            case Hye.ROW_SPLITS:
              return e10.getMaxWidthRowSplit(n10);
            default:
              throw new Error("Cannot handle partition type ".concat(Hye[this.getRowPartitionTypeByDimension(t10 - 1)]));
          }
        } }, { key: "tensorShapeFromTensor", value: function(e11, t10) {
          var n10 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
          if (0 === t10.length) {
            if (-1 === e11[0]) return [];
            throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.");
          }
          return Xye(e11, n10);
        } }, { key: "calculateOutputSize", value: function(e11) {
          var t10 = this.valuesShape;
          lie(this.defaultValueShape, t10);
          var n10 = this.tensorShapeFromTensor(this.shape, this.shapeShape), r10 = sie(this.raggedRank, n10, t10);
          r10[0] < 0 && (r10[0] = e11);
          for (var a10 = 1; a10 <= this.raggedRank; ++a10) r10[a10] < 0 && (r10[a10] = this.getMaxWidth(a10));
          return r10;
        } }, { key: "calculateFirstParentOutputIndex", value: function(e11, t10, n10) {
          for (var r10 = Math.min(e11, n10), a10 = [], i10 = 0, o10 = 0; o10 < r10; ++o10, i10 += t10) a10.push(i10);
          for (var s10 = r10; s10 < e11; ++s10) a10.push(-1);
          return F$(a10.length === e11, function() {
            return "Final length of result must be equal to firstDimension.";
          }), a10;
        } }, { key: "calculateOutputIndexRowSplit", value: function(e11, t10, n10, r10) {
          for (var a10 = e11.length, i10 = [], o10 = 0; o10 < a10 - 1; ++o10) {
            var s10 = e11[o10 + 1] - e11[o10], u10 = Math.min(r10, s10), c10 = t10[o10];
            -1 === c10 && (u10 = 0);
            for (var l10 = 0; l10 < u10; ++l10) i10.push(c10), c10 += n10;
            for (var h10 = 0; h10 < s10 - u10; ++h10) i10.push(-1);
          }
          if (a10 > 0 && i10.length !== e11[a10 - 1]) throw new Error("Invalid row split size.");
          return i10;
        } }, { key: "calculateOutputIndexValueRowID", value: function(e11, t10, n10, r10) {
          var a10 = e11.length, i10 = [];
          if (0 === a10) return [];
          var o10 = 0, s10 = e11[0];
          if (s10 >= t10.length) throw new Error("Got currentValueRowId=".concat(s10, ", which is not less than ").concat(t10.length));
          var u10 = t10[s10];
          i10.push(u10);
          for (var c10 = 1; c10 < a10; ++c10) {
            var l10 = e11[c10];
            if (l10 === s10) u10 >= 0 && (++o10 < r10 ? u10 += n10 : u10 = -1);
            else {
              if (o10 = 0, s10 = l10, l10 >= t10.length) throw new Error("Got nextValueRowId=".concat(l10, " which is not less than ").concat(t10.length));
              u10 = t10[l10];
            }
            i10.push(u10);
          }
          if (i10.length !== e11.length) throw new Error("Invalid row ids.");
          return i10;
        } }, { key: "calculateOutputIndex", value: function(e11, t10, n10, r10) {
          var a10 = this.getRowPartitionTensor(e11), i10 = this.getRowPartitionTypeByDimension(e11);
          switch (i10) {
            case Hye.VALUE_ROWIDS:
              return this.calculateOutputIndexValueRowID(a10, t10, n10, r10);
            case Hye.ROW_SPLITS:
              if (a10.length - 1 > t10.length) throw new Error("Row partition size is greater than output size: ".concat(a10.length - 1, " > ").concat(t10.length));
              return this.calculateOutputIndexRowSplit(a10, t10, n10, r10);
            default:
              throw new Error("Unsupported partition type: ".concat(Hye[i10]));
          }
        } }, { key: "getFirstDimensionSize", value: function() {
          var e11 = this.rowPartitionValues[0];
          if (0 === this.rowPartitionTypes.length) throw new Error("No row_partition_types given.");
          var t10 = this.rowPartitionTypes[0];
          switch (t10) {
            case Hye.FIRST_DIM_SIZE:
              return e11[0];
            case Hye.VALUE_ROWIDS:
              throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
            case Hye.ROW_SPLITS:
              return this.rowPartitionValuesShapes[0][0] - 1;
            default:
              throw new Error("Cannot handle type ".concat(Hye[t10]));
          }
        } }, { key: "compute", value: function() {
          if (this.rowPartitionValues[0].length <= 0) throw new Error("Invalid first partition input. Tensor requires at least one element.");
          var e11 = this.getFirstDimensionSize(), t10 = this.calculateOutputSize(e11), n10 = new Array(this.raggedRank + 1);
          n10[n10.length - 1] = 1;
          for (var r10 = n10.length - 2; r10 >= 0; --r10) n10[r10] = n10[r10 + 1] * t10[r10 + 1];
          var a10 = Xye(t10, false), i10 = K$(this.valuesDType, L$(a10));
          if (n10[0] * t10[0] > 0) {
            for (var o10 = this.calculateFirstParentOutputIndex(e11, n10[0], t10[0]), s10 = 1; s10 <= this.raggedRank; ++s10) {
              o10 = this.calculateOutputIndex(s10 - 1, o10, n10[s10], t10[s10]);
            }
            this.setOutput(this.raggedRank, o10, i10, a10);
          }
          return [a10, i10];
        } }, { key: "setOutput", value: function(e11, t10, n10, r10) {
          if (0 !== n10.length) {
            var a10 = this.values, i10 = n10, o10 = r10.slice(), s10 = L$(o10 = o10.slice(e11 + 1)), u10 = t10.length, c10 = this.defaultValue;
            if (c10.length !== s10 && 1 !== c10.length) {
              var l10 = this.defaultValueShape;
              X5(function() {
                var e12 = X8(c10, l10), t11 = h7(e12, o10);
                c10 = t11.dataSync();
              });
            }
            for (var h10 = 0, p10 = 0, f10 = 0, d10 = 0; d10 <= u10; ++d10) {
              var v10 = d10 < u10 ? t10[d10] : -1;
              if (v10 !== f10) {
                if (p10 < f10) {
                  var m10 = a10.subarray(h10 * s10);
                  Kye(i10.subarray(p10 * s10), m10, (f10 - p10) * s10);
                }
                if (d10 >= u10) {
                  var g10 = n10.length;
                  v10 = Math.floor(g10 / s10);
                }
                if (v10 > f10) if (1 === this.defaultValue.length) i10.subarray(f10 * s10, v10 * s10).fill(this.defaultValue[0]), f10 = v10;
                else for (; v10 > f10; ) {
                  Kye(i10.slice(f10 * s10), c10, s10), ++f10;
                }
                v10 < 0 ? (h10 = d10 + 1, p10 = f10) : (h10 = d10, f10 = (p10 = f10) + 1);
              } else ++f10;
            }
          }
        } }], [{ key: "getMaxWidthRowSplit", value: function(e11) {
          var t10 = e11.length;
          if (0 === t10 || 1 === t10) return 0;
          for (var n10 = 0, r10 = 0; r10 < t10 - 1; ++r10) {
            var a10 = e11[r10 + 1] - e11[r10];
            a10 > n10 && (n10 = a10);
          }
          return n10;
        } }, { key: "getMaxWidthValueRowID", value: function(e11) {
          var t10 = e11.length;
          if (0 === t10) return 0;
          for (var n10 = 0, r10 = e11[0], a10 = 0, i10 = 1; i10 < t10; ++i10) {
            var o10 = e11[i10];
            o10 !== r10 && (r10 = o10, a10 = Math.max(i10 - n10, a10), n10 = i10);
          }
          return Math.max(t10 - n10, a10);
        } }]), e10;
      }();
      function Kye(e10, t10, n10) {
        for (var r10 = 0; r10 < n10; r10++) e10[r10] = t10[r10];
      }
      function Xye(e10, t10) {
        var n10, r10 = [], a10 = O(e10);
        try {
          for (a10.s(); !(n10 = a10.n()).done; ) {
            var i10 = n10.value;
            if (i10 < 0) {
              if (!t10) throw new Error("Dimension ".concat(i10, " must be >= 0"));
              if (i10 < -1) throw new Error("Dimension ".concat(i10, " must be >= -1"));
              i10 = -1;
            }
            r10.push(i10);
          }
        } catch (e11) {
          a10.e(e11);
        } finally {
          a10.f();
        }
        return r10;
      }
      function Yye(e10, t10, n10, r10, a10, i10, o10, s10, u10, c10) {
        return new qye(e10, t10, n10, r10, a10, i10, o10, s10, u10, c10).compute();
      }
      function Jye(e10, t10, n10, r10) {
        if (e10 === t10 || e10 < t10 && n10 < 0 || t10 < e10 && n10 > 1) return l0(0, r10);
        var a10 = l0(Math.abs(Math.ceil((t10 - e10) / n10)), r10);
        t10 < e10 && 1 === n10 && (n10 = -1), a10[0] = e10;
        for (var i10 = 1; i10 < a10.length; i10++) a10[i10] = a10[i10 - 1] + n10;
        return a10;
      }
      var Zye = Oge(function(e10) {
        return 1 / Math.sqrt(e10);
      }), Qye = Dge(H2, Zye), $ye = { kernelName: H2, backendName: "cpu", kernelFunc: Qye };
      function ebe(e10, t10, n10, r10, a10, i10, o10, s10, u10, c10) {
        var l10 = [r10 / a10, a10], h10 = e10.values, p10 = t10.values;
        if (0 === r10) return l8(n10, t10.dtype);
        var f10 = u10 instanceof $4 ? u10 : l8(l10, t10.dtype);
        "string" == typeof u10 || "number" == typeof u10 ? f10.values.fill(u10) : "boolean" == typeof u10 && f10.values.fill(+u10);
        for (var d10 = 0; d10 < i10; d10++) {
          for (var v10 = [], m10 = 0, g10 = 0; g10 < o10; g10++) {
            var y10 = h10[d10 * o10 + g10];
            v10.push(y10), m10 += y10 * s10[g10];
          }
          if (m10 < 0 || m10 >= r10 / a10) throw new Error("Invalid indices: ".concat(v10, " does not index into ").concat(n10));
          for (var b10 = 0; b10 < a10; b10++) c10 ? f10.values[m10 * a10 + b10] += p10[d10 * a10 + b10] : f10.values[m10 * a10 + b10] = 0 === t10.rank ? p10[0] : p10[d10 * a10 + b10];
        }
        return f10;
      }
      var tbe = Oge(function(e10) {
        return 1 / (1 + Math.exp(-e10));
      }), nbe = Fge(t3, function(e10) {
        return 1 / (1 + Math.exp(-e10));
      }), rbe = { kernelName: t3, backendName: "cpu", kernelFunc: nbe };
      function abe(e10, t10, n10, r10, a10) {
        var i10 = Kae(r10, t10, n10), o10 = L$(n10), s10 = i0(r10);
        if (i10) {
          var u10 = Xae(t10, s10);
          return "string" === a10 ? e10.slice(u10, u10 + o10) : e10.subarray(u10, u10 + o10);
        }
        for (var c10 = l8(r10, a10, "string" === a10 ? aoe(e10) : e10), l10 = l8(n10, a10), h10 = 0; h10 < l10.size; ++h10) {
          var p10 = l10.indexToLoc(h10), f10 = p10.map(function(e11, n11) {
            return e11 + t10[n11];
          });
          l10.set.apply(l10, [c10.get.apply(c10, T(f10))].concat(T(p10)));
        }
        return "string" === a10 ? ioe(l10.values) : l10.values;
      }
      function ibe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.begin, o10 = r10.size;
        ige(a10, "slice");
        var s10 = S(Yae(a10, i10, o10), 2), u10 = s10[0], c10 = s10[1];
        zae(a10, u10, c10);
        var l10 = abe(n10.data.get(a10.dataId).values, u10, c10, a10.shape, a10.dtype);
        return n10.makeTensorInfo(c10, a10.dtype, l10);
      }
      var obe = { kernelName: Z2, backendName: "cpu", kernelFunc: ibe };
      function sbe(e10, t10, n10, r10, a10, i10, o10) {
        var s10 = t10[0], u10 = i10[0], c10 = new Array(u10), l10 = new Array(s10), h10 = t10[1];
        if (0 === u10) {
          if (0 !== s10) throw new Error(Gie(s10));
          return [K$(n10, 0), [0, h10], K$(a10, 0), c10, l10];
        }
        for (var p10 = true, f10 = 0, d10 = new Array(u10).fill(0), v10 = 0; v10 < s10; ++v10) {
          var m10 = e10[v10 * h10];
          if (m10 < 0) throw new Error(jie(v10, m10));
          if (m10 >= u10) throw new Error(Hie(v10, m10, u10));
          ++d10[m10], p10 = p10 && m10 >= f10, f10 = m10;
        }
        for (var g10 = true, y10 = 0; y10 < u10; ++y10) {
          var b10 = 0 === d10[y10];
          c10[y10] = b10, g10 = g10 && !b10, d10[y10] = Math.max(d10[y10], 1), y10 > 0 && (d10[y10] += d10[y10 - 1]);
        }
        if (g10 && p10) {
          for (var x10 = e10, k10 = r10, w10 = 0; w10 < s10; ++w10) l10[w10] = w10;
          return [x10, [s10, h10], k10, c10, l10];
        }
        for (var I10 = d10[u10 - 1], N10 = K$(n10, I10 * h10), S10 = K$(a10, I10), T10 = new Array(u10).fill(0), E10 = 0; E10 < s10; ++E10) {
          var C10 = e10[E10 * h10], A10 = T10[C10], R10 = (0 === C10 ? 0 : d10[C10 - 1]) + A10;
          T10[C10]++;
          for (var _10 = 0; _10 < h10; ++_10) N10[R10 * h10 + _10] = e10[E10 * h10 + _10];
          S10[R10] = r10[E10], l10[E10] = R10;
        }
        for (var O10 = 0; O10 < u10; ++O10) {
          if (0 === T10[O10]) {
            var F10 = 0 === O10 ? 0 : d10[O10 - 1];
            N10[F10 * h10 + 0] = O10;
            for (var D10 = 1; D10 < h10; ++D10) N10[F10 * h10 + D10] = 0;
            S10[F10] = o10;
          }
        }
        return [N10, [I10, h10], S10, c10, l10];
      }
      function ube(e10, t10, n10, r10, a10) {
        for (var i10 = L$(r10), o10 = t10[0], s10 = a10.length, u10 = [], c10 = 1, l10 = -1, h10 = 0; h10 < s10; ++h10) {
          var p10 = a10[h10];
          if (-1 === p10) {
            if (-1 !== l10) throw new Error(qie(l10, h10));
            l10 = h10, u10.push(1);
          } else {
            if (p10 < 0) throw new Error(Kie(h10, p10));
            c10 *= p10, u10.push(p10);
          }
        }
        if (-1 !== l10) {
          if (c10 <= 0) throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");
          var f10 = Math.trunc(i10 / c10);
          if (c10 * f10 !== i10) throw new Error(Yie(r10, u10));
          u10[l10] = f10;
        }
        if (L$(u10) !== i10) throw new Error(Jie(r10, u10));
        var d10 = r10.length, v10 = [];
        if (d10 > 0) {
          v10[d10 - 1] = 1;
          for (var m10 = d10 - 2; m10 >= 0; --m10) v10[m10] = v10[m10 + 1] * r10[m10 + 1];
        }
        var g10 = [];
        if (s10 > 0) {
          g10[s10 - 1] = 1;
          for (var y10 = s10 - 2; y10 >= 0; --y10) g10[y10] = g10[y10 + 1] * u10[y10 + 1];
        }
        for (var b10 = K$(n10, o10 * s10), x10 = 0; x10 < o10; ++x10) {
          for (var k10 = 0, w10 = 0; w10 < d10; ++w10) k10 += e10[x10 * d10 + w10] * v10[w10];
          for (var I10 = 0; I10 < s10; ++I10) b10[x10 * s10 + I10] = Math.trunc(k10 / g10[I10]), k10 %= g10[I10];
        }
        return [b10, [o10, s10], u10];
      }
      function cbe(e10, t10, n10, r10, a10) {
        var i10 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5], o10 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, s10 = r10.length, u10 = [t10[0], e10.length / t10[0]], c10 = u10[1], l10 = s10 > 0 ? a10[s10 - 1] + 1 : 0, h10 = l10;
        if (h10 < 0) throw new Error("segment ids must be >= 0");
        var p10 = t10.slice();
        p10[0] = h10;
        var f10 = p10.reduce(function(e11, t11) {
          return e11 * t11;
        }, 1), d10 = K$(n10, f10);
        if (0 === s10) return h10 > 0 && d10.fill(o10), [d10, p10];
        if (h10 <= 0) throw new Error("segment ids must be >= 0");
        for (var v10 = 0, m10 = 1, g10 = 0, y10 = a10[v10]; ; ) {
          var b10 = 0;
          if (m10 < s10) {
            if (y10 === (b10 = a10[m10])) {
              ++m10;
              continue;
            }
            if (y10 >= b10) throw new Error("segment ids are not increasing");
          }
          if (y10 < 0 || y10 >= h10) throw new Error($ie(y10, h10));
          y10 > g10 && d10.fill(o10, g10 * c10, y10 * c10);
          for (var x10 = v10; x10 < m10; ++x10) {
            var k10 = r10[x10];
            if (k10 < 0 || k10 >= u10[0]) throw new Error(eoe(x10, r10[x10], u10[0]));
            for (var w10 = 0; w10 < c10; w10++) d10[y10 * c10 + w10] += e10[k10 * c10 + w10];
          }
          if (i10) for (var I10 = 0; I10 < c10; I10++) d10[y10 * c10 + I10] /= m10 - v10;
          if (v10 = m10, g10 = y10 + 1, y10 = b10, ++m10 > s10) break;
        }
        return g10 < h10 && d10.fill(o10, g10 * c10, h10 * c10), [d10, p10];
      }
      var lbe = Oge(function(e10) {
        return Math.sqrt(e10);
      }), hbe = Fge(r3, function(e10) {
        return Math.sqrt(e10);
      }), pbe = { kernelName: r3, backendName: "cpu", kernelFunc: hbe }, fbe = lge(function(e10, t10) {
        var n10 = e10 - t10;
        return n10 * n10;
      }), dbe = kge(f3, fbe), vbe = { kernelName: f3, backendName: "cpu", kernelFunc: dbe }, mbe = Oge(function(e10, t10) {
        var n10 = t10.pattern, r10 = t10.replaceGlobal, a10 = t10.rewrite;
        return e10.replace(new RegExp(n10, r10 ? "g" : ""), a10);
      }), gbe = Dge(v3, mbe), ybe = { kernelName: v3, backendName: "cpu", kernelFunc: gbe };
      function bbe(e10, t10, n10, r10) {
        for (var a10 = l8(e10, t10.dtype), i10 = 0; i10 < a10.size; i10++) {
          for (var o10 = a10.indexToLoc(i10), s10 = new Array(o10.length), u10 = 0; u10 < s10.length; u10++) s10[u10] = o10[u10] * n10[u10] + r10[u10];
          a10.set.apply(a10, [t10.get.apply(t10, s10)].concat(T(o10)));
        }
        return a10;
      }
      var xbe = function() {
        function e10(t10, n10, r10, a10, i10, o10) {
          l(this, e10), this.separator = B4(t10), this.nGramWidths = n10, this.leftPad = B4(r10), this.rightPad = B4(a10), this.padWidth = i10, this.preserveShort = o10;
        }
        return p(e10, [{ key: "getPadWidth", value: function(e11) {
          return Math.min(this.padWidth < 0 ? e11 - 1 : this.padWidth, e11 - 1);
        } }, { key: "getNumNGrams", value: function(e11, t10) {
          var n10 = this.getPadWidth(t10);
          return Math.max(0, e11 + 2 * n10 - t10 + 1);
        } }, { key: "createNGrams", value: function(e11, t10, n10, r10, a10, i10) {
          for (var o10 = this, s10 = function() {
            var s11 = o10.getPadWidth(i10), c10 = Math.max(0, s11 - u10), l10 = Math.max(0, s11 - (a10 - (u10 + 1))), h10 = i10 - (c10 + l10), p10 = t10 + (c10 > 0 ? 0 : u10 - s11), f10 = 0;
            f10 += c10 * o10.leftPad.length;
            for (var d10 = 0; d10 < h10; ++d10) f10 += e11[p10 + d10].length;
            f10 += l10 * o10.rightPad.length, f10 += (c10 + l10 + h10 - 1) * o10.separator.length, n10[r10 + u10] = new Uint8Array(f10);
            for (var v10 = n10[r10 + u10], m10 = 0, g10 = function(e12) {
              return e12.forEach(function(e13) {
                return v10[m10++] = e13;
              });
            }, y10 = 0; y10 < c10; ++y10) g10(o10.leftPad), g10(o10.separator);
            for (var b10 = 0; b10 < h10 - 1; ++b10) g10(e11[p10 + b10]), g10(o10.separator);
            if (h10 > 0) {
              g10(e11[p10 + h10 - 1]);
              for (var x10 = 0; x10 < l10; ++x10) g10(o10.separator), g10(o10.rightPad);
            } else {
              for (var k10 = 0; k10 < l10 - 1; ++k10) g10(o10.rightPad), g10(o10.separator);
              g10(o10.rightPad);
            }
          }, u10 = 0; u10 < a10; ++u10) s10();
        } }, { key: "compute", value: function(e11, t10) {
          var n10 = this, r10 = e11.length, a10 = t10.length;
          if (a10 > 0) {
            var i10 = t10[0];
            if (0 !== i10) throw new Error("First split value must be 0, got ".concat(i10));
            for (var o10 = 1; o10 < a10; ++o10) {
              var s10 = t10[o10] >= i10;
              if (!(s10 = s10 && t10[o10] <= r10)) throw new Error("Invalid split value ".concat(t10[o10], ", must be in [").concat(i10, ", ").concat(r10, "]"));
              i10 = t10[o10];
            }
            if (i10 !== r10) throw new Error("Last split value must be data size. Expected ".concat(r10, ", got ").concat(i10));
          }
          var u10 = a10 - 1, c10 = K$("int32", a10);
          if (0 === r10 || 0 === a10) {
            for (var l10 = new Array(r10), h10 = 0; h10 <= u10; ++h10) c10[h10] = 0;
            return [l10, c10];
          }
          c10[0] = 0;
          for (var p10 = function() {
            var e12 = t10[f10] - t10[f10 - 1], r11 = 0;
            n10.nGramWidths.forEach(function(t11) {
              r11 += n10.getNumNGrams(e12, t11);
            }), n10.preserveShort && e12 > 0 && 0 === r11 && (r11 = 1), c10[f10] = c10[f10 - 1] + r11;
          }, f10 = 1; f10 <= u10; ++f10) p10();
          for (var d10 = new Array(c10[u10]), v10 = function(r11) {
            var a11 = t10[r11], i11 = c10[r11];
            if (n10.nGramWidths.forEach(function(o12) {
              var s12 = t10[r11 + 1] - t10[r11], u11 = n10.getNumNGrams(s12, o12);
              n10.createNGrams(e11, a11, d10, i11, u11, o12), i11 += u11;
            }), n10.preserveShort && i11 === c10[r11]) {
              var o11 = t10[r11 + 1] - t10[r11];
              if (0 === o11) return "continue";
              var s11 = o11 + 2 * n10.padWidth;
              n10.createNGrams(e11, a11, d10, i11, 1, s11);
            }
          }, m10 = 0; m10 < u10; ++m10) v10(m10);
          return [d10, c10];
        } }]), e10;
      }();
      function kbe(e10, t10, n10, r10, a10, i10, o10, s10) {
        return new xbe(n10, r10, a10, i10, o10, s10).compute(e10, t10);
      }
      function wbe(e10, t10, n10, r10) {
        if (e10.length) if (0 !== t10.length) if (1 !== t10.length) {
          for (var a10 = 0, i10 = 0; i10 < e10.length + 1; i10++) if (i10 === e10.length || -1 !== t10.indexOf(e10[i10])) {
            var o10 = e10.subarray(a10, i10);
            n10 && 0 === o10.length || r10.push(o10), a10 = i10 + 1;
          }
        } else {
          for (var s10 = t10[0], u10 = e10.indexOf(s10); -1 !== u10; ) {
            var c10 = e10.subarray(0, u10);
            n10 && 0 === c10.length || r10.push(c10), u10 = (e10 = e10.subarray(u10 + 1)).indexOf(s10);
          }
          n10 && 0 === e10.length || r10.push(e10);
        }
        else for (var l10 = 0; l10 < e10.length; ++l10) r10.push(e10.subarray(l10, l10 + 1));
      }
      function Ibe(e10, t10, n10) {
        for (var r10 = e10.length, a10 = [], i10 = 0, o10 = 0, s10 = new Array(r10), u10 = 0; u10 < r10; ++u10) {
          var c10 = a10.length;
          wbe(e10[u10], t10, n10, a10);
          var l10 = a10.length - c10;
          s10[u10] = l10, i10 += l10, o10 = Math.max(o10, l10);
        }
        for (var h10 = K$("int32", 2 * i10), p10 = new Array(i10), f10 = [r10, o10], d10 = 0, v10 = 0; v10 < r10; ++v10) for (var m10 = 0; m10 < s10[v10]; ++m10) h10[2 * d10] = v10, h10[2 * d10 + 1] = m10, p10[d10] = a10[d10], ++d10;
        return [h10, p10, f10];
      }
      function Nbe(e10, t10) {
        for (var n10 = K$("int32", e10.length), r10 = 0; r10 < e10.length; ++r10) n10[r10] = D4(e10[r10]).modulo(t10).getLowBitsUnsigned();
        return n10;
      }
      var Sbe = lge(function(e10, t10) {
        return e10 - t10;
      }), Tbe = wge(function(e10, t10, n10, r10) {
        return { real: e10 - n10, imag: t10 - r10 };
      }), Ebe = kge(x3, Sbe, Tbe), Cbe = { kernelName: x3, backendName: "cpu", kernelFunc: Ebe };
      function Abe(e10, t10) {
        for (var n10 = new Array(e10.rank), r10 = 0; r10 < n10.length; r10++) n10[r10] = e10.shape[r10] * t10[r10];
        for (var a10 = l8(n10, e10.dtype), i10 = 0; i10 < a10.values.length; ++i10) {
          for (var o10 = a10.indexToLoc(i10), s10 = new Array(e10.rank), u10 = 0; u10 < s10.length; u10++) s10[u10] = o10[u10] % e10.shape[u10];
          var c10 = e10.locToIndex(s10);
          a10.values[i10] = e10.values[c10];
        }
        return a10;
      }
      var Rbe = function(e10, t10) {
        var n10 = t10.value - e10.value;
        return 0 === n10 ? e10.index - t10.index : n10;
      };
      function _be(e10, t10) {
        for (var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e10.length - 1; r10 > n10; ) {
          if (r10 - n10 > 600) {
            var a10 = r10 - n10 + 1, i10 = t10 - n10 + 1, o10 = Math.log(a10), s10 = 0.5 * Math.exp(2 * o10 / 3), u10 = 0.5 * Math.sqrt(o10 * s10 * (a10 - s10) / a10) * Math.sign(i10 - a10 / 2), c10 = Math.max(n10, Math.floor(t10 - i10 * s10 / a10 + u10)), l10 = Math.min(r10, Math.floor(t10 + (a10 - i10) * s10 / a10 + u10));
            _be(e10, t10, c10, l10);
          }
          var h10 = e10[t10], p10 = n10, f10 = r10;
          for (_$(e10, n10, t10), Rbe(e10[r10], h10) > 0 && _$(e10, n10, r10); p10 < f10; ) {
            for (_$(e10, p10, f10), p10++, f10--; Rbe(e10[p10], h10) < 0; ) p10 += 1;
            for (; Rbe(e10[f10], h10) > 0; ) f10 -= 1;
          }
          0 === Rbe(e10[n10], h10) ? _$(e10, n10, f10) : _$(e10, f10 += 1, r10), f10 <= t10 && (n10 = f10 + 1), t10 <= f10 && (r10 = f10 - 1);
        }
      }
      function Obe(e10, t10, n10, r10, a10) {
        for (var i10 = t10[t10.length - 1], o10 = e10.length / i10, s10 = i10, u10 = q$(n10, o10 * r10), c10 = q$("int32", o10 * r10), l10 = function() {
          var t11 = h10 * s10, n11 = e10.subarray(t11, t11 + s10), i11 = new Array(n11.length);
          n11.forEach(function(e11, t12) {
            return i11[t12] = { value: e11, index: t12 };
          }), r10 < i11.length && (_be(i11, r10), i11 = i11.slice(0, r10)), a10 && i11.sort(Rbe);
          for (var o11 = h10 * r10, l11 = u10.subarray(o11, o11 + r10), p11 = c10.subarray(o11, o11 + r10), f10 = 0; f10 < r10; f10++) l11[f10] = i11[f10].value, p11[f10] = i11[f10].index;
        }, h10 = 0; h10 < o10; h10++) l10();
        var p10 = t10.slice();
        return p10[p10.length - 1] = r10, [l8(p10, n10, u10), l8(p10, "int32", c10)];
      }
      function Fbe(e10, t10, n10, r10) {
        for (var a10 = j$(t10, n10)[0], i10 = [1, n10[0], 1], o10 = 0; o10 < a10; o10++) i10[0] *= n10[o10];
        i10[1] = n10[a10];
        for (var s10 = a10 + 1; s10 < n10.length; s10++) i10[2] *= n10[s10];
        for (var u10 = /* @__PURE__ */ new Map(), c10 = new Int32Array(n10[a10]), l10 = new $4(i10, r10, e10), h10 = [], p10 = 1 === i10[0] && 1 === i10[2], f10 = 0; f10 < n10[a10]; f10++) {
          var d10 = void 0;
          if (p10) d10 = e10[f10].toString();
          else {
            for (var v10 = [], m10 = 0; m10 < i10[0]; m10++) for (var g10 = 0; g10 < i10[2]; g10++) v10.push(l10.get(m10, f10, g10));
            d10 = v10.join(",");
          }
          var y10 = u10.get(d10);
          if (null != y10) c10[f10] = y10;
          else {
            var b10 = u10.size;
            u10.set(d10, b10), c10[f10] = b10, h10.push(f10);
          }
        }
        var x10 = i10.slice();
        x10[1] = u10.size;
        var k10 = new $4(x10, r10);
        h10.forEach(function(e11, t11) {
          for (var n11 = 0; n11 < i10[0]; n11++) for (var r11 = 0; r11 < i10[2]; r11++) k10.set(l10.get(n11, e11, r11), n11, t11, r11);
        });
        var w10 = n10.slice();
        return w10[a10] = x10[1], { outputValues: k10.values, outputShape: w10, indices: c10 };
      }
      var Dbe = { __proto__: null, addImpl: Ige, bincountImpl: Ege, bincountReduceImpl: Cge, bitwiseAndImpl: Age, castImpl: yge, ceilImpl: Mge, concatImpl: Pge, equalImpl: Bge, expImpl: Vge, expm1Impl: Hge, floorDivImpl: Zge, floorImpl: Xge, gatherNdImpl: eye, gatherV2Impl: tye, greaterEqualImpl: iye, greaterImpl: nye, lessEqualImpl: hye, lessImpl: uye, linSpaceImpl: dye, logImpl: vye, maxImpl: yye, maximumImpl: bye, minimumImpl: wye, multiplyImpl: Sye, negImpl: Aye, notEqualImpl: _ye, prodImpl: zye, raggedGatherImpl: Vye, raggedRangeImpl: jye, raggedTensorToTensorImpl: Yye, rangeImpl: Jye, rsqrtImpl: Zye, scatterImpl: ebe, sigmoidImpl: tbe, simpleAbsImpl: uge, sliceImpl: abe, sparseFillEmptyRowsImpl: sbe, sparseReshapeImpl: ube, sparseSegmentReductionImpl: cbe, sqrtImpl: lbe, squaredDifferenceImpl: fbe, staticRegexReplaceImpl: mbe, stridedSliceImpl: bbe, stringNGramsImpl: kbe, stringSplitImpl: Ibe, stringToHashBucketFastImpl: Nbe, subImpl: Sbe, tileImpl: Abe, topKImpl: Obe, transposeImpl: Dye, uniqueImpl: Fbe }, Mbe = "4.17.0";
      $5("cpu", function() {
        return new sge();
      }, 1);
      var Lbe = Fge(I1, function(e10) {
        return e10 >= 0 ? e10 : Math.exp(e10) - 1;
      }), zbe = { kernelName: I1, backendName: "cpu", kernelFunc: Lbe };
      function Pbe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.alpha;
        ige([a10], "leakyRelu");
        for (var o10 = L$(a10.shape), s10 = n10.data.get(a10.dataId).values, u10 = q$("float32", o10), c10 = 0; c10 < s10.length; c10++) u10[c10] = s10[c10] < 0 ? i10 * s10[c10] : s10[c10];
        return n10.makeTensorInfo(a10.shape, "float32", u10);
      }
      var Bbe = { kernelName: q1, backendName: "cpu", kernelFunc: Pbe }, Wbe = lge(function(e10, t10) {
        return e10 < 0 ? t10 * e10 : e10;
      });
      function Ube(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.x, a10 = t10.alpha;
        ige([r10, a10], "prelu");
        var i10 = n10.data.get(r10.dataId).values, o10 = n10.data.get(a10.dataId).values, s10 = S(Wbe(r10.shape, a10.shape, i10, o10, "float32"), 2), u10 = s10[0], c10 = s10[1];
        return n10.makeTensorInfo(c10, "float32", u10);
      }
      var Vbe = { kernelName: C2, backendName: "cpu", kernelFunc: Ube }, Gbe = Fge(L2, function(e10) {
        return Math.max(0, e10);
      }), jbe = { kernelName: L2, backendName: "cpu", kernelFunc: Gbe }, Hbe = Fge(V2, function(e10) {
        return Math.min(Math.max(0, e10), 6);
      }), qbe = { kernelName: V2, backendName: "cpu", kernelFunc: Hbe };
      function Kbe(e10, t10, n10, r10, a10) {
        if ("linear" === n10) return dge({ inputs: { x: t10 }, backend: e10 });
        if ("relu" === n10) return Gbe({ inputs: { x: t10 }, backend: e10 });
        if ("elu" === n10) return Lbe({ inputs: { x: t10 }, backend: e10 });
        if ("relu6" === n10) return Hbe({ inputs: { x: t10 }, backend: e10 });
        if ("prelu" === n10) return Ube({ inputs: { x: t10, alpha: r10 }, backend: e10 });
        if ("leakyrelu" === n10) return Pbe({ inputs: { x: t10 }, backend: e10, attrs: { alpha: a10 } });
        if ("sigmoid" === n10) return nbe({ inputs: { x: t10 }, backend: e10 });
        throw new Error("Activation ".concat(n10, " has not been implemented for the CPU backend."));
      }
      function Xbe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.shape, o10 = L$(a10.shape), s10 = G$(i10, o10), u10 = L$(s10);
        F$(o10 === u10, function() {
          return "The new shape (".concat(s10, ") has ").concat(u10, " elements and the old ") + "shape (".concat(a10.shape, ") has ").concat(o10, " elements. The new shape and old ") + "shape must have the same number of elements.";
        }), n10.incRef(a10.dataId);
        var c10 = n10.data.get(a10.dataId);
        if (null != c10.complexTensorInfos) {
          var l10 = c10.complexTensorInfos.real, h10 = c10.complexTensorInfos.imag;
          l10.shape = s10, h10.shape = s10;
        }
        return { dataId: a10.dataId, shape: s10, dtype: a10.dtype };
      }
      var Ybe = { kernelName: z2, backendName: "cpu", kernelFunc: Xbe };
      function Jbe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.a, i10 = t10.b, o10 = r10.transposeA, s10 = r10.transposeB;
        ige([a10, i10], "matMul");
        var u10 = a10.shape.length, c10 = i10.shape.length, l10 = o10 ? a10.shape[u10 - 2] : a10.shape[u10 - 1], h10 = s10 ? i10.shape[c10 - 1] : i10.shape[c10 - 2], p10 = o10 ? a10.shape[u10 - 1] : a10.shape[u10 - 2], f10 = s10 ? i10.shape[c10 - 2] : i10.shape[c10 - 1], d10 = a10.shape.slice(0, -2), v10 = i10.shape.slice(0, -2), m10 = L$(d10), g10 = L$(v10), y10 = z7(a10.shape.slice(0, -2), i10.shape.slice(0, -2)).concat([p10, f10]);
        F$(l10 === h10, function() {
          return "Error in matMul: inner shapes (".concat(l10, ") and (") + "".concat(h10, ") of Tensors with shapes ").concat(a10.shape, " and ") + "".concat(i10.shape, " and transposeA=").concat(o10) + " and transposeB=".concat(s10, " must match.");
        });
        for (var b10 = s10 ? [g10, f10, h10] : [g10, h10, f10], x10 = Xbe({ inputs: { x: a10 }, backend: n10, attrs: { shape: o10 ? [m10, l10, p10] : [m10, p10, l10] } }), k10 = Xbe({ inputs: { x: i10 }, backend: n10, attrs: { shape: b10 } }), w10 = o10 ? x10.shape[1] : x10.shape[2], I10 = o10 ? x10.shape[2] : x10.shape[1], N10 = s10 ? k10.shape[1] : k10.shape[2], T10 = Math.max(m10, g10), E10 = n10.data.get(x10.dataId).values, C10 = n10.data.get(k10.dataId).values, A10 = i0(x10.shape), R10 = i0(k10.shape), _10 = S(o10 ? [A10[0], 1, A10[1]] : [A10[0], A10[1], 1], 3), O10 = _10[0], F10 = _10[1], D10 = _10[2], M10 = S(s10 ? [1, R10[1], R10[0]] : [R10[1], 1, R10[0]], 3), L10 = M10[0], z10 = M10[1], P10 = M10[2], B10 = I10 * N10, W10 = l8([T10, I10, N10], x10.dtype), U10 = W10.values, V10 = n10.blockSize, G10 = 0; G10 < T10; G10++) for (var j10 = G10 % m10, H10 = G10 % g10, q10 = 0; q10 < I10; q10 += V10) for (var K10 = Math.min(q10 + V10, I10), X10 = 0; X10 < N10; X10 += V10) for (var Y10 = Math.min(X10 + V10, N10), J10 = 0; J10 < w10; J10 += V10) for (var Z10 = Math.min(J10 + V10, w10), Q10 = q10; Q10 < K10; Q10++) for (var $10 = X10; $10 < Y10; $10++) {
          for (var ee2 = 0, te2 = J10; te2 < Z10; te2++) {
            ee2 += E10[j10 * O10 + Q10 * F10 + te2 * D10] * C10[te2 * L10 + $10 * z10 + H10 * P10];
          }
          U10[G10 * B10 + (Q10 * N10 + $10)] += ee2;
        }
        return n10.disposeIntermediateTensorInfo(x10), n10.disposeIntermediateTensorInfo(k10), n10.makeTensorInfo(y10, W10.dtype, W10.values);
      }
      var Zbe = { kernelName: V0, backendName: "cpu", kernelFunc: Jbe };
      var Qbe = { kernelName: D3, backendName: "cpu", kernelFunc: function(e10) {
        var t10, n10, r10, a10 = e10.inputs, i10 = e10.backend, o10 = e10.attrs, s10 = a10.a, u10 = a10.b, c10 = a10.bias, l10 = a10.preluActivationWeights, h10 = o10.transposeA, p10 = o10.transposeB, f10 = o10.activation, d10 = o10.leakyreluAlpha, v10 = [];
        t10 = Jbe({ inputs: { a: s10, b: u10 }, attrs: { transposeA: h10, transposeB: p10 }, backend: i10 }), c10 && (n10 = Sge({ inputs: { a: t10, b: c10 }, backend: i10 }), v10.push(t10), t10 = n10), f10 && (r10 = Kbe(i10, t10, f10, l10, d10), v10.push(t10), t10 = r10);
        for (var m10 = 0, g10 = v10; m10 < g10.length; m10++) {
          var y10 = g10[m10];
          i10.disposeIntermediateTensorInfo(y10);
        }
        return t10;
      } }, $be = Fge(S0, function(e10) {
        return Math.acos(e10);
      }), exe = { kernelName: S0, backendName: "cpu", kernelFunc: $be }, txe = Fge(T0, function(e10) {
        return Math.acosh(e10);
      }), nxe = { kernelName: T0, backendName: "cpu", kernelFunc: txe };
      var rxe = { kernelName: C0, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10;
        ige(t10, "addN");
        for (var a10 = r10.map(function(e11) {
          return n10.data.get(e11.dataId).values;
        }), i10 = l8(r10[0].shape, r10[0].dtype), o10 = i10.values, s10 = 0; s10 < r10.length; s10++) for (var u10 = a10[s10], c10 = 0; c10 < o10.length; c10++) o10[c10] += u10[c10];
        return n10.makeTensorInfo(i10.shape, i10.dtype, i10.values);
      } };
      var axe = { kernelName: A0, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.axis, o10 = r10.keepDims;
        ige(a10, "all");
        var s10 = j$(i10, a10.shape), u10 = s10, c10 = $7(u10, a10.shape.length), l10 = a10;
        null != c10 && (l10 = Mye({ inputs: { x: a10 }, backend: n10, attrs: { perm: c10 } }), u10 = t9(u10.length, a10.shape.length)), Q7("all", u10, l10.shape.length);
        for (var h10 = S(J7(l10.shape, u10), 2), p10 = h10[0], f10 = L$(h10[1]), d10 = l0(L$(p10), l10.dtype), v10 = n10.data.get(l10.dataId).values, m10 = 0; m10 < d10.length; ++m10) {
          for (var g10 = m10 * f10, y10 = v10[g10], b10 = 0; b10 < f10; ++b10) {
            var x10 = v10[g10 + b10];
            y10 = y10 && x10;
          }
          d10[m10] = y10;
        }
        null != c10 && n10.disposeIntermediateTensorInfo(l10);
        var k10 = n10.makeTensorInfo(p10, l10.dtype, d10);
        if (o10) {
          var w10 = Xbe({ inputs: { x: k10 }, backend: n10, attrs: { shape: Z7(p10, s10) } });
          return n10.disposeIntermediateTensorInfo(k10), w10;
        }
        return k10;
      } };
      var ixe = { kernelName: R0, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.axis, o10 = r10.keepDims;
        ige(a10, "any");
        var s10 = j$(i10, a10.shape), u10 = s10, c10 = $7(u10, a10.shape.length), l10 = a10;
        null != c10 && (l10 = Mye({ inputs: { x: a10 }, backend: n10, attrs: { perm: c10 } }), u10 = t9(u10.length, a10.shape.length)), Q7("any", u10, l10.shape.length);
        for (var h10 = S(J7(l10.shape, u10), 2), p10 = h10[0], f10 = L$(h10[1]), d10 = l0(L$(p10), l10.dtype), v10 = n10.data.get(l10.dataId).values, m10 = 0; m10 < d10.length; ++m10) {
          for (var g10 = m10 * f10, y10 = v10[g10], b10 = 0; b10 < f10; ++b10) {
            var x10 = v10[g10 + b10];
            y10 = y10 || x10;
          }
          d10[m10] = y10;
        }
        null != c10 && n10.disposeIntermediateTensorInfo(l10);
        var k10 = n10.makeTensorInfo(p10, l10.dtype, d10);
        if (o10) {
          var w10 = Xbe({ inputs: { x: k10 }, backend: n10, attrs: { shape: Z7(p10, s10) } });
          return n10.disposeIntermediateTensorInfo(k10), w10;
        }
        return k10;
      } };
      var oxe = { kernelName: _0, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.axis;
        ige(a10, "argMax");
        var o10 = j$(i10, a10.shape), s10 = $7(o10, a10.shape.length), u10 = a10, c10 = [];
        null != s10 && (u10 = Mye({ inputs: { x: a10 }, backend: n10, attrs: { perm: s10 } }), c10.push(u10), o10 = t9(o10.length, u10.shape.length)), Q7("argMax", o10 = [o10[0]], u10.shape.length);
        for (var l10 = S(J7(u10.shape, o10), 2), h10 = l10[0], p10 = l10[1], f10 = l0(L$(h10), "int32"), d10 = L$(p10), v10 = n10.data.get(u10.dataId).values, m10 = 0; m10 < f10.length; ++m10) {
          for (var g10 = m10 * d10, y10 = v10[g10], b10 = 0, x10 = 0; x10 < d10; ++x10) {
            var k10 = v10[g10 + x10];
            k10 > y10 && (y10 = k10, b10 = x10);
          }
          f10[m10] = b10;
        }
        return c10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), n10.makeTensorInfo(h10, "int32", f10);
      } };
      var sxe = { kernelName: O0, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.axis;
        ige(a10, "argMin");
        var o10 = j$(i10, a10.shape), s10 = $7(o10, a10.shape.length), u10 = a10, c10 = [];
        null != s10 && (u10 = Mye({ inputs: { x: a10 }, backend: n10, attrs: { perm: s10 } }), c10.push(u10), o10 = t9(o10.length, u10.shape.length)), Q7("argMin", o10 = [o10[0]], u10.shape.length);
        for (var l10 = S(J7(u10.shape, o10), 2), h10 = l10[0], p10 = l10[1], f10 = l0(L$(h10), "int32"), d10 = L$(p10), v10 = n10.data.get(u10.dataId).values, m10 = 0; m10 < f10.length; ++m10) {
          for (var g10 = m10 * d10, y10 = v10[g10], b10 = 0, x10 = 0; x10 < d10; ++x10) {
            var k10 = v10[g10 + x10];
            k10 < y10 && (y10 = k10, b10 = x10);
          }
          f10[m10] = b10;
        }
        return c10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), n10.makeTensorInfo(h10, "int32", f10);
      } }, uxe = Fge(F0, function(e10) {
        return Math.asin(e10);
      }), cxe = { kernelName: F0, backendName: "cpu", kernelFunc: uxe }, lxe = Fge(D0, function(e10) {
        return Math.asinh(e10);
      }), hxe = { kernelName: D0, backendName: "cpu", kernelFunc: lxe }, pxe = Fge(M0, function(e10) {
        return Math.atan(e10);
      }), fxe = { kernelName: M0, backendName: "cpu", kernelFunc: pxe }, dxe = lge(function(e10, t10) {
        return Math.atan2(e10, t10);
      }), vxe = kge(z0, dxe), mxe = { kernelName: z0, backendName: "cpu", kernelFunc: vxe }, gxe = Fge(L0, function(e10) {
        return Math.atanh(e10);
      }), yxe = { kernelName: L0, backendName: "cpu", kernelFunc: gxe };
      function bxe(e10, t10, n10, r10, a10, i10) {
        for (var o10 = a10.strideHeight, s10 = a10.strideWidth, u10 = a10.dilationHeight, c10 = a10.dilationWidth, l10 = a10.effectiveFilterHeight, h10 = a10.effectiveFilterWidth, p10 = a10.padInfo.top, f10 = a10.padInfo.left, d10 = "max" === i10 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, v10 = l8(a10.outShape, n10), m10 = v10.values, g10 = a10.outShape[1] * a10.outShape[2] * a10.outShape[3], y10 = a10.outShape[2] * a10.outShape[3], b10 = a10.outShape[3], x10 = 0; x10 < a10.batchSize; ++x10) for (var k10 = x10 * g10, w10 = x10 * r10[0], I10 = 0; I10 < a10.inChannels; ++I10) for (var N10 = 0; N10 < a10.outHeight; ++N10) for (var S10 = N10 * o10 - p10, T10 = Math.max(0, S10), E10 = Math.min(a10.inHeight, l10 + S10), C10 = k10 + N10 * y10, A10 = 0; A10 < a10.outWidth; ++A10) {
          for (var R10 = A10 * s10 - f10, _10 = Math.max(0, R10), O10 = Math.min(a10.inWidth, h10 + R10), F10 = d10, D10 = 0, M10 = 0, L10 = T10; L10 < E10; L10 += u10) {
            for (var z10 = w10 + L10 * r10[1], P10 = _10; P10 < O10; P10 += c10) {
              var B10 = e10[z10 + P10 * r10[2] + I10];
              "max" === i10 && B10 > F10 ? F10 = B10 : "avg" === i10 && (D10 += B10, M10++);
            }
            if (isNaN(F10)) break;
          }
          m10[C10 + A10 * b10 + I10] = "avg" === i10 ? D10 / M10 : F10;
        }
        return v10;
      }
      function xxe(e10, t10, n10, r10) {
        for (var a10 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], i10 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5], o10 = l8(r10.outShape, "int32"), s10 = r10.strideHeight, u10 = r10.strideWidth, c10 = r10.dilationHeight, l10 = r10.dilationWidth, h10 = r10.effectiveFilterHeight, p10 = r10.effectiveFilterWidth, f10 = r10.padInfo.top, d10 = r10.padInfo.left, v10 = l8(t10, n10, e10), m10 = 0; m10 < r10.batchSize; ++m10) for (var g10 = 0; g10 < r10.inChannels; ++g10) for (var y10 = 0; y10 < r10.outHeight; ++y10) {
          for (var b10 = y10 * s10 - f10, x10 = b10; x10 < 0; ) x10 += c10;
          for (var k10 = Math.min(r10.inHeight, h10 + b10), w10 = 0; w10 < r10.outWidth; ++w10) {
            for (var I10 = w10 * u10 - d10, N10 = I10; N10 < 0; ) N10 += l10;
            for (var S10 = Math.min(r10.inWidth, p10 + I10), T10 = Number.NEGATIVE_INFINITY, E10 = -1, C10 = x10; C10 < k10; C10 += c10) for (var A10 = C10 - b10, R10 = N10; R10 < S10; R10 += l10) {
              var _10 = R10 - I10, O10 = v10.get(m10, C10, R10, g10);
              O10 > T10 && (T10 = O10, E10 = a10 ? i10 ? ((m10 * r10.inHeight + C10) * r10.inWidth + R10) * r10.inChannels + g10 : (C10 * r10.inWidth + R10) * r10.inChannels + g10 : A10 * p10 + _10);
            }
            o10.set(E10, m10, y10, w10, g10);
          }
        }
        return o10;
      }
      function kxe(e10, t10, n10, r10, a10, i10) {
        for (var o10 = a10.strideDepth, s10 = a10.strideHeight, u10 = a10.strideWidth, c10 = a10.dilationDepth, l10 = a10.dilationHeight, h10 = a10.dilationWidth, p10 = a10.effectiveFilterDepth, f10 = a10.effectiveFilterHeight, d10 = a10.effectiveFilterWidth, v10 = a10.padInfo.front, m10 = a10.padInfo.top, g10 = a10.padInfo.left, y10 = "max" === i10 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, b10 = l8(a10.outShape, n10), x10 = b10.values, k10 = a10.outShape[1] * a10.outShape[2] * a10.outShape[3] * a10.outShape[4], w10 = a10.outShape[2] * a10.outShape[3] * a10.outShape[4], I10 = a10.outShape[3] * a10.outShape[4], N10 = a10.outShape[4], S10 = 0; S10 < a10.batchSize; ++S10) for (var T10 = S10 * k10, E10 = S10 * r10[0], C10 = 0; C10 < a10.inChannels; ++C10) for (var A10 = 0; A10 < a10.outDepth; ++A10) {
          for (var R10 = A10 * o10 - v10, _10 = R10; _10 < 0; ) _10 += c10;
          for (var O10 = Math.min(a10.inDepth, p10 + R10), F10 = T10 + A10 * w10, D10 = 0; D10 < a10.outHeight; ++D10) {
            for (var M10 = D10 * s10 - m10, L10 = M10; L10 < 0; ) L10 += l10;
            for (var z10 = Math.min(a10.inHeight, f10 + M10), P10 = F10 + D10 * I10, B10 = 0; B10 < a10.outWidth; ++B10) {
              for (var W10 = B10 * u10 - g10, U10 = W10; U10 < 0; ) U10 += h10;
              for (var V10 = Math.min(a10.inWidth, d10 + W10), G10 = P10 + B10 * N10, j10 = y10, H10 = 0, q10 = 0, K10 = _10; K10 < O10; K10 += c10) {
                for (var X10 = E10 + K10 * r10[1], Y10 = L10; Y10 < z10; Y10 += l10) {
                  for (var J10 = X10 + Y10 * r10[2], Z10 = U10; Z10 < V10; Z10 += h10) {
                    var Q10 = e10[J10 + Z10 * r10[3] + C10];
                    if ("max" === i10 && Q10 > j10 ? j10 = Q10 : "avg" === i10 && (H10 += Q10, q10++), isNaN(j10)) break;
                  }
                  if (isNaN(j10)) break;
                }
                if (isNaN(j10)) break;
              }
              x10[G10 + C10] = "avg" === i10 ? H10 / Math.max(q10, 1) : j10;
            }
          }
        }
        return b10;
      }
      var wxe = { kernelName: P0, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x;
        ige(a10, "avgPool");
        var i10 = r10.filterSize, o10 = r10.strides, s10 = r10.pad, u10 = r10.dimRoundingMode;
        F$(j8(o10, 1), function() {
          return "Error in avgPool: Either strides or dilations must be 1. " + "Got strides ".concat(o10, " and dilations '").concat(1, "'");
        });
        var c10, l10 = O8(a10.shape, i10, o10, 1, s10, u10);
        if (1 === l10.filterWidth && 1 === l10.filterHeight && P$(l10.inShape, l10.outShape)) c10 = dge({ inputs: { x: a10 }, backend: n10 });
        else {
          var h10 = n10.data.get(a10.dataId).values, p10 = i0(a10.shape), f10 = bxe(h10, a10.shape, a10.dtype, p10, l10, "avg");
          c10 = n10.makeTensorInfo(l10.outShape, a10.dtype, f10.values);
        }
        return c10;
      } };
      var Ixe = { kernelName: W0, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.filterSize, o10 = r10.strides, s10 = r10.pad, u10 = r10.dimRoundingMode, c10 = r10.dataFormat;
        ige(a10, "avgPool3d");
        var l10 = F8(a10.shape, i10, o10, 1, s10, u10, c10), h10 = kxe(n10.data.get(a10.dataId).values, a10.shape, a10.dtype, i0(a10.shape), l10, "avg");
        return n10.makeTensorInfo(h10.shape, "float32", h10.values);
      } };
      var Nxe = { kernelName: U0, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.dy, i10 = t10.input, o10 = r10.filterSize, s10 = r10.strides, u10 = r10.pad, c10 = r10.dimRoundingMode;
        ige([a10, i10], "avgPool3DGrad");
        for (var l10 = F8(i10.shape, o10, s10, 1, u10, c10), h10 = l10.strideDepth, p10 = l10.strideHeight, f10 = l10.strideWidth, d10 = l10.filterDepth, v10 = l10.filterHeight, m10 = l10.filterWidth, g10 = l10.dilationDepth, y10 = l10.dilationHeight, b10 = l10.dilationWidth, x10 = l10.effectiveFilterDepth, k10 = l10.effectiveFilterHeight, w10 = l10.effectiveFilterWidth, I10 = x10 - 1 - l10.padInfo.front, N10 = w10 - 1 - l10.padInfo.left, S10 = k10 - 1 - l10.padInfo.top, T10 = l8(i10.shape, "float32"), E10 = 1 / (d10 * v10 * m10), C10 = n10.bufferSync(a10), A10 = 0; A10 < l10.batchSize; ++A10) for (var R10 = 0; R10 < l10.inChannels; ++R10) for (var _10 = 0; _10 < l10.inDepth; ++_10) for (var O10 = 0; O10 < l10.inHeight; ++O10) for (var F10 = 0; F10 < l10.inWidth; ++F10) {
          for (var D10 = _10 - I10, M10 = O10 - S10, L10 = F10 - N10, z10 = 0, P10 = 0; P10 < x10; P10 += g10) {
            var B10 = (D10 + P10) / h10;
            if (!(B10 < 0 || B10 >= l10.outDepth || Math.floor(B10) !== B10)) for (var W10 = 0; W10 < k10; W10 += y10) {
              var U10 = (M10 + W10) / p10;
              if (!(U10 < 0 || U10 >= l10.outHeight || Math.floor(U10) !== U10)) for (var V10 = 0; V10 < w10; V10 += b10) {
                var G10 = (L10 + V10) / f10;
                if (!(G10 < 0 || G10 >= l10.outWidth || Math.floor(G10) !== G10)) z10 += C10.get(A10, B10, U10, G10, R10);
              }
            }
          }
          T10.set(z10 * E10, A10, _10, O10, F10, R10);
        }
        return n10.makeTensorInfo(T10.shape, T10.dtype, T10.values);
      } };
      var Sxe = { kernelName: B0, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.dy, i10 = t10.input, o10 = i10;
        ige([a10, i10], "avgPoolGrad");
        for (var s10 = r10.filterSize, u10 = r10.strides, c10 = r10.pad, l10 = O8(o10.shape, s10, u10, 1, c10), h10 = l10.strideHeight, p10 = l10.strideWidth, f10 = l10.filterHeight, d10 = l10.filterWidth, v10 = l10.dilationHeight, m10 = l10.dilationWidth, g10 = l10.effectiveFilterHeight, y10 = l10.effectiveFilterWidth, b10 = y10 - 1 - l10.padInfo.left, x10 = g10 - 1 - l10.padInfo.top, k10 = l8(o10.shape, "float32"), w10 = 1 / (f10 * d10), I10 = n10.data.get(a10.dataId).values, N10 = l8(a10.shape, "float32", I10), S10 = 0; S10 < l10.batchSize; ++S10) for (var T10 = 0; T10 < l10.inChannels; ++T10) for (var E10 = 0; E10 < l10.inHeight; ++E10) for (var C10 = 0; C10 < l10.inWidth; ++C10) {
          for (var A10 = E10 - x10, R10 = C10 - b10, _10 = 0, O10 = 0; O10 < g10; O10 += v10) {
            var F10 = (A10 + O10) / h10;
            if (!(F10 < 0 || F10 >= l10.outHeight || Math.floor(F10) !== F10)) for (var D10 = 0; D10 < y10; D10 += m10) {
              var M10 = (R10 + D10) / p10;
              if (!(M10 < 0 || M10 >= l10.outWidth || Math.floor(M10) !== M10)) _10 += N10.get(S10, F10, M10, T10);
            }
          }
          k10.set(_10 * w10, S10, E10, C10, T10);
        }
        return n10.makeTensorInfo(k10.shape, k10.dtype, k10.values);
      } };
      var Txe = { kernelName: M1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.scale, o10 = t10.offset, s10 = t10.mean, u10 = t10.variance;
        F$(s10.shape.length === u10.shape.length, function() {
          return "Batch normalization gradient requires mean and variance to have equal ranks.";
        }), F$(null == o10 || s10.shape.length === o10.shape.length, function() {
          return "Batch normalization gradient requires mean and offset to have equal ranks.";
        }), F$(null == i10 || s10.shape.length === i10.shape.length, function() {
          return "Batch normalization gradient requires mean and scale to have equal ranks.";
        }), ige([a10, s10, u10, i10, o10], "batchNorm");
        var c10 = r10.varianceEpsilon;
        null == c10 && (c10 = 1e-3);
        for (var l10 = n10.data.get(a10.dataId).values, h10 = n10.data.get(s10.dataId).values, p10 = n10.data.get(u10.dataId).values, f10 = i10 ? n10.data.get(i10.dataId).values : new Float32Array([1]), d10 = o10 ? n10.data.get(o10.dataId).values : new Float32Array([0]), v10 = new Float32Array(l10.length), m10 = d10.length, g10 = f10.length, y10 = p10.length, b10 = h10.length, x10 = 0, k10 = 0, w10 = 0, I10 = 0, N10 = 0; N10 < l10.length; ++N10) v10[N10] = d10[x10++] + (l10[N10] - h10[k10++]) * f10[w10++] / Math.sqrt(p10[I10++] + c10), x10 >= m10 && (x10 = 0), k10 >= b10 && (k10 = 0), w10 >= g10 && (w10 = 0), I10 >= y10 && (I10 = 0);
        return n10.makeTensorInfo(a10.shape, a10.dtype, v10);
      } };
      var Exe = { kernelName: G0, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.blockShape, o10 = r10.crops;
        ige([a10], "batchToSpaceND");
        var s10 = i10.reduce(function(e11, t11) {
          return e11 * t11;
        }), u10 = fie(a10.shape, i10, s10), c10 = die(u10.length, i10.length), l10 = vie(a10.shape, i10, s10), h10 = mie(o10, i10.length), p10 = gie(l10, o10, i10.length), f10 = Xbe({ inputs: { x: a10 }, backend: n10, attrs: { shape: u10 } }), d10 = Mye({ inputs: { x: f10 }, backend: n10, attrs: { perm: c10 } }), v10 = Xbe({ inputs: { x: d10 }, backend: n10, attrs: { shape: l10 } }), m10 = ibe({ inputs: { x: v10 }, backend: n10, attrs: { begin: h10, size: p10 } });
        return n10.disposeIntermediateTensorInfo(f10), n10.disposeIntermediateTensorInfo(d10), n10.disposeIntermediateTensorInfo(v10), m10;
      } };
      var Cxe = { kernelName: j0, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.weights, o10 = r10.size, s10 = Ege(n10.data.get(a10.dataId).values, n10.data.get(i10.dataId).values, i10.dtype, i10.shape, o10);
        return n10.makeTensorInfo([o10], i10.dtype, s10);
      } };
      var Axe = { kernelName: K0, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.s0, a10 = t10.s1, i10 = n10.data.get(r10.dataId).values, o10 = n10.data.get(a10.dataId).values, s10 = z7(Array.from(i10), Array.from(o10));
        return n10.makeTensorInfo([s10.length], "int32", Int32Array.from(s10));
      } }, Rxe = Fge(J0, function(e10, t10) {
        var n10 = t10;
        return e10 > n10.clipValueMax ? n10.clipValueMax : e10 < n10.clipValueMin ? n10.clipValueMin : e10;
      }), _xe = { kernelName: J0, backendName: "cpu", kernelFunc: Rxe }, Oxe = { kernelName: Q0, backendName: "cpu", kernelFunc: function(e10) {
        for (var t10 = e10.inputs.x, n10 = e10.backend, r10 = new Float32Array(L$(t10.shape)), a10 = n10.data.get(t10.dataId), i10 = a10.complexTensorInfos.real, o10 = a10.complexTensorInfos.imag, s10 = n10.data.get(i10.dataId).values, u10 = n10.data.get(o10.dataId).values, c10 = 0; c10 < s10.length; c10++) {
          var l10 = s10[c10], h10 = u10[c10];
          r10[c10] = Math.hypot(l10, h10);
        }
        return n10.makeOutput(r10, t10.shape, "float32");
      } };
      function Fxe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.input, a10 = n10.data.get(r10.dataId).complexTensorInfos.imag, i10 = n10.data.get(a10.dataId).values;
        return n10.makeTensorInfo(a10.shape, a10.dtype, i10);
      }
      var Dxe = { kernelName: V1, backendName: "cpu", kernelFunc: Fxe };
      function Mxe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = j$(e10.attrs.axis, t10[0].shape)[0];
        iie(t10.map(function(e11) {
          return e11.shape;
        }), r10);
        var a10 = oie(t10.map(function(e11) {
          return e11.shape;
        }), r10);
        if (0 === L$(a10)) return n10.makeTensorInfo(a10, t10[0].dtype, []);
        var i10 = t10.filter(function(e11) {
          return L$(e11.shape) > 0;
        });
        if (1 === i10.length) return dge({ inputs: { x: i10[0] }, backend: n10 });
        if ("complex64" === i10[0].dtype) {
          var o10 = i10.map(function(e11) {
            return mge({ inputs: { input: e11 }, backend: n10 });
          }), s10 = i10.map(function(e11) {
            return Fxe({ inputs: { input: e11 }, backend: n10 });
          }), u10 = Mxe({ inputs: o10, backend: n10, attrs: { axis: r10 } }), c10 = Mxe({ inputs: s10, backend: n10, attrs: { axis: r10 } }), l10 = hge({ inputs: { real: u10, imag: c10 }, backend: n10 });
          return o10.forEach(function(e11) {
            return n10.disposeIntermediateTensorInfo(e11);
          }), s10.forEach(function(e11) {
            return n10.disposeIntermediateTensorInfo(e11);
          }), n10.disposeIntermediateTensorInfo(u10), n10.disposeIntermediateTensorInfo(c10), l10;
        }
        var h10 = i10.map(function(e11) {
          var t11 = L$(e11.shape.slice(r10));
          return Xbe({ inputs: { x: e11 }, backend: n10, attrs: { shape: [-1, t11] } });
        }), p10 = h10.map(function(e11) {
          return { vals: n10.data.get(e11.dataId).values, shape: e11.shape };
        });
        a10 = oie(h10.map(function(e11) {
          return e11.shape;
        }), 1);
        var f10 = 1 === h10[0].shape[0], d10 = Pge(p10, a10, t10[0].dtype, f10), v10 = oie(i10.map(function(e11) {
          return e11.shape;
        }), r10), m10 = n10.makeTensorInfo(v10, t10[0].dtype, d10);
        return h10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), m10;
      }
      var Lxe = { kernelName: $0, backendName: "cpu", kernelFunc: Mxe };
      function zxe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.filter, o10 = r10.strides, s10 = r10.pad, u10 = r10.dataFormat, c10 = r10.dilations, l10 = r10.dimRoundingMode;
        ige([a10, i10], "conv2d");
        for (var h10 = q8(u10), p10 = D8(a10.shape, i10.shape, o10, c10, s10, l10, false, h10), f10 = p10.filterHeight, d10 = p10.filterWidth, v10 = p10.dilationHeight, m10 = p10.dilationWidth, g10 = p10.padInfo.left, y10 = p10.padInfo.top, b10 = "channelsLast" === p10.dataFormat, x10 = new $4(p10.outShape, a10.dtype), k10 = i0(a10.shape), w10 = i0(i10.shape), I10 = k10[0], N10 = b10 ? k10[1] : k10[2], S10 = b10 ? k10[2] : 1, T10 = b10 ? 1 : k10[1], E10 = x10.strides[0], C10 = b10 ? x10.strides[1] : x10.strides[2], A10 = b10 ? x10.strides[2] : 1, R10 = b10 ? 1 : x10.strides[1], _10 = n10.data.get(a10.dataId).values, O10 = n10.data.get(i10.dataId).values, F10 = x10.values, D10 = 0; D10 < p10.batchSize; ++D10) for (var M10 = D10 * I10, L10 = D10 * E10, z10 = 0; z10 < p10.outHeight; ++z10) for (var P10 = L10 + z10 * C10, B10 = z10 * p10.strideHeight - y10, W10 = 0; W10 < f10; ++W10) {
          var U10 = B10 + W10 * v10;
          if (!(U10 < 0 || U10 >= p10.inHeight)) for (var V10 = W10 * w10[0], G10 = M10 + U10 * N10, j10 = 0; j10 < p10.outWidth; ++j10) for (var H10 = P10 + j10 * A10, q10 = j10 * p10.strideWidth - g10, K10 = 0; K10 < d10; ++K10) {
            var X10 = q10 + K10 * m10;
            if (!(X10 < 0 || X10 >= p10.inWidth)) for (var Y10 = G10 + X10 * S10, J10 = V10 + K10 * w10[1], Z10 = 0; Z10 < p10.inChannels; ++Z10) {
              for (var Q10 = _10[Y10 + Z10 * T10], $10 = 0; $10 < p10.outChannels; ++$10) F10[H10 + $10 * R10] += Q10 * O10[J10 + $10];
              J10 += p10.outChannels;
            }
          }
        }
        return n10.makeTensorInfo(x10.shape, x10.dtype, F10);
      }
      var Pxe = { kernelName: e1, backendName: "cpu", kernelFunc: zxe };
      var Bxe = { kernelName: t1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.dy, o10 = r10.strides, s10 = r10.pad, u10 = r10.dataFormat, c10 = r10.dimRoundingMode, l10 = r10.filterShape;
        ige([a10, i10], "conv2dBackpropFilter");
        for (var h10 = q8(u10), p10 = D8(a10.shape, l10, o10, 1, s10, c10, false, h10), f10 = p10.strideHeight, d10 = p10.strideWidth, v10 = p10.filterHeight, m10 = p10.filterWidth, g10 = "channelsLast" === p10.dataFormat, y10 = new $4(p10.filterShape, "float32"), b10 = p10.padInfo.left, x10 = p10.padInfo.top, k10 = n10.data.get(a10.dataId).values, w10 = n10.data.get(i10.dataId).values, I10 = new $4(a10.shape, a10.dtype, k10), N10 = new $4(i10.shape, i10.dtype, w10), S10 = 0; S10 < v10; ++S10) for (var T10 = Math.max(0, Math.ceil((x10 - S10) / f10)), E10 = Math.min(p10.outHeight, (p10.inHeight + x10 - S10) / f10), C10 = 0; C10 < m10; ++C10) for (var A10 = Math.max(0, Math.ceil((b10 - C10) / d10)), R10 = Math.min(p10.outWidth, (p10.inWidth + b10 - C10) / d10), _10 = 0; _10 < p10.inChannels; ++_10) for (var O10 = 0; O10 < p10.outChannels; ++O10) {
          for (var F10 = 0, D10 = 0; D10 < p10.batchSize; ++D10) for (var M10 = T10; M10 < E10; ++M10) for (var L10 = S10 + M10 * f10 - x10, z10 = A10; z10 < R10; ++z10) {
            var P10 = C10 + z10 * d10 - b10;
            F10 += g10 ? I10.get(D10, L10, P10, _10) * N10.get(D10, M10, z10, O10) : I10.get(D10, _10, L10, P10) * N10.get(D10, O10, M10, z10);
          }
          y10.set(F10, S10, C10, _10, O10);
        }
        return n10.makeTensorInfo(y10.shape, y10.dtype, y10.values);
      } };
      var Wxe = { kernelName: n1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.dy, i10 = t10.filter, o10 = r10.inputShape, s10 = r10.strides, u10 = r10.pad, c10 = r10.dataFormat, l10 = r10.dimRoundingMode;
        ige([a10, i10], "conv2dBackpropInput");
        var h10 = i0(i10.shape), p10 = i0(a10.shape), f10 = q8(c10), d10 = D8(o10, i10.shape, s10, 1, u10, l10, false, f10), v10 = new $4(d10.inShape, "float32"), m10 = v10.values, g10 = n10.data.get(a10.dataId).values, y10 = n10.data.get(i10.dataId).values, b10 = S(h10, 3), x10 = b10[0], k10 = b10[1], w10 = b10[2], I10 = d10.batchSize, N10 = d10.filterHeight, T10 = d10.filterWidth, E10 = d10.inChannels, C10 = d10.inHeight, A10 = d10.inWidth, R10 = d10.outChannels, _10 = d10.outHeight, O10 = d10.outWidth, F10 = d10.strideHeight, D10 = d10.strideWidth;
        f10 = d10.dataFormat;
        for (var M10 = N10 - 1 - d10.padInfo.top, L10 = T10 - 1 - d10.padInfo.left, z10 = "channelsLast" === f10, P10 = v10.strides[0], B10 = z10 ? v10.strides[1] : v10.strides[2], W10 = z10 ? v10.strides[2] : 1, U10 = z10 ? 1 : v10.strides[1], V10 = p10[0], G10 = z10 ? p10[1] : p10[2], j10 = z10 ? p10[2] : 1, H10 = z10 ? 1 : p10[1], q10 = 0; q10 < I10; ++q10) for (var K10 = 0; K10 < E10; ++K10) for (var X10 = 0; X10 < C10; ++X10) for (var Y10 = X10 - M10, J10 = Math.max(0, Math.ceil(Y10 / F10)), Z10 = Math.min(_10, (N10 + Y10) / F10), Q10 = 0; Q10 < A10; ++Q10) {
          for (var $10 = Q10 - L10, ee2 = Math.max(0, Math.ceil($10 / D10)), te2 = Math.min(O10, (T10 + $10) / D10), ne2 = 0, re2 = J10; re2 < Z10; ++re2) for (var ae2 = re2 * F10 - Y10, ie2 = ee2; ie2 < te2; ++ie2) for (var oe2 = V10 * q10 + G10 * re2 + j10 * ie2, se2 = x10 * (N10 - 1 - ae2) + k10 * (T10 - 1 - (ie2 * D10 - $10)) + w10 * K10, ue2 = 0; ue2 < R10; ++ue2) {
            ne2 += g10[oe2 + H10 * ue2] * y10[se2 + ue2];
          }
          m10[P10 * q10 + B10 * X10 + W10 * Q10 + U10 * K10] = ne2;
        }
        return n10.makeTensorInfo(v10.shape, v10.dtype, v10.values);
      } };
      var Uxe = { kernelName: r1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.filter, o10 = r10.strides, s10 = r10.pad, u10 = r10.dilations;
        ige([a10, i10], "conv3d");
        for (var c10 = M8(a10.shape, i10.shape, o10, u10, s10), l10 = c10.filterDepth, h10 = c10.filterHeight, p10 = c10.filterWidth, f10 = c10.dilationDepth, d10 = c10.dilationHeight, v10 = c10.dilationWidth, m10 = c10.padInfo, g10 = m10.front, y10 = m10.left, b10 = m10.top, x10 = new $4(c10.outShape, a10.dtype), k10 = n10.data.get(a10.dataId).values, w10 = n10.data.get(i10.dataId).values, I10 = x10.values, N10 = i0(a10.shape), S10 = i0(i10.shape), T10 = 0; T10 < c10.batchSize; ++T10) for (var E10 = T10 * N10[0], C10 = T10 * x10.strides[0], A10 = 0; A10 < c10.outDepth; ++A10) for (var R10 = C10 + A10 * x10.strides[1], _10 = A10 * c10.strideDepth - g10, O10 = 0; O10 < l10; ++O10) {
          var F10 = _10 + O10 * f10;
          if (!(F10 < 0 || F10 >= c10.inDepth)) for (var D10 = O10 * S10[0], M10 = E10 + F10 * N10[1], L10 = 0; L10 < c10.outHeight; ++L10) for (var z10 = R10 + L10 * x10.strides[2], P10 = L10 * c10.strideHeight - b10, B10 = 0; B10 < h10; ++B10) {
            var W10 = P10 + B10 * d10;
            if (!(W10 < 0 || W10 >= c10.inHeight)) for (var U10 = D10 + B10 * S10[1], V10 = M10 + W10 * N10[2], G10 = 0; G10 < c10.outWidth; ++G10) for (var j10 = z10 + G10 * c10.outChannels, H10 = G10 * c10.strideWidth - y10, q10 = 0; q10 < p10; ++q10) {
              var K10 = H10 + q10 * v10;
              if (!(K10 < 0 || K10 >= c10.inWidth)) for (var X10 = U10 + q10 * S10[2], Y10 = V10 + K10 * c10.inChannels, J10 = X10, Z10 = 0; Z10 < c10.inChannels; ++Z10) {
                for (var Q10 = k10[Y10 + Z10], $10 = 0; $10 < c10.outChannels; ++$10) I10[j10 + $10] += Q10 * w10[J10 + $10];
                J10 += c10.outChannels;
              }
            }
          }
        }
        return n10.makeTensorInfo(x10.shape, x10.dtype, x10.values);
      } };
      var Vxe = { kernelName: a1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.dy, o10 = r10.strides, s10 = r10.pad, u10 = r10.filterShape;
        ige([a10, i10], "conv3dBackpropFilterV2");
        for (var c10 = i0(a10.shape), l10 = i0(i10.shape), h10 = M8(a10.shape, u10, o10, 1, s10), p10 = h10.strideDepth, f10 = h10.strideHeight, d10 = h10.strideWidth, v10 = h10.filterDepth, m10 = h10.filterHeight, g10 = h10.filterWidth, y10 = new $4(h10.filterShape, "float32"), b10 = y10.values, x10 = S(y10.strides, 4), k10 = x10[0], w10 = x10[1], I10 = x10[2], N10 = x10[3], T10 = n10.data.get(i10.dataId).values, E10 = S(l10, 4), C10 = E10[0], A10 = E10[1], R10 = E10[2], _10 = E10[3], O10 = n10.data.get(a10.dataId).values, F10 = S(c10, 4), D10 = F10[0], M10 = F10[1], L10 = F10[2], z10 = F10[3], P10 = h10.padInfo.front, B10 = h10.padInfo.left, W10 = h10.padInfo.top, U10 = 0; U10 < v10; ++U10) for (var V10 = Math.max(0, Math.ceil((P10 - U10) / p10)), G10 = Math.min(h10.outDepth, (h10.inDepth + P10 - U10) / p10), j10 = U10 * k10, H10 = 0; H10 < m10; ++H10) for (var q10 = Math.max(0, Math.ceil((W10 - H10) / f10)), K10 = Math.min(h10.outHeight, (h10.inHeight + W10 - H10) / f10), X10 = H10 * w10 + j10, Y10 = 0; Y10 < g10; ++Y10) for (var J10 = Math.max(0, Math.ceil((B10 - Y10) / d10)), Z10 = Math.min(h10.outWidth, (h10.inWidth + B10 - Y10) / d10), Q10 = Y10 * I10 + X10, $10 = 0; $10 < h10.inChannels; ++$10) for (var ee2 = $10 * N10 + Q10, te2 = 0; te2 < h10.outChannels; ++te2) {
          for (var ne2 = 0, re2 = 0; re2 < h10.batchSize; ++re2) for (var ae2 = re2 * D10, ie2 = re2 * C10, oe2 = V10; oe2 < G10; ++oe2) for (var se2 = (U10 + oe2 * p10 - P10) * M10 + ae2, ue2 = oe2 * A10 + ie2, ce2 = q10; ce2 < K10; ++ce2) for (var le2 = (H10 + ce2 * f10 - W10) * L10 + se2, he2 = ce2 * R10 + ue2, pe2 = J10; pe2 < Z10; ++pe2) {
            var fe2 = pe2 * _10 + he2;
            ne2 += O10[(Y10 + pe2 * d10 - B10) * z10 + le2 + $10] * T10[fe2 + te2];
          }
          b10[ee2 + te2] = ne2;
        }
        return n10.makeTensorInfo(y10.shape, y10.dtype, y10.values);
      } };
      var Gxe = { kernelName: i1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.dy, i10 = t10.filter, o10 = r10.pad, s10 = r10.strides, u10 = r10.inputShape;
        ige([a10], "conv3dBackpropInputV2");
        for (var c10 = i0(a10.shape), l10 = i0(i10.shape), h10 = M8(u10, i10.shape, s10, 1, o10), p10 = new $4(h10.inShape, "float32"), f10 = p10.values, d10 = S(p10.strides, 4), v10 = d10[0], m10 = d10[1], g10 = d10[2], y10 = d10[3], b10 = n10.data.get(a10.dataId).values, x10 = S(c10, 4), k10 = x10[0], w10 = x10[1], I10 = x10[2], N10 = x10[3], T10 = n10.data.get(i10.dataId).values, E10 = S(l10, 4), C10 = E10[0], A10 = E10[1], R10 = E10[2], _10 = E10[3], O10 = h10.batchSize, F10 = h10.filterDepth, D10 = h10.filterHeight, M10 = h10.filterWidth, L10 = h10.inChannels, z10 = h10.inDepth, P10 = h10.inHeight, B10 = h10.inWidth, W10 = h10.outChannels, U10 = h10.outDepth, V10 = h10.outHeight, G10 = h10.outWidth, j10 = h10.strideDepth, H10 = h10.strideHeight, q10 = h10.strideWidth, K10 = F10 - 1 - h10.padInfo.front, X10 = D10 - 1 - h10.padInfo.top, Y10 = M10 - 1 - h10.padInfo.left, J10 = 0; J10 < O10; ++J10) for (var Z10 = 0; Z10 < L10; ++Z10) for (var Q10 = 0; Q10 < z10; ++Q10) for (var $10 = Q10 - K10, ee2 = Math.max(0, Math.ceil($10 / j10)), te2 = Math.min(U10, (F10 + $10) / j10), ne2 = 0; ne2 < P10; ++ne2) for (var re2 = ne2 - X10, ae2 = Math.max(0, Math.ceil(re2 / H10)), ie2 = Math.min(V10, (D10 + re2) / H10), oe2 = 0; oe2 < B10; ++oe2) {
          for (var se2 = oe2 - Y10, ue2 = Math.max(0, Math.ceil(se2 / q10)), ce2 = Math.min(G10, (M10 + se2) / q10), le2 = 0, he2 = ee2; he2 < te2; ++he2) for (var pe2 = he2 * j10 - $10, fe2 = ae2; fe2 < ie2; ++fe2) for (var de2 = fe2 * H10 - re2, ve2 = ue2; ve2 < ce2; ++ve2) for (var me2 = k10 * J10 + w10 * he2 + I10 * fe2 + N10 * ve2, ge2 = C10 * (F10 - 1 - pe2) + A10 * (D10 - 1 - de2) + R10 * (M10 - 1 - (ve2 * q10 - se2)) + _10 * Z10, ye2 = 0; ye2 < W10; ++ye2) {
            le2 += b10[me2 + ye2] * T10[ge2 + ye2];
          }
          f10[v10 * J10 + m10 * Q10 + g10 * ne2 + y10 * oe2 + Z10] = le2;
        }
        return n10.makeTensorInfo(p10.shape, p10.dtype, p10.values);
      } }, jxe = Fge(o1, function(e10) {
        return Math.cos(e10);
      }), Hxe = { kernelName: o1, backendName: "cpu", kernelFunc: jxe }, qxe = Fge(s1, function(e10) {
        return Math.cosh(e10);
      }), Kxe = { kernelName: s1, backendName: "cpu", kernelFunc: qxe };
      var Xxe = { kernelName: l1, backendName: "cpu", kernelFunc: function(e10) {
        for (var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.image, i10 = t10.boxes, o10 = t10.boxInd, s10 = r10.cropSize, u10 = r10.method, c10 = r10.extrapolationValue, l10 = S(a10.shape, 4), h10 = l10[0], p10 = l10[1], f10 = l10[2], d10 = l10[3], v10 = i10.shape[0], m10 = S(s10, 2), g10 = m10[0], y10 = m10[1], b10 = l8([v10, g10, y10, d10], "float32"), x10 = n10.data.get(i10.dataId).values, k10 = n10.data.get(o10.dataId).values, w10 = n10.data.get(a10.dataId).values, I10 = i0(a10.shape), N10 = i0(b10.shape), T10 = 0; T10 < v10; T10++) {
          var E10 = 4 * T10, C10 = x10[E10], A10 = x10[E10 + 1], R10 = x10[E10 + 2], _10 = x10[E10 + 3], O10 = k10[T10];
          if (!(O10 >= h10)) for (var F10 = g10 > 1 ? (R10 - C10) * (p10 - 1) / (g10 - 1) : 0, D10 = y10 > 1 ? (_10 - A10) * (f10 - 1) / (y10 - 1) : 0, M10 = 0; M10 < g10; M10++) {
            var L10 = g10 > 1 ? C10 * (p10 - 1) + M10 * F10 : 0.5 * (C10 + R10) * (p10 - 1);
            if (L10 < 0 || L10 > p10 - 1) for (var z10 = 0; z10 < y10; z10++) for (var P10 = 0; P10 < d10; P10++) {
              var B10 = P10 + z10 * N10[2] + M10 * N10[1] + T10 * N10[0];
              b10.values[B10] = c10;
            }
            else if ("bilinear" === u10) for (var W10 = Math.floor(L10), U10 = Math.ceil(L10), V10 = L10 - W10, G10 = 0; G10 < y10; G10++) {
              var j10 = y10 > 1 ? A10 * (f10 - 1) + G10 * D10 : 0.5 * (A10 + _10) * (f10 - 1);
              if (j10 < 0 || j10 > f10 - 1) for (var H10 = 0; H10 < d10; H10++) {
                var q10 = H10 + G10 * N10[2] + M10 * N10[1] + T10 * N10[0];
                b10.values[q10] = c10;
              }
              else for (var K10 = Math.floor(j10), X10 = Math.ceil(j10), Y10 = j10 - K10, J10 = 0; J10 < d10; J10++) {
                var Z10 = J10 + K10 * I10[2] + W10 * I10[1] + O10 * I10[0], Q10 = w10[Z10], $10 = w10[Z10 = J10 + X10 * I10[2] + W10 * I10[1] + O10 * I10[0]], ee2 = w10[Z10 = J10 + K10 * I10[2] + U10 * I10[1] + O10 * I10[0]], te2 = Q10 + ($10 - Q10) * Y10, ne2 = ee2 + (w10[Z10 = J10 + X10 * I10[2] + U10 * I10[1] + O10 * I10[0]] - ee2) * Y10;
                Z10 = J10 + G10 * N10[2] + M10 * N10[1] + T10 * N10[0], b10.values[Z10] = te2 + (ne2 - te2) * V10;
              }
            }
            else for (var re2 = 0; re2 < y10; ++re2) {
              var ae2 = y10 > 1 ? A10 * (f10 - 1) + re2 * D10 : 0.5 * (A10 + _10) * (f10 - 1);
              if (ae2 < 0 || ae2 > f10 - 1) for (var ie2 = 0; ie2 < d10; ie2++) {
                var oe2 = ie2 + re2 * N10[2] + M10 * N10[1] + T10 * N10[0];
                b10.values[oe2] = c10;
              }
              else for (var se2 = Math.round(ae2), ue2 = Math.round(L10), ce2 = 0; ce2 < d10; ce2++) {
                var le2 = ce2 + se2 * I10[2] + ue2 * I10[1] + O10 * I10[0], he2 = ce2 + re2 * N10[2] + M10 * N10[1] + T10 * N10[0];
                b10.values[he2] = w10[le2];
              }
            }
          }
        }
        return n10.makeTensorInfo(b10.shape, b10.dtype, b10.values);
      } };
      var Yxe = { kernelName: u1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.axis, o10 = r10.exclusive, s10 = r10.reverse;
        ige(a10, "cumprod");
        var u10 = $7([i10], a10.shape.length), c10 = a10;
        null != u10 && (c10 = Mye({ inputs: { x: a10 }, backend: n10, attrs: { perm: u10 } }));
        var l10 = t9(1, a10.shape.length)[0];
        if (l10 !== c10.shape.length - 1) throw new Error("backend.cumprod in CPU expects an inner-most " + "axis=".concat(c10.shape.length - 1, " but got axis=").concat(l10));
        for (var h10 = h5(c10.dtype, "int32"), p10 = c0(L$(c10.shape), h10), f10 = n10.data.get(c10.dataId).values, d10 = c10.shape[c10.shape.length - 1], v10 = s10 ? function(e11, t11) {
          return e11 + d10 - t11 - 1;
        } : function(e11, t11) {
          return e11 + t11;
        }, m10 = 0; m10 < f10.length; m10 += d10) for (var g10 = 0; g10 < d10; g10++) {
          var y10 = v10(m10, g10);
          if (0 === g10) p10[y10] = o10 ? 1 : f10[y10];
          else {
            var b10 = v10(m10, g10 - 1);
            p10[y10] = o10 ? f10[b10] * p10[b10] : f10[y10] * p10[b10];
          }
        }
        var x10 = n10.makeTensorInfo(c10.shape, h10, p10);
        if (null != u10) {
          var k10 = Mye({ inputs: { x: x10 }, backend: n10, attrs: { perm: e9(u10) } });
          return n10.disposeIntermediateTensorInfo(x10), n10.disposeIntermediateTensorInfo(c10), k10;
        }
        return x10;
      } };
      var Jxe = { kernelName: c1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.axis, o10 = r10.exclusive, s10 = r10.reverse;
        ige(a10, "cumsum");
        var u10 = $7([i10], a10.shape.length), c10 = a10;
        null != u10 && (c10 = Mye({ inputs: { x: a10 }, backend: n10, attrs: { perm: u10 } }));
        var l10 = t9(1, a10.shape.length)[0];
        if (l10 !== c10.shape.length - 1) throw new Error("backend.cumsum in CPU expects an inner-most " + "axis=".concat(c10.shape.length - 1, " but got axis=").concat(l10));
        for (var h10 = h5(c10.dtype, "int32"), p10 = l0(L$(c10.shape), h10), f10 = n10.data.get(c10.dataId).values, d10 = c10.shape[c10.shape.length - 1], v10 = s10 ? function(e11, t11) {
          return e11 + d10 - t11 - 1;
        } : function(e11, t11) {
          return e11 + t11;
        }, m10 = 0; m10 < f10.length; m10 += d10) for (var g10 = 0; g10 < d10; g10++) {
          var y10 = v10(m10, g10);
          if (0 === g10) p10[y10] = o10 ? 0 : f10[y10];
          else {
            var b10 = v10(m10, g10 - 1);
            p10[y10] = o10 ? f10[b10] + p10[b10] : f10[y10] + p10[b10];
          }
        }
        var x10 = n10.makeTensorInfo(c10.shape, h10, p10);
        if (null != u10) {
          var k10 = Mye({ inputs: { x: x10 }, backend: n10, attrs: { perm: e9(u10) } });
          return n10.disposeIntermediateTensorInfo(x10), n10.disposeIntermediateTensorInfo(c10), k10;
        }
        return x10;
      } };
      var Zxe = { kernelName: h1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.weights, o10 = r10.size, s10 = r10.binaryOutput;
        if (1 === a10.shape.length) {
          var u10 = Ege(n10.data.get(a10.dataId).values, n10.data.get(i10.dataId).values, i10.dtype, i10.shape, o10);
          return n10.makeTensorInfo([o10], i10.dtype, u10);
        }
        if (2 === a10.shape.length) {
          var c10 = Cge(n10.bufferSync(a10), n10.bufferSync(i10), o10, s10);
          return n10.makeTensorInfo(c10.shape, i10.dtype, c10.values);
        }
        throw new Error("Error in denseBincount: input must be at most rank 2, but got rank" + "".concat(a10.shape.length, "."));
      } };
      var Qxe = { kernelName: p1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.blockSize, o10 = r10.dataFormat;
        F$("NHWC" === o10, function() {
          return "Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(o10);
        });
        for (var s10 = a10.shape[0], u10 = a10.shape[1], c10 = a10.shape[2], l10 = a10.shape[3], h10 = u10 * i10, p10 = c10 * i10, f10 = l10 / (i10 * i10), d10 = n10.data.get(a10.dataId).values, v10 = new Float32Array(s10 * h10 * p10 * f10), m10 = 0, g10 = 0; g10 < s10; ++g10) for (var y10 = 0; y10 < h10; ++y10) for (var b10 = Math.floor(y10 / i10), x10 = y10 % i10, k10 = 0; k10 < p10; ++k10) for (var w10 = Math.floor(k10 / i10), I10 = (x10 * i10 + k10 % i10) * f10, N10 = 0; N10 < f10; ++N10) {
          var S10 = N10 + I10 + l10 * (w10 + c10 * (b10 + u10 * g10));
          v10[m10++] = d10[S10];
        }
        return n10.makeTensorInfo([s10, h10, p10, f10], a10.dtype, v10);
      } };
      function $xe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.filter, o10 = r10.strides, s10 = r10.pad, u10 = r10.dilations, c10 = r10.dimRoundingMode;
        ige([a10, i10], "depthwiseConv2DNative");
        var l10 = i0(a10.shape), h10 = i0(i10.shape), p10 = u10;
        null == p10 && (p10 = [1, 1]), F$(j8(o10, p10), function() {
          return "Error in depthwiseConv2d: Either strides or dilations must be " + "1. Got strides ".concat(o10, " and dilations '").concat(p10, "'");
        });
        for (var f10 = D8(a10.shape, i10.shape, o10, p10, s10, c10, true), d10 = f10.filterHeight, v10 = f10.filterWidth, m10 = f10.dilationHeight, g10 = f10.dilationWidth, y10 = f10.padInfo, b10 = y10.left, x10 = y10.top, k10 = f10.outChannels / f10.inChannels, w10 = new $4(f10.outShape, a10.dtype), I10 = n10.data.get(a10.dataId).values, N10 = n10.data.get(i10.dataId).values, S10 = w10.values, T10 = 0; T10 < f10.batchSize; ++T10) for (var E10 = T10 * l10[0], C10 = T10 * w10.strides[0], A10 = 0; A10 < f10.outHeight; ++A10) for (var R10 = C10 + A10 * w10.strides[1], _10 = A10 * f10.strideHeight - x10, O10 = 0; O10 < d10; ++O10) {
          var F10 = _10 + O10 * m10;
          if (!(F10 < 0 || F10 >= f10.inHeight)) for (var D10 = O10 * h10[0], M10 = E10 + F10 * l10[1], L10 = 0; L10 < f10.outWidth; ++L10) for (var z10 = R10 + L10 * w10.strides[2], P10 = L10 * f10.strideWidth - b10, B10 = 0; B10 < v10; ++B10) {
            var W10 = P10 + B10 * g10;
            if (!(W10 < 0 || W10 >= f10.inWidth)) for (var U10 = D10 + B10 * h10[1], V10 = M10 + W10 * f10.inChannels, G10 = z10, j10 = U10, H10 = 0; H10 < f10.inChannels; ++H10) {
              for (var q10 = I10[V10 + H10], K10 = 0; K10 < k10; ++K10) S10[G10 + K10] += q10 * N10[j10 + K10];
              G10 += k10, j10 += k10;
            }
          }
        }
        return n10.makeTensorInfo(w10.shape, w10.dtype, w10.values);
      }
      var eke = { kernelName: f1, backendName: "cpu", kernelFunc: $xe };
      var tke = { kernelName: d1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.dy, o10 = r10.strides, s10 = r10.dilations, u10 = r10.pad, c10 = r10.dimRoundingMode, l10 = r10.filterShape;
        ige([a10, i10], "depthwiseConv2dNativeBackpropFilter");
        for (var h10 = D8(a10.shape, l10, o10, s10, u10, c10, true), p10 = h10.strideHeight, f10 = h10.strideWidth, d10 = h10.filterHeight, v10 = h10.filterWidth, m10 = new $4(h10.filterShape, "float32"), g10 = h10.padInfo.left, y10 = h10.padInfo.top, b10 = h10.outChannels / h10.inChannels, x10 = n10.data.get(a10.dataId).values, k10 = new $4(a10.shape, a10.dtype, x10), w10 = n10.data.get(i10.dataId).values, I10 = new $4(i10.shape, i10.dtype, w10), N10 = 0; N10 < d10; ++N10) for (var S10 = Math.max(0, Math.ceil((y10 - N10) / p10)), T10 = Math.min(h10.outHeight, (h10.inHeight + y10 - N10) / p10), E10 = 0; E10 < v10; ++E10) for (var C10 = Math.max(0, Math.ceil((g10 - E10) / f10)), A10 = Math.min(h10.outWidth, (h10.inWidth + g10 - E10) / f10), R10 = 0; R10 < h10.outChannels; ++R10) {
          for (var _10 = Math.trunc(R10 / b10), O10 = R10 % b10, F10 = 0, D10 = 0; D10 < h10.batchSize; ++D10) for (var M10 = S10; M10 < T10; ++M10) for (var L10 = N10 + M10 * p10 - y10, z10 = C10; z10 < A10; ++z10) {
            var P10 = E10 + z10 * f10 - g10;
            F10 += k10.get(D10, L10, P10, _10) * I10.get(D10, M10, z10, R10);
          }
          m10.set(F10, N10, E10, _10, O10);
        }
        return n10.makeTensorInfo(m10.shape, m10.dtype, m10.values);
      } };
      var nke = { kernelName: v1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.dy, i10 = t10.filter, o10 = r10.strides, s10 = r10.dilations, u10 = r10.pad, c10 = r10.dimRoundingMode, l10 = r10.inputShape;
        ige([a10, i10], "depthwiseConv2DNativeBackpropInput");
        for (var h10 = i0(a10.shape), p10 = i0(i10.shape), f10 = D8(l10, i10.shape, o10, s10, u10, c10, true), d10 = new $4(f10.inShape, "float32"), v10 = d10.values, m10 = S(d10.strides, 3), g10 = m10[0], y10 = m10[1], b10 = m10[2], x10 = n10.data.get(a10.dataId).values, k10 = S(h10, 3), w10 = k10[0], I10 = k10[1], N10 = k10[2], T10 = n10.data.get(i10.dataId).values, E10 = S(p10, 3), C10 = E10[0], A10 = E10[1], R10 = E10[2], _10 = f10.batchSize, O10 = f10.filterHeight, F10 = f10.filterWidth, D10 = f10.inChannels, M10 = f10.inHeight, L10 = f10.inWidth, z10 = f10.outChannels, P10 = f10.outHeight, B10 = f10.outWidth, W10 = f10.strideHeight, U10 = f10.strideWidth, V10 = O10 - 1 - f10.padInfo.top, G10 = F10 - 1 - f10.padInfo.left, j10 = z10 / D10, H10 = 0; H10 < _10; ++H10) for (var q10 = 0; q10 < D10; ++q10) for (var K10 = 0; K10 < M10; ++K10) for (var X10 = K10 - V10, Y10 = Math.max(0, Math.ceil(X10 / W10)), J10 = Math.min(P10, (O10 + X10) / W10), Z10 = 0; Z10 < L10; ++Z10) {
          for (var Q10 = Z10 - G10, $10 = Math.max(0, Math.ceil(Q10 / U10)), ee2 = Math.min(B10, (F10 + Q10) / U10), te2 = 0, ne2 = Y10; ne2 < J10; ++ne2) for (var re2 = ne2 * W10 - X10, ae2 = $10; ae2 < ee2; ++ae2) for (var ie2 = w10 * H10 + I10 * ne2 + N10 * ae2, oe2 = C10 * (O10 - 1 - re2) + A10 * (F10 - 1 - (ae2 * U10 - Q10)) + R10 * q10, se2 = 0; se2 < j10; ++se2) {
            te2 += x10[ie2 + (q10 * j10 + se2)] * T10[oe2 + se2];
          }
          v10[g10 * H10 + y10 * K10 + b10 * Z10 + q10] = te2;
        }
        return n10.makeTensorInfo(d10.shape, d10.dtype, d10.values);
      } };
      var rke = { kernelName: m1, backendName: "cpu", kernelFunc: function(e10) {
        for (var t10 = e10.inputs, n10 = e10.backend, r10 = t10.x, a10 = L$(r10.shape), i10 = n10.data.get(r10.dataId).values, o10 = l8([a10, a10], r10.dtype), s10 = o10.values, u10 = 0; u10 < i10.length; u10++) s10[u10 * a10 + u10] = i10[u10];
        var c10 = [].concat(T(r10.shape), T(r10.shape));
        return n10.makeTensorInfo(c10, o10.dtype, o10.values);
      } }, ake = { kernelName: g1, backendName: "cpu", kernelFunc: function(e10) {
        for (var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.filter, o10 = r10.strides, s10 = r10.pad, u10 = r10.dilations, c10 = n10, l10 = c10.data.get(a10.dataId).values, h10 = a10.shape.length, p10 = c10.data.get(i10.dataId).values, f10 = i10.shape.length, d10 = _8(a10.shape, i10.shape, o10, s10, "NHWC", u10), v10 = d10.batchSize, m10 = d10.inHeight, g10 = d10.inWidth, y10 = d10.inChannels, b10 = d10.outHeight, x10 = d10.outWidth, k10 = d10.padInfo, w10 = d10.strideHeight, I10 = d10.strideWidth, N10 = d10.filterHeight, S10 = d10.filterWidth, T10 = d10.dilationHeight, E10 = d10.dilationWidth, C10 = d10.outShape, A10 = L$(C10), R10 = C10.length, _10 = K$(a10.dtype, A10), O10 = 0; O10 < v10; ++O10) for (var F10 = 0; F10 < b10; ++F10) for (var D10 = F10 * w10 - k10.top, M10 = 0; M10 < x10; ++M10) for (var L10 = M10 * I10 - k10.left, z10 = 0; z10 < y10; ++z10) {
          for (var P10 = Number.MIN_SAFE_INTEGER, B10 = 0; B10 < N10; ++B10) {
            var W10 = D10 + B10 * T10;
            if (W10 >= 0 && W10 < m10) for (var U10 = 0; U10 < S10; ++U10) {
              var V10 = L10 + U10 * E10;
              if (V10 >= 0 && V10 < g10) {
                var G10 = f0([O10, W10, V10, z10], h10, i0(a10.shape)), j10 = f0([B10, U10, z10], f10, i0(i10.shape)), H10 = l10[G10] + p10[j10];
                H10 > P10 && (P10 = H10);
              }
            }
          }
          _10[f0([O10, F10, M10, z10], R10, i0(C10))] = P10;
        }
        return { dataId: c10.write(L4(_10, a10.dtype), C10, a10.dtype), shape: C10, dtype: a10.dtype };
      } }, ike = { kernelName: b1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.filter, o10 = t10.dy, s10 = r10.strides, u10 = r10.pad, c10 = r10.dilations, l10 = n10, h10 = s0(a10.shape, l10.data.get(a10.dataId).values), p10 = s0(i10.shape, l10.data.get(i10.dataId).values), f10 = _8(a10.shape, i10.shape, s10, u10, "NHWC", c10), d10 = f10.batchSize, v10 = f10.inHeight, m10 = f10.inWidth, g10 = f10.inChannels, y10 = f10.outHeight, b10 = f10.outWidth, x10 = f10.padInfo, k10 = f10.strideHeight, w10 = f10.strideWidth, I10 = f10.filterHeight, N10 = f10.filterWidth, S10 = f10.dilationHeight, T10 = f10.dilationWidth, E10 = f10.outShape;
        F$(o10.rank === E10.length, function() {
          return "Error in ".concat(b1, ", dy ") + "must have the same rank as output ".concat(E10.length, ", but got ") + "".concat(o10.rank);
        });
        for (var C10 = s0(E10, l10.data.get(o10.dataId).values), A10 = h0(i10.shape, i10.dtype), R10 = 0; R10 < d10; ++R10) for (var _10 = 0; _10 < y10; ++_10) for (var O10 = _10 * k10 - x10.top, F10 = 0; F10 < b10; ++F10) for (var D10 = F10 * w10 - x10.left, M10 = 0; M10 < g10; ++M10) {
          for (var L10 = Number.MIN_SAFE_INTEGER, z10 = 0, P10 = 0, B10 = 0; B10 < I10; ++B10) {
            var W10 = O10 + B10 * S10;
            if (W10 >= 0 && W10 < v10) for (var U10 = 0; U10 < N10; ++U10) {
              var V10 = D10 + U10 * T10;
              if (V10 >= 0 && V10 < m10) {
                var G10 = h10[R10][W10][V10][M10] + p10[B10][U10][M10];
                G10 > L10 && (L10 = G10, z10 = B10, P10 = U10);
              }
            }
          }
          A10[z10][P10][M10] += C10[R10][_10][F10][M10];
        }
        return { dataId: l10.write(L4(A10, a10.dtype), i10.shape, i10.dtype), shape: i10.shape, dtype: i10.dtype };
      } }, oke = { kernelName: y1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.filter, o10 = t10.dy, s10 = r10.strides, u10 = r10.pad, c10 = r10.dilations, l10 = n10, h10 = s0(a10.shape, l10.data.get(a10.dataId).values), p10 = s0(i10.shape, l10.data.get(i10.dataId).values), f10 = _8(a10.shape, i10.shape, s10, u10, "NHWC", c10), d10 = f10.batchSize, v10 = f10.inHeight, m10 = f10.inWidth, g10 = f10.inChannels, y10 = f10.outHeight, b10 = f10.outWidth, x10 = f10.padInfo, k10 = f10.strideHeight, w10 = f10.strideWidth, I10 = f10.filterHeight, N10 = f10.filterWidth, S10 = f10.dilationHeight, T10 = f10.dilationWidth, E10 = f10.outShape;
        F$(o10.rank === E10.length, function() {
          return "Error in ".concat(y1, ", dy ") + "must have the same rank as output ".concat(E10.length, ", but got ") + "".concat(o10.rank);
        });
        for (var C10 = s0(E10, l10.data.get(o10.dataId).values), A10 = h0(a10.shape, a10.dtype), R10 = 0; R10 < d10; ++R10) for (var _10 = 0; _10 < y10; ++_10) for (var O10 = _10 * k10 - x10.top, F10 = 0; F10 < b10; ++F10) for (var D10 = F10 * w10 - x10.left, M10 = 0; M10 < g10; ++M10) {
          for (var L10 = Number.MIN_SAFE_INTEGER, z10 = O10 < 0 ? 0 : O10, P10 = D10 < 0 ? 0 : D10, B10 = 0; B10 < I10; ++B10) {
            var W10 = O10 + B10 * S10;
            if (W10 >= 0 && W10 < v10) for (var U10 = 0; U10 < N10; ++U10) {
              var V10 = D10 + U10 * T10;
              if (V10 >= 0 && V10 < m10) {
                var G10 = h10[R10][W10][V10][M10] + p10[B10][U10][M10];
                G10 > L10 && (L10 = G10, z10 = W10, P10 = V10);
              }
            }
          }
          A10[R10][z10][P10][M10] += C10[R10][_10][F10][M10];
        }
        return { dataId: l10.write(L4(A10, a10.dtype), a10.shape, a10.dtype), shape: a10.shape, dtype: a10.dtype };
      } };
      var ske = { kernelName: x1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.image, i10 = r10.canvas, o10 = r10.options || {}, s10 = o10.contextOptions, u10 = o10.imageOptions, c10 = (null == u10 ? void 0 : u10.alpha) || 1, l10 = (null == s10 ? void 0 : s10.contextType) || "2d";
        if ("2d" !== l10) throw new Error("Context type ".concat(s10.contextType, " is not supported by the CPU backend."));
        var h10 = i10.getContext(l10, (null == s10 ? void 0 : s10.contextAttributes) || {});
        if (null == h10) throw new Error("Could not get the context with ".concat(l10, " type."));
        for (var p10 = S(a10.shape.slice(0, 2), 2), f10 = p10[0], d10 = p10[1], v10 = 2 === a10.shape.length ? 1 : a10.shape[2], m10 = n10.data.get(a10.dataId).values, g10 = "float32" === a10.dtype ? 255 : 1, y10 = new Uint8ClampedArray(d10 * f10 * 4), b10 = 0; b10 < f10 * d10; ++b10) {
          for (var x10 = [0, 0, 0, 255 * c10], k10 = 0; k10 < v10; k10++) {
            var w10 = m10[b10 * v10 + k10];
            if ("float32" === a10.dtype) {
              if (w10 < 0 || w10 > 1) throw new Error("Tensor values for a float32 Tensor must be in the " + "range [0 - 1] but encountered ".concat(w10, "."));
            } else if ("int32" === a10.dtype && (w10 < 0 || w10 > 255)) throw new Error("Tensor values for a int32 Tensor must be in the " + "range [0 - 255] but encountered ".concat(w10, "."));
            1 === v10 ? (x10[0] = w10 * g10, x10[1] = w10 * g10, x10[2] = w10 * g10) : x10[k10] = w10 * g10;
          }
          var I10 = 4 * b10;
          y10[I10 + 0] = Math.round(x10[0]), y10[I10 + 1] = Math.round(x10[1]), y10[I10 + 2] = Math.round(x10[2]), y10[I10 + 3] = Math.round(x10[3]);
        }
        i10.width = d10, i10.height = f10;
        var N10 = new ImageData(y10, d10, f10);
        return h10.putImageData(N10, 0, 0), a10;
      } };
      function uke(e10) {
        var t10, n10 = e10.inputs, r10 = e10.backend, a10 = e10.attrs, i10 = n10.x, o10 = a10.axis, s10 = a10.keepDims;
        ige(i10, "sum");
        var u10 = (t10 = "bool" === i10.dtype ? bge({ inputs: { x: i10 }, backend: r10, attrs: { dtype: "int32" } }) : dge({ inputs: { x: i10 }, backend: r10 })).shape.length, c10 = j$(o10, t10.shape), l10 = $7(c10, u10), h10 = c10, p10 = t10;
        null != l10 && (p10 = Mye({ inputs: { x: t10 }, backend: r10, attrs: { perm: l10 } }), h10 = t9(h10.length, u10)), Q7("sum", h10, p10.shape.length);
        for (var f10 = S(J7(p10.shape, h10), 2), d10 = f10[0], v10 = f10[1], m10 = fge(r10, d10, h5(p10.dtype, "int32")), g10 = L$(v10), y10 = r10.data.get(m10.dataId).values, b10 = r10.data.get(p10.dataId).values, x10 = 0; x10 < y10.length; ++x10) {
          for (var k10 = x10 * g10, w10 = 0, I10 = 0; I10 < g10; ++I10) w10 += b10[k10 + I10];
          y10[x10] = w10;
        }
        if (s10) {
          var N10 = m10;
          m10 = Xbe({ inputs: { x: m10 }, backend: r10, attrs: { shape: Z7(m10.shape, c10) } }), r10.disposeIntermediateTensorInfo(N10);
        }
        return r10.disposeIntermediateTensorInfo(t10), null != l10 && r10.disposeIntermediateTensorInfo(p10), m10;
      }
      var cke = { kernelName: a3, backendName: "cpu", kernelFunc: uke };
      var lke = { kernelName: w1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10, a10 = Lie(e10.attrs.equation, r10.length), i10 = a10.allDims, o10 = a10.summedDims, s10 = a10.idDims;
        Pie(i10.length, s10, r10);
        for (var u10 = Bie(o10, s10), c10 = u10.path, l10 = u10.steps, h10 = l10.length, p10 = null, f10 = i10.length, d10 = [], v10 = 0; v10 < h10; ++v10) {
          var m10, g10 = O(l10[v10]);
          try {
            for (g10.s(); !(m10 = g10.n()).done; ) {
              var y10 = m10.value, b10 = zie(f10, s10[y10]), x10 = b10.permutationIndices, k10 = b10.expandDims, w10 = void 0;
              Wie(x10) ? w10 = r10[y10] : (w10 = Mye({ inputs: { x: r10[y10] }, backend: n10, attrs: { perm: x10 } }), d10.push(w10));
              for (var I10 = w10.shape.slice(), N10 = 0; N10 < k10.length; ++N10) I10.splice(k10[N10], 0, 1);
              P$(w10.shape, I10) || (w10 = Xbe({ inputs: { x: w10 }, backend: n10, attrs: { shape: I10 } }), d10.push(w10)), null === p10 ? p10 = w10 : (p10 = Eye({ inputs: { a: w10, b: p10 }, backend: n10 }), d10.push(p10));
            }
          } catch (e11) {
            g10.e(e11);
          } finally {
            g10.f();
          }
          v10 < h10 - 1 && (c10[v10] >= 0 && (p10 = uke({ inputs: { x: p10 }, backend: n10, attrs: { axis: c10[v10] - (i10.length - f10), keepDims: false } }), d10.push(p10)), f10--);
        }
        for (var S10 = 0, T10 = d10; S10 < T10.length; S10++) {
          var E10 = T10[S10];
          E10 !== p10 && n10.disposeIntermediateTensorInfo(E10);
        }
        return p10;
      } };
      var hke = { kernelName: N1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.dy, a10 = t10.y;
        ige([r10, a10], "eluGrad");
        for (var i10 = new Float32Array(L$(a10.shape)), o10 = n10.data.get(a10.dataId).values, s10 = n10.data.get(r10.dataId).values, u10 = 0; u10 < o10.length; ++u10) {
          var c10 = o10[u10];
          i10[u10] = c10 >= 0 ? s10[u10] : s10[u10] * (c10 + 1);
        }
        return n10.makeTensorInfo(a10.shape, "float32", i10);
      } }, pke = Fge(S1, function(e10) {
        var t10 = Math.sign(e10), n10 = Math.abs(e10), r10 = 1 / (1 + 0.3275911 * n10);
        return t10 * (1 - ((((1.061405429 * r10 - 1.453152027) * r10 + 1.421413741) * r10 - 0.284496736) * r10 + 0.254829592) * r10 * Math.exp(-n10 * n10));
      }), fke = { kernelName: S1, backendName: "cpu", kernelFunc: pke };
      function dke(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.input, i10 = r10.dim, o10 = a10.shape.length, s10 = a10.shape.slice(), u10 = i10;
        return i10 < 0 && (F$(-(o10 + 1) <= i10, function() {
          return "Axis must be in the interval [".concat(-(o10 + 1), ", ").concat(o10, "]");
        }), u10 = o10 + i10 + 1), s10.splice(u10, 0, 1), Xbe({ inputs: { x: a10 }, backend: n10, attrs: { shape: s10 } });
      }
      var vke = { kernelName: C1, backendName: "cpu", kernelFunc: dke }, mke = lge(function(e10, t10) {
        return e10 / t10;
      }), gke = kge(k1, mke), yke = { kernelName: k1, backendName: "cpu", kernelFunc: gke };
      function bke(e10, t10, n10) {
        for (var r10 = e10.shape, a10 = r10[0], i10 = r10[1], o10 = n10.data.get(e10.dataId), s10 = o10.complexTensorInfos.real, u10 = o10.complexTensorInfos.imag, c10 = [a10, i10], l10 = L$(c10), h10 = q$("float32", l10), p10 = q$("float32", l10), f10 = 0; f10 < a10; f10++) {
          for (var d10 = ibe({ inputs: { x: s10 }, backend: n10, attrs: { begin: [f10, 0], size: [1, i10] } }), v10 = ibe({ inputs: { x: u10 }, backend: n10, attrs: { begin: [f10, 0], size: [1, i10] } }), m10 = hge({ inputs: { real: d10, imag: v10 }, backend: n10 }), g10 = xke(m10, t10, n10), y10 = Tie(g10.real, g10.imag), b10 = 0; b10 < i10; b10++) {
            var x10 = Rie(y10, b10);
            h10[f10 * i10 + b10] = x10.real, p10[f10 * i10 + b10] = x10.imag;
          }
          n10.disposeIntermediateTensorInfo(d10), n10.disposeIntermediateTensorInfo(v10), n10.disposeIntermediateTensorInfo(m10);
        }
        var k10 = n10.makeTensorInfo(c10, "float32", h10), w10 = n10.makeTensorInfo(c10, "float32", p10), I10 = hge({ inputs: { real: k10, imag: w10 }, backend: n10 });
        return n10.disposeIntermediateTensorInfo(k10), n10.disposeIntermediateTensorInfo(w10), I10;
      }
      function xke(e10, t10, n10) {
        var r10 = L$(e10.shape), a10 = n10.data.get(e10.dataId), i10 = n10.data.get(a10.complexTensorInfos.real.dataId).values, o10 = n10.data.get(a10.complexTensorInfos.imag.dataId).values;
        if (0 == ((g10 = r10) & g10 - 1)) {
          var s10 = kke(i10, o10, r10, t10, n10), u10 = [e10.shape[0], e10.shape[1]];
          if (t10) {
            var c10 = n10.makeTensorInfo(u10, "float32", s10.real), l10 = n10.makeTensorInfo(u10, "float32", s10.imag), h10 = n10.makeTensorInfo([], "float32", M4(r10, "float32")), p10 = dge({ inputs: { x: h10 }, backend: n10 }), f10 = yke.kernelFunc({ inputs: { a: c10, b: h10 }, backend: n10 }), d10 = yke.kernelFunc({ inputs: { a: l10, b: p10 }, backend: n10 }), v10 = n10.data.get(f10.dataId).values, m10 = n10.data.get(d10.dataId).values;
            return n10.disposeIntermediateTensorInfo(c10), n10.disposeIntermediateTensorInfo(l10), n10.disposeIntermediateTensorInfo(h10), n10.disposeIntermediateTensorInfo(p10), n10.disposeIntermediateTensorInfo(f10), n10.disposeIntermediateTensorInfo(d10), { real: v10, imag: m10 };
          }
          return s10;
        }
        var g10, y10 = function(e11, t11, n11) {
          for (var r11 = new Float32Array(2 * t11), a11 = 0; a11 < t11; a11++) {
            for (var i11 = 0, o11 = 0, s11 = 0; s11 < t11; s11++) {
              var u11 = Fie(a11 * s11, t11, n11), c11 = Rie(e11, s11);
              i11 += c11.real * u11.real - c11.imag * u11.imag, o11 += c11.real * u11.imag + c11.imag * u11.real;
            }
            n11 && (i11 /= t11, o11 /= t11), _ie(r11, i11, o11, a11);
          }
          return r11;
        }(Tie(i10, o10), r10, t10);
        return Eie(y10);
      }
      function kke(e10, t10, n10, r10, a10) {
        if (1 === n10) return { real: e10, imag: t10 };
        var i10 = Tie(e10, t10), o10 = n10 / 2, s10 = Cie(i10), u10 = s10.real, c10 = s10.imag, l10 = [u10.length], h10 = a10.makeTensorInfo(l10, "float32", u10), p10 = a10.makeTensorInfo(l10, "float32", c10), f10 = hge({ inputs: { real: h10, imag: p10 }, backend: a10 }), d10 = Aie(i10), v10 = d10.real, m10 = d10.imag, g10 = [v10.length], y10 = a10.makeTensorInfo(g10, "float32", v10), b10 = a10.makeTensorInfo(g10, "float32", m10), x10 = hge({ inputs: { real: y10, imag: b10 }, backend: a10 }), k10 = kke(u10, c10, o10, r10, a10), w10 = k10.real, I10 = k10.imag, N10 = [w10.length], S10 = a10.makeTensorInfo(N10, "float32", w10), T10 = a10.makeTensorInfo(N10, "float32", I10), E10 = hge({ inputs: { real: S10, imag: T10 }, backend: a10 }), C10 = kke(v10, m10, o10, r10, a10), A10 = C10.real, R10 = C10.imag, _10 = [A10.length], O10 = a10.makeTensorInfo(_10, "float32", A10), F10 = a10.makeTensorInfo(_10, "float32", R10), D10 = hge({ inputs: { real: O10, imag: F10 }, backend: a10 }), M10 = Oie(n10, r10), L10 = [M10.real.length], z10 = a10.makeTensorInfo(L10, "float32", M10.real), P10 = a10.makeTensorInfo(L10, "float32", M10.imag), B10 = hge({ inputs: { real: z10, imag: P10 }, backend: a10 }), W10 = Eye({ inputs: { a: B10, b: D10 }, backend: a10 }), U10 = Sge({ inputs: { a: E10, b: W10 }, backend: a10 }), V10 = Ebe({ inputs: { a: E10, b: W10 }, backend: a10 }), G10 = mge({ inputs: { input: U10 }, backend: a10 }), j10 = mge({ inputs: { input: V10 }, backend: a10 }), H10 = Fxe({ inputs: { input: U10 }, backend: a10 }), q10 = Fxe({ inputs: { input: V10 }, backend: a10 }), K10 = Mxe({ inputs: [G10, j10], backend: a10, attrs: { axis: 0 } }), X10 = Mxe({ inputs: [H10, q10], backend: a10, attrs: { axis: 0 } }), Y10 = a10.data.get(K10.dataId).values, J10 = a10.data.get(X10.dataId).values;
        return a10.disposeIntermediateTensorInfo(h10), a10.disposeIntermediateTensorInfo(p10), a10.disposeIntermediateTensorInfo(f10), a10.disposeIntermediateTensorInfo(y10), a10.disposeIntermediateTensorInfo(b10), a10.disposeIntermediateTensorInfo(x10), a10.disposeIntermediateTensorInfo(S10), a10.disposeIntermediateTensorInfo(T10), a10.disposeIntermediateTensorInfo(E10), a10.disposeIntermediateTensorInfo(O10), a10.disposeIntermediateTensorInfo(F10), a10.disposeIntermediateTensorInfo(D10), a10.disposeIntermediateTensorInfo(z10), a10.disposeIntermediateTensorInfo(P10), a10.disposeIntermediateTensorInfo(B10), a10.disposeIntermediateTensorInfo(W10), a10.disposeIntermediateTensorInfo(U10), a10.disposeIntermediateTensorInfo(V10), a10.disposeIntermediateTensorInfo(G10), a10.disposeIntermediateTensorInfo(H10), a10.disposeIntermediateTensorInfo(j10), a10.disposeIntermediateTensorInfo(q10), a10.disposeIntermediateTensorInfo(K10), a10.disposeIntermediateTensorInfo(X10), { real: Y10, imag: J10 };
      }
      var wke = { kernelName: R1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.input, a10 = L$(r10.shape), i10 = r10.shape[r10.shape.length - 1], o10 = Xbe({ inputs: { x: r10 }, backend: n10, attrs: { shape: [a10 / i10, i10] } }), s10 = bke(o10, false, n10), u10 = Xbe({ inputs: { x: s10 }, backend: n10, attrs: { shape: r10.shape } });
        return n10.disposeIntermediateTensorInfo(o10), n10.disposeIntermediateTensorInfo(s10), u10;
      } };
      function Ike(e10) {
        var t10 = e10.backend, n10 = e10.attrs, r10 = n10.shape, a10 = n10.value, i10 = n10.dtype || n0(a10), o10 = K$(i10, L$(r10));
        return function(e11, t11, n11) {
          e11.fill(t11);
        }(o10, a10), t10.makeTensorInfo(r10, i10, o10);
      }
      var Nke = { kernelName: _1, backendName: "cpu", kernelFunc: Ike };
      var Ske = { kernelName: O1, backendName: "cpu", kernelFunc: function(e10) {
        for (var t10 = e10.inputs, n10 = (e10.attrs, e10.backend), r10 = t10.image, a10 = n10, i10 = q$(r10.dtype, L$(r10.shape)), o10 = S(r10.shape, 4), s10 = o10[0], u10 = o10[1], c10 = o10[2], l10 = o10[3], h10 = a10.data.get(r10.dataId).values, p10 = 0; p10 < s10; p10++) for (var f10 = p10 * c10 * u10 * l10, d10 = 0; d10 < u10; d10++) for (var v10 = d10 * (c10 * l10), m10 = 0; m10 < c10; m10++) for (var g10 = m10 * l10, y10 = 0; y10 < l10; y10++) {
          var b10 = Math.round(c10 - m10 - 1), x10 = f10 + v10 + g10 + y10, k10 = h10[x10];
          if (b10 >= 0 && b10 < c10) k10 = h10[f10 + v10 + b10 * l10 + y10];
          i10[x10] = k10;
        }
        return { dataId: a10.write(i10, r10.shape, r10.dtype), shape: r10.shape, dtype: r10.dtype };
      } };
      var Tke = { kernelName: M3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.filter, o10 = t10.bias, s10 = t10.preluActivationWeights, u10 = r10.strides, c10 = r10.pad, l10 = r10.dataFormat, h10 = r10.dilations, p10 = r10.dimRoundingMode, f10 = r10.activation, d10 = r10.leakyreluAlpha, v10 = zxe({ inputs: { x: a10, filter: i10 }, backend: n10, attrs: { strides: u10, pad: c10, dataFormat: l10, dilations: h10, dimRoundingMode: p10 } });
        if (o10) {
          var m10 = v10;
          if ("NCHW" === l10 && 1 === o10.shape.length && 1 !== o10.shape[0]) {
            var g10 = Xbe({ inputs: { x: o10 }, backend: n10, attrs: { shape: [o10.shape[0], 1, 1] } });
            v10 = Sge({ inputs: { a: v10, b: g10 }, backend: n10 }), n10.disposeIntermediateTensorInfo(g10);
          } else v10 = Sge({ inputs: { a: v10, b: o10 }, backend: n10 });
          n10.disposeIntermediateTensorInfo(m10);
        }
        if (f10) {
          var y10 = v10;
          if ("NCHW" === l10 && "prelu" === f10 && 1 === s10.shape.length && 1 !== s10.shape[0]) {
            var b10 = Xbe({ inputs: { x: s10 }, backend: n10, attrs: { shape: [s10.shape[0], 1, 1] } });
            v10 = Kbe(n10, v10, f10, b10, d10), n10.disposeIntermediateTensorInfo(b10);
          } else v10 = Kbe(n10, v10, f10, s10, d10);
          n10.disposeIntermediateTensorInfo(y10);
        }
        return v10;
      } };
      var Eke = { kernelName: L3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.filter, o10 = t10.bias, s10 = t10.preluActivationWeights, u10 = r10.strides, c10 = r10.pad, l10 = r10.dataFormat, h10 = r10.dilations, p10 = r10.dimRoundingMode, f10 = r10.activation, d10 = r10.leakyreluAlpha, v10 = $xe({ inputs: { x: a10, filter: i10 }, backend: n10, attrs: { strides: u10, pad: c10, dataFormat: l10, dilations: h10, dimRoundingMode: p10 } });
        if (o10) {
          var m10 = v10;
          v10 = Sge({ inputs: { a: v10, b: o10 }, backend: n10 }), n10.disposeIntermediateTensorInfo(m10);
        }
        if (f10) {
          var g10 = v10;
          v10 = Kbe(n10, v10, f10, s10, d10), n10.disposeIntermediateTensorInfo(g10);
        }
        return v10;
      } };
      var Cke = { kernelName: z1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.params, a10 = t10.indices, i10 = L$(r10.shape), o10 = a10.shape, s10 = o10[o10.length - 1], u10 = S(Mae(r10, a10), 4), c10 = u10[0], l10 = u10[1], h10 = u10[2], p10 = u10[3];
        if (0 === l10) return n10.makeTensorInfo(c10, r10.dtype, []);
        var f10 = eye(n10.data.get(a10.dataId).values, n10.bufferSync(r10), r10.dtype, l10, s10, h10, p10, r10.shape, i10);
        return n10.makeTensorInfo(c10, r10.dtype, f10.values);
      } };
      var Ake = { kernelName: L1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.indices, o10 = r10.axis, s10 = r10.batchDims;
        ige([a10, i10], "gatherV2");
        for (var u10 = j$(o10, a10.shape)[0], c10 = n10.data.get(i10.dataId).values, l10 = a10.shape[u10], h10 = function() {
          var e11 = c10[p10];
          F$(e11 <= l10 - 1 && e11 >= 0, function() {
            return "GatherV2: the index value ".concat(e11, " is not in [0, ").concat(l10 - 1, "]");
          });
        }, p10 = 0; p10 < c10.length; ++p10) h10();
        var f10 = s10;
        null == s10 && (f10 = 0);
        var d10 = L$(i10.shape), v10 = roe(a10, i10, u10, f10), m10 = Xbe({ inputs: { x: a10 }, backend: n10, attrs: { shape: [v10.batchSize, v10.outerSize, v10.dimSize, v10.sliceSize] } }), g10 = Xbe({ inputs: { x: i10 }, backend: n10, attrs: { shape: [v10.batchSize, d10 / v10.batchSize] } }), y10 = [v10.batchSize, v10.outerSize, d10 / v10.batchSize, v10.sliceSize], b10 = n10.bufferSync(g10), x10 = tye(n10.bufferSync(m10), b10, y10);
        return n10.disposeIntermediateTensorInfo(m10), n10.disposeIntermediateTensorInfo(g10), n10.makeTensorInfo(v10.outputShape, x10.dtype, x10.values);
      } };
      var Rke = { kernelName: U1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.input, a10 = L$(r10.shape), i10 = r10.shape[r10.shape.length - 1], o10 = Xbe({ inputs: { x: r10 }, backend: n10, attrs: { shape: [a10 / i10, i10] } }), s10 = bke(o10, true, n10), u10 = Xbe({ inputs: { x: s10 }, backend: n10, attrs: { shape: r10.shape } });
        return n10.disposeIntermediateTensorInfo(o10), n10.disposeIntermediateTensorInfo(s10), u10;
      } }, _ke = Fge(G1, function(e10) {
        return Number.isFinite(e10) ? 1 : 0;
      }, "bool"), Oke = { kernelName: G1, backendName: "cpu", kernelFunc: _ke }, Fke = Fge(j1, function(e10) {
        return Math.abs(e10) === 1 / 0 ? 1 : 0;
      }, "bool"), Dke = { kernelName: j1, backendName: "cpu", kernelFunc: Fke }, Mke = Fge(H1, function(e10) {
        return Number.isNaN(e10) ? 1 : 0;
      }, "bool"), Lke = { kernelName: H1, backendName: "cpu", kernelFunc: Mke };
      var zke = { kernelName: Y1, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.backend, n10 = e10.attrs, r10 = dye(n10.start, n10.stop, n10.num);
        return t10.makeTensorInfo([r10.length], "float32", r10);
      } }, Pke = Fge(Z1, function(e10) {
        return Math.log1p(e10);
      }), Bke = { kernelName: Z1, backendName: "cpu", kernelFunc: Pke }, Wke = lge(function(e10, t10) {
        return e10 && t10;
      }), Uke = kge(Q1, Wke, null, "bool"), Vke = { kernelName: Q1, backendName: "cpu", kernelFunc: Uke }, Gke = Fge($1, function(e10) {
        return e10 ? 0 : 1;
      }, "bool"), jke = { kernelName: $1, backendName: "cpu", kernelFunc: Gke }, Hke = lge(function(e10, t10) {
        return e10 || t10;
      }), qke = kge(e2, Hke, null, "bool"), Kke = { kernelName: e2, backendName: "cpu", kernelFunc: qke };
      var Xke = { kernelName: n2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.depthRadius, o10 = r10.bias, s10 = r10.alpha, u10 = r10.beta;
        ige(a10, "LRN");
        var c10 = a10.shape[3], l10 = c10 - 1, h10 = n10.data.get(a10.dataId).values, p10 = L$(a10.shape), f10 = new Float32Array(p10);
        function d10(e11) {
          for (var t11 = e11 % c10, n11 = e11 - t11 + Math.max(0, t11 - i10), r11 = e11 - t11 + Math.min(t11 + i10, l10), a11 = 0; n11 <= r11; n11++) {
            var o11 = h10[n11];
            a11 += o11 * o11;
          }
          return a11;
        }
        for (var v10 = 0; v10 < p10; v10++) {
          var m10 = d10(v10), g10 = h10[v10] * Math.pow(o10 + s10 * m10, -u10);
          f10[v10] = g10;
        }
        return n10.makeTensorInfo(a10.shape, a10.dtype, f10);
      } };
      var Yke = { kernelName: r2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.y, o10 = t10.dy, s10 = r10.depthRadius, u10 = r10.bias, c10 = r10.alpha, l10 = r10.beta;
        ige(o10, "LRNGrad");
        for (var h10 = L$(o10.shape), p10 = o10.shape[3], f10 = n10.data.get(o10.dataId).values, d10 = n10.data.get(a10.dataId).values, v10 = n10.data.get(i10.dataId).values, m10 = new Float32Array(h10), g10 = h10, y10 = 0; y10 < g10; y10++) {
          for (var b10 = y10 % p10, x10 = y10 - b10 + Math.max(0, b10 - s10), k10 = y10 - b10 + Math.min(p10, b10 + s10 + 1), w10 = 0, I10 = x10; I10 < k10; I10++) w10 += Math.pow(d10[I10], 2);
          w10 = c10 * w10 + u10;
          for (var N10 = x10; N10 < k10; N10++) {
            var S10 = -2 * c10 * l10 * d10[N10] * v10[y10] / w10;
            y10 === N10 && (S10 += Math.pow(w10, -l10)), S10 *= f10[y10], m10[N10] += S10;
          }
        }
        return n10.makeTensorInfo(o10.shape, a10.dtype, m10);
      } };
      function Jke(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.reductionIndices, o10 = r10.keepDims, s10 = n10, u10 = a10.shape, c10 = u10.length, l10 = j$(i10, u10), h10 = l10, p10 = $7(h10, c10), f10 = s10.data.get(a10.dataId).values;
        if (null != p10) {
          for (var d10 = new Array(c10), v10 = 0; v10 < d10.length; v10++) d10[v10] = u10[p10[v10]];
          f10 = Dye(f10, u10, a10.dtype, p10, d10), h10 = t9(h10.length, c10), u10 = d10;
        }
        ige(a10, "max"), Q7("max", h10, c10);
        var m10 = S(J7(u10, h10), 2), g10 = m10[0], y10 = yye(f10, L$(m10[1]), g10, a10.dtype), b10 = s10.write(y10, g10, a10.dtype), x10 = g10;
        o10 && (x10 = Z7(g10, l10));
        return { dataId: b10, shape: x10, dtype: a10.dtype };
      }
      var Zke = { kernelName: a2, backendName: "cpu", kernelFunc: Jke };
      var Qke = { kernelName: o2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x;
        ige(a10, "maxPool");
        var i10 = r10.filterSize, o10 = r10.strides, s10 = r10.pad, u10 = r10.dimRoundingMode;
        F$(j8(o10, 1), function() {
          return "Error in maxPool: Either strides or dilations must be 1. " + "Got strides ".concat(o10, " and dilations '").concat(1, "'");
        });
        var c10, l10 = O8(a10.shape, i10, o10, 1, s10, u10);
        if (1 === l10.filterWidth && 1 === l10.filterHeight && P$(l10.inShape, l10.outShape)) c10 = dge({ inputs: { x: a10 }, backend: n10 });
        else {
          var h10 = n10.data.get(a10.dataId).values, p10 = i0(a10.shape), f10 = bxe(h10, a10.shape, a10.dtype, p10, l10, "max");
          c10 = n10.makeTensorInfo(l10.outShape, a10.dtype, f10.values);
        }
        return c10;
      } };
      var $ke = { kernelName: u2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.filterSize, o10 = r10.strides, s10 = r10.pad, u10 = r10.dimRoundingMode, c10 = r10.dataFormat;
        ige(a10, "maxPool3d");
        var l10 = F8(a10.shape, i10, o10, 1, s10, u10, c10), h10 = kxe(n10.data.get(a10.dataId).values, a10.shape, a10.dtype, i0(a10.shape), l10, "max");
        return n10.makeTensorInfo(h10.shape, "float32", h10.values);
      } };
      var ewe = { kernelName: c2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.dy, i10 = t10.input, o10 = r10.filterSize, s10 = r10.strides, u10 = r10.pad, c10 = r10.dimRoundingMode;
        ige([a10, i10], "maxPool3DGrad");
        for (var l10 = F8(i10.shape, o10, s10, 1, u10, c10), h10 = function(e11, t11) {
          for (var n11 = l8(t11.outShape, "int32"), r11 = t11.strideDepth, a11 = t11.strideHeight, i11 = t11.strideWidth, o11 = t11.dilationDepth, s11 = t11.dilationHeight, u11 = t11.dilationWidth, c11 = t11.effectiveFilterDepth, l11 = t11.effectiveFilterHeight, h11 = t11.effectiveFilterWidth, p11 = t11.padInfo.front, f11 = t11.padInfo.top, d11 = t11.padInfo.left, v11 = 0; v11 < t11.batchSize; ++v11) for (var m11 = 0; m11 < t11.inChannels; ++m11) for (var g11 = 0; g11 < t11.outDepth; ++g11) {
            for (var y11 = g11 * r11 - p11, b11 = y11; b11 < 0; ) b11 += o11;
            for (var x11 = Math.min(t11.inDepth, c11 + y11), k11 = 0; k11 < t11.outHeight; ++k11) {
              for (var w11 = k11 * a11 - f11, I11 = w11; I11 < 0; ) I11 += s11;
              for (var N11 = Math.min(t11.inHeight, l11 + w11), S11 = 0; S11 < t11.outWidth; ++S11) {
                for (var T11 = S11 * i11 - d11, E11 = T11; E11 < 0; ) E11 += u11;
                for (var C11 = Math.min(t11.inWidth, h11 + T11), A11 = Number.NEGATIVE_INFINITY, R11 = -1, _11 = b11; _11 < x11; _11 += o11) for (var O11 = _11 - y11, F11 = I11; F11 < N11; F11 += s11) for (var D11 = F11 - w11, M11 = E11; M11 < C11; M11 += u11) {
                  var L11 = M11 - T11, z11 = e11.get(v11, _11, F11, M11, m11);
                  z11 >= A11 && (A11 = z11, R11 = O11 * l11 * h11 + D11 * l11 + L11);
                }
                n11.set(R11, v11, g11, k11, S11, m11);
              }
            }
          }
          return n11;
        }(n10.bufferSync(i10), l10), p10 = l10.strideDepth, f10 = l10.strideHeight, d10 = l10.strideWidth, v10 = l10.dilationDepth, m10 = l10.dilationHeight, g10 = l10.dilationWidth, y10 = l10.effectiveFilterDepth, b10 = l10.effectiveFilterHeight, x10 = l10.effectiveFilterWidth, k10 = y10 - 1 - l10.padInfo.front, w10 = x10 - 1 - l10.padInfo.left, I10 = b10 - 1 - l10.padInfo.top, N10 = l8(i10.shape, "float32"), S10 = n10.bufferSync(a10), T10 = 0; T10 < l10.batchSize; ++T10) for (var E10 = 0; E10 < l10.inChannels; ++E10) for (var C10 = 0; C10 < l10.inDepth; ++C10) for (var A10 = 0; A10 < l10.inHeight; ++A10) for (var R10 = 0; R10 < l10.inWidth; ++R10) {
          for (var _10 = C10 - k10, O10 = A10 - I10, F10 = R10 - w10, D10 = 0, M10 = 0; M10 < y10; M10 += v10) {
            var L10 = (_10 + M10) / p10;
            if (!(L10 < 0 || L10 >= l10.outDepth || Math.floor(L10) !== L10)) for (var z10 = 0; z10 < b10; z10 += m10) {
              var P10 = (O10 + z10) / f10;
              if (!(P10 < 0 || P10 >= l10.outHeight || Math.floor(P10) !== P10)) for (var B10 = 0; B10 < x10; B10 += g10) {
                var W10 = (F10 + B10) / d10;
                if (!(W10 < 0 || W10 >= l10.outWidth || Math.floor(W10) !== W10)) {
                  var U10 = y10 * b10 * x10 - 1 - h10.get(T10, L10, P10, W10, E10) === M10 * b10 * x10 + z10 * x10 + B10 ? 1 : 0;
                  if (0 !== U10) D10 += S10.get(T10, L10, P10, W10, E10) * U10;
                }
              }
            }
          }
          N10.set(D10, T10, C10, A10, R10, E10);
        }
        return n10.makeTensorInfo(N10.shape, N10.dtype, N10.values);
      } };
      var twe = { kernelName: s2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.dy, i10 = t10.input, o10 = i10;
        ige([i10, t10.output], "maxPoolGrad");
        for (var s10 = r10.filterSize, u10 = r10.strides, c10 = r10.pad, l10 = r10.dimRoundingMode, h10 = O8(o10.shape, s10, u10, 1, c10, l10), p10 = n10.data.get(o10.dataId).values, f10 = l8(h10.outShape, o10.dtype, xxe(p10, o10.shape, o10.dtype, h10).values), d10 = h10.strideHeight, v10 = h10.strideWidth, m10 = h10.dilationHeight, g10 = h10.dilationWidth, y10 = h10.effectiveFilterHeight, b10 = h10.effectiveFilterWidth, x10 = b10 - 1 - h10.padInfo.left, k10 = y10 - 1 - h10.padInfo.top, w10 = l8(o10.shape, "float32"), I10 = n10.data.get(a10.dataId).values, N10 = l8(a10.shape, "float32", I10), S10 = 0; S10 < h10.batchSize; ++S10) for (var T10 = 0; T10 < h10.inChannels; ++T10) for (var E10 = 0; E10 < h10.inHeight; ++E10) for (var C10 = 0; C10 < h10.inWidth; ++C10) {
          for (var A10 = E10 - k10, R10 = C10 - x10, _10 = 0, O10 = 0; O10 < y10; O10 += m10) {
            var F10 = (A10 + O10) / d10;
            if (!(F10 < 0 || F10 >= h10.outHeight || Math.floor(F10) !== F10)) for (var D10 = 0; D10 < b10; D10 += g10) {
              var M10 = (R10 + D10) / v10;
              if (!(M10 < 0 || M10 >= h10.outWidth || Math.floor(M10) !== M10)) {
                var L10 = y10 * b10 - 1 - f10.get(S10, F10, M10, T10) === O10 * b10 + D10 ? 1 : 0;
                if (0 !== L10) _10 += N10.get(S10, F10, M10, T10) * L10;
              }
            }
          }
          w10.set(_10, S10, E10, C10, T10);
        }
        return n10.makeTensorInfo(w10.shape, w10.dtype, w10.values);
      } };
      var nwe = { kernelName: l2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.attrs, r10 = e10.backend, a10 = t10.x, i10 = n10.filterSize, o10 = n10.strides, s10 = n10.pad, u10 = n10.includeBatchInIndex, c10 = r10;
        ige(a10, "MaxPoolWithArgmax");
        var l10 = c10.data.get(a10.dataId).values, h10 = O8(a10.shape, i10, o10, [1, 1], s10), p10 = function(e11, t11, n11, r11, a11) {
          var i11 = bxe(e11, 0, n11, i0(t11), a11, "max"), o11 = xxe(e11, t11, n11, a11, true, r11);
          return [i11.values, o11.values];
        }(l10, a10.shape, a10.dtype, u10, h10), f10 = S(p10, 2), d10 = f10[0], v10 = f10[1], m10 = c10.write(d10, h10.outShape, a10.dtype), g10 = c10.write(v10, h10.outShape, a10.dtype);
        return [{ dataId: m10, shape: h10.outShape, dtype: a10.dtype }, { dataId: g10, shape: h10.outShape, dtype: "int32" }];
      } };
      var rwe = { kernelName: h2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.axis, o10 = r10.keepDims, s10 = j$(i10, a10.shape), u10 = L$(J7(a10.shape, s10)[1]), c10 = [], l10 = n10.makeTensorInfo([], "float32", new Float32Array([u10]));
        c10.push(l10);
        var h10 = bge({ inputs: { x: a10 }, backend: n10, attrs: { dtype: "float32" } });
        c10.push(h10);
        var p10 = gke({ inputs: { a: h10, b: l10 }, backend: n10 });
        c10.push(p10);
        var f10 = uke({ inputs: { x: p10 }, backend: n10, attrs: { axis: i10, keepDims: o10 } });
        return c10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), f10;
      } };
      var awe = { kernelName: p2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.axis, o10 = r10.keepDims;
        ige(a10, "min");
        var s10 = j$(i10, a10.shape), u10 = s10, c10 = $7(u10, a10.shape.length), l10 = a10;
        null != c10 && (l10 = Mye({ inputs: { x: a10 }, backend: n10, attrs: { perm: c10 } }), u10 = t9(u10.length, a10.shape.length)), Q7("min", u10, l10.shape.length);
        for (var h10 = S(J7(l10.shape, u10), 2), p10 = h10[0], f10 = L$(h10[1]), d10 = l0(L$(p10), l10.dtype), v10 = n10.data.get(l10.dataId).values, m10 = 0; m10 < d10.length; ++m10) {
          for (var g10 = m10 * f10, y10 = v10[g10], b10 = 0; b10 < f10; ++b10) {
            var x10 = v10[g10 + b10];
            (Number.isNaN(x10) || x10 < y10) && (y10 = x10);
          }
          d10[m10] = y10;
        }
        null != c10 && n10.disposeIntermediateTensorInfo(l10);
        var k10 = n10.makeTensorInfo(p10, l10.dtype, d10);
        if (o10) {
          var w10 = Xbe({ inputs: { x: k10 }, backend: n10, attrs: { shape: Z7(p10, s10) } });
          return n10.disposeIntermediateTensorInfo(k10), w10;
        }
        return k10;
      } };
      var iwe = { kernelName: d2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.paddings, o10 = r10.mode;
        ige(a10, "mirrorPad");
        for (var s10 = i10.map(function(e11, t11) {
          return e11[0] + a10.shape[t11] + e11[1];
        }), u10 = i10.map(function(e11) {
          return e11[0];
        }), c10 = i10.map(function(e11, t11) {
          return e11[0] + a10.shape[t11];
        }), l10 = "reflect" === o10 ? 0 : 1, h10 = n10.data.get(a10.dataId).values, p10 = a10.shape.length, f10 = i0(a10.shape), d10 = L$(s10), v10 = s10.length, m10 = i0(s10), g10 = q$(a10.dtype, d10), y10 = 0; y10 < d10; y10++) {
          for (var b10 = d0(y10, v10, m10), x10 = 0; x10 < v10; x10++) b10[x10] < u10[x10] ? b10[x10] = 2 * u10[x10] - b10[x10] - l10 : b10[x10] >= c10[x10] && (b10[x10] = 2 * (c10[x10] - 1) - b10[x10] + l10);
          b10 = b10.map(function(e11, t11) {
            return e11 - u10[t11];
          });
          var k10 = f0(b10, p10, f10);
          g10[y10] = h10[k10];
        }
        return { dataId: n10.write(g10, s10, a10.dtype), shape: s10, dtype: a10.dtype };
      } }, owe = lge(function(e10, t10) {
        var n10 = e10 % t10;
        return e10 < 0 && t10 < 0 || e10 >= 0 && t10 >= 0 ? n10 : (n10 + t10) % t10;
      }), swe = kge(v2, owe), uwe = { kernelName: v2, backendName: "cpu", kernelFunc: swe };
      function cwe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.logits, i10 = r10.dim, o10 = a10.shape.length, s10 = i10;
        if (-1 === s10 && (s10 = o10 - 1), s10 !== o10 - 1) throw Error("Softmax along a non-last dimension is not yet supported. " + "Logits was rank ".concat(o10, " and dim was ").concat(s10));
        var u10 = j$([s10], a10.shape), c10 = Jke({ inputs: { x: a10 }, backend: n10, attrs: { reductionIndices: u10, keepDims: false } }), l10 = Z7(c10.shape, u10), h10 = Xbe({ inputs: { x: c10 }, backend: n10, attrs: { shape: l10 } }), p10 = Ebe({ inputs: { a: a10, b: h10 }, backend: n10 }), f10 = Gge({ inputs: { x: p10 }, backend: n10 }), d10 = uke({ inputs: { x: f10 }, backend: n10, attrs: { axis: u10, keepDims: false } }), v10 = Xbe({ inputs: { x: d10 }, backend: n10, attrs: { shape: l10 } }), m10 = gke({ inputs: { a: f10, b: v10 }, backend: n10 });
        return n10.disposeIntermediateTensorInfo(c10), n10.disposeIntermediateTensorInfo(h10), n10.disposeIntermediateTensorInfo(p10), n10.disposeIntermediateTensorInfo(f10), n10.disposeIntermediateTensorInfo(d10), n10.disposeIntermediateTensorInfo(v10), m10;
      }
      var lwe = { kernelName: s3, backendName: "cpu", kernelFunc: cwe };
      var hwe = { kernelName: m2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.logits, i10 = r10.numSamples, o10 = r10.seed, s10 = r10.normalized;
        ige(a10, "multinomial");
        for (var u10 = s10 ? a10 : cwe({ inputs: { logits: a10 }, backend: n10, attrs: { dim: -1 } }), c10 = u10.shape[0], l10 = u10.shape[1], h10 = n10.data.get(u10.dataId).values, p10 = [c10, i10], f10 = l0(L$(p10), "int32"), d10 = 0; d10 < c10; ++d10) {
          var v10 = d10 * l10, m10 = new Float32Array(l10 - 1);
          m10[0] = h10[v10];
          for (var g10 = 1; g10 < m10.length; ++g10) m10[g10] = m10[g10 - 1] + h10[v10 + g10];
          for (var y10 = qee.alea(o10.toString()), b10 = d10 * i10, x10 = 0; x10 < i10; ++x10) {
            var k10 = y10();
            f10[b10 + x10] = m10.length;
            for (var w10 = 0; w10 < m10.length; w10++) if (k10 < m10[w10]) {
              f10[b10 + x10] = w10;
              break;
            }
          }
        }
        return s10 || n10.disposeIntermediateTensorInfo(u10), n10.makeTensorInfo(p10, "int32", f10);
      } }, pwe = qne;
      var fwe = { kernelName: x2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.boxes, i10 = t10.scores, o10 = r10.maxOutputSize, s10 = r10.iouThreshold, u10 = r10.scoreThreshold;
        ige(a10, "NonMaxSuppression");
        var c10 = n10.data.get(a10.dataId).values, l10 = n10.data.get(i10.dataId).values, h10 = pwe(c10, l10, o10, s10, u10).selectedIndices;
        return n10.makeTensorInfo([h10.length], "int32", new Int32Array(h10));
      } }, dwe = Kne;
      var vwe = { kernelName: k2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.boxes, i10 = t10.scores, o10 = r10.maxOutputSize, s10 = r10.iouThreshold, u10 = r10.scoreThreshold, c10 = r10.padToMaxOutputSize;
        ige(a10, "NonMaxSuppressionPadded");
        var l10 = n10.data.get(a10.dataId).values, h10 = n10.data.get(i10.dataId).values, p10 = dwe(l10, h10, o10, s10, u10, c10), f10 = p10.selectedIndices, d10 = p10.validOutputs;
        return [n10.makeTensorInfo([f10.length], "int32", new Int32Array(f10)), n10.makeTensorInfo([], "int32", new Int32Array([d10]))];
      } }, mwe = Xne;
      var gwe = { kernelName: w2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.boxes, i10 = t10.scores, o10 = r10.maxOutputSize, s10 = r10.iouThreshold, u10 = r10.scoreThreshold, c10 = r10.softNmsSigma;
        ige(a10, "NonMaxSuppressionWithScore");
        var l10 = n10.data.get(a10.dataId).values, h10 = n10.data.get(i10.dataId).values, p10 = mwe(l10, h10, o10, s10, u10, c10), f10 = p10.selectedIndices, d10 = p10.selectedScores;
        return [n10.makeTensorInfo([f10.length], "int32", new Int32Array(f10)), n10.makeTensorInfo([d10.length], "float32", new Float32Array(d10))];
      } };
      var ywe = { kernelName: N2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.indices, i10 = r10.dtype, o10 = r10.depth, s10 = r10.onValue, u10 = r10.offValue;
        ige(a10, "oneHot");
        var c10 = L$(a10.shape), l10 = new Float32Array(c10 * o10);
        l10.fill(u10);
        for (var h10 = n10.data.get(a10.dataId).values, p10 = 0; p10 < c10; ++p10) h10[p10] >= 0 && h10[p10] < o10 && (l10[p10 * o10 + h10[p10]] = s10);
        return n10.makeTensorInfo([].concat(T(a10.shape), [o10]), i10, l10);
      } };
      function bwe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.x;
        if ("string" === r10.dtype) throw new Error("zerosLike is not supported for string tensors");
        if ("complex64" === r10.dtype) {
          var a10 = mge({ inputs: { input: r10 }, backend: n10 }), i10 = bwe({ inputs: { x: a10 }, backend: n10 }), o10 = Fxe({ inputs: { input: r10 }, backend: n10 }), s10 = bwe({ inputs: { x: o10 }, backend: n10 }), u10 = hge({ inputs: { real: i10, imag: s10 }, backend: n10 });
          return n10.disposeIntermediateTensorInfo(a10), n10.disposeIntermediateTensorInfo(i10), n10.disposeIntermediateTensorInfo(o10), n10.disposeIntermediateTensorInfo(s10), u10;
        }
        return Ike({ backend: n10, attrs: { shape: r10.shape, value: 0, dtype: r10.dtype } });
      }
      var xwe = { kernelName: R3, backendName: "cpu", kernelFunc: bwe };
      var kwe = { kernelName: I2, backendName: "cpu", kernelFunc: function e10(t10) {
        var n10 = t10.inputs, r10 = t10.backend, a10 = n10.x;
        if ("string" === a10.dtype) throw new Error("onesLike is not supported for string tensors");
        if ("complex64" === a10.dtype) {
          var i10 = mge({ inputs: { input: a10 }, backend: r10 }), o10 = e10({ inputs: { x: i10 }, backend: r10 }), s10 = Fxe({ inputs: { input: a10 }, backend: r10 }), u10 = bwe({ inputs: { x: s10 }, backend: r10 }), c10 = hge({ inputs: { real: o10, imag: u10 }, backend: r10 });
          return r10.disposeIntermediateTensorInfo(i10), r10.disposeIntermediateTensorInfo(o10), r10.disposeIntermediateTensorInfo(s10), r10.disposeIntermediateTensorInfo(u10), c10;
        }
        return Ike({ backend: r10, attrs: { shape: a10.shape, value: 1, dtype: a10.dtype } });
      } };
      function wwe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs.axis;
        if (1 === t10.length) return dke({ inputs: { input: t10[0] }, backend: n10, attrs: { dim: r10 } });
        var a10 = t10[0].shape, i10 = t10[0].dtype;
        t10.forEach(function(e11) {
          D$(a10, e11.shape, "All tensors passed to stack must have matching shapes"), F$(i10 === e11.dtype, function() {
            return "All tensors passed to stack must have matching dtypes";
          });
        });
        var o10 = [], s10 = Mxe({ inputs: t10.map(function(e11) {
          var t11 = dke({ inputs: { input: e11 }, backend: n10, attrs: { dim: r10 } });
          return o10.push(t11), t11;
        }), backend: n10, attrs: { axis: r10 } });
        return o10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), s10;
      }
      var Iwe = { kernelName: S2, backendName: "cpu", kernelFunc: wwe };
      var Nwe = { kernelName: T2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.paddings, o10 = r10.constantValue;
        ige(a10, "pad");
        var s10 = i10.map(function(e11, t11) {
          return e11[0] + a10.shape[t11] + e11[1];
        }), u10 = i10.map(function(e11) {
          return e11[0];
        }), c10 = n10.data.get(a10.dataId).values, l10 = L$(a10.shape), h10 = a10.shape.length, p10 = i0(a10.shape), f10 = L$(s10), d10 = s10.length, v10 = i0(s10), m10 = q$(a10.dtype, f10);
        0 !== o10 && m10.fill(o10);
        for (var g10 = 0; g10 < l10; g10++) {
          m10[f0(d0(g10, h10, p10).map(function(e11, t11) {
            return e11 + u10[t11];
          }), d10, v10)] = c10[g10];
        }
        return { dataId: n10.write(m10, s10, a10.dtype), shape: s10, dtype: a10.dtype };
      } }, Swe = lge(function(e10, t10) {
        return Math.pow(e10, t10);
      }), Twe = kge(E2, Swe), Ewe = { kernelName: E2, backendName: "cpu", kernelFunc: Twe };
      var Cwe = { kernelName: R2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.paramsNestedSplits, i10 = t10.paramsDenseValues, o10 = t10.indices, s10 = (r10.outputRaggedRank, a10.map(function(e11) {
          return n10.data.get(e11.dataId).values;
        })), u10 = a10.map(function(e11) {
          return e11.shape;
        }), c10 = n10.data.get(i10.dataId).values, l10 = n10.data.get(o10.dataId).values, h10 = S(Vye(s10, u10, c10, i10.shape, i10.dtype, l10, o10.shape), 3), p10 = h10[0], f10 = h10[1], d10 = h10[2], v10 = p10.map(function(e11) {
          return n10.makeTensorInfo([e11.length], "int32", e11);
        }), m10 = n10.makeTensorInfo(d10, i10.dtype, f10);
        return v10.concat([m10]);
      } };
      var Awe = { kernelName: _2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.starts, a10 = t10.limits, i10 = t10.deltas, o10 = n10.data.get(r10.dataId).values, s10 = n10.data.get(a10.dataId).values, u10 = n10.data.get(i10.dataId).values, c10 = S(jye(o10, r10.shape, r10.dtype, s10, a10.shape, u10, i10.shape), 2), l10 = c10[0], h10 = c10[1];
        return [n10.makeTensorInfo([l10.length], "int32", l10), n10.makeTensorInfo([h10.length], r10.dtype, h10)];
      } };
      var Rwe = { kernelName: O2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.shape, i10 = t10.values, o10 = t10.defaultValue, s10 = t10.rowPartitionTensors, u10 = r10.rowPartitionTypes, c10 = n10.data.get(a10.dataId).values, l10 = n10.data.get(i10.dataId).values, h10 = n10.data.get(o10.dataId).values, p10 = s10.map(function(e11) {
          return n10.data.get(e11.dataId).values;
        }), f10 = s10.map(function(e11) {
          return e11.shape;
        }), d10 = S(Yye(c10, a10.shape, l10, i10.shape, i10.dtype, h10, o10.shape, p10, f10, u10), 2), v10 = d10[0], m10 = d10[1];
        return n10.makeTensorInfo(v10, i10.dtype, m10);
      } };
      var _we = { kernelName: F2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.backend, n10 = e10.attrs, r10 = n10.start, a10 = n10.stop, i10 = n10.dtype, o10 = Jye(r10, a10, n10.step, i10);
        return t10.makeTensorInfo([o10.length], i10, o10);
      } }, Owe = Fge(M2, function(e10) {
        return 1 / e10;
      }), Fwe = { kernelName: M2, backendName: "cpu", kernelFunc: Owe };
      var Dwe = { kernelName: W2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.images, i10 = r10.alignCorners, o10 = r10.halfPixelCenters, s10 = r10.size;
        ige(a10, "resizeBilinear");
        for (var u10 = i0(a10.shape), c10 = S(s10, 2), l10 = c10[0], h10 = c10[1], p10 = S(a10.shape, 4), f10 = p10[0], d10 = p10[1], v10 = p10[2], m10 = p10[3], g10 = n10.data.get(a10.dataId).values, y10 = new Float32Array(L$([f10, l10, h10, m10])), b10 = [i10 && l10 > 1 ? d10 - 1 : d10, i10 && h10 > 1 ? v10 - 1 : v10], x10 = [i10 && l10 > 1 ? l10 - 1 : l10, i10 && h10 > 1 ? h10 - 1 : h10], k10 = 0, w10 = b10[0] / x10[0], I10 = b10[1] / x10[1], N10 = 0; N10 < f10; N10++) for (var T10 = 0; T10 < l10; T10++) {
          var E10 = void 0;
          E10 = o10 ? w10 * (T10 + 0.5) - 0.5 : w10 * T10;
          for (var C10 = Math.max(0, Math.floor(E10)), A10 = E10 - C10, R10 = Math.min(d10 - 1, Math.ceil(E10)), _10 = N10 * u10[0] + C10 * u10[1], O10 = N10 * u10[0] + R10 * u10[1], F10 = 0; F10 < h10; F10++) {
            var D10 = void 0;
            D10 = o10 ? I10 * (F10 + 0.5) - 0.5 : I10 * F10;
            for (var M10 = Math.max(0, Math.floor(D10)), L10 = D10 - M10, z10 = Math.min(v10 - 1, Math.ceil(D10)), P10 = _10 + M10 * u10[2], B10 = O10 + M10 * u10[2], W10 = _10 + z10 * u10[2], U10 = O10 + z10 * u10[2], V10 = 0; V10 < m10; V10++) {
              var G10 = g10[P10 + V10], j10 = g10[B10 + V10], H10 = G10 + (g10[W10 + V10] - G10) * L10, q10 = H10 + (j10 + (g10[U10 + V10] - j10) * L10 - H10) * A10;
              y10[k10++] = q10;
            }
          }
        }
        return n10.makeTensorInfo([f10, l10, h10, m10], "float32", y10);
      } };
      var Mwe = { kernelName: U2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.images, i10 = t10.dy, o10 = r10.alignCorners;
        ige([i10, a10], "resizeBilinearGrad");
        for (var s10 = i0(a10.shape), u10 = S(a10.shape, 4), c10 = u10[0], l10 = u10[1], h10 = u10[2], p10 = u10[3], f10 = S(i10.shape, 3), d10 = f10[1], v10 = f10[2], m10 = new Float32Array(c10 * l10 * h10 * p10), g10 = [o10 && d10 > 1 ? l10 - 1 : l10, o10 && v10 > 1 ? h10 - 1 : h10], y10 = [o10 && d10 > 1 ? d10 - 1 : d10, o10 && v10 > 1 ? v10 - 1 : v10], b10 = g10[0] / y10[0], x10 = g10[1] / y10[1], k10 = n10.data.get(i10.dataId).values, w10 = 0, I10 = 0; I10 < c10; I10++) for (var N10 = I10 * s10[0], T10 = 0; T10 < d10; T10++) for (var E10 = T10 * b10, C10 = Math.floor(E10), A10 = Math.min(Math.ceil(E10), l10 - 1), R10 = N10 + C10 * s10[1], _10 = N10 + A10 * s10[1], O10 = E10 - C10, F10 = 1 - O10, D10 = 0; D10 < v10; D10++) for (var M10 = D10 * x10, L10 = Math.floor(M10), z10 = Math.min(Math.ceil(M10), h10 - 1), P10 = M10 - L10, B10 = 1 - P10, W10 = R10 + L10 * s10[2], U10 = R10 + z10 * s10[2], V10 = _10 + L10 * s10[2], G10 = _10 + z10 * s10[2], j10 = F10 * B10, H10 = F10 * P10, q10 = O10 * B10, K10 = O10 * P10, X10 = 0; X10 < p10; X10++) {
          var Y10 = k10[w10++];
          m10[W10 + X10] += Y10 * j10, m10[U10 + X10] += Y10 * H10, m10[V10 + X10] += Y10 * q10, m10[G10 + X10] += Y10 * K10;
        }
        return n10.makeTensorInfo([c10, h10, l10, p10], "float32", m10);
      } };
      var Lwe = { kernelName: P2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.images, i10 = r10.alignCorners, o10 = r10.halfPixelCenters, s10 = r10.size;
        ige(a10, "resizeNearestNeighbor");
        for (var u10 = i0(a10.shape), c10 = S(s10, 2), l10 = c10[0], h10 = c10[1], p10 = S(a10.shape, 4), f10 = p10[0], d10 = p10[1], v10 = p10[2], m10 = p10[3], g10 = n10.data.get(a10.dataId).values, y10 = new Float32Array(f10 * l10 * h10 * m10), b10 = [i10 && l10 > 1 ? d10 - 1 : d10, i10 && h10 > 1 ? v10 - 1 : v10], x10 = [i10 && l10 > 1 ? l10 - 1 : l10, i10 && h10 > 1 ? h10 - 1 : h10], k10 = b10[0] / x10[0], w10 = b10[1] / x10[1], I10 = 0, N10 = 0; N10 < f10; N10++) for (var T10 = N10 * u10[0], E10 = 0; E10 < l10; E10++) {
          var C10 = o10 ? k10 * (E10 + 0.5) : k10 * E10, A10 = Math.min(d10 - 1, i10 ? Math.round(C10) : Math.floor(C10));
          o10 && (A10 = Math.max(0, A10));
          for (var R10 = T10 + A10 * u10[1], _10 = 0; _10 < h10; _10++) {
            var O10 = o10 ? w10 * (_10 + 0.5) : w10 * _10, F10 = Math.min(v10 - 1, i10 ? Math.round(O10) : Math.floor(O10));
            o10 && (F10 = Math.max(0, F10));
            for (var D10 = R10 + F10 * u10[2], M10 = 0; M10 < m10; M10++) {
              var L10 = g10[D10 + M10];
              y10[I10++] = L10;
            }
          }
        }
        return n10.makeTensorInfo([f10, l10, h10, m10], a10.dtype, y10);
      } };
      var zwe = { kernelName: B2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.images, i10 = t10.dy, o10 = r10.alignCorners;
        ige([i10, a10], "resizeNearestNeighborGrad");
        for (var s10 = i0(a10.shape), u10 = i0(i10.shape), c10 = S(a10.shape, 4), l10 = c10[0], h10 = c10[1], p10 = c10[2], f10 = c10[3], d10 = S(i10.shape, 3), v10 = d10[1], m10 = d10[2], g10 = new Float32Array(l10 * h10 * p10 * f10), y10 = n10.data.get(i10.dataId).values, b10 = [o10 && v10 > 1 ? h10 - 1 : h10, o10 && m10 > 1 ? p10 - 1 : p10], x10 = [o10 && v10 > 1 ? v10 - 1 : v10, o10 && m10 > 1 ? m10 - 1 : m10], k10 = b10[0] / x10[0], w10 = b10[1] / x10[1], I10 = 1 / k10, N10 = 1 / w10, T10 = 2 * Math.ceil(I10) + 2, E10 = 2 * Math.ceil(N10) + 2, C10 = 0; C10 < l10; C10++) for (var A10 = C10 * s10[0], R10 = 0; R10 < h10; R10++) for (var _10 = A10 + R10 * s10[1], O10 = Math.floor(R10 * I10), F10 = Math.floor(O10 - T10 / 2), D10 = 0; D10 < p10; D10++) for (var M10 = _10 + D10 * s10[2], L10 = Math.floor(D10 * N10), z10 = Math.floor(L10 - E10 / 2), P10 = 0; P10 < f10; P10++) {
          for (var B10 = 0, W10 = 0; W10 < T10; W10++) {
            var U10 = W10 + F10;
            if (!(U10 < 0 || U10 >= v10)) {
              var V10 = A10 + U10 * u10[1], G10 = U10 * k10;
              if (R10 === Math.min(h10 - 1, o10 ? Math.round(G10) : Math.floor(G10))) for (var j10 = 0; j10 < E10; j10++) {
                var H10 = j10 + z10;
                if (!(H10 < 0 || H10 >= m10)) {
                  var q10 = V10 + H10 * u10[2], K10 = H10 * w10;
                  D10 === Math.min(p10 - 1, o10 ? Math.round(K10) : Math.floor(K10)) && (B10 += y10[q10 + P10]);
                }
              }
            }
          }
          g10[M10 + P10] = B10;
        }
        return n10.makeTensorInfo(a10.shape, a10.dtype, g10);
      } };
      var Pwe = { kernelName: G2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.dims;
        ige(a10, "reverse");
        var o10 = a10.shape.length, s10 = j$(i10, a10.shape);
        if (0 === o10) return dge({ inputs: { x: a10 }, backend: n10 });
        for (var u10 = new $4(a10.shape, a10.dtype), c10 = n10.bufferSync(a10), l10 = function() {
          var e11 = u10.indexToLoc(h10), t11 = e11.slice();
          s10.forEach(function(e12) {
            return t11[e12] = a10.shape[e12] - 1 - t11[e12];
          }), u10.set.apply(u10, [c10.get.apply(c10, T(t11))].concat(T(e11)));
        }, h10 = 0; h10 < u10.size; h10++) l10();
        return n10.makeTensorInfo(u10.shape, u10.dtype, u10.values);
      } }, Bwe = { kernelName: F3, backendName: "cpu", kernelFunc: function(e10) {
        for (var t10 = e10.inputs, n10 = e10.attrs, r10 = e10.backend, a10 = t10.image, i10 = n10.radians, o10 = n10.fillValue, s10 = n10.center, u10 = r10, c10 = q$(a10.dtype, L$(a10.shape)), l10 = S(a10.shape, 4), h10 = l10[0], p10 = l10[1], f10 = l10[2], d10 = l10[3], v10 = S(pie(s10, p10, f10), 2), m10 = v10[0], g10 = v10[1], y10 = Math.sin(i10), b10 = Math.cos(i10), x10 = u10.data.get(a10.dataId).values, k10 = 0; k10 < h10; k10++) for (var w10 = k10 * f10 * p10 * d10, I10 = 0; I10 < p10; I10++) for (var N10 = I10 * (f10 * d10), T10 = 0; T10 < f10; T10++) for (var E10 = T10 * d10, C10 = 0; C10 < d10; C10++) {
          var A10 = [h10, I10, T10, C10], R10 = A10[2], _10 = A10[1], O10 = (R10 - m10) * b10 - (_10 - g10) * y10, F10 = (R10 - m10) * y10 + (_10 - g10) * b10;
          O10 = Math.round(O10 + m10), F10 = Math.round(F10 + g10);
          var D10 = o10;
          if ("number" != typeof o10 && (D10 = 3 === C10 ? 255 : o10[C10]), O10 >= 0 && O10 < f10 && F10 >= 0 && F10 < p10) D10 = x10[w10 + F10 * (f10 * d10) + O10 * d10 + C10];
          c10[w10 + N10 + E10 + C10] = D10;
        }
        return { dataId: u10.write(c10, a10.shape, a10.dtype), shape: a10.shape, dtype: a10.dtype };
      } }, Wwe = Fge(j2, function(e10) {
        var t10 = Math.floor(e10);
        return e10 - t10 < 0.5 ? Math.floor(e10) : e10 - t10 > 0.5 ? Math.ceil(e10) : t10 % 2 == 0 ? t10 : t10 + 1;
      }), Uwe = { kernelName: j2, backendName: "cpu", kernelFunc: Wwe };
      var Vwe = { kernelName: q2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.indices, i10 = t10.updates, o10 = r10.shape, s10 = Jte(0, a10, o10), u10 = s10.sliceRank, c10 = s10.numUpdates, l10 = s10.sliceSize, h10 = s10.strides, p10 = s10.outputSize, f10 = ebe(n10.bufferSync(a10), n10.bufferSync(i10), o10, p10, l10, c10, u10, h10, 0, true);
        return n10.makeTensorInfo(o10, f10.dtype, f10.values);
      } };
      function Gwe(e10, t10) {
        for (var n10 = 0, r10 = e10.length, a10 = 0; n10 < r10; ) e10[a10 = Math.floor((n10 + r10) / 2)] < t10 ? n10 = a10 + 1 : r10 = a10;
        return r10;
      }
      function jwe(e10, t10) {
        for (var n10 = 0, r10 = e10.length, a10 = 0; n10 < r10; ) e10[a10 = Math.floor((n10 + r10) / 2)] <= t10 ? n10 = a10 + 1 : r10 = a10;
        return r10;
      }
      var Hwe = { kernelName: X2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.sortedSequence, i10 = t10.values, o10 = r10.side, s10 = function(e11, t11, n11, r11, a11, i11) {
          for (var o11 = K$("int32", n11 * a11), s11 = 0; s11 < n11; ++s11) for (var u10 = e11.slice(s11 * r11, (s11 + 1) * r11), c10 = s11 * a11, l10 = 0; l10 < a11; ++l10) o11[c10 + l10] = "left" === i11 ? Gwe(u10, t11[l10 + c10]) : jwe(u10, t11[l10 + c10]);
          return o11;
        }(n10.data.get(a10.dataId).values, n10.data.get(i10.dataId).values, a10.shape[0], a10.shape[1], i10.shape[1], o10);
        return n10.makeTensorInfo(i10.shape, "int32", s10);
      } };
      var qwe = { kernelName: Y2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.condition, a10 = t10.t, i10 = t10.e;
        ige([r10, a10, i10], "select");
        for (var o10 = r10.shape.length, s10 = n10.data.get(r10.dataId).values, u10 = n10.data.get(a10.dataId).values, c10 = n10.data.get(i10.dataId).values, l10 = h5(a10.dtype, i10.dtype), h10 = l0(L$(a10.shape), l10), p10 = 0, f10 = 0 === o10 || o10 > 1 || 1 === a10.shape.length ? 1 : L$(a10.shape.slice(1)), d10 = 0; d10 < s10.length; d10++) for (var v10 = 0; v10 < f10; v10++) 1 === s10[d10] ? h10[p10++] = u10[d10] : h10[p10++] = c10[d10];
        return n10.makeTensorInfo(a10.shape, l10, h10);
      } }, Kwe = Fge(J2, function(e10) {
        return e10 >= 0 ? 1.0507009873554805 * e10 : 1.7580993408473768 * (Math.exp(e10) - 1);
      }), Xwe = { kernelName: J2, backendName: "cpu", kernelFunc: Kwe }, Ywe = Fge(e3, function(e10) {
        return e10 < 0 ? -1 : e10 > 0 ? 1 : 0;
      }), Jwe = { kernelName: e3, backendName: "cpu", kernelFunc: Ywe }, Zwe = Fge(Q2, function(e10) {
        return Math.sin(e10);
      }), Qwe = { kernelName: Q2, backendName: "cpu", kernelFunc: Zwe }, $we = Fge($2, function(e10) {
        return Math.sinh(e10);
      }), eIe = { kernelName: $2, backendName: "cpu", kernelFunc: $we }, tIe = Math.log(11920928955078125e-23) + 2, nIe = Fge(n3, function(e10) {
        var t10 = e10 > -tIe, n10 = e10 < tIe, r10 = Math.exp(e10);
        return n10 ? r10 : t10 ? e10 : Math.log(1 + r10);
      }), rIe = { kernelName: n3, backendName: "cpu", kernelFunc: nIe };
      var aIe = { kernelName: i3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.blockShape, o10 = r10.paddings;
        ige([a10], "spaceToBatchND");
        var s10 = L$(i10), u10 = [[0, 0]];
        u10.push.apply(u10, T(o10));
        for (var c10 = 1 + i10.length; c10 < a10.shape.length; ++c10) u10.push([0, 0]);
        var l10 = Nwe.kernelFunc({ inputs: { x: a10 }, backend: n10, attrs: { paddings: u10, constantValue: 0 } }), h10 = fie(l10.shape, i10, s10, false), p10 = die(h10.length, i10.length, false), f10 = vie(l10.shape, i10, s10, false), d10 = Xbe({ inputs: { x: l10 }, backend: n10, attrs: { shape: h10 } }), v10 = Mye({ inputs: { x: d10 }, backend: n10, attrs: { perm: p10 } }), m10 = Xbe({ inputs: { x: v10 }, backend: n10, attrs: { shape: f10 } });
        return n10.disposeIntermediateTensorInfo(l10), n10.disposeIntermediateTensorInfo(d10), n10.disposeIntermediateTensorInfo(v10), m10;
      } };
      var iIe = { kernelName: u3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.indices, a10 = t10.values, i10 = t10.denseShape, o10 = t10.defaultValue;
        if (1 !== i10.shape.length) throw new Error("Dense shape must be a vector, saw:\n        ".concat(i10.shape));
        if (2 !== r10.shape.length) throw new Error("Indices must be a matrix, saw:\n        ".concat(r10.shape));
        if (1 !== a10.shape.length) throw new Error("Values must be a vector, saw:\n        ".concat(a10.shape));
        if (0 !== o10.shape.length) throw new Error("Default value must be a scalar, saw:\n        ".concat(o10.shape));
        var s10 = n10.data.get(r10.dataId).values, u10 = n10.data.get(a10.dataId).values, c10 = n10.data.get(i10.dataId).values, l10 = n10.data.get(o10.dataId).values[0], h10 = S(sbe(s10, r10.shape, r10.dtype, u10, a10.dtype, c10, l10), 5), p10 = h10[0], f10 = h10[1], d10 = h10[2], v10 = h10[3], m10 = h10[4];
        return [n10.makeTensorInfo(f10, r10.dtype, p10), n10.makeTensorInfo([f10[0]], a10.dtype, d10), n10.makeTensorInfo([v10.length], "bool", new Uint8Array(v10.map(function(e11) {
          return Number(e11);
        }))), n10.makeTensorInfo([m10.length], r10.dtype, new Int32Array(m10))];
      } };
      var oIe = { kernelName: c3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.inputIndices, a10 = t10.inputShape, i10 = t10.newShape;
        if (2 !== r10.shape.length) throw new Error("Input indices should be a matrix but received shape\n        ".concat(r10.shape));
        if (1 !== a10.shape.length) throw new Error("Input shape should be a vector but received shape\n        ".concat(a10.shape));
        if (1 !== i10.shape.length) throw new Error("Target shape should be a vector but received shape ".concat(i10.shape));
        var o10 = Array.from(n10.data.get(a10.dataId).values), s10 = n10.data.get(r10.dataId).values, u10 = Array.from(n10.data.get(i10.dataId).values), c10 = S(ube(s10, r10.shape, r10.dtype, o10, u10), 3), l10 = c10[0], h10 = c10[1], p10 = c10[2];
        return [n10.makeTensorInfo(h10, r10.dtype, l10), n10.makeTensorInfo([p10.length], i10.dtype, new Int32Array(p10))];
      } };
      var sIe = { kernelName: l3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.data, a10 = t10.indices, i10 = t10.segmentIds;
        if (r10.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
        if (1 !== a10.shape.length) throw new Error("Indices should be a vector but received shape\n          ".concat(a10.shape));
        if (1 !== i10.shape.length) throw new Error("Segment ids should be a vector but received shape\n          ".concat(i10.shape));
        if (a10.shape[0] !== i10.shape[0]) throw new Error("segmentIds and indices should have same size.");
        var o10 = n10.data.get(r10.dataId).values, s10 = n10.data.get(a10.dataId).values, u10 = n10.data.get(i10.dataId).values, c10 = S(cbe(o10, r10.shape, r10.dtype, s10, u10, true), 2), l10 = c10[0], h10 = c10[1];
        return n10.makeTensorInfo(h10, r10.dtype, l10);
      } };
      var uIe = { kernelName: h3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.data, a10 = t10.indices, i10 = t10.segmentIds;
        if (r10.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
        if (1 !== a10.shape.length) throw new Error("Indices should be a vector but received shape\n         ".concat(a10.shape));
        if (1 !== i10.shape.length) throw new Error("Segment ids should be a vector but received shape\n         ".concat(i10.shape));
        if (a10.shape[0] !== i10.shape[0]) throw new Error("segmentIds and indices should have same size.");
        var o10 = n10.data.get(r10.dataId).values, s10 = n10.data.get(a10.dataId).values, u10 = n10.data.get(i10.dataId).values, c10 = S(cbe(o10, r10.shape, r10.dtype, s10, u10), 2), l10 = c10[0], h10 = c10[1];
        return n10.makeTensorInfo(h10, r10.dtype, l10);
      } };
      var cIe = { kernelName: p3, backendName: "cpu", kernelFunc: function(e10) {
        var t10, n10 = e10.inputs, r10 = e10.backend, a10 = e10.attrs, i10 = n10.sparseIndices, o10 = n10.sparseValues, s10 = n10.defaultValue, u10 = a10.outputShape, c10 = Jte(0, i10, u10), l10 = c10.sliceRank, h10 = c10.numUpdates, p10 = c10.sliceSize, f10 = c10.strides, d10 = c10.outputSize, v10 = false, m10 = r10.bufferSync(i10);
        switch (o10.dtype) {
          case "bool":
            t10 = ebe(m10, r10.bufferSync(o10), u10, d10, p10, h10, l10, f10, Boolean(r10.data.get(s10.dataId).values[0]), v10);
            break;
          case "float32":
            t10 = ebe(m10, r10.bufferSync(o10), u10, d10, p10, h10, l10, f10, r10.data.get(s10.dataId).values[0], v10);
            break;
          case "int32":
            t10 = ebe(m10, r10.bufferSync(o10), u10, d10, p10, h10, l10, f10, r10.data.get(s10.dataId).values[0], v10);
            break;
          case "string":
            t10 = ebe(m10, r10.bufferSync(o10), u10, d10, p10, h10, l10, f10, W4(r10.data.get(s10.dataId).values[0]), v10);
            break;
          default:
            throw new Error("Unsupported type ".concat(o10.dtype));
        }
        return r10.makeTensorInfo(u10, t10.dtype, t10.values);
      } };
      var lIe = { kernelName: o3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.numOrSizeSplits, o10 = j$(r10.axis, a10.shape)[0], s10 = Vie(a10, i10, o10), u10 = new Array(a10.shape.length).fill(0), c10 = a10.shape.slice();
        return s10.map(function(e11) {
          var t11 = T(c10);
          t11[o10] = e11;
          var r11 = ibe({ inputs: { x: a10 }, backend: n10, attrs: { begin: u10, size: t11 } });
          return u10[o10] += e11, r11;
        });
      } }, hIe = { kernelName: d3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.x, a10 = n10;
        ige(r10, "square");
        for (var i10 = a10.data.get(r10.dataId).values, o10 = new Float32Array(i10.length), s10 = 0; s10 < i10.length; ++s10) {
          var u10 = i10[s10];
          o10[s10] = u10 * u10;
        }
        return { dataId: a10.write(o10, r10.shape, r10.dtype), shape: r10.shape, dtype: r10.dtype };
      } }, pIe = Fge(_3, function(e10, t10) {
        var n10 = t10;
        return isNaN(e10) ? NaN : e10 > 0 ? 1 : n10.alpha;
      }), fIe = { kernelName: _3, backendName: "cpu", kernelFunc: pIe };
      var dIe = { kernelName: m3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.begin, o10 = r10.end, s10 = r10.strides, u10 = r10.beginMask, c10 = r10.endMask, l10 = r10.ellipsisMask, h10 = r10.newAxisMask, p10 = r10.shrinkAxisMask;
        ige(a10, "stridedSlice");
        var f10, d10 = Jae(a10.shape, i10, o10, s10, u10, c10, l10, h10, p10), v10 = d10.finalShapeSparse, m10 = d10.finalShape, g10 = d10.isIdentity, y10 = d10.sliceDim0, b10 = d10.isSimpleSlice, x10 = d10.begin, k10 = d10.end, w10 = d10.strides;
        if (g10) f10 = Xbe({ inputs: { x: a10 }, backend: n10, attrs: { shape: m10 } });
        else if (y10 || b10) {
          F$(a10.shape.length >= 1, function() {
            return "Input must have rank at least 1, got: ".concat(a10.shape.length);
          });
          var I10 = Pae(x10, k10, w10), N10 = ibe({ inputs: { x: a10 }, backend: n10, attrs: { begin: x10, size: I10 } });
          f10 = Xbe({ inputs: { x: N10 }, backend: n10, attrs: { shape: m10 } }), n10.disposeIntermediateTensorInfo(N10);
        } else {
          var S10 = bbe(v10, n10.bufferSync(a10), w10, x10);
          f10 = n10.makeTensorInfo(m10, S10.dtype, S10.values);
        }
        return f10;
      } };
      var vIe = { kernelName: g3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = r10.separator, i10 = r10.nGramWidths, o10 = r10.leftPad, s10 = r10.rightPad, u10 = r10.padWidth, c10 = r10.preserveShortSequences, l10 = t10.data, h10 = t10.dataSplits, p10 = S(kbe(n10.data.get(l10.dataId).values, n10.data.get(h10.dataId).values, a10, i10, o10, s10, u10, c10), 2), f10 = p10[0], d10 = p10[1];
        return [n10.makeTensorInfo([f10.length], "string", f10), n10.makeTensorInfo(h10.shape, "int32", d10)];
      } };
      var mIe = { kernelName: y3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs.skipEmpty, a10 = t10.input, i10 = t10.delimiter;
        if ("string" !== a10.dtype) throw new Error("Input must be of datatype string");
        if (1 !== a10.shape.length) throw new Error("Input must be a vector, got shape: ".concat(a10.shape));
        if (0 !== i10.shape.length) throw new Error("Delimiter must be a scalar, got shape: ".concat(i10.shape));
        var o10 = S(Ibe(n10.data.get(a10.dataId).values, n10.data.get(i10.dataId).values[0], r10), 3), s10 = o10[0], u10 = o10[1], c10 = o10[2], l10 = u10.length;
        return [n10.makeTensorInfo([l10, 2], "int32", s10), n10.makeTensorInfo([l10], "string", u10), n10.makeTensorInfo([2], "int32", new Int32Array(c10))];
      } };
      var gIe = { kernelName: b3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs.numBuckets, a10 = t10.input;
        if ("string" !== a10.dtype) throw new Error("Input must be of datatype string");
        if (r10 <= 0) throw new Error("Number of buckets must be at least 1");
        var i10 = Nbe(n10.data.get(a10.dataId).values, r10);
        return n10.makeTensorInfo(a10.shape, "int32", i10);
      } }, yIe = Fge(k3, function(e10) {
        return Math.tan(e10);
      }), bIe = { kernelName: k3, backendName: "cpu", kernelFunc: yIe }, xIe = Fge(w3, function(e10) {
        return Math.tanh(e10);
      });
      var kIe = { kernelName: K2, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.tensor, a10 = t10.indices, i10 = t10.updates, o10 = Jte(0, a10, r10.shape), s10 = o10.sliceRank, u10 = o10.numUpdates, c10 = o10.sliceSize, l10 = o10.strides, h10 = o10.outputSize, p10 = n10.bufferSync(a10), f10 = n10.bufferSync(i10), d10 = n10.bufferSync(r10), v10 = ebe(p10, f10, r10.shape, h10, c10, u10, s10, l10, d10, false);
        return n10.makeTensorInfo(r10.shape, v10.dtype, v10.values);
      } };
      var wIe = { kernelName: I3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.reps;
        ige(a10, "tile");
        var o10 = Abe(n10.bufferSync(a10), i10);
        return n10.makeTensorInfo(o10.shape, o10.dtype, o10.values);
      } };
      var IIe = { kernelName: N3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.k, o10 = r10.sorted;
        ige(a10, "topk");
        var s10 = S(Obe(n10.data.get(a10.dataId).values, a10.shape, a10.dtype, i10, o10), 2), u10 = s10[0], c10 = s10[1];
        return [n10.makeTensorInfo(u10.shape, u10.dtype, u10.values), n10.makeTensorInfo(c10.shape, c10.dtype, c10.values)];
      } };
      var NIe = { kernelName: S3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.attrs, r10 = e10.backend, a10 = t10.image, i10 = t10.transforms, o10 = n10.interpolation, s10 = n10.fillMode, u10 = n10.fillValue, c10 = n10.outputShape, l10 = S(a10.shape, 4), h10 = l10[0], p10 = l10[1], f10 = l10[2], d10 = l10[3], v10 = S(null != c10 ? c10 : [p10, f10], 2), m10 = v10[0], g10 = v10[1], y10 = [h10, m10, g10, d10], b10 = i0(a10.shape), x10 = b10[0], k10 = b10[1], w10 = b10[2], I10 = i0(y10), N10 = I10[0], T10 = I10[1], E10 = I10[2], C10 = q$(a10.dtype, L$(y10));
        C10.fill(u10);
        for (var A10 = r10.data.get(a10.dataId).values, R10 = r10.data.get(i10.dataId).values, _10 = 0; _10 < h10; ++_10) {
          for (var O10 = 1 === i10.shape[0] ? R10 : R10.subarray(8 * _10, 8 * _10 + 8), F10 = 0; F10 < m10; ++F10) for (var D10 = 0; D10 < g10; ++D10) for (var M10 = 0; M10 < d10; ++M10) {
            var L10 = void 0, z10 = O10[6] * D10 + O10[7] * F10 + 1;
            if (0 !== z10) {
              var P10 = (O10[0] * D10 + O10[1] * F10 + O10[2]) / z10, B10 = (O10[3] * D10 + O10[4] * F10 + O10[5]) / z10, W10 = SIe(P10, f10, s10), U10 = SIe(B10, p10, s10);
              switch (o10) {
                case "nearest":
                  L10 = EIe(A10, p10, f10, x10, k10, w10, _10, U10, W10, M10, u10);
                  break;
                case "bilinear":
                  L10 = CIe(A10, p10, f10, x10, k10, w10, _10, U10, W10, M10, u10);
                  break;
                default:
                  throw new Error("Error in Transform: Expect 'nearest' or " + "'bilinear', but got ".concat(o10));
              }
              C10[_10 * N10 + F10 * T10 + D10 * E10 + M10] = L10;
            }
          }
          return r10.makeTensorInfo(y10, a10.dtype, C10);
        }
        return { dataId: r10.write(C10, y10, a10.dtype), shape: a10.shape, dtype: a10.dtype };
      } };
      function SIe(e10, t10, n10) {
        switch (n10) {
          case "reflect":
            return function(e11, t11) {
              var n11 = e11;
              if (n11 < 0) if (t11 <= 1) n11 = 0;
              else {
                var r10 = 2 * t11;
                n11 < r10 && (n11 = r10 * Math.trunc(-n11 / r10) + n11), n11 = n11 < -t11 ? n11 + r10 : -n11 - 1;
              }
              else if (n11 > t11 - 1) if (t11 <= 1) n11 = 0;
              else {
                var a10 = 2 * t11;
                (n11 -= a10 * Math.trunc(n11 / a10)) >= t11 && (n11 = a10 - n11 - 1);
              }
              return A$(0, n11, t11 - 1);
            }(e10, t10);
          case "wrap":
            return function(e11, t11) {
              var n11 = e11;
              if (n11 < 0) if (t11 <= 1) n11 = 0;
              else {
                var r10 = t11 - 1;
                n11 += t11 * (Math.trunc(-n11 / r10) + 1);
              }
              else if (n11 > t11 - 1) if (t11 <= 1) n11 = 0;
              else {
                var a10 = t11 - 1;
                n11 -= t11 * Math.trunc(n11 / a10);
              }
              return A$(0, n11, t11 - 1);
            }(e10, t10);
          case "nearest":
            return function(e11, t11) {
              return A$(0, e11, t11 - 1);
            }(e10, t10);
          default:
            return /* @__PURE__ */ function(e11, t11) {
              return e11;
            }(e10);
        }
      }
      function TIe(e10, t10, n10, r10, a10, i10, o10, s10, u10, c10, l10) {
        return 0 <= s10 && s10 < t10 && 0 <= u10 && u10 < n10 ? e10[o10 * r10 + s10 * a10 + u10 * i10 + c10] : l10;
      }
      function EIe(e10, t10, n10, r10, a10, i10, o10, s10, u10, c10, l10) {
        return TIe(e10, t10, n10, r10, a10, i10, o10, Math.round(s10), Math.round(u10), c10, l10);
      }
      function CIe(e10, t10, n10, r10, a10, i10, o10, s10, u10, c10, l10) {
        var h10 = Math.floor(s10), p10 = Math.floor(u10), f10 = h10 + 1, d10 = p10 + 1;
        return (f10 - s10) * ((d10 - u10) * TIe(e10, t10, n10, r10, a10, i10, o10, h10, p10, c10, l10) + (u10 - p10) * TIe(e10, t10, n10, r10, a10, i10, o10, h10, d10, c10, l10)) + (s10 - h10) * ((d10 - u10) * TIe(e10, t10, n10, r10, a10, i10, o10, f10, p10, c10, l10) + (u10 - p10) * TIe(e10, t10, n10, r10, a10, i10, o10, f10, d10, c10, l10));
      }
      var AIe = { kernelName: E3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.attrs, r10 = e10.backend, a10 = n10.axis, i10 = t10.x;
        ige(i10, "unique");
        var o10 = Fbe(r10.data.get(i10.dataId).values, a10, i10.shape, i10.dtype), s10 = o10.outputValues, u10 = o10.outputShape, c10 = o10.indices;
        return [r10.makeTensorInfo(u10, i10.dtype, s10), r10.makeTensorInfo([c10.length], "int32", c10)];
      } };
      var RIe = { kernelName: C3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.value, i10 = r10.axis;
        i10 < 0 && (i10 += a10.shape.length);
        for (var o10 = a10.shape.length, s10 = a10.shape[i10], u10 = new Array(o10 - 1), c10 = 0, l10 = 0; l10 < o10; l10++) l10 !== i10 && (u10[c10++] = a10.shape[l10]);
        var h10 = new Array(o10).fill(0), p10 = a10.shape.slice();
        p10[i10] = 1;
        for (var f10 = new Array(s10), d10 = 0; d10 < f10.length; d10++) {
          h10[i10] = d10;
          var v10 = ibe({ inputs: { x: a10 }, backend: n10, attrs: { begin: h10, size: p10 } });
          f10[d10] = Xbe({ inputs: { x: v10 }, backend: n10, attrs: { shape: u10 } }), n10.disposeIntermediateTensorInfo(v10);
        }
        return f10;
      } };
      for (var _Ie = { kernelName: A3, backendName: "cpu", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.segmentIds, o10 = r10.numSegments;
        ige(a10, "unsortedSegmentSum");
        for (var s10 = [], u10 = [], c10 = a10.shape.length - i10.shape.length, l10 = i10, h10 = 0; h10 < c10; ++h10) {
          var p10 = dke({ inputs: { input: l10 }, backend: n10, attrs: { dim: h10 + 1 } });
          l10 = p10, u10.push(p10);
        }
        for (var f10 = 0; f10 < o10; ++f10) {
          var d10 = M4(f10, "int32"), v10 = n10.makeTensorInfo([], "int32", d10), m10 = Wge({ inputs: { a: v10, b: l10 }, backend: n10 }), g10 = bge({ inputs: { x: m10 }, backend: n10, attrs: { dtype: "float32" } }), y10 = Eye({ inputs: { a: g10, b: a10 }, backend: n10 }), b10 = uke({ inputs: { x: y10 }, backend: n10, attrs: { axis: 0, keepDims: false } });
          s10.push(b10), u10.push(v10), u10.push(m10), u10.push(g10), u10.push(y10), u10.push(b10);
        }
        var x10 = wwe({ inputs: s10, backend: n10, attrs: { axis: 0 } });
        return u10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), x10;
      } }, OIe = 0, FIe = [Qbe, cge, exe, nxe, Tge, rxe, axe, ixe, oxe, sxe, cxe, hxe, fxe, mxe, yxe, wxe, Ixe, Nxe, Sxe, Zbe, Txe, Exe, Cxe, _ge, Axe, xge, zge, _xe, pge, Oxe, Lxe, Pxe, Bxe, Wxe, Uxe, Vxe, Gxe, Hxe, Kxe, Xxe, Yxe, Jxe, Zxe, Qxe, eke, tke, nke, rke, ake, ike, oke, ske, lke, zbe, hke, Uge, fke, jge, vke, Kge, wke, Nke, Ske, Jge, $ge, Tke, Eke, Cke, Ake, aye, sye, vge, Rke, Dxe, Oke, Dke, Lke, Bbe, lye, fye, zke, gye, Bke, Vke, jke, Kke, Xke, Yke, Zke, kye, Qke, $ke, ewe, twe, nwe, rwe, awe, Nye, iwe, uwe, hwe, Cye, Rye, fwe, vwe, gwe, Fye, ywe, kwe, Iwe, Nwe, Ewe, Vbe, Pye, Cwe, Awe, Rwe, _we, gge, yke, Fwe, jbe, qbe, Ybe, Dwe, Mwe, Lwe, zwe, Pwe, Bwe, Uwe, $ye, Vwe, Hwe, qwe, Xwe, rbe, Jwe, Qwe, eIe, obe, lwe, rIe, aIe, iIe, oIe, sIe, uIe, cIe, lIe, pbe, hIe, vbe, ybe, fIe, dIe, vIe, mIe, gIe, Cbe, cke, bIe, { kernelName: w3, backendName: "cpu", kernelFunc: xIe }, kIe, wIe, IIe, NIe, Lye, AIe, RIe, _Ie, xwe]; OIe < FIe.length; OIe++) {
        G3(FIe[OIe]);
      }
      var DIe, MIe, LIe, zIe = {}, PIe = { alpha: false, antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: false, depth: false, stencil: false, failIfMajorPerformanceCaveat: true };
      function BIe(e10, t10) {
        zIe[e10] = t10;
      }
      function WIe(e10, t10) {
        if (!(e10 in zIe) || null != t10) {
          var n10 = function(e11, t11) {
            if (1 !== e11 && 2 !== e11) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
            var n11 = null == t11 ? function(e12) {
              if (k0().getBool("IS_SAFARI") || "undefined" == typeof OffscreenCanvas || 2 !== e12) {
                if ("undefined" != typeof document) return document.createElement("canvas");
                throw new Error("Cannot create a canvas in this context");
              }
              return new OffscreenCanvas(300, 150);
            }(e11) : t11;
            n11.addEventListener("webglcontextlost", function(t12) {
              t12.preventDefault(), delete zIe[e11];
            }, false), k0().getBool("SOFTWARE_WEBGL_ENABLED") && (PIe.failIfMajorPerformanceCaveat = false);
            if (1 === e11) return n11.getContext("webgl", PIe) || n11.getContext("experimental-webgl", PIe);
            return n11.getContext("webgl2", PIe);
          }(e10, t10);
          if (null === n10) return console.log("Could not get context for WebGL version", e10), null;
          zIe[e10] = n10;
        }
        var r10 = zIe[e10];
        return null == r10 || r10.isContextLost() ? (delete zIe[e10], WIe(e10)) : (r10.disable(r10.DEPTH_TEST), r10.disable(r10.STENCIL_TEST), r10.disable(r10.BLEND), r10.disable(r10.DITHER), r10.disable(r10.POLYGON_OFFSET_FILL), r10.disable(r10.SAMPLE_COVERAGE), r10.enable(r10.SCISSOR_TEST), r10.enable(r10.CULL_FACE), r10.cullFace(r10.BACK), zIe[e10]);
      }
      function UIe(e10, t10) {
        return [t10, e10];
      }
      function VIe(e10) {
        var t10 = L$(e10);
        return W$(Math.ceil(t10 / 4));
      }
      function GIe(e10, t10) {
        return [Math.max(1, Math.ceil(t10 / 2)), Math.max(1, Math.ceil(e10 / 2))];
      }
      function jIe(e10, t10) {
        var n10, r10, a10, i10, o10, s10, u10, c10, l10, h10, p10 = e10;
        return 2 === k0().getNumber("WEBGL_VERSION") ? (n10 = p10.R32F, r10 = p10.R16F, a10 = p10.RGBA16F, i10 = p10.RGBA32F, o10 = p10.RED, u10 = 4, c10 = 1, l10 = p10.HALF_FLOAT, h10 = p10.FLOAT, s10 = p10.RGBA8) : (n10 = e10.RGBA, r10 = e10.RGBA, a10 = e10.RGBA, i10 = p10.RGBA, o10 = e10.RGBA, u10 = 4, c10 = 4, l10 = null != t10 ? t10.HALF_FLOAT_OES : null, h10 = e10.FLOAT, s10 = e10.RGBA), { internalFormatFloat: n10, internalFormatHalfFloat: r10, internalFormatPackedHalfFloat: a10, internalFormatPackedFloat: i10, textureFormatFloat: o10, downloadTextureFormat: s10, downloadUnpackNumChannels: u10, defaultNumChannels: c10, textureTypeHalfFloat: l10, textureTypeFloat: h10 };
      }
      function HIe(e10, t10) {
        var n10 = t10();
        return k0().getBool("DEBUG") && function(e11) {
          var t11 = e11.getError();
          if (t11 !== e11.NO_ERROR) throw new Error("WebGL Error: " + KIe(e11, t11));
        }(e10), n10;
      }
      !function(e10) {
        e10[e10.DENSE = 0] = "DENSE", e10[e10.SHARED_BATCH = 1] = "SHARED_BATCH";
      }(DIe || (DIe = {})), function(e10) {
        e10[e10.RENDER = 0] = "RENDER", e10[e10.UPLOAD = 1] = "UPLOAD", e10[e10.PIXELS = 2] = "PIXELS", e10[e10.DOWNLOAD = 3] = "DOWNLOAD";
      }(MIe || (MIe = {})), function(e10) {
        e10[e10.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", e10[e10.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", e10[e10.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", e10[e10.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", e10[e10.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
      }(LIe || (LIe = {}));
      function qIe(e10) {
        return !!(k0().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === e10 || 596e-10 < Math.abs(e10) && Math.abs(e10) < 65504);
      }
      function KIe(e10, t10) {
        switch (t10) {
          case e10.NO_ERROR:
            return "NO_ERROR";
          case e10.INVALID_ENUM:
            return "INVALID_ENUM";
          case e10.INVALID_VALUE:
            return "INVALID_VALUE";
          case e10.INVALID_OPERATION:
            return "INVALID_OPERATION";
          case e10.INVALID_FRAMEBUFFER_OPERATION:
            return "INVALID_FRAMEBUFFER_OPERATION";
          case e10.OUT_OF_MEMORY:
            return "OUT_OF_MEMORY";
          case e10.CONTEXT_LOST_WEBGL:
            return "CONTEXT_LOST_WEBGL";
          default:
            return "Unknown error code ".concat(t10);
        }
      }
      function XIe(e10, t10) {
        return yNe(e10, function() {
          return e10.getExtension(t10);
        }, 'Extension "' + t10 + '" not supported on this browser.');
      }
      function YIe(e10, t10) {
        var n10 = yNe(e10, function() {
          return e10.createShader(e10.VERTEX_SHADER);
        }, "Unable to create vertex WebGLShader.");
        if (HIe(e10, function() {
          return e10.shaderSource(n10, t10);
        }), HIe(e10, function() {
          return e10.compileShader(n10);
        }), false === e10.getShaderParameter(n10, e10.COMPILE_STATUS)) throw console.log(e10.getShaderInfoLog(n10)), new Error("Failed to compile vertex shader.");
        return n10;
      }
      function JIe(e10, t10) {
        var n10 = yNe(e10, function() {
          return e10.createShader(e10.FRAGMENT_SHADER);
        }, "Unable to create fragment WebGLShader.");
        if (HIe(e10, function() {
          return e10.shaderSource(n10, t10);
        }), HIe(e10, function() {
          return e10.compileShader(n10);
        }), k0().get("ENGINE_COMPILE_ONLY")) return n10;
        if (false === e10.getShaderParameter(n10, e10.COMPILE_STATUS)) throw eNe(t10, e10.getShaderInfoLog(n10)), new Error("Failed to compile fragment shader.");
        return n10;
      }
      var ZIe, QIe, $Ie = /ERROR: [0-9]+:([0-9]+):/g;
      function eNe(e10, t10) {
        var n10 = $Ie.exec(t10);
        if (null == n10) return console.log("Couldn't parse line number in error: ".concat(t10)), void console.log(e10);
        for (var r10 = +n10[1], a10 = e10.split("\n"), i10 = a10.length.toString().length + 2, o10 = a10.map(function(e11, t11) {
          return U$((t11 + 1).toString(), i10) + e11;
        }), s10 = 0, u10 = 0; u10 < o10.length; u10++) s10 = Math.max(o10[u10].length, s10);
        var c10 = o10.slice(0, r10 - 1), l10 = o10.slice(r10 - 1, r10), h10 = o10.slice(r10);
        console.log(c10.join("\n")), console.log(t10.split("\n")[0]), console.log("%c ".concat(U$(l10[0], s10)), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(h10.join("\n"));
      }
      function tNe(e10) {
        return yNe(e10, function() {
          return e10.createProgram();
        }, "Unable to create WebGLProgram.");
      }
      function nNe(e10, t10) {
        if (HIe(e10, function() {
          return e10.linkProgram(t10);
        }), !k0().get("ENGINE_COMPILE_ONLY") && false === e10.getProgramParameter(t10, e10.LINK_STATUS)) throw console.log(e10.getProgramInfoLog(t10)), new Error("Failed to link vertex and fragment shaders.");
      }
      function rNe(e10, t10) {
        if (HIe(e10, function() {
          return e10.validateProgram(t10);
        }), false === e10.getProgramParameter(t10, e10.VALIDATE_STATUS)) throw console.log(e10.getProgramInfoLog(t10)), new Error("Shader program validation failed.");
      }
      function aNe(e10, t10) {
        var n10 = yNe(e10, function() {
          return e10.createBuffer();
        }, "Unable to create WebGLBuffer");
        return HIe(e10, function() {
          return e10.bindBuffer(e10.ARRAY_BUFFER, n10);
        }), HIe(e10, function() {
          return e10.bufferData(e10.ARRAY_BUFFER, t10, e10.STATIC_DRAW);
        }), n10;
      }
      function iNe(e10, t10) {
        var n10 = yNe(e10, function() {
          return e10.createBuffer();
        }, "Unable to create WebGLBuffer");
        return HIe(e10, function() {
          return e10.bindBuffer(e10.ELEMENT_ARRAY_BUFFER, n10);
        }), HIe(e10, function() {
          return e10.bufferData(e10.ELEMENT_ARRAY_BUFFER, t10, e10.STATIC_DRAW);
        }), n10;
      }
      function oNe(e10) {
        return yNe(e10, function() {
          return e10.createTexture();
        }, "Unable to create WebGLTexture.");
      }
      function sNe(e10, t10) {
        var n10 = k0().getNumber("WEBGL_MAX_TEXTURE_SIZE");
        if (e10 <= 0 || t10 <= 0) {
          var r10 = "[".concat(e10, "x").concat(t10, "]");
          throw new Error("Requested texture size " + r10 + " is invalid.");
        }
        if (e10 > n10 || t10 > n10) {
          var a10 = "[".concat(e10, "x").concat(t10, "]"), i10 = "[".concat(n10, "x").concat(n10, "]");
          throw new Error("Requested texture size " + a10 + " greater than WebGL maximum on this browser / GPU " + i10 + ".");
        }
      }
      function uNe(e10) {
        return yNe(e10, function() {
          return e10.createFramebuffer();
        }, "Unable to create WebGLFramebuffer.");
      }
      function cNe(e10, t10, n10, r10, a10, i10, o10) {
        var s10 = e10.getAttribLocation(t10, n10);
        return -1 !== s10 && (HIe(e10, function() {
          return e10.bindBuffer(e10.ARRAY_BUFFER, r10);
        }), HIe(e10, function() {
          return e10.vertexAttribPointer(s10, a10, e10.FLOAT, false, i10, o10);
        }), HIe(e10, function() {
          return e10.enableVertexAttribArray(s10);
        }), true);
      }
      function lNe(e10, t10, n10) {
        bNe(e10, n10), HIe(e10, function() {
          return e10.activeTexture(e10.TEXTURE0 + n10);
        }), HIe(e10, function() {
          return e10.bindTexture(e10.TEXTURE_2D, t10);
        });
      }
      function hNe(e10, t10, n10) {
        return yNe(e10, function() {
          return e10.getUniformLocation(t10, n10);
        }, 'uniform "' + n10 + '" not present in program.');
      }
      function pNe(e10, t10, n10) {
        return e10.getUniformLocation(t10, n10);
      }
      function fNe(e10, t10, n10, r10) {
        HIe(e10, function() {
          return lNe(e10, t10, r10);
        }), HIe(e10, function() {
          return e10.uniform1i(n10, r10);
        });
      }
      function dNe(e10, t10, n10) {
        HIe(e10, function() {
          return e10.bindFramebuffer(e10.FRAMEBUFFER, n10);
        }), HIe(e10, function() {
          return e10.framebufferTexture2D(e10.FRAMEBUFFER, e10.COLOR_ATTACHMENT0, e10.TEXTURE_2D, t10, 0);
        });
      }
      function vNe(e10, t10) {
        HIe(e10, function() {
          return e10.bindFramebuffer(e10.FRAMEBUFFER, t10);
        }), HIe(e10, function() {
          return e10.framebufferTexture2D(e10.FRAMEBUFFER, e10.COLOR_ATTACHMENT0, e10.TEXTURE_2D, null, 0);
        });
      }
      function mNe(e10) {
        var t10 = e10.checkFramebufferStatus(e10.FRAMEBUFFER);
        if (t10 !== e10.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + gNe(e10, t10));
      }
      function gNe(e10, t10) {
        switch (t10) {
          case e10.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
          case e10.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
          case e10.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
          case e10.FRAMEBUFFER_UNSUPPORTED:
            return "FRAMEBUFFER_UNSUPPORTED";
          default:
            return "unknown error ".concat(t10);
        }
      }
      function yNe(e10, t10, n10) {
        var r10 = HIe(e10, function() {
          return t10();
        });
        if (null == r10) throw new Error(n10);
        return r10;
      }
      function bNe(e10, t10) {
        var n10 = e10.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, r10 = t10 + e10.TEXTURE0;
        if (r10 < e10.TEXTURE0 || r10 > n10) {
          var a10 = "[gl.TEXTURE0, gl.TEXTURE".concat(n10, "]");
          throw new Error("textureUnit must be in ".concat(a10, "."));
        }
      }
      function xNe(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
        return L$(e10.slice(0, e10.length - t10));
      }
      function kNe(e10) {
        if (0 === e10.length) throw Error("Cannot get rows and columns of an empty shape array.");
        return [e10.length > 1 ? e10[e10.length - 2] : 1, e10[e10.length - 1]];
      }
      function wNe(e10) {
        var t10 = [1, 1, 1];
        return 0 === e10.length || 1 === e10.length && 1 === e10[0] || (t10 = [xNe(e10)].concat(T(kNe(e10)))), t10;
      }
      function INe(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n10 = k0().getNumber("WEBGL_MAX_TEXTURE_SIZE"), r10 = k0().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
        if (r10 === 1 / 0 && k0().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE") && (r10 = n10 / 2), t10 && (n10 *= 2, r10 *= 2, 1 === (e10 = e10.map(function(t11, n11) {
          return n11 >= e10.length - 2 ? R$(e10[n11]) : e10[n11];
        })).length && (e10 = [2, e10[0]])), 2 !== e10.length) {
          var a10 = H$(e10);
          e10 = a10.newShape;
        }
        var i10 = L$(e10), o10 = null;
        e10.length <= 1 && i10 <= n10 ? o10 = [1, i10] : 2 === e10.length && e10[0] <= n10 && e10[1] <= n10 ? o10 = e10 : 3 === e10.length && e10[0] * e10[1] <= n10 && e10[2] <= n10 ? o10 = [e10[0] * e10[1], e10[2]] : 3 === e10.length && e10[0] <= n10 && e10[1] * e10[2] <= n10 ? o10 = [e10[0], e10[1] * e10[2]] : 4 === e10.length && e10[0] * e10[1] * e10[2] <= n10 && e10[3] <= n10 ? o10 = [e10[0] * e10[1] * e10[2], e10[3]] : 4 === e10.length && e10[0] <= n10 && e10[1] * e10[2] * e10[3] <= n10 && (o10 = [e10[0], e10[1] * e10[2] * e10[3]]);
        var s10 = null != o10 && Math.max.apply(Math, T(o10)) > r10 && Math.min.apply(Math, T(o10)) <= (t10 ? 2 : 1) && Math.min.apply(Math, T(o10)) > 0;
        if (null == o10 || s10) if (t10) {
          var u10 = xNe(e10), c10 = 2, l10 = 2;
          if (e10.length) {
            var h10 = kNe(e10), p10 = S(h10, 2);
            c10 = p10[0], l10 = p10[1];
          }
          o10 = W$(i10 = u10 * (c10 / 2) * (l10 / 2)).map(function(e11) {
            return 2 * e11;
          });
        } else o10 = W$(i10);
        return o10;
      }
      function NNe(e10) {
        return e10 % 2 == 0;
      }
      function SNe(e10, t10) {
        if (P$(e10 = e10.slice(-2), t10 = t10.slice(-2))) return true;
        if (!e10.length || !t10.length) return true;
        if (0 === e10[0] || 0 === e10[1] || 0 === t10[0] || 0 === t10[1]) return true;
        if (e10.length !== t10.length) {
          var n10 = e10[e10.length - 1], r10 = t10[t10.length - 1];
          if (n10 === r10) return true;
          if (NNe(n10) && NNe(r10) && (1 === e10[0] || 1 === t10[0])) return true;
        }
        return e10[1] === t10[1] && NNe(e10[0]) && NNe(t10[0]);
      }
      function TNe(e10) {
        if (null == ZIe) {
          var t10 = WIe(e10);
          ZIe = t10.getParameter(t10.MAX_TEXTURE_SIZE);
        }
        return ZIe;
      }
      function ENe(e10) {
        if (null == QIe) {
          var t10 = WIe(e10);
          QIe = t10.getParameter(t10.MAX_TEXTURE_IMAGE_UNITS);
        }
        return Math.min(16, QIe);
      }
      function CNe(e10) {
        if (0 === e10) return 0;
        var t10 = WIe(e10);
        return ANe(t10, "EXT_disjoint_timer_query_webgl2") && 2 === e10 ? 2 : ANe(t10, "EXT_disjoint_timer_query") ? 1 : 0;
      }
      function ANe(e10, t10) {
        return null != e10.getExtension(t10);
      }
      function RNe(e10) {
        try {
          if (null != WIe(e10)) return true;
        } catch (e11) {
          return console.log("Error when getting WebGL context: ", e11), false;
        }
        return false;
      }
      function _Ne(e10) {
        if (0 === e10) return false;
        var t10 = WIe(e10);
        if (1 === e10) {
          if (!ANe(t10, "OES_texture_float")) return false;
        } else if (!ANe(t10, "EXT_color_buffer_float")) return false;
        return FNe(t10);
      }
      function ONe(e10) {
        if (0 === e10) return false;
        var t10 = WIe(e10);
        if (1 !== e10) {
          if (ANe(t10, "EXT_color_buffer_float")) return FNe(t10);
          var n10 = "EXT_color_buffer_half_float";
          if (ANe(t10, n10)) {
            var r10 = t10.getExtension(n10);
            return function(e11, t11) {
              var n11 = jIe(e11, t11), r11 = e11.createTexture();
              e11.bindTexture(e11.TEXTURE_2D, r11);
              var a10 = 1, i10 = 1;
              e11.texImage2D(e11.TEXTURE_2D, 0, n11.internalFormatHalfFloat, a10, i10, 0, n11.textureFormatFloat, n11.textureTypeHalfFloat, null);
              var o10 = e11.createFramebuffer();
              e11.bindFramebuffer(e11.FRAMEBUFFER, o10), e11.framebufferTexture2D(e11.FRAMEBUFFER, e11.COLOR_ATTACHMENT0, e11.TEXTURE_2D, r11, 0);
              var s10 = e11.checkFramebufferStatus(e11.FRAMEBUFFER) === e11.FRAMEBUFFER_COMPLETE;
              return e11.bindTexture(e11.TEXTURE_2D, null), e11.bindFramebuffer(e11.FRAMEBUFFER, null), e11.deleteTexture(r11), e11.deleteFramebuffer(o10), s10;
            }(t10, r10);
          }
          return false;
        }
        return !!ANe(t10, "OES_texture_float") && (!!ANe(t10, "WEBGL_color_buffer_float") && FNe(t10));
      }
      function FNe(e10) {
        var t10 = jIe(e10), n10 = e10.createTexture();
        e10.bindTexture(e10.TEXTURE_2D, n10);
        e10.texImage2D(e10.TEXTURE_2D, 0, t10.internalFormatFloat, 1, 1, 0, t10.textureFormatFloat, t10.textureTypeFloat, null);
        var r10 = e10.createFramebuffer();
        e10.bindFramebuffer(e10.FRAMEBUFFER, r10), e10.framebufferTexture2D(e10.FRAMEBUFFER, e10.COLOR_ATTACHMENT0, e10.TEXTURE_2D, n10, 0);
        var a10 = e10.checkFramebufferStatus(e10.FRAMEBUFFER) === e10.FRAMEBUFFER_COMPLETE;
        return e10.bindTexture(e10.TEXTURE_2D, null), e10.bindFramebuffer(e10.FRAMEBUFFER, null), e10.deleteTexture(n10), e10.deleteFramebuffer(r10), a10;
      }
      function DNe(e10) {
        return 2 === e10 && null != WIe(e10).fenceSync;
      }
      function MNe(e10, t10) {
        Array.isArray(e10) || (e10 = [e10]), e10.forEach(function(e11) {
          null != e11 && F$("complex64" !== e11.dtype, function() {
            return "".concat(t10, " does not support complex64 tensors ") + "in the WebGL backend.";
          });
        });
      }
      var LNe = { __proto__: null, assertNotComplex: MNe, bindCanvasToFramebuffer: function(e10) {
        HIe(e10, function() {
          return e10.bindFramebuffer(e10.FRAMEBUFFER, null);
        }), HIe(e10, function() {
          return e10.viewport(0, 0, e10.canvas.width, e10.canvas.height);
        }), HIe(e10, function() {
          return e10.scissor(0, 0, e10.canvas.width, e10.canvas.height);
        });
      }, bindColorTextureToFramebuffer: dNe, bindTextureToProgramUniformSampler: fNe, bindTextureUnit: lNe, bindVertexBufferToProgramAttribute: cNe, callAndCheck: HIe, canBeRepresented: qIe, createFragmentShader: JIe, createFramebuffer: uNe, createProgram: tNe, createStaticIndexBuffer: iNe, createStaticVertexBuffer: aNe, createTexture: oNe, createVertexShader: YIe, getBatchDim: xNe, getExtensionOrThrow: XIe, getFramebufferErrorMessage: gNe, getMaxTexturesInShader: ENe, getNumChannels: function() {
        return 2 === k0().getNumber("WEBGL_VERSION") ? 1 : 4;
      }, getProgramUniformLocation: pNe, getProgramUniformLocationOrThrow: hNe, getRowsCols: kNe, getShapeAs3D: wNe, getTextureShapeFromLogicalShape: INe, getWebGLDisjointQueryTimerVersion: CNe, getWebGLErrorMessage: KIe, getWebGLMaxTextureSize: TNe, hasExtension: ANe, isCapableOfRenderingToFloatTexture: _Ne, isDownloadFloatTextureEnabled: ONe, isReshapeFree: SNe, isWebGLFenceEnabled: DNe, isWebGLVersionEnabled: RNe, linkProgram: nNe, logShaderSourceAndInfoLog: eNe, resetMaxTextureSize: function() {
        ZIe = null;
      }, resetMaxTexturesInShader: function() {
        QIe = null;
      }, unbindColorTextureFromFramebuffer: vNe, unbindTextureUnit: function(e10, t10) {
        bNe(e10, t10), HIe(e10, function() {
          return e10.activeTexture(e10.TEXTURE0 + t10);
        }), HIe(e10, function() {
          return e10.bindTexture(e10.TEXTURE_2D, null);
        });
      }, validateFramebuffer: mNe, validateProgram: rNe, validateTextureSize: sNe }, zNe = k0();
      function PNe() {
        var e10, t10, n10, r10, a10, i10, o10, s10, u10, c10;
        return 2 === k0().getNumber("WEBGL_VERSION") ? (e10 = "#version 300 es", t10 = "in", n10 = "out", r10 = "in", a10 = "texture", i10 = "outputColor", o10 = "out vec4 outputColor;", s10 = k0().getBool("WEBGL2_ISNAN_CUSTOM") ? "\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    " : "", u10 = "", c10 = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (e10 = "", t10 = "attribute", n10 = "varying", r10 = "varying", a10 = "texture2D", i10 = "gl_FragColor", o10 = "", s10 = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", u10 = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", c10 = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), { version: e10, attribute: t10, varyingVs: n10, varyingFs: r10, texture2D: a10, output: i10, defineOutput: o10, defineSpecialNaN: s10, defineSpecialInf: u10, defineRound: c10 };
      }
      function BNe(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "index", r10 = i0(t10);
        return r10.map(function(t11, a10) {
          var i10 = "int ".concat(e10[a10], " = ").concat(n10, " / ").concat(t11), o10 = a10 === r10.length - 1 ? "int ".concat(e10[a10 + 1], " = ").concat(n10, " - ").concat(e10[a10], " * ").concat(t11) : "index -= ".concat(e10[a10], " * ").concat(t11);
          return "".concat(i10, "; ").concat(o10, ";");
        }).join("");
      }
      function WNe(e10, t10) {
        var n10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "index", r10 = i0(t10);
        return r10.map(function(t11, a10) {
          var i10 = "int ".concat(e10[a10], " = ").concat(n10, " / outShapeStrides[").concat(a10, "]"), o10 = a10 === r10.length - 1 ? "int ".concat(e10[a10 + 1], " = ").concat(n10, " - ").concat(e10[a10], " * outShapeStrides[").concat(a10, "]") : "index -= ".concat(e10[a10], " * outShapeStrides[").concat(a10, "]");
          return "".concat(i10, "; ").concat(o10, ";");
        }).join("");
      }
      function UNe(e10, t10) {
        var n10 = e10.length, r10 = e10.map(function(e11) {
          return "".concat(t10, "[").concat(e11, "]");
        }), a10 = new Array(n10 - 1);
        a10[n10 - 2] = r10[n10 - 1];
        for (var i10 = n10 - 3; i10 >= 0; --i10) a10[i10] = "(".concat(a10[i10 + 1], " * ").concat(r10[i10 + 1], ")");
        return a10;
      }
      function VNe(e10) {
        var t10 = i0(e10).map(function(e11) {
          return e11.toString();
        });
        return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t10[0], " + coords.y * ").concat(t10[1], " + coords.z;\n  }\n");
      }
      zNe.registerFlag("HAS_WEBGL", function() {
        return zNe.getNumber("WEBGL_VERSION") > 0;
      }), zNe.registerFlag("WEBGL_VERSION", function() {
        return RNe(2) ? 2 : RNe(1) ? 1 : 0;
      }), zNe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", function() {
        return false;
      }), zNe.registerFlag("WEBGL_BUFFER_SUPPORTED", function() {
        return 2 === zNe.get("WEBGL_VERSION");
      }), zNe.registerFlag("WEBGL_CPU_FORWARD", function() {
        return true;
      }), zNe.registerFlag("WEBGL_FORCE_F16_TEXTURES", function() {
        return false;
      }), zNe.registerFlag("WEBGL_PACK", function() {
        return zNe.getBool("HAS_WEBGL");
      }), zNe.registerFlag("WEBGL_PACK_NORMALIZATION", function() {
        return zNe.getBool("WEBGL_PACK");
      }), zNe.registerFlag("WEBGL_PACK_CLIP", function() {
        return zNe.getBool("WEBGL_PACK");
      }), zNe.registerFlag("WEBGL_PACK_DEPTHWISECONV", function() {
        return zNe.getBool("WEBGL_PACK");
      }), zNe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function() {
        return zNe.getBool("WEBGL_PACK");
      }), zNe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function() {
        return zNe.getBool("WEBGL_PACK");
      }), zNe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function() {
        return zNe.getBool("WEBGL_PACK");
      }), zNe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function() {
        return zNe.getBool("WEBGL_PACK");
      }), zNe.registerFlag("WEBGL_PACK_REDUCE", function() {
        return zNe.getBool("WEBGL_PACK");
      }), zNe.registerFlag("WEBGL_LAZILY_UNPACK", function() {
        return zNe.getBool("WEBGL_PACK");
      }), zNe.registerFlag("WEBGL_CONV_IM2COL", function() {
        return zNe.getBool("WEBGL_PACK");
      }), zNe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE", function() {
        return zNe.getBool("WEBGL_PACK");
      }), zNe.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function() {
        return TNe(zNe.getNumber("WEBGL_VERSION"));
      }), zNe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function() {
        return ENe(zNe.getNumber("WEBGL_VERSION"));
      }), zNe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function() {
        var e10 = zNe.getNumber("WEBGL_VERSION");
        return 0 === e10 ? 0 : CNe(e10);
      }), zNe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function() {
        return zNe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !A5();
      }), zNe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function() {
        return _Ne(zNe.getNumber("WEBGL_VERSION"));
      }), zNe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function() {
        return !zNe.getBool("WEBGL_FORCE_F16_TEXTURES") && zNe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
      }), zNe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function() {
        return ONe(zNe.getNumber("WEBGL_VERSION"));
      }), zNe.registerFlag("WEBGL_FENCE_API_ENABLED", function() {
        return DNe(zNe.getNumber("WEBGL_VERSION"));
      }), zNe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function() {
        return zNe.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
      }), zNe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", function() {
        return -1;
      }, function(e10) {
        if ("number" != typeof e10) throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but " + "got ".concat(e10, "."));
        if (e10 < 0 && -1 !== e10) throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never " + "delete) or at least 0, but got ".concat(e10, "."));
      }), zNe.registerFlag("WEBGL_FLUSH_THRESHOLD", function() {
        return A5() ? 1 : -1;
      }, function(e10) {
        if ("number" != typeof e10) throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got " + "".concat(e10, "."));
        if (e10 < 0 && -1 !== e10) throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never " + "manual flush) or at least 0, but got ".concat(e10, "."));
      }), zNe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", function() {
        return 128;
      }), zNe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", function() {
        return false;
      }), zNe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", function() {
        return 1e5;
      }), zNe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", function() {
        return 128;
      }), zNe.registerFlag("WEBGL_EXP_CONV", function() {
        return false;
      }), zNe.registerFlag("SOFTWARE_WEBGL_ENABLED", function() {
        return zNe.getBool("IS_TEST");
      }), zNe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", function() {
        return 1 / 0;
      }), zNe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", function() {
        return false;
      }), zNe.registerFlag("WEBGL2_ISNAN_CUSTOM", function() {
        return false;
      }), zNe.registerFlag("ENGINE_COMPILE_ONLY", function() {
        return false;
      });
      var GNe = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n", jNe = M7;
      function HNe(e10, t10, n10) {
        var r10 = [];
        if (e10.forEach(function(e11) {
          var t11 = L$(e11.shapeInfo.logicalShape);
          if (e11.shapeInfo.isUniform ? r10.push("uniform float ".concat(e11.name).concat(t11 > 1 ? "[".concat(t11, "]") : "", ";")) : (r10.push("uniform sampler2D ".concat(e11.name, ";")), r10.push("uniform int offset".concat(e11.name, ";"))), n10.enableShapeUniforms) {
            switch (lSe(n10.packedInputs, e11.shapeInfo.logicalShape, e11.shapeInfo.texShape).uniformShape.length) {
              case 1:
                r10.push("uniform int ".concat(e11.name, "Shape;"));
                break;
              case 2:
                r10.push("uniform ivec2 ".concat(e11.name, "Shape;"));
                break;
              case 3:
                r10.push("uniform ivec3 ".concat(e11.name, "Shape;"));
                break;
              case 4:
                r10.push("uniform ivec4 ".concat(e11.name, "Shape;"));
            }
            r10.push("uniform ivec2 ".concat(e11.name, "TexShape;"));
          }
        }), n10.enableShapeUniforms) {
          switch (t10.logicalShape.length) {
            case 1:
              r10.push("uniform int outShape;");
              break;
            case 2:
              r10.push("uniform ivec2 outShape;"), r10.push("uniform int outShapeStrides;");
              break;
            case 3:
              r10.push("uniform ivec3 outShape;"), r10.push("uniform ivec2 outShapeStrides;");
              break;
            case 4:
              r10.push("uniform ivec4 outShape;"), r10.push("uniform ivec3 outShapeStrides;");
          }
          r10.push("uniform ivec2 outTexShape;");
        }
        n10.customUniforms && n10.customUniforms.forEach(function(e11) {
          r10.push("uniform ".concat(e11.type, " ").concat(e11.name).concat(e11.arrayIndex ? "[".concat(e11.arrayIndex, "]") : "", ";"));
        });
        var a10, i10, o10 = r10.join("\n"), s10 = e10.map(function(e11) {
          return function(e12, t11) {
            var n11 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r11 = arguments.length > 3 ? arguments[3] : void 0, a11 = "";
            a11 += n11 ? KNe(e12, r11) : qNe(e12, r11);
            var i11 = e12.shapeInfo.logicalShape, o11 = t11.logicalShape;
            i11.length <= o11.length && (a11 += n11 ? sSe(e12, t11) : uSe(e12, t11));
            return a11;
          }(e11, t10, n10.packedInputs, n10.enableShapeUniforms);
        }).join("\n"), u10 = t10.texShape, c10 = PNe(), l10 = function(e11) {
          return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e11.texture2D, "(textureSampler, uv).r;\n    }\n  ");
        }(c10), h10 = function(e11) {
          return "".concat(e11.version, "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e11.varyingFs, " vec2 resultUV;\n    ").concat(e11.defineOutput, "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e11.defineSpecialNaN, "\n    ").concat(e11.defineSpecialInf, "\n    ").concat(e11.defineRound, "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(XNe, "\n    ").concat(YNe, "\n    ").concat(JNe, "\n  ");
        }(c10);
        return t10.isPacked ? (a10 = function(e11, t11, n11) {
          switch (e11.length) {
            case 0:
              return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
            case 1:
              return function(e12, t12, n12) {
                var r11 = [Math.ceil(t12[0] / 2), Math.ceil(t12[1] / 2)];
                if (1 === r11[0]) return n12 ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    " : "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(r11[1], ".0);\n      }\n    ");
                if (1 === r11[1]) return n12 ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    " : "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(r11[0], ".0);\n      }\n    ");
                if (n12) return "\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";
                return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r11[0], ", ").concat(r11[1], "));\n      return 2 * (resTexRC.x * ").concat(r11[1], " + resTexRC.y);\n    }\n  ");
              }(0, t11, n11);
            case 2:
              return function(e12, t12, n12) {
                var r11 = [Math.ceil(t12[0] / 2), Math.ceil(t12[1] / 2)];
                if (P$(e12, t12)) return n12 ? "\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(r11[0], ", ").concat(r11[1], "));\n      }\n    ");
                var a11 = Math.ceil(e12[1] / 2);
                if (n12) return "\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";
                return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r11[0], ", ").concat(r11[1], "));\n\n      int index = resTexRC.x * ").concat(r11[1], " + resTexRC.y;\n      int r = 2 * (index / ").concat(a11, ");\n      int c = imod(index, ").concat(a11, ") * 2;\n\n      return ivec2(r, c);\n    }\n  ");
              }(e11, t11, n11);
            case 3:
              return function(e12, t12, n12) {
                if (n12) return "\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
                var r11 = [Math.ceil(t12[0] / 2), Math.ceil(t12[1] / 2)], a11 = Math.ceil(e12[2] / 2), i11 = a11 * Math.ceil(e12[1] / 2);
                return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r11[0], ", ").concat(r11[1], "));\n      int index = resTexRC.x * ").concat(r11[1], " + resTexRC.y;\n\n      int b = index / ").concat(i11, ";\n      index -= b * ").concat(i11, ";\n\n      int r = 2 * (index / ").concat(a11, ");\n      int c = imod(index, ").concat(a11, ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ");
              }(e11, t11, n11);
            default:
              return function(e12, t12, n12) {
                if (n12) return "\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";
                for (var r11 = [Math.ceil(t12[0] / 2), Math.ceil(t12[1] / 2)], a11 = Math.ceil(e12[e12.length - 1] / 2), i11 = a11 * Math.ceil(e12[e12.length - 2] / 2), o11 = i11, s11 = "", u11 = "b, r, c", c11 = 2; c11 < e12.length - 1; c11++) o11 *= e12[e12.length - c11 - 1], s11 = "\n      int b".concat(c11, " = index / ").concat(o11, ";\n      index -= b").concat(c11, " * ").concat(o11, ";\n    ") + s11, u11 = "b".concat(c11, ", ") + u11;
                return "\n    ivec".concat(e12.length, " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(r11[0], ", ").concat(r11[1], "));\n      int index = resTexRC.x * ").concat(r11[1], " + resTexRC.y;\n\n      ").concat(s11, "\n\n      int b = index / ").concat(i11, ";\n      index -= b * ").concat(i11, ";\n\n      int r = 2 * (index / ").concat(a11, ");\n      int c = imod(index, ").concat(a11, ") * 2;\n\n      return ivec").concat(e12.length, "(").concat(u11, ");\n    }\n  ");
              }(e11, t11, n11);
          }
        }(t10.logicalShape, u10, n10.enableShapeUniforms), i10 = function(e11) {
          return "\n    void setOutput(vec4 val) {\n      ".concat(e11.output, " = val;\n    }\n  ");
        }(c10)) : (a10 = function(e11, t11, n11) {
          switch (e11.length) {
            case 0:
              return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
            case 1:
              return function(e12, t12, n12) {
                if (1 === t12[0]) return n12 ? "\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    " : "\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t12[1], ".0);\n      }\n    ");
                if (1 === t12[1]) return n12 ? "\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    " : "\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t12[0], ".0);\n      }\n    ");
                if (n12) return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";
                return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t12[0], ", ").concat(t12[1], "));\n      return resTexRC.x * ").concat(t12[1], " + resTexRC.y;\n    }\n  ");
              }(0, t11, n11);
            case 2:
              return function(e12, t12, n12) {
                if (P$(e12, t12)) return n12 ? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t12[0], ", ").concat(t12[1], "));\n      }\n    ");
                if (1 === e12[1]) return n12 ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t12[0], ", ").concat(t12[1], "));\n        int index = resTexRC.x * ").concat(t12[1], " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");
                if (1 === e12[0]) return n12 ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t12[0], ", ").concat(t12[1], "));\n        int index = resTexRC.x * ").concat(t12[1], " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");
                if (n12) return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";
                return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t12[0], ", ").concat(t12[1], "));\n      int index = resTexRC.x * ").concat(t12[1], " + resTexRC.y;\n      int r = index / ").concat(e12[1], ";\n      int c = index - r * ").concat(e12[1], ";\n      return ivec2(r, c);\n    }\n  ");
              }(e11, t11, n11);
            case 3:
              return function(e12, t12, n12) {
                if (n12) {
                  var r12 = WNe(["r", "c", "d"], e12);
                  return "\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(r12, "\n    return ivec3(r, c, d);\n  }\n");
                }
                var a12 = BNe(["r", "c", "d"], e12);
                return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t12[0], ", ").concat(t12[1], "));\n      int index = resTexRC.x * ").concat(t12[1], " + resTexRC.y;\n      ").concat(a12, "\n      return ivec3(r, c, d);\n    }\n  ");
              }(e11, t11, n11);
            case 4:
              return function(e12, t12, n12) {
                if (n12) {
                  var r12 = WNe(["r", "c", "d", "d2"], e12);
                  return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(r12, "\n      return ivec4(r, c, d, d2);\n    }\n  ");
                }
                var a12 = BNe(["r", "c", "d", "d2"], e12);
                return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t12[0], ", ").concat(t12[1], "));\n      int index = resTexRC.x * ").concat(t12[1], " + resTexRC.y;\n      ").concat(a12, "\n      return ivec4(r, c, d, d2);\n    }\n  ");
              }(e11, t11, n11);
            case 5:
              return r11 = t11, a11 = BNe(["r", "c", "d", "d2", "d3"], e11), "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(r11[0], ",\n                             ").concat(r11[1], "));\n\n      int index = resTexRC.x * ").concat(r11[1], " + resTexRC.y;\n\n      ").concat(a11, "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ");
            case 6:
              return function(e12, t12) {
                var n12 = BNe(["r", "c", "d", "d2", "d3", "d4"], e12);
                return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t12[0], ", ").concat(t12[1], "));\n      int index = resTexRC.x * ").concat(t12[1], " + resTexRC.y;\n\n      ").concat(n12, "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ");
              }(e11, t11);
            default:
              throw new Error("".concat(e11.length, "-D output sampling is not yet supported"));
          }
          var r11, a11;
        }(t10.logicalShape, u10, n10.enableShapeUniforms), i10 = function(e11) {
          return "\n    void setOutput(float val) {\n      ".concat(e11.output, " = vec4(val, 0, 0, 0);\n    }\n  ");
        }(c10)), n10.packedInputs && (h10 += ZNe), [h10, l10, i10, o10, a10, s10, n10.userCode].join("\n");
      }
      function qNe(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n10 = e10.shapeInfo.logicalShape;
        switch (n10.length) {
          case 0:
            return $Ne(e10, t10);
          case 1:
            return eSe(e10, t10);
          case 2:
            return tSe(e10, t10);
          case 3:
            return nSe(e10, t10);
          case 4:
            return rSe(e10, t10);
          case 5:
            return aSe(e10);
          case 6:
            return iSe(e10);
          default:
            throw new Error("".concat(n10.length, "-D input sampling") + " is not yet supported");
        }
      }
      function KNe(e10, t10) {
        var n10, r10, a10;
        switch (e10.shapeInfo.logicalShape.length) {
          case 0:
            return n10 = e10.name, r10 = "get" + n10.charAt(0).toUpperCase() + n10.slice(1), a10 = PNe(), "\n    vec4 ".concat(r10, "() {\n      return ").concat(a10.texture2D, "(").concat(n10, ", halfCR);\n    }\n  ");
          case 1:
            return function(e11, t11) {
              var n11 = e11.name, r11 = "get" + n11.charAt(0).toUpperCase() + n11.slice(1), a11 = e11.shapeInfo.texShape, i10 = PNe();
              if (t11) return "\n    vec4 ".concat(r11, "(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n11, "TexShape[0]) / 2.0), ceil(float(").concat(n11, "TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(i10.texture2D, "(").concat(n11, ", uv);\n    }\n  ");
              var o10 = [Math.ceil(a11[0] / 2), Math.ceil(a11[1] / 2)];
              return "\n    vec4 ".concat(r11, "(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(o10[0], ", ").concat(o10[1], ", index);\n      return ").concat(i10.texture2D, "(").concat(n11, ", uv);\n    }\n  ");
            }(e10, t10);
          case 2:
            return function(e11, t11) {
              var n11 = e11.shapeInfo.logicalShape, r11 = e11.name, a11 = "get" + r11.charAt(0).toUpperCase() + r11.slice(1), i10 = e11.shapeInfo.texShape, o10 = i10[0], s10 = i10[1], u10 = PNe();
              if (null != i10 && P$(n11, i10)) return t11 ? "\n      vec4 ".concat(a11, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(r11, "TexShape[1], ").concat(r11, "TexShape[0]);\n\n        return ").concat(u10.texture2D, "(").concat(r11, ", uv);\n      }\n    ") : "\n      vec4 ".concat(a11, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(s10, ".0, ").concat(o10, ".0);\n\n        return ").concat(u10.texture2D, "(").concat(r11, ", uv);\n      }\n    ");
              if (t11) return "\n    vec4 ".concat(a11, "(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(r11, "TexShape[0]) / 2.0), ceil(float(").concat(r11, "TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(r11, "Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(u10.texture2D, "(").concat(r11, ", uv);\n    }\n  ");
              var c10 = [Math.ceil(i10[0] / 2), Math.ceil(i10[1] / 2)], l10 = Math.ceil(n11[1] / 2);
              return "\n    vec4 ".concat(a11, "(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(l10, ", ").concat(c10[0], ", ").concat(c10[1], ", row, col);\n      return ").concat(u10.texture2D, "(").concat(r11, ", uv);\n    }\n  ");
            }(e10, t10);
          case 3:
            return function(e11, t11) {
              var n11 = e11.shapeInfo.logicalShape, r11 = e11.name, a11 = "get" + r11.charAt(0).toUpperCase() + r11.slice(1), i10 = e11.shapeInfo.texShape, o10 = [Math.ceil(i10[0] / 2), Math.ceil(i10[1] / 2)];
              if (1 === n11[0]) {
                var s10 = [1, 2], u10 = hSe(e11, n11.slice(1)), c10 = ["b", "row", "col"];
                return "\n        ".concat(KNe(u10, t11), "\n        vec4 ").concat(a11, "(int b, int row, int col) {\n          return ").concat(a11, "(").concat(pSe(c10, s10), ");\n        }\n      ");
              }
              var l10 = PNe();
              if (t11) return "\n    vec4 ".concat(a11, "(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(r11, "TexShape[0]) / 2.0), ceil(float(").concat(r11, "TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(r11, "Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(r11, "Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(l10.texture2D, "(").concat(r11, ", uv);\n    }\n  ");
              var h10 = o10[0], p10 = o10[1], f10 = Math.ceil(n11[2] / 2), d10 = f10 * Math.ceil(n11[1] / 2);
              return "\n    vec4 ".concat(a11, "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(h10, ", ").concat(p10, ", ").concat(d10, ", ").concat(f10, ", b, row, col);\n      return ").concat(l10.texture2D, "(").concat(r11, ", uv);\n    }\n  ");
            }(e10, t10);
          default:
            return function(e11, t11) {
              var n11 = e11.name, r11 = "get" + n11.charAt(0).toUpperCase() + n11.slice(1), a11 = PNe();
              if (t11) return "\n    vec4 ".concat(r11, "(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n11, "Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n11, "Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n11, "Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n11, "TexShape[0]) / 2.0), ceil(float(").concat(n11, "TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(a11.texture2D, "(").concat(n11, ", uv);\n    }\n  ");
              for (var i10 = e11.shapeInfo.logicalShape, o10 = i10.length, s10 = e11.shapeInfo.texShape, u10 = [Math.ceil(s10[0] / 2), Math.ceil(s10[1] / 2)], c10 = u10[0], l10 = u10[1], h10 = Math.ceil(i10[o10 - 1] / 2), p10 = h10 * Math.ceil(i10[o10 - 2] / 2), f10 = "int b, int row, int col", d10 = "b * ".concat(p10, " + (row / 2) * ").concat(h10, " + (col / 2)"), v10 = 2; v10 < o10 - 1; v10++) f10 = "int b".concat(v10, ", ") + f10, p10 *= i10[o10 - v10 - 1], d10 = "b".concat(v10, " * ").concat(p10, " + ") + d10;
              return "\n    vec4 ".concat(r11, "(").concat(f10, ") {\n      int index = ").concat(d10, ";\n      int texR = index / ").concat(l10, ";\n      int texC = index - texR * ").concat(l10, ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(l10, ", ").concat(c10, ");\n      return ").concat(a11.texture2D, "(").concat(n11, ", uv);\n    }\n  ");
            }(e10, t10);
        }
      }
      var XNe = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n", YNe = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n", JNe = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n", ZNe = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
      function QNe(e10) {
        return "offset".concat(e10);
      }
      function $Ne(e10, t10) {
        var n10 = e10.name, r10 = "get" + n10.charAt(0).toUpperCase() + n10.slice(1);
        if (e10.shapeInfo.isUniform) return "float ".concat(r10, "() {return ").concat(n10, ";}");
        var a10 = S(e10.shapeInfo.texShape, 2), i10 = a10[0], o10 = a10[1];
        if (1 === i10 && 1 === o10) return "\n      float ".concat(r10, "() {\n        return sampleTexture(").concat(n10, ", halfCR);\n      }\n    ");
        var s10 = QNe(n10);
        if (t10) return "\n    float ".concat(r10, "() {\n      vec2 uv = uvFromFlat(").concat(n10, "TexShape[0], ").concat(n10, "TexShape[1], ").concat(s10, ");\n      return sampleTexture(").concat(n10, ", uv);\n    }\n  ");
        var u10 = S(e10.shapeInfo.texShape, 2), c10 = u10[0], l10 = u10[1];
        return "\n    float ".concat(r10, "() {\n      vec2 uv = uvFromFlat(").concat(c10, ", ").concat(l10, ", ").concat(s10, ");\n      return sampleTexture(").concat(n10, ", uv);\n    }\n  ");
      }
      function eSe(e10, t10) {
        var n10 = e10.name, r10 = "get" + n10.charAt(0).toUpperCase() + n10.slice(1);
        if (e10.shapeInfo.isUniform) return "\n      float ".concat(r10, "(int index) {\n        ").concat(oSe(e10), "\n      }\n    ");
        var a10 = e10.shapeInfo.texShape, i10 = a10[0], o10 = a10[1];
        if (1 === o10 && 1 === i10) return "\n      float ".concat(r10, "(int index) {\n        return sampleTexture(").concat(n10, ", halfCR);\n      }\n    ");
        var s10 = QNe(n10);
        return 1 === o10 ? t10 ? "\n      float ".concat(r10, "(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(s10, ") + 0.5) / float(").concat(n10, "TexShape[0]));\n        return sampleTexture(").concat(n10, ", uv);\n      }\n    ") : "\n      float ".concat(r10, "(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(s10, ") + 0.5) / ").concat(i10, ".0);\n        return sampleTexture(").concat(n10, ", uv);\n      }\n    ") : 1 === i10 ? t10 ? "\n      float ".concat(r10, "(int index) {\n        vec2 uv = vec2((float(index + ").concat(s10, ") + 0.5) / float(").concat(n10, "TexShape[1]), 0.5);\n        return sampleTexture(").concat(n10, ", uv);\n      }\n    ") : "\n      float ".concat(r10, "(int index) {\n        vec2 uv = vec2((float(index + ").concat(s10, ") + 0.5) / ").concat(o10, ".0, 0.5);\n        return sampleTexture(").concat(n10, ", uv);\n      }\n    ") : t10 ? "\n    float ".concat(r10, "(int index) {\n      vec2 uv = uvFromFlat(").concat(n10, "TexShape[0], ").concat(n10, "TexShape[1], index + ").concat(s10, ");\n      return sampleTexture(").concat(n10, ", uv);\n    }\n  ") : "\n    float ".concat(r10, "(int index) {\n      vec2 uv = uvFromFlat(").concat(i10, ", ").concat(o10, ", index + ").concat(s10, ");\n      return sampleTexture(").concat(n10, ", uv);\n    }\n  ");
      }
      function tSe(e10, t10) {
        var n10 = e10.shapeInfo.logicalShape, r10 = e10.name, a10 = "get" + r10.charAt(0).toUpperCase() + r10.slice(1), i10 = e10.shapeInfo.texShape;
        if (null != i10 && P$(n10, i10)) {
          if (t10) return "\n      float ".concat(a10, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(r10, "TexShape[1], ").concat(r10, "TexShape[0]);\n        return sampleTexture(").concat(r10, ", uv);\n      }\n    ");
          var o10 = i10[0], s10 = i10[1];
          return "\n    float ".concat(a10, "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(s10, ".0, ").concat(o10, ".0);\n      return sampleTexture(").concat(r10, ", uv);\n    }\n  ");
        }
        var u10 = H$(n10), c10 = u10.newShape, l10 = u10.keptDims, h10 = c10;
        if (h10.length < n10.length) {
          var p10 = hSe(e10, h10);
          return "\n      ".concat(qNe(p10, t10), "\n      float ").concat(a10, "(int row, int col) {\n        return ").concat(a10, "(").concat(pSe(["row", "col"], l10), ");\n      }\n    ");
        }
        if (e10.shapeInfo.isUniform) return "\n      float ".concat(a10, "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n10[1], ", 1)));\n        ").concat(oSe(e10), "\n      }\n    ");
        var f10 = i10[0], d10 = i10[1], v10 = QNe(r10);
        return 1 === d10 ? t10 ? "\n      float ".concat(a10, "(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(v10, "), vec3(").concat(r10, "Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(r10, "TexShape[0]));\n        return sampleTexture(").concat(r10, ", uv);\n      }\n    ") : "\n    float ".concat(a10, "(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(v10, "), vec3(").concat(n10[1], ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(f10, ".0);\n      return sampleTexture(").concat(r10, ", uv);\n    }\n  ") : 1 === f10 ? t10 ? "\n      float ".concat(a10, "(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(v10, "), vec3(").concat(r10, "Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(r10, "TexShape[1]), 0.5);\n        return sampleTexture(").concat(r10, ", uv);\n      }\n    ") : "\n    float ".concat(a10, "(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(v10, "), vec3(").concat(n10[1], ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(d10, ".0, 0.5);\n      return sampleTexture(").concat(r10, ", uv);\n    }\n  ") : t10 ? "\n      float ".concat(a10, "(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(r10, "Shape[1] + col + ").concat(v10, ";\n        vec2 uv = uvFromFlat(").concat(r10, "TexShape[0], ").concat(r10, "TexShape[1], index);\n        return sampleTexture(").concat(r10, ", uv);\n      }\n    ") : "\n  float ".concat(a10, "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n10[1], " + col + ").concat(v10, ";\n    vec2 uv = uvFromFlat(").concat(f10, ", ").concat(d10, ", index);\n    return sampleTexture(").concat(r10, ", uv);\n  }\n");
      }
      function nSe(e10, t10) {
        var n10 = e10.shapeInfo.logicalShape, r10 = e10.name, a10 = "get" + r10.charAt(0).toUpperCase() + r10.slice(1), i10 = n10[1] * n10[2], o10 = n10[2], s10 = H$(n10), u10 = s10.newShape, c10 = s10.keptDims, l10 = u10;
        if (l10.length < n10.length) {
          var h10 = hSe(e10, l10);
          return "\n        ".concat(qNe(h10, t10), "\n        float ").concat(a10, "(int row, int col, int depth) {\n          return ").concat(a10, "(").concat(pSe(["row", "col", "depth"], c10), ");\n        }\n      ");
        }
        if (e10.shapeInfo.isUniform) return "\n      float ".concat(a10, "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(i10, ", ").concat(o10, ", 1)));\n        ").concat(oSe(e10), "\n      }\n    ");
        var p10 = e10.shapeInfo.texShape, f10 = p10[0], d10 = p10[1], v10 = e10.shapeInfo.flatOffset;
        if (d10 === i10 && null == v10) return t10 ? "\n      float ".concat(a10, "(int row, int col, int depth) {\n        int stride1 = ").concat(r10, "Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(r10, "TexShape[1], ").concat(r10, "TexShape[0]);\n        return sampleTexture(").concat(r10, ", uv);\n      }\n    ") : "\n        float ".concat(a10, "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(o10, ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(d10, ".0, ").concat(f10, ".0);\n          return sampleTexture(").concat(r10, ", uv);\n        }\n      ");
        if (d10 === o10 && null == v10) return t10 ? "\n      float ".concat(a10, "(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(r10, "Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(r10, "TexShape[1], ").concat(r10, "TexShape[0]);\n        return sampleTexture(").concat(r10, ", uv);\n      }\n    ") : "\n    float ".concat(a10, "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n10[1], ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(d10, ".0, ").concat(f10, ".0);\n      return sampleTexture(").concat(r10, ", uv);\n    }\n  ");
        var m10 = QNe(r10);
        return t10 ? "\n    float ".concat(a10, "(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(r10, "Shape[1] * ").concat(r10, "Shape[2];\n      int stride1 = ").concat(r10, "Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(m10, ";\n      vec2 uv = uvFromFlat(").concat(r10, "TexShape[0], ").concat(r10, "TexShape[1], index);\n      return sampleTexture(").concat(r10, ", uv);\n    }\n    ") : "\n      float ".concat(a10, "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(i10, " + col * ").concat(o10, " + depth + ").concat(m10, ";\n        vec2 uv = uvFromFlat(").concat(f10, ", ").concat(d10, ", index);\n        return sampleTexture(").concat(r10, ", uv);\n      }\n  ");
      }
      function rSe(e10, t10) {
        var n10 = e10.shapeInfo.logicalShape, r10 = e10.name, a10 = "get" + r10.charAt(0).toUpperCase() + r10.slice(1), i10 = n10[3], o10 = n10[2] * i10, s10 = n10[1] * o10, u10 = H$(n10), c10 = u10.newShape, l10 = u10.keptDims;
        if (c10.length < n10.length) {
          var h10 = hSe(e10, c10);
          return "\n      ".concat(qNe(h10, t10), "\n      float ").concat(a10, "(int row, int col, int depth, int depth2) {\n        return ").concat(a10, "(").concat(pSe(["row", "col", "depth", "depth2"], l10), ");\n      }\n    ");
        }
        if (e10.shapeInfo.isUniform) return "\n      float ".concat(a10, "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(s10, ", ").concat(o10, ", ").concat(i10, ", 1)));\n        ").concat(oSe(e10), "\n      }\n    ");
        var p10 = e10.shapeInfo.flatOffset, f10 = e10.shapeInfo.texShape, d10 = f10[0], v10 = f10[1], m10 = "int stride2 = ".concat(r10, "Shape[3];"), g10 = "int stride1 = ".concat(r10, "Shape[2] * stride2;"), y10 = "int stride0 = ".concat(r10, "Shape[1] * stride1;");
        if (v10 === s10 && null == p10) return t10 ? "\n      float ".concat(a10, "(int row, int col, int depth, int depth2) {\n        ").concat(m10, "\n        ").concat(g10, "\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(r10, "TexShape[1], ").concat(r10, "TexShape[0]);\n        return sampleTexture(").concat(r10, ", uv);\n      }\n    ") : "\n      float ".concat(a10, "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(o10, ", ").concat(i10, ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(v10, ".0, ").concat(d10, ".0);\n        return sampleTexture(").concat(r10, ", uv);\n      }\n    ");
        if (v10 === i10 && null == p10) return t10 ? "\n      float ".concat(a10, "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(r10, "Shape[1] * ").concat(r10, "Shape[2], ").concat(r10, "Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(r10, "TexShape[1], ").concat(r10, "TexShape[0]);\n        return sampleTexture(").concat(r10, ", uv);\n      }\n    ") : "\n      float ".concat(a10, "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n10[1] * n10[2], ", ").concat(n10[2], ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(v10, ".0, ").concat(d10, ".0);\n        return sampleTexture(").concat(r10, ", uv);\n      }\n    ");
        var b10 = QNe(r10);
        return t10 ? "\n    float ".concat(a10, "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(m10, "\n      ").concat(g10, "\n      ").concat(y10, "\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(r10, "TexShape[0], ").concat(r10, "TexShape[1], index + ").concat(b10, ");\n      return sampleTexture(").concat(r10, ", uv);\n    }\n  ") : "\n    float ".concat(a10, "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(s10, " + col * ").concat(o10, " +\n          depth * ").concat(i10, " + depth2;\n      vec2 uv = uvFromFlat(").concat(d10, ", ").concat(v10, ", index + ").concat(b10, ");\n      return sampleTexture(").concat(r10, ", uv);\n    }\n  ");
      }
      function aSe(e10) {
        var t10 = e10.shapeInfo.logicalShape, n10 = e10.name, r10 = "get" + n10.charAt(0).toUpperCase() + n10.slice(1), a10 = t10[4], i10 = t10[3] * a10, o10 = t10[2] * i10, s10 = t10[1] * o10, u10 = H$(t10), c10 = u10.newShape, l10 = u10.keptDims;
        if (c10.length < t10.length) {
          var h10 = hSe(e10, c10);
          return "\n      ".concat(qNe(h10), "\n      float ").concat(r10, "(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(r10, "(").concat(pSe(["row", "col", "depth", "depth2", "depth3"], l10), ");\n      }\n    ");
        }
        if (e10.shapeInfo.isUniform) return "\n      float ".concat(r10, "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(s10, ", ").concat(o10, ", ").concat(i10, ", ").concat(a10, ")) +\n          depth3;\n        ").concat(oSe(e10), "\n      }\n    ");
        var p10 = e10.shapeInfo.flatOffset, f10 = e10.shapeInfo.texShape, d10 = f10[0], v10 = f10[1];
        if (v10 === s10 && null == p10) return "\n      float ".concat(r10, "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(o10, ", ").concat(i10, ", ").concat(a10, ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(v10, ".0, ").concat(d10, ".0);\n        return sampleTexture(").concat(n10, ", uv);\n      }\n    ");
        if (v10 === a10 && null == p10) return "\n      float ".concat(r10, "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t10[1] * t10[2] * t10[3], ",\n               ").concat(t10[2] * t10[3], ", ").concat(t10[3], ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(v10, ".0, ").concat(d10, ".0);\n        return sampleTexture(").concat(n10, ", uv);\n      }\n    ");
        var m10 = QNe(n10);
        return "\n    float ".concat(r10, "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(s10, " + col * ").concat(o10, " + depth * ").concat(i10, " +\n          depth2 * ").concat(a10, " + depth3 + ").concat(m10, ";\n      vec2 uv = uvFromFlat(").concat(d10, ", ").concat(v10, ", index);\n      return sampleTexture(").concat(n10, ", uv);\n    }\n  ");
      }
      function iSe(e10) {
        var t10 = e10.shapeInfo.logicalShape, n10 = e10.name, r10 = "get" + n10.charAt(0).toUpperCase() + n10.slice(1), a10 = H$(t10), i10 = a10.newShape, o10 = a10.keptDims;
        if (i10.length < t10.length) {
          var s10 = hSe(e10, i10);
          return "\n      ".concat(qNe(s10), "\n      float ").concat(r10, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(r10, "(").concat(pSe(["row", "col", "depth", "depth2", "depth3", "depth4"], o10), ");\n      }\n    ");
        }
        var u10 = t10[5], c10 = t10[4] * u10, l10 = t10[3] * c10, h10 = t10[2] * l10, p10 = t10[1] * h10;
        if (e10.shapeInfo.isUniform) return "\n      float ".concat(r10, "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(p10, ", ").concat(h10, ", ").concat(l10, ", ").concat(c10, ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(u10, ", 1)));\n        ").concat(oSe(e10), "\n      }\n    ");
        var f10 = e10.shapeInfo.flatOffset, d10 = e10.shapeInfo.texShape, v10 = d10[0], m10 = d10[1];
        if (m10 === p10 && null == f10) return "\n      float ".concat(r10, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(h10, ", ").concat(l10, ", ").concat(c10, ", ").concat(u10, ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(m10, ".0, ").concat(v10, ".0);\n        return sampleTexture(").concat(n10, ", uv);\n      }\n    ");
        if (m10 === u10 && null == f10) return "\n      float ".concat(r10, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t10[1] * t10[2] * t10[3] * t10[4], ",\n               ").concat(t10[2] * t10[3] * t10[4], ",\n               ").concat(t10[3] * t10[4], ",\n               ").concat(t10[4], ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(m10, ".0, ").concat(v10, ".0);\n        return sampleTexture(").concat(n10, ", uv);\n      }\n    ");
        var g10 = QNe(n10);
        return "\n    float ".concat(r10, "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(p10, " + col * ").concat(h10, " + depth * ").concat(l10, " +\n          depth2 * ").concat(c10, " + depth3 * ").concat(u10, " + depth4 + ").concat(g10, ";\n      vec2 uv = uvFromFlat(").concat(v10, ", ").concat(m10, ", index);\n      return sampleTexture(").concat(n10, ", uv);\n    }\n  ");
      }
      function oSe(e10) {
        var t10 = e10.name, n10 = L$(e10.shapeInfo.logicalShape);
        return n10 < 2 ? "return ".concat(t10, ";") : "\n    for (int i = 0; i < ".concat(n10, "; i++) {\n      if (i == index) {\n        return ").concat(t10, "[i];\n      }\n    }\n  ");
      }
      function sSe(e10, t10) {
        var n10, r10 = e10.name, a10 = r10.charAt(0).toUpperCase() + r10.slice(1), i10 = "get" + a10 + "AtOutCoords", o10 = e10.shapeInfo.logicalShape.length, s10 = t10.logicalShape.length, u10 = jNe(e10.shapeInfo.logicalShape, t10.logicalShape), c10 = cSe(s10), l10 = s10 - o10, h10 = ["x", "y", "z", "w", "u", "v"];
        n10 = 0 === o10 ? "" : s10 < 2 && u10.length >= 1 ? "coords = 0;" : u10.map(function(e11) {
          return "coords.".concat(h10[e11 + l10], " = 0;");
        }).join("\n");
        var p10 = "";
        p10 = s10 < 2 && o10 > 0 ? "coords" : e10.shapeInfo.logicalShape.map(function(e11, t11) {
          return "coords.".concat(h10[t11 + l10]);
        }).join(", ");
        var f10 = "return outputValue;", d10 = 1 === L$(e10.shapeInfo.logicalShape), v10 = 1 === L$(t10.logicalShape);
        if (1 !== o10 || d10 || v10) {
          if (d10 && !v10) f10 = 1 === s10 ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
          else if (u10.length) {
            var m10 = o10 - 2, g10 = o10 - 1;
            u10.indexOf(m10) > -1 && u10.indexOf(g10) > -1 ? f10 = "return vec4(outputValue.x);" : u10.indexOf(m10) > -1 ? f10 = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : u10.indexOf(g10) > -1 && (f10 = "return vec4(outputValue.xx, outputValue.zz);");
          }
        } else f10 = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
        return "\n    vec4 ".concat(i10, "() {\n      ").concat(c10, " coords = getOutputCoords();\n      ").concat(n10, "\n      vec4 outputValue = get").concat(a10, "(").concat(p10, ");\n      ").concat(f10, "\n    }\n  ");
      }
      function uSe(e10, t10) {
        var n10 = e10.name, r10 = n10.charAt(0).toUpperCase() + n10.slice(1), a10 = "get" + r10 + "AtOutCoords", i10 = t10.texShape, o10 = e10.shapeInfo.texShape, s10 = e10.shapeInfo.logicalShape.length, u10 = t10.logicalShape.length;
        if (!e10.shapeInfo.isUniform && s10 === u10 && null == e10.shapeInfo.flatOffset && P$(o10, i10)) return "\n      float ".concat(a10, "() {\n        return sampleTexture(").concat(n10, ", resultUV);\n      }\n    ");
        var c10, l10 = cSe(u10), h10 = jNe(e10.shapeInfo.logicalShape, t10.logicalShape), p10 = u10 - s10, f10 = ["x", "y", "z", "w", "u", "v"];
        c10 = 0 === s10 ? "" : u10 < 2 && h10.length >= 1 ? "coords = 0;" : h10.map(function(e11) {
          return "coords.".concat(f10[e11 + p10], " = 0;");
        }).join("\n");
        var d10 = "";
        return d10 = u10 < 2 && s10 > 0 ? "coords" : e10.shapeInfo.logicalShape.map(function(e11, t11) {
          return "coords.".concat(f10[t11 + p10]);
        }).join(", "), "\n    float ".concat(a10, "() {\n      ").concat(l10, " coords = getOutputCoords();\n      ").concat(c10, "\n      return get").concat(r10, "(").concat(d10, ");\n    }\n  ");
      }
      function cSe(e10) {
        if (e10 <= 1) return "int";
        if (2 === e10) return "ivec2";
        if (3 === e10) return "ivec3";
        if (4 === e10) return "ivec4";
        if (5 === e10) return "ivec5";
        if (6 === e10) return "ivec6";
        throw Error("GPU for rank ".concat(e10, " is not yet supported"));
      }
      function lSe(e10, t10, n10) {
        var r10 = H$(t10), a10 = r10.newShape, i10 = r10.keptDims, o10 = t10.length, s10 = e10 && 3 === o10 && 1 === t10[0], u10 = s10 ? t10.slice(1) : a10, c10 = !e10 && o10 > 1 && !P$(t10, n10) && a10.length < o10 || s10;
        return { useSqueezeShape: c10, uniformShape: c10 ? u10 : t10, keptDims: i10 };
      }
      function hSe(e10, t10) {
        var n10 = JSON.parse(JSON.stringify(e10));
        return n10.shapeInfo.logicalShape = t10, n10;
      }
      function pSe(e10, t10) {
        return t10.map(function(t11) {
          return e10[t11];
        }).join(", ");
      }
      function fSe(e10, t10, n10, r10) {
        var a10 = n10.map(function(e11, n11) {
          var r11 = { logicalShape: e11.shape, texShape: e11.isUniform ? null : e11.texData.texShape, isUniform: e11.isUniform, isPacked: !e11.isUniform && e11.texData.isPacked, flatOffset: null };
          return null != e11.texData && null != e11.texData.slice && e11.texData.slice.flatOffset > 0 && (r11.flatOffset = e11.texData.slice.flatOffset), { name: t10.variableNames[n11], shapeInfo: r11 };
        }), i10 = a10.map(function(e11) {
          return e11.shapeInfo;
        }), o10 = { logicalShape: r10.shape, texShape: r10.texData.texShape, isUniform: false, isPacked: r10.texData.isPacked, flatOffset: null }, s10 = HNe(a10, o10, t10), u10 = JIe(e10.gl, s10), c10 = e10.createProgram(u10);
        return k0().get("ENGINE_COMPILE_ONLY") ? { program: t10, fragmentShader: u10, source: s10, webGLProgram: c10, inShapeInfos: i10, outShapeInfo: o10, variablesLocations: null, customUniformLocations: null, infLoc: null, nanLoc: null, outShapeLocation: null, outShapeStridesLocation: null, outTexShapeLocation: null } : (e10.buildVao(c10), Object.assign({ program: t10, fragmentShader: u10, source: s10, webGLProgram: c10, inShapeInfos: i10, outShapeInfo: o10 }, dSe(e10, t10, c10)));
      }
      function dSe(e10, t10, n10) {
        var r10, a10, i10, o10, s10 = [], u10 = [], c10 = null;
        o10 = e10.getUniformLocation(n10, "NAN", false), 1 === k0().getNumber("WEBGL_VERSION") && (c10 = e10.getUniformLocation(n10, "INFINITY", false));
        var l10, h10 = false, p10 = O(t10.variableNames);
        try {
          for (p10.s(); !(l10 = p10.n()).done; ) {
            var f10 = l10.value, d10 = { name: f10, uniform: e10.getUniformLocation(n10, f10, h10), offset: e10.getUniformLocation(n10, "offset".concat(f10), h10) };
            t10.enableShapeUniforms && (d10.shape = e10.getUniformLocation(n10, "".concat(f10, "Shape"), h10), d10.texShape = e10.getUniformLocation(n10, "".concat(f10, "TexShape"), h10)), s10.push(d10);
          }
        } catch (e11) {
          p10.e(e11);
        } finally {
          p10.f();
        }
        if (t10.enableShapeUniforms && (r10 = e10.getUniformLocation(n10, "outShape", h10), i10 = e10.getUniformLocation(n10, "outShapeStrides", h10), a10 = e10.getUniformLocation(n10, "outTexShape", h10)), t10.customUniforms) {
          var v10, m10 = O(t10.customUniforms);
          try {
            for (m10.s(); !(v10 = m10.n()).done; ) {
              var g10 = v10.value;
              u10.push(e10.getUniformLocation(n10, g10.name, h10));
            }
          } catch (e11) {
            m10.e(e11);
          } finally {
            m10.f();
          }
        }
        return { variablesLocations: s10, customUniformLocations: u10, infLoc: c10, nanLoc: o10, outShapeLocation: r10, outShapeStridesLocation: i10, outTexShapeLocation: a10 };
      }
      function vSe(e10, t10) {
        if (e10.length !== t10.length) throw Error("Binary was compiled with ".concat(e10.length, " inputs, but ") + "was executed with ".concat(t10.length, " inputs"));
        e10.forEach(function(e11, n10) {
          var r10 = e11.logicalShape, a10 = t10[n10], i10 = a10.shape;
          if (!P$(r10, i10)) throw Error("Binary was compiled with different shapes than " + "the current args. Shapes ".concat(r10, " and ").concat(i10, " must match"));
          if (!e11.isUniform || !a10.isUniform) {
            var o10 = e11.texShape, s10 = a10.isUniform ? null : a10.texData.texShape;
            if (!P$(o10, s10)) throw Error("Binary was compiled with different texture shapes than the" + " current args. Shape ".concat(o10, " and ").concat(s10, " must match"));
          }
        });
      }
      function mSe(e10, t10, n10, r10, a10) {
        t10.program.enableShapeUniforms || (vSe(t10.inShapeInfos, n10), vSe([t10.outShapeInfo], [r10]));
        var i10 = r10.texData.texture, o10 = r10.texData.texShape;
        r10.texData.isPacked ? e10.setOutputPackedMatrixTexture(i10.texture, o10[0], o10[1]) : e10.setOutputMatrixTexture(i10.texture, o10[0], o10[1]), e10.setProgram(t10.webGLProgram), e10.bindVertexArray(t10.webGLProgram.vao), 1 === k0().getNumber("WEBGL_VERSION") && null !== t10.infLoc && e10.gl.uniform1f(t10.infLoc, 1 / 0), null !== t10.nanLoc && e10.gl.uniform1f(t10.nanLoc, NaN);
        for (var s10 = 0; s10 < n10.length; ++s10) {
          var u10 = n10[s10], c10 = t10.variablesLocations[s10], l10 = c10.uniform, h10 = c10.offset, p10 = c10.shape, f10 = c10.texShape;
          if (p10) {
            var d10 = lSe(t10.program.packedInputs, u10.shape, u10.texData.texShape).uniformShape;
            switch (d10.length) {
              case 1:
                e10.gl.uniform1iv(p10, new Int32Array(d10));
                break;
              case 2:
                e10.gl.uniform2iv(p10, new Int32Array(d10));
                break;
              case 3:
                e10.gl.uniform3iv(p10, new Int32Array(d10));
                break;
              case 4:
                e10.gl.uniform4iv(p10, new Int32Array(d10));
            }
          }
          if (f10 && e10.gl.uniform2i(f10, u10.texData.texShape[0], u10.texData.texShape[1]), null != l10) if (u10.isUniform) if (L$(u10.shape) < 2) e10.gl.uniform1f(l10, u10.uniformValues[0]);
          else {
            var v10 = u10.uniformValues;
            v10 instanceof Float32Array || (v10 = new Float32Array(v10)), e10.gl.uniform1fv(l10, v10);
          }
          else null != u10.texData.slice && null != h10 && e10.gl.uniform1i(h10, u10.texData.slice.flatOffset), e10.setInputMatrixTexture(u10.texData.texture.texture, l10, s10);
        }
        var m10 = t10.outShapeLocation;
        if (m10) switch (r10.shape.length) {
          case 1:
            e10.gl.uniform1iv(m10, new Int32Array(r10.shape));
            break;
          case 2:
            e10.gl.uniform2iv(m10, new Int32Array(r10.shape));
            break;
          case 3:
            e10.gl.uniform3iv(m10, new Int32Array(r10.shape));
            break;
          case 4:
            e10.gl.uniform4iv(m10, new Int32Array(r10.shape));
        }
        if (t10.outShapeStridesLocation) {
          var g10 = i0(r10.shape);
          switch (r10.shape.length) {
            case 2:
              e10.gl.uniform1iv(t10.outShapeStridesLocation, new Int32Array(g10));
              break;
            case 3:
              e10.gl.uniform2iv(t10.outShapeStridesLocation, new Int32Array(g10));
              break;
            case 4:
              e10.gl.uniform3iv(t10.outShapeStridesLocation, new Int32Array(g10));
          }
        }
        if (t10.outTexShapeLocation && e10.gl.uniform2i(t10.outTexShapeLocation, r10.texData.texShape[0], r10.texData.texShape[1]), t10.program.customUniforms && a10) for (var y10 = 0; y10 < t10.program.customUniforms.length; ++y10) {
          var b10 = t10.program.customUniforms[y10], x10 = t10.customUniformLocations[y10], k10 = a10[y10];
          if ("float" === b10.type) e10.gl.uniform1fv(x10, k10);
          else if ("vec2" === b10.type) e10.gl.uniform2fv(x10, k10);
          else if ("vec3" === b10.type) e10.gl.uniform3fv(x10, k10);
          else if ("vec4" === b10.type) e10.gl.uniform4fv(x10, k10);
          else if ("int" === b10.type) e10.gl.uniform1iv(x10, k10);
          else if ("ivec2" === b10.type) e10.gl.uniform2iv(x10, k10);
          else if ("ivec3" === b10.type) e10.gl.uniform3iv(x10, k10);
          else {
            if ("ivec4" !== b10.type) throw Error("uniform type ".concat(b10.type, " is not supported yet."));
            e10.gl.uniform4iv(x10, k10);
          }
        }
        e10.executeProgram();
      }
      function gSe(e10, t10, n10) {
        var r10 = "";
        t10.concat(n10).forEach(function(t11) {
          var a11 = null != t11.texData && null != t11.texData.slice && t11.texData.slice.flatOffset > 0;
          if (e10.enableShapeUniforms && !t11.isUniform) {
            var i11 = t11.texData.texShape, o10 = lSe(e10.packedInputs, t11.shape, i11), s10 = o10.useSqueezeShape, u10 = o10.uniformShape, c10 = o10.keptDims, l10 = "", h10 = "", p10 = "";
            if (1 === u10.length && e10.packedInputs) {
              var f10 = [Math.ceil(i11[0] / 2), Math.ceil(i11[1] / 2)];
              l10 = "".concat(f10[0] > 1, "_").concat(f10[1] > 1);
            } else if (2 !== u10.length || e10.packedInputs) {
              if (u10.length > 2 && !e10.packedInputs) {
                var d10 = i0(u10);
                p10 = "".concat(d10[0] === i11[1], "_").concat(d10[d10.length - 1] === i11[1]);
              }
            } else h10 = "".concat(u10[0] > 1, "_").concat(u10[1] > 1);
            var v10 = t11.shape.length, m10 = 2 === u10.length && P$(t11.shape, i11), g10 = 1 === L$(t11.shape), y10 = M7(t11.shape, n10.shape), b10 = !e10.packedInputs && v10 === n10.shape.length && P$(i11, n10.texData.texShape), x10 = e10.packedInputs || u10.length > 2 ? "" : "".concat(i11[0] > 1, "_").concat(i11[1] > 1);
            r10 += "".concat(v10, "_").concat(b10, "_").concat(s10 ? c10 : "", "_").concat(u10.length, "_").concat(g10, "_").concat(y10, "_").concat(m10, "_").concat(l10, "_").concat(h10, "_").concat(p10, "_").concat(x10, "_").concat(a11);
          } else {
            var k10 = t11.isUniform ? "uniform" : t11.texData.texShape;
            r10 += "".concat(t11.shape, "_").concat(k10, "_").concat(a11);
          }
        });
        var a10 = e10.userCode, i10 = e10.constructor.name;
        return i10 += "_" + r10 + "_" + a10 + "".concat(k0().getNumber("WEBGL_VERSION"));
      }
      function ySe(e10) {
        return k0().getBool("WEBGL_USE_SHAPES_UNIFORMS") && e10 <= 4;
      }
      var bSe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outPackingScheme = DIe.DENSE, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
        var n10 = PNe();
        this.outputShape = t10, this.enableShapeUniforms = ySe(this.outputShape.length), this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms ? WNe(["r", "c", "d"], t10) : BNe(["r", "c", "d"], t10), "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(n10.output, " = result;\n      }\n    ");
      }), xSe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outPackingScheme = DIe.DENSE, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
        var n10 = PNe();
        this.outputShape = t10, this.enableShapeUniforms = ySe(this.outputShape.length), this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms ? WNe(["r", "c", "d"], t10) : BNe(["r", "c", "d"], t10), "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(n10.output, " = result;\n      }\n    ");
      }), kSe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["A"], this.outTexUsage = MIe.DOWNLOAD;
        var n10 = PNe();
        this.outputShape = t10, this.userCode = "\n      ".concat(GNe, "\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(n10.output, " = encode_float(x);\n      }\n    ");
      }), wSe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outTexUsage = MIe.DOWNLOAD;
        var n10 = PNe();
        this.outputShape = t10, this.userCode = "\n      ".concat(GNe, "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(n10.output, " = encode_float(x);\n      }\n    ");
      }), ISe = { R: 0, G: 1, B: 2, A: 3 }, NSe = p(function e10(t10) {
        var n10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "RGBA";
        l(this, e10), this.variableNames = ["A"], this.customUniforms = [{ name: "texShape", type: "ivec2" }];
        var a10 = PNe();
        this.outputShape = t10, this.enableShapeUniforms = ySe(this.outputShape.length);
        var i10 = "result";
        n10 && (i10 = "floor(result * 255. + 0.5)");
        for (var o10 = "", s10 = 0; s10 < r10.length; s10++) {
          var u10 = r10[s10];
          o10 += "\n          if(offset == ".concat(s10, ") {\n            result = values[").concat(ISe[u10], "];\n          }");
        }
        this.userCode = "\n      ".concat(this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : VNe(t10), "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(r10.length, ");\n\n        flatIndex = idiv(flatIndex, ").concat(r10.length, ", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(a10.texture2D, "(A, uv);\n          ").concat(o10, "\n        }\n        ").concat(a10.output, " = vec4(").concat(i10, ", 0., 0., 0.);\n      }\n    ");
      }), SSe = p(function e10(t10) {
        var n10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        l(this, e10), this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
        var r10 = PNe();
        this.outputShape = t10, this.enableShapeUniforms = ySe(this.outputShape.length);
        var a10 = "", i10 = "result";
        n10 && (i10 = "floor(result * 255. + 0.5)");
        for (var o10 = 0; o10 <= 1; o10++) for (var s10 = 0; s10 <= 1; s10++) {
          var u10 = 2 * o10 + s10;
          a10 += "\n          localCoords = coords;\n          if(localCoords[2] + ".concat(s10, " < ").concat(this.enableShapeUniforms ? "outShape[2]" : "".concat(t10[2]), ") {\n          localCoords[2] += ").concat(s10, ";\n          if (localCoords[1] + ").concat(o10, " < ").concat(this.enableShapeUniforms ? "outShape[1]" : "".concat(t10[1]), ") {\n            localCoords[1] += ").concat(o10, ";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(r10.texture2D, "(A, uv);\n\n            if (offset == 0) {\n              result[").concat(u10, "] = values[0];\n            } else if (offset == 1) {\n              result[").concat(u10, "] = values[1];\n            } else if (offset == 2) {\n              result[").concat(u10, "] = values[2];\n            } else {\n              result[").concat(u10, "] = values[3];\n            }\n          }\n        }\n        ");
        }
        this.userCode = "\n        ".concat(this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : VNe(t10), "\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(a10, "\n\n          ").concat(r10.output, " = ").concat(i10, ";\n        }\n    ");
      });
      function TSe(e10) {
        var t10 = PNe();
        return YIe(e10, "".concat(t10.version, "\n    precision highp float;\n    ").concat(t10.attribute, " vec3 clipSpacePos;\n    ").concat(t10.attribute, " vec2 uv;\n    ").concat(t10.varyingVs, " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"));
      }
      function ESe(e10) {
        return aNe(e10, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
      }
      function CSe(e10) {
        return iNe(e10, new Uint16Array([0, 1, 2, 2, 1, 3]));
      }
      function ASe(e10, t10, n10, r10, a10, i10) {
        sNe(t10, n10);
        var o10 = oNe(e10), s10 = e10.TEXTURE_2D;
        return HIe(e10, function() {
          return e10.bindTexture(s10, o10);
        }), HIe(e10, function() {
          return e10.texParameteri(s10, e10.TEXTURE_WRAP_S, e10.CLAMP_TO_EDGE);
        }), HIe(e10, function() {
          return e10.texParameteri(s10, e10.TEXTURE_WRAP_T, e10.CLAMP_TO_EDGE);
        }), HIe(e10, function() {
          return e10.texParameteri(s10, e10.TEXTURE_MIN_FILTER, e10.NEAREST);
        }), HIe(e10, function() {
          return e10.texParameteri(s10, e10.TEXTURE_MAG_FILTER, e10.NEAREST);
        }), 1 === k0().getNumber("WEBGL_VERSION") ? HIe(e10, function() {
          return e10.texImage2D(s10, 0, r10, t10, n10, 0, a10, i10, null);
        }) : HIe(e10, function() {
          return e10.texStorage2D(s10, 1, r10, t10, n10);
        }), HIe(e10, function() {
          return e10.bindTexture(e10.TEXTURE_2D, null);
        }), { texture: o10, texShape: [n10, t10] };
      }
      function RSe(e10) {
        return e10.internalFormatFloat;
      }
      function _Se(e10, t10, n10, r10) {
        var a10 = S(UIe(t10, n10), 2);
        return ASe(e10, a10[0], a10[1], RSe(r10), r10.textureFormatFloat, e10.FLOAT);
      }
      function OSe(e10) {
        return e10.internalFormatHalfFloat;
      }
      function FSe(e10, t10, n10, r10) {
        var a10 = S(UIe(t10, n10), 2);
        return ASe(e10, a10[0], a10[1], OSe(r10), r10.textureFormatFloat, r10.textureTypeHalfFloat);
      }
      function DSe(e10) {
        return e10.downloadTextureFormat;
      }
      function MSe(e10, t10, n10, r10) {
        var a10 = S(UIe(t10, n10), 2);
        return ASe(e10, a10[0], a10[1], DSe(r10), e10.RGBA, e10.UNSIGNED_BYTE);
      }
      function LSe(e10) {
        return e10.internalFormatPackedFloat;
      }
      function zSe(e10, t10, n10, r10) {
        var a10 = S(GIe(t10, n10), 2);
        return ASe(e10, a10[0], a10[1], LSe(r10), e10.RGBA, e10.FLOAT);
      }
      function PSe(e10) {
        return e10.internalFormatPackedHalfFloat;
      }
      function BSe(e10, t10, n10, r10) {
        var a10 = S(GIe(t10, n10), 2);
        return ASe(e10, a10[0], a10[1], PSe(r10), e10.RGBA, r10.textureTypeHalfFloat);
      }
      function WSe(e10, t10, n10) {
        return HIe(e10, function() {
          return e10.bindBuffer(e10.ARRAY_BUFFER, n10);
        }), cNe(e10, t10, "clipSpacePos", n10, 3, 20, 0) && cNe(e10, t10, "uv", n10, 2, 20, 12);
      }
      function USe(e10, t10, n10, r10, a10, i10) {
        var o10, s10, u10;
        HIe(e10, function() {
          return e10.bindTexture(e10.TEXTURE_2D, t10);
        }), a10 instanceof Uint8Array ? (o10 = new Uint8Array(n10 * r10 * 4), s10 = e10.UNSIGNED_BYTE, u10 = e10.RGBA) : (o10 = new Float32Array(n10 * r10 * 4), s10 = e10.FLOAT, u10 = i10.internalFormatPackedFloat), o10.set(a10), 2 === k0().getNumber("WEBGL_VERSION") ? HIe(e10, function() {
          return e10.texSubImage2D(e10.TEXTURE_2D, 0, 0, 0, n10, r10, e10.RGBA, s10, o10);
        }) : HIe(e10, function() {
          return e10.texImage2D(e10.TEXTURE_2D, 0, u10, n10, r10, 0, e10.RGBA, s10, o10);
        }), HIe(e10, function() {
          return e10.bindTexture(e10.TEXTURE_2D, null);
        });
      }
      function VSe(e10, t10, n10) {
        HIe(e10, function() {
          return e10.bindTexture(e10.TEXTURE_2D, t10);
        }), n10.data instanceof Uint8Array ? 2 === k0().getNumber("WEBGL_VERSION") ? HIe(e10, function() {
          return e10.texSubImage2D(e10.TEXTURE_2D, 0, 0, 0, n10.width, n10.height, e10.RGBA, e10.UNSIGNED_BYTE, n10.data);
        }) : HIe(e10, function() {
          return e10.texImage2D(e10.TEXTURE_2D, 0, e10.RGBA, n10.width, n10.height, 0, e10.RGBA, e10.UNSIGNED_BYTE, n10.data);
        }) : 2 === k0().getNumber("WEBGL_VERSION") ? HIe(e10, function() {
          return e10.texSubImage2D(e10.TEXTURE_2D, 0, 0, 0, e10.RGBA, e10.UNSIGNED_BYTE, n10);
        }) : HIe(e10, function() {
          return e10.texImage2D(e10.TEXTURE_2D, 0, e10.RGBA, e10.RGBA, e10.UNSIGNED_BYTE, n10);
        }), HIe(e10, function() {
          return e10.bindTexture(e10.TEXTURE_2D, null);
        });
      }
      function GSe(e10, t10, n10, r10) {
        var a10 = e10.createBuffer();
        HIe(e10, function() {
          return e10.bindBuffer(e10.PIXEL_PACK_BUFFER, a10);
        });
        var i10 = 16 * t10 * n10;
        return HIe(e10, function() {
          return e10.bufferData(e10.PIXEL_PACK_BUFFER, i10, e10.STREAM_READ);
        }), HIe(e10, function() {
          return e10.readPixels(0, 0, n10, t10, e10.RGBA, e10.FLOAT, 0);
        }), HIe(e10, function() {
          return e10.bindBuffer(e10.PIXEL_PACK_BUFFER, null);
        }), a10;
      }
      function jSe(e10, t10, n10) {
        var r10 = e10, a10 = new Float32Array(n10);
        return r10.bindBuffer(r10.PIXEL_PACK_BUFFER, t10), r10.getBufferSubData(r10.PIXEL_PACK_BUFFER, 0, a10), r10.bindBuffer(r10.PIXEL_PACK_BUFFER, null), a10;
      }
      function HSe(e10, t10, n10, r10) {
        var a10 = S(UIe(t10, n10), 2), i10 = a10[0], o10 = a10[1], s10 = new Uint8Array(t10 * n10 * 4);
        return HIe(e10, function() {
          return e10.readPixels(0, 0, i10, o10, r10.downloadTextureFormat, e10.UNSIGNED_BYTE, s10);
        }), new Float32Array(s10.buffer);
      }
      function qSe(e10, t10, n10, r10, a10, i10, o10, s10) {
        var u10 = e10, c10 = new Float32Array(function(e11, t11) {
          var n11 = S(GIe(e11, t11), 2);
          return n11[0] * n11[1] * 4;
        }(i10, o10));
        return u10.bindBuffer(u10.PIXEL_PACK_BUFFER, t10), u10.getBufferSubData(u10.PIXEL_PACK_BUFFER, 0, c10), u10.bindBuffer(u10.PIXEL_PACK_BUFFER, null), c10;
      }
      function KSe(e10, t10, n10) {
        var r10 = new Float32Array(t10 * n10 * 4);
        return HIe(e10, function() {
          return e10.readPixels(0, 0, n10, t10, e10.RGBA, e10.FLOAT, r10);
        }), r10;
      }
      var XSe = { __proto__: null, bindVertexProgramAttributeStreams: WSe, createBufferFromOutputTexture: GSe, createFloat16MatrixTexture: FSe, createFloat16PackedMatrixTexture: BSe, createFloat32MatrixTexture: _Se, createIndexBuffer: CSe, createPackedMatrixTexture: zSe, createUnsignedBytesMatrixTexture: MSe, createVertexBuffer: ESe, createVertexShader: TSe, downloadByteEncodedFloatMatrixFromOutputTexture: HSe, downloadFloat32MatrixFromBuffer: jSe, downloadMatrixFromPackedOutputTexture: KSe, downloadPackedMatrixFromBuffer: qSe, getInternalFormatForFloat16MatrixTexture: OSe, getInternalFormatForFloat16PackedMatrixTexture: PSe, getInternalFormatForFloat32MatrixTexture: RSe, getInternalFormatForPackedMatrixTexture: LSe, getInternalFormatForUnsignedBytesMatrixTexture: DSe, uploadDenseMatrixToTexture: USe, uploadPixelDataToTexture: VSe }, YSe = function() {
        function e10(t11) {
          l(this, e10), this.outputTexture = null, this.program = null, this.disposed = false, this.itemsToPoll = [];
          var n10 = k0().getNumber("WEBGL_VERSION");
          if (null != t11 ? (this.gl = t11, BIe(n10, t11)) : this.gl = WIe(n10), t11 = this.gl, 2 === k0().getNumber("WEBGL_VERSION")) {
            var r10 = t11;
            this.createVertexArray = function() {
              return HIe(r10, function() {
                return r10.createVertexArray();
              });
            }, this.bindVertexArray = function(e11) {
              return HIe(r10, function() {
                return r10.bindVertexArray(e11);
              });
            }, this.deleteVertexArray = function(e11) {
              return HIe(r10, function() {
                return r10.deleteVertexArray(e11);
              });
            }, this.getVertexArray = function() {
              return HIe(r10, function() {
                return r10.getParameter(r10.VERTEX_ARRAY_BINDING);
              });
            };
          } else if (null != t11) {
            var a10 = t11.getExtension("OES_vertex_array_object");
            if (null == a10) throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
            this.createVertexArray = function() {
              return HIe(t11, function() {
                return a10.createVertexArrayOES();
              });
            }, this.bindVertexArray = function(e11) {
              return HIe(t11, function() {
                return a10.bindVertexArrayOES(e11);
              });
            }, this.deleteVertexArray = function(e11) {
              return HIe(t11, function() {
                return a10.deleteVertexArrayOES(e11);
              });
            }, this.getVertexArray = function() {
              return HIe(t11, function() {
                return t11.getParameter(a10.VERTEX_ARRAY_BINDING_OES);
              });
            };
          }
          var i10 = "WEBGL_color_buffer_float", o10 = "EXT_color_buffer_half_float";
          if (this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile"), 1 === k0().getNumber("WEBGL_VERSION")) {
            var s10 = "OES_texture_half_float";
            if (this.textureFloatExtension = XIe(this.gl, "OES_texture_float"), ANe(this.gl, s10)) this.textureHalfFloatExtension = XIe(this.gl, s10);
            else if (k0().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
            if (this.colorBufferFloatExtension = this.gl.getExtension(i10), ANe(this.gl, o10)) this.colorBufferHalfFloatExtension = XIe(this.gl, o10);
            else if (k0().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
          } else if (i10 = "EXT_color_buffer_float", ANe(this.gl, i10)) this.colorBufferFloatExtension = this.gl.getExtension(i10);
          else {
            if (!ANe(this.gl, o10)) throw new Error("GL context does not support color renderable floats");
            this.colorBufferHalfFloatExtension = this.gl.getExtension(o10);
          }
          this.vertexBuffer = ESe(this.gl), this.indexBuffer = CSe(this.gl), this.framebuffer = uNe(this.gl), this.textureConfig = jIe(this.gl, this.textureHalfFloatExtension);
        }
        var t10;
        return p(e10, [{ key: "debug", get: function() {
          return k0().getBool("DEBUG");
        } }, { key: "dispose", value: function() {
          var e11 = this;
          if (!this.disposed) {
            null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
            var t11 = this.gl;
            HIe(t11, function() {
              return t11.finish();
            }), HIe(t11, function() {
              return t11.bindFramebuffer(t11.FRAMEBUFFER, null);
            }), HIe(t11, function() {
              return t11.deleteFramebuffer(e11.framebuffer);
            }), HIe(t11, function() {
              return t11.bindBuffer(t11.ARRAY_BUFFER, null);
            }), HIe(t11, function() {
              return t11.bindBuffer(t11.ELEMENT_ARRAY_BUFFER, null);
            }), HIe(t11, function() {
              return t11.deleteBuffer(e11.indexBuffer);
            }), this.disposed = true;
          }
        } }, { key: "createFloat32MatrixTexture", value: function(e11, t11) {
          return this.throwIfDisposed(), _Se(this.gl, e11, t11, this.textureConfig);
        } }, { key: "createFloat16MatrixTexture", value: function(e11, t11) {
          return this.throwIfDisposed(), FSe(this.gl, e11, t11, this.textureConfig);
        } }, { key: "createUnsignedBytesMatrixTexture", value: function(e11, t11) {
          return this.throwIfDisposed(), MSe(this.gl, e11, t11, this.textureConfig);
        } }, { key: "uploadPixelDataToTexture", value: function(e11, t11) {
          this.throwIfDisposed(), VSe(this.gl, e11, t11);
        } }, { key: "uploadDenseMatrixToTexture", value: function(e11, t11, n10, r10) {
          this.throwIfDisposed(), USe(this.gl, e11, t11, n10, r10, this.textureConfig);
        } }, { key: "createFloat16PackedMatrixTexture", value: function(e11, t11) {
          return this.throwIfDisposed(), BSe(this.gl, e11, t11, this.textureConfig);
        } }, { key: "createPackedMatrixTexture", value: function(e11, t11) {
          return this.throwIfDisposed(), zSe(this.gl, e11, t11, this.textureConfig);
        } }, { key: "deleteMatrixTexture", value: function(e11) {
          var t11 = this;
          this.throwIfDisposed(), this.outputTexture === e11 && (vNe(this.gl, this.framebuffer), this.outputTexture = null), HIe(this.gl, function() {
            return t11.gl.deleteTexture(e11);
          });
        } }, { key: "downloadByteEncodedFloatMatrixFromOutputTexture", value: function(e11, t11, n10) {
          var r10 = this;
          return this.downloadMatrixDriver(e11, function() {
            return HSe(r10.gl, t11, n10, r10.textureConfig);
          });
        } }, { key: "downloadPackedMatrixFromBuffer", value: function(e11, t11, n10, r10, a10, i10) {
          return qSe(this.gl, e11, 0, 0, 0, a10, i10, this.textureConfig);
        } }, { key: "downloadFloat32MatrixFromBuffer", value: function(e11, t11) {
          return jSe(this.gl, e11, t11);
        } }, { key: "createBufferFromTexture", value: function(e11, t11, n10) {
          this.bindTextureToFrameBuffer(e11);
          var r10 = GSe(this.gl, t11, n10, this.textureConfig);
          return this.unbindTextureToFrameBuffer(), r10;
        } }, { key: "createAndWaitForFence", value: function() {
          var e11 = this.createFence(this.gl);
          return this.pollFence(e11);
        } }, { key: "createFence", value: function(e11) {
          var t11, n10, r10 = this;
          if (k0().getBool("WEBGL_FENCE_API_ENABLED")) {
            var a10 = e11, i10 = a10.fenceSync(a10.SYNC_GPU_COMMANDS_COMPLETE, 0);
            e11.flush(), n10 = function() {
              var e12 = a10.clientWaitSync(i10, 0, 0);
              return e12 === a10.ALREADY_SIGNALED || e12 === a10.CONDITION_SATISFIED;
            }, t11 = i10;
          } else k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (t11 = this.beginQuery(), this.endQuery(), n10 = function() {
            return r10.isQueryAvailable(t11, k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
          }) : n10 = function() {
            return true;
          };
          return { query: t11, isFencePassed: n10 };
        } }, { key: "downloadMatrixFromPackedTexture", value: function(e11, t11, n10) {
          var r10 = this;
          return this.downloadMatrixDriver(e11, function() {
            return KSe(r10.gl, t11, n10);
          });
        } }, { key: "createProgram", value: function(e11) {
          var t11 = this;
          this.throwIfDisposed();
          var n10 = this.gl;
          null == this.vertexShader && (this.vertexShader = TSe(n10));
          var r10 = tNe(n10);
          HIe(n10, function() {
            return n10.attachShader(r10, t11.vertexShader);
          }), HIe(n10, function() {
            return n10.attachShader(r10, e11);
          }), nNe(n10, r10);
          var a10 = Object.assign(r10, { vao: this.createVertexArray() });
          return this.debug && rNe(n10, a10), a10;
        } }, { key: "buildVao", value: function(e11) {
          var t11 = this;
          this.setProgram(e11), this.bindVertexArray(e11.vao);
          var n10 = this.gl;
          HIe(n10, function() {
            return n10.bindBuffer(n10.ELEMENT_ARRAY_BUFFER, t11.indexBuffer);
          }), WSe(n10, e11, this.vertexBuffer);
        } }, { key: "deleteProgram", value: function(e11) {
          var t11 = this;
          this.throwIfDisposed(), e11 === this.program && (this.program = null), null != e11 && (HIe(this.gl, function() {
            return t11.gl.deleteProgram(e11);
          }), this.deleteVertexArray(e11.vao));
        } }, { key: "setProgram", value: function(e11) {
          var t11 = this;
          this.throwIfDisposed(), this.program = e11, null != this.program && this.debug && rNe(this.gl, this.program), HIe(this.gl, function() {
            return t11.gl.useProgram(e11);
          });
        } }, { key: "getUniformLocation", value: function(e11, t11) {
          var n10 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
          return this.throwIfDisposed(), n10 ? hNe(this.gl, e11, t11) : pNe(this.gl, e11, t11);
        } }, { key: "getAttributeLocation", value: function(e11, t11) {
          var n10 = this;
          return this.throwIfDisposed(), HIe(this.gl, function() {
            return n10.gl.getAttribLocation(e11, t11);
          });
        } }, { key: "getUniformLocationNoThrow", value: function(e11, t11) {
          return this.throwIfDisposed(), this.gl.getUniformLocation(e11, t11);
        } }, { key: "setInputMatrixTexture", value: function(e11, t11, n10) {
          this.throwIfDisposed(), this.throwIfNoProgram(), fNe(this.gl, e11, t11, n10);
        } }, { key: "setOutputMatrixTexture", value: function(e11, t11, n10) {
          this.setOutputMatrixTextureDriver(e11, n10, t11);
        } }, { key: "setOutputPackedMatrixTexture", value: function(e11, t11, n10) {
          this.throwIfDisposed();
          var r10 = S(GIe(t11, n10), 2), a10 = r10[0], i10 = r10[1];
          this.setOutputMatrixTextureDriver(e11, a10, i10);
        } }, { key: "setOutputMatrixWriteRegion", value: function(e11, t11, n10, r10) {
          this.setOutputMatrixWriteRegionDriver(n10, e11, r10, t11);
        } }, { key: "setOutputPackedMatrixWriteRegion", value: function(e11, t11, n10, r10) {
          throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
        } }, { key: "debugValidate", value: function() {
          null != this.program && rNe(this.gl, this.program), mNe(this.gl);
        } }, { key: "executeProgram", value: function() {
          this.throwIfDisposed(), this.throwIfNoProgram();
          var e11 = this.gl;
          if (this.debug) {
            var t11 = this.getVertexArray();
            console.assert(t11 === this.program.vao, "VAO changed between setProgram and executeProgram!"), this.debugValidate();
          }
          HIe(e11, function() {
            return e11.drawElements(e11.TRIANGLES, 6, e11.UNSIGNED_SHORT, 0);
          });
        } }, { key: "blockUntilAllProgramsCompleted", value: function() {
          var e11 = this;
          this.throwIfDisposed(), HIe(this.gl, function() {
            return e11.gl.finish();
          });
        } }, { key: "getQueryTimerExtension", value: function() {
          return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = XIe(this.gl, 2 === k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
        } }, { key: "getQueryTimerExtensionWebGL2", value: function() {
          return this.getQueryTimerExtension();
        } }, { key: "getQueryTimerExtensionWebGL1", value: function() {
          return this.getQueryTimerExtension();
        } }, { key: "beginQuery", value: function() {
          if (2 === k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
            var e11 = this.gl, t11 = this.getQueryTimerExtensionWebGL2(), n10 = e11.createQuery();
            return e11.beginQuery(t11.TIME_ELAPSED_EXT, n10), n10;
          }
          var r10 = this.getQueryTimerExtensionWebGL1(), a10 = r10.createQueryEXT();
          return r10.beginQueryEXT(r10.TIME_ELAPSED_EXT, a10), a10;
        } }, { key: "endQuery", value: function() {
          if (2 !== k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
            var e11 = this.getQueryTimerExtensionWebGL1();
            e11.endQueryEXT(e11.TIME_ELAPSED_EXT);
          } else {
            var t11 = this.gl, n10 = this.getQueryTimerExtensionWebGL2();
            t11.endQuery(n10.TIME_ELAPSED_EXT);
          }
        } }, { key: "waitForQueryAndGetTime", value: (t10 = c(o().mark(function e11(t11) {
          var n10 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                return e12.next = 2, V$(function() {
                  return n10.disposed || n10.isQueryAvailable(t11, k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
                });
              case 2:
                return e12.abrupt("return", this.getQueryTime(t11, k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")));
              case 3:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "getQueryTime", value: function(e11, t11) {
          if (0 === t11) return null;
          if (2 === t11) {
            var n10 = this.gl;
            return n10.getQueryParameter(e11, n10.QUERY_RESULT) / 1e6;
          }
          var r10 = this.getQueryTimerExtensionWebGL1();
          return r10.getQueryObjectEXT(e11, r10.QUERY_RESULT_EXT) / 1e6;
        } }, { key: "isQueryAvailable", value: function(e11, t11) {
          if (0 === t11) return true;
          if (2 === t11) {
            var n10 = this.gl, r10 = this.getQueryTimerExtensionWebGL2(), a10 = n10.getQueryParameter(e11, n10.QUERY_RESULT_AVAILABLE);
            return null == this.disjoint && (this.disjoint = this.gl.getParameter(r10.GPU_DISJOINT_EXT)), a10 && !this.disjoint;
          }
          var i10 = this.getQueryTimerExtensionWebGL1(), o10 = i10.getQueryObjectEXT(e11, i10.QUERY_RESULT_AVAILABLE_EXT);
          return null == this.disjoint && (this.disjoint = this.gl.getParameter(i10.GPU_DISJOINT_EXT)), o10 && !this.disjoint;
        } }, { key: "pollFence", value: function(e11) {
          var t11 = this;
          return new Promise(function(n10) {
            t11.addItemToPoll(function() {
              return e11.isFencePassed();
            }, function() {
              return n10();
            });
          });
        } }, { key: "pollItems", value: function() {
          for (var e11 = function(e12) {
            for (var t12 = 0; t12 < e12.length; ++t12) {
              if (!e12[t12]()) break;
            }
            return t12 - 1;
          }(this.itemsToPoll.map(function(e12) {
            return e12.isDoneFn;
          })), t11 = 0; t11 <= e11; ++t11) {
            (0, this.itemsToPoll[t11].resolveFn)();
          }
          this.itemsToPoll = this.itemsToPoll.slice(e11 + 1);
        } }, { key: "addItemToPoll", value: function(e11, t11) {
          var n10 = this;
          if (this.itemsToPoll.push({ isDoneFn: e11, resolveFn: t11 }), !(this.itemsToPoll.length > 1)) {
            var r10 = void 0;
            "setTimeoutCustom" in k0().platform && (r10 = k0().platform.setTimeoutCustom.bind(k0().platform)), V$(function() {
              return n10.pollItems(), 0 === n10.itemsToPoll.length;
            }, function() {
              return 0;
            }, null, r10);
          }
        } }, { key: "bindTextureToFrameBuffer", value: function(e11) {
          this.throwIfDisposed(), dNe(this.gl, e11, this.framebuffer), this.debug && mNe(this.gl);
        } }, { key: "unbindTextureToFrameBuffer", value: function() {
          null != this.outputTexture ? (dNe(this.gl, this.outputTexture, this.framebuffer), this.debug && mNe(this.gl)) : vNe(this.gl, this.framebuffer);
        } }, { key: "downloadMatrixDriver", value: function(e11, t11) {
          this.bindTextureToFrameBuffer(e11);
          var n10 = t11();
          return this.unbindTextureToFrameBuffer(), n10;
        } }, { key: "setOutputMatrixTextureDriver", value: function(e11, t11, n10) {
          this.throwIfDisposed();
          var r10 = this.gl;
          dNe(r10, e11, this.framebuffer), this.debug && mNe(r10), this.outputTexture = e11, HIe(r10, function() {
            return r10.viewport(0, 0, t11, n10);
          }), HIe(r10, function() {
            return r10.scissor(0, 0, t11, n10);
          });
        } }, { key: "setOutputMatrixWriteRegionDriver", value: function(e11, t11, n10, r10) {
          var a10 = this;
          this.throwIfDisposed(), HIe(this.gl, function() {
            return a10.gl.scissor(e11, t11, n10, r10);
          });
        } }, { key: "throwIfDisposed", value: function() {
          if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
        } }, { key: "throwIfNoProgram", value: function() {
          if (null == this.program) throw new Error("No GPU program is currently set.");
        } }]), e10;
      }();
      var JSe = Ige, ZSe = Ege, QSe = Cge, $Se = Age, eTe = yge, tTe = Mge, nTe = Pge, rTe = Bge, aTe = Vge, iTe = Hge, oTe = Xge, sTe = eye, uTe = tye, cTe = nye, lTe = iye, hTe = uye, pTe = hye, fTe = dye, dTe = vye, vTe = yye, mTe = bye, gTe = wye, yTe = Sye, bTe = Aye, xTe = _ye, kTe = zye, wTe = Vye, ITe = jye, NTe = Yye, STe = Jye, TTe = Zye, ETe = ebe, CTe = tbe, ATe = uge, RTe = abe, _Te = sbe, OTe = ube, FTe = cbe, DTe = lbe, MTe = mbe, LTe = bbe, zTe = kbe, PTe = Ibe, BTe = Nbe, WTe = Sbe, UTe = Abe, VTe = Obe, GTe = Dye, jTe = Fbe;
      function HTe(e10, t10) {
        return ["x", "y", "z", "w", "u", "v"].slice(0, t10).map(function(t11) {
          return "".concat(e10, ".").concat(t11);
        });
      }
      function qTe(e10, t10) {
        return 1 === t10 ? [e10] : HTe(e10, t10);
      }
      var KTe = function() {
        function e10(t10) {
          if (l(this, e10), this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outputShape = t10, this.rank = t10.length, this.enableShapeUniforms = ySe(this.outputShape.length), 0 === this.rank) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
          else {
            var n10 = qTe("rc", this.rank), r10 = cSe(this.rank), a10 = this.getOutOfBoundsCondition(n10), i10 = this.getSetup(n10), o10 = this.getOutput(n10);
            this.userCode = "\n        void main() {\n          ".concat(r10, " rc = getOutputCoords();\n\n          if(").concat(a10, ") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(i10, "\n\n            setOutput(vec4(").concat(o10, "));\n          }\n        }\n      ");
          }
        }
        return p(e10, [{ key: "getSourceCoordsArr", value: function(e11) {
          for (var t10 = [], n10 = 0; n10 <= 1; n10++) for (var r10 = 0; r10 <= 1; r10++) {
            for (var a10 = "".concat(0 === n10 ? "r" : "rp1", ", ").concat(0 === r10 ? "c" : "cp1"), i10 = 2; i10 < this.rank; i10++) a10 = "".concat(e11[e11.length - 1 - i10], ",") + a10;
            t10.push(a10);
          }
          return t10;
        } }, { key: "getOutOfBoundsCondition", value: function(e11) {
          if (1 === this.rank) return "rc > ".concat(this.enableShapeUniforms ? "outShape" : this.outputShape[0]);
          for (var t10 = "", n10 = this.rank - 2; n10 < this.rank; n10++) t10 += "".concat(e11[n10], " >= ").concat(this.enableShapeUniforms ? "outShape[".concat(n10, "]") : this.outputShape[n10]), n10 < this.rank - 1 && (t10 += "||");
          return t10;
        } }, { key: "getSetup", value: function(e11) {
          if (1 === this.rank) return "";
          var t10 = e11.slice(-2), n10 = this.enableShapeUniforms ? "outShape[".concat(this.rank, " - 1]") : this.outputShape[this.rank - 1], r10 = this.enableShapeUniforms ? "outShape[".concat(this.rank, " - 2]") : this.outputShape[this.rank - 2];
          return "\n      int r = ".concat(t10[0], ";\n      int c = ").concat(t10[1], ";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n10, ";\n      bool rEdge = rp1 >= ").concat(r10, ";\n    ");
        } }, { key: "getOutput", value: function(e11) {
          var t10 = this.getSourceCoordsArr(e11);
          if (1 === this.rank) {
            var n10 = this.enableShapeUniforms ? "outShape" : this.outputShape[0];
            return "getA(rc), (rc + 1 >= ".concat(n10, " ? 0. : getA(rc + 1)), 0, 0");
          }
          return "getA(".concat(t10[0], "),\n            cEdge ? 0. : getA(").concat(t10[1], "),\n            rEdge ? 0. : getA(").concat(t10[2], "),\n            rEdge || cEdge ? 0. : getA(").concat(t10[3], ")");
        } }]), e10;
      }(), XTe = p(function e10(t10, n10) {
        l(this, e10), this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "inputShape", type: "ivec3" }], this.outputShape = t10, this.enableShapeUniforms = ySe(this.outputShape.length);
        for (var r10, a10, i10, o10 = "", s10 = 0; s10 < 4; s10++) {
          var u10 = "thisRC = rc;";
          s10 % 2 == 1 && (u10 += "thisRC.z += 1;"), s10 > 1 && (u10 += "thisRC.y += 1;"), o10 += "\n        ".concat(u10, "\n        ").concat(s10 > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "", "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(s10, "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(s10 > 0 ? "}" : "", "\n      ");
        }
        this.userCode = "\n      ".concat((r10 = n10, a10 = this.enableShapeUniforms, i10 = a10 ? function(e11, t11) {
          var n11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "index", r11 = e11.map(function(e12, t12) {
            return t12;
          }), a11 = UNe(r11, t11);
          return a11.map(function(t12, r12) {
            var i11 = "int ".concat(e11[r12], " = ").concat(n11, " / ").concat(a11[r12]), o11 = r12 === a11.length - 1 ? "int ".concat(e11[r12 + 1], " = ").concat(n11, " - ").concat(e11[r12], " * ").concat(a11[r12]) : "index -= ".concat(e11[r12], " * ").concat(a11[r12]);
            return "".concat(i11, "; ").concat(o11, ";");
          }).join("");
        }(["r", "c", "d"], "inputShape") : BNe(["r", "c", "d"], r10), "\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(i10, "\n      return ivec3(r, c, d);\n    }\n  ")), "\n      ").concat(this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : VNe(t10), "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms ? "outShape[1]" : t10[1], ";\n        int cols = ").concat(this.enableShapeUniforms ? "outShape[2]" : t10[2], ";\n\n        ").concat(o10, "\n\n        setOutput(result);\n      }\n    ");
      });
      var YTe = function() {
        function e10(t10) {
          l(this, e10), this.gpgpu = t10, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.usedTextures = {}, this.logEnabled = false;
        }
        return p(e10, [{ key: "acquireTexture", value: function(e11, t10, n10) {
          var r10 = ZTe(t10, n10), a10 = QTe(e11, r10, n10);
          a10 in this.freeTextures || (this.freeTextures[a10] = []), a10 in this.usedTextures || (this.usedTextures[a10] = []);
          var i10, o10 = JTe(e11, r10, this.gpgpu.gl, this.gpgpu.textureConfig, n10);
          if (this.freeTextures[a10].length > 0) {
            this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= o10, this.log();
            var s10 = this.freeTextures[a10].pop();
            return this.usedTextures[a10].push(s10), s10;
          }
          return r10 === LIe.PACKED_2X2_FLOAT32 ? i10 = this.gpgpu.createPackedMatrixTexture(e11[0], e11[1]) : r10 === LIe.PACKED_2X2_FLOAT16 ? i10 = this.gpgpu.createFloat16PackedMatrixTexture(e11[0], e11[1]) : r10 === LIe.UNPACKED_FLOAT32 ? i10 = this.gpgpu.createFloat32MatrixTexture(e11[0], e11[1]) : r10 === LIe.UNPACKED_FLOAT16 ? i10 = this.gpgpu.createFloat16MatrixTexture(e11[0], e11[1]) : r10 === LIe.PACKED_4X1_UNSIGNED_BYTE && (i10 = this.gpgpu.createUnsignedBytesMatrixTexture(e11[0], e11[1])), this.usedTextures[a10].push(i10), this.numUsedTextures++, this._numBytesAllocated += o10, this.log(), i10;
        } }, { key: "releaseTexture", value: function(e11, t10, n10, r10) {
          if (null != this.freeTextures) {
            var a10 = ZTe(n10, r10), i10 = QTe(t10, a10, r10);
            i10 in this.freeTextures || (this.freeTextures[i10] = []);
            var o10 = JTe(t10, a10, this.gpgpu.gl, this.gpgpu.textureConfig, r10), s10 = k0().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");
            -1 !== s10 && this._numBytesAllocated > s10 ? (this.gpgpu.deleteMatrixTexture(e11.texture), this._numBytesAllocated -= o10) : (this.freeTextures[i10].push(e11), this.numFreeTextures++, this._numBytesFree += o10), this.numUsedTextures--;
            var u10 = this.usedTextures[i10], c10 = u10 && u10.indexOf(e11);
            if (null == c10 || c10 < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
            u10[c10] = u10[u10.length - 1], u10.pop(), this.log();
          }
        } }, { key: "log", value: function() {
          if (this.logEnabled) {
            var e11 = this.numFreeTextures + this.numUsedTextures;
            console.log("Free/Used", "".concat(this.numFreeTextures, " / ").concat(this.numUsedTextures), "(".concat(e11, ")"));
            var t10 = this._numBytesFree / this._numBytesAllocated;
            console.log("Bytes allocated: ".concat(this._numBytesAllocated)), console.log("Bytes unused: ".concat(this._numBytesFree, " (").concat(Math.round(100 * t10), "%)"));
          }
        } }, { key: "numBytesAllocated", get: function() {
          return this._numBytesAllocated;
        } }, { key: "numBytesFree", get: function() {
          return this._numBytesFree;
        } }, { key: "getNumUsedTextures", value: function() {
          return this.numUsedTextures;
        } }, { key: "getNumFreeTextures", value: function() {
          return this.numFreeTextures;
        } }, { key: "dispose", value: function() {
          var e11 = this;
          if (null != this.freeTextures) {
            for (var t10 in this.freeTextures) this.freeTextures[t10].forEach(function(t11) {
              e11.gpgpu.deleteMatrixTexture(t11.texture);
            });
            for (var n10 in this.usedTextures) this.usedTextures[n10].forEach(function(t11) {
              e11.gpgpu.deleteMatrixTexture(t11.texture);
            });
            this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0;
          }
        } }]), e10;
      }();
      function JTe(e10, t10, n10, r10, a10) {
        var i10, o10 = function(e11, t11) {
          switch (e11) {
            case LIe.PACKED_2X2_FLOAT32:
              return LSe(t11);
            case LIe.PACKED_2X2_FLOAT16:
              return PSe(t11);
            case LIe.UNPACKED_FLOAT32:
              return RSe(t11);
            case LIe.UNPACKED_FLOAT16:
              return OSe(t11);
            case LIe.PACKED_4X1_UNSIGNED_BYTE:
              return DSe(t11);
            default:
              throw new Error("Unknown physical texture type ".concat(e11));
          }
        }(t10, r10);
        if (a10) {
          var s10 = S(GIe(e10[0], e10[1]), 2);
          i10 = s10[0] * s10[1];
        } else {
          var u10 = S(UIe(e10[0], e10[1]), 2);
          i10 = u10[0] * u10[1];
        }
        var c10 = function(e11, t11) {
          var n11 = e11;
          if (t11 === n11.R32F) return 4;
          if (t11 === n11.R16F) return 2;
          if (t11 === n11.RGBA32F) return 16;
          if (t11 === e11.RGBA) return 16;
          if (t11 === n11.RGBA16F) return 8;
          if (t11 === n11.RGBA8) return 4;
          throw new Error("Unknown internal format ".concat(t11));
        }(n10, o10);
        return i10 * c10;
      }
      function ZTe(e10, t10) {
        if (e10 === MIe.UPLOAD) return LIe.PACKED_2X2_FLOAT32;
        if (e10 === MIe.RENDER || null == e10) return function(e11) {
          return k0().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? e11 ? LIe.PACKED_2X2_FLOAT32 : LIe.UNPACKED_FLOAT32 : e11 ? LIe.PACKED_2X2_FLOAT16 : LIe.UNPACKED_FLOAT16;
        }(t10);
        if (e10 === MIe.DOWNLOAD || e10 === MIe.PIXELS) return LIe.PACKED_4X1_UNSIGNED_BYTE;
        throw new Error("Unknown logical texture type ".concat(e10));
      }
      function QTe(e10, t10, n10) {
        return "".concat(e10[0], "_").concat(e10[1], "_").concat(t10, "_").concat(n10);
      }
      var $Te = p(function e10(t10, n10) {
        l(this, e10), this.variableNames = ["A"], this.outputShape = t10, this.enableShapeUniforms = ySe(this.outputShape.length), this.userCode = "\n      float unaryOperation(float x) {\n        ".concat(n10, "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ");
      }), eEe = "if (isnan(x)) return x;", tEe = "return x;", nEe = "return abs(x);";
      var rEe = "return (x >= 0.0) ? x : (exp(x) - 1.0);", aEe = eEe + "\n  return (x < 0.0) ? 0.0 : x;\n", iEe = eEe + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n", oEe = "return x;", sEe = "return 1.0 / (1.0 + exp(-1.0 * x));", uEe = "return x;", cEe = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n", lEe = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n", hEe = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n", pEe = "return 1.0 / (1.0 + exp(-1.0 * x));", fEe = p(function e10(t10, n10) {
        l(this, e10), this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t10, this.enableShapeUniforms = ySe(this.outputShape.length), this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        ".concat(n10, "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ");
      }), dEe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outputShape = t10, this.enableShapeUniforms = ySe(this.outputShape.length);
        var n10 = t10.length, r10 = qTe("rc", n10), a10 = cSe(n10), i10 = function(e11, t11) {
          if (1 === e11) return "rc";
          for (var n11 = "", r11 = 0; r11 < e11; r11++) n11 += t11[r11], r11 < e11 - 1 && (n11 += ",");
          return n11;
        }(n10, r10), o10 = r10.slice(-2), s10 = n10 <= 1 ? "rc" : "vec2(".concat(o10.join(","), ")");
        this.userCode = "\n      void main() {\n        ".concat(a10, " rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(i10, ");\n\n        setOutput(getChannel(packedInput, ").concat(s10, "));\n      }\n    ");
      }), vEe = one, mEe = {};
      var gEe = k0().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
      var yEe = function(e10) {
        d(s10, e10);
        var t10, n10, r10, a10, i10 = w(s10);
        function s10(e11) {
          var t11, n11, r11;
          if (l(this, s10), (t11 = i10.call(this)).pendingRead = /* @__PURE__ */ new WeakMap(), t11.pendingDisposal = /* @__PURE__ */ new WeakSet(), t11.dataRefCount = /* @__PURE__ */ new WeakMap(), t11.numBytesInGPU = 0, t11.uploadWaitMs = 0, t11.downloadWaitMs = 0, t11.lastGlFlushTime = 0, t11.warnedAboutMemory = false, t11.pendingDeletes = 0, t11.disposed = false, !k0().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
          if (null != e11) {
            if (e11 instanceof YSe) n11 = e11;
            else {
              var a11 = WIe(k0().getNumber("WEBGL_VERSION"), e11);
              n11 = new YSe(a11);
            }
            t11.binaryCache = {}, t11.gpgpuCreatedLocally = false;
          } else {
            var o10 = WIe(k0().getNumber("WEBGL_VERSION"));
            n11 = new YSe(o10), t11.binaryCache = ((r11 = k0().getNumber("WEBGL_VERSION")) in mEe || (mEe[r11] = {}), mEe[r11]), t11.gpgpuCreatedLocally = true;
          }
          return t11.gpgpu = n11, t11.canvas = t11.gpgpu.gl.canvas, t11.textureManager = new YTe(t11.gpgpu), t11.numMBBeforeWarning = null == k0().global.screen ? 1024 : k0().global.screen.height * k0().global.screen.width * window.devicePixelRatio * 600 / 1024 / 1024, t11.texData = new S$(x(t11), q5()), t11;
        }
        return p(s10, [{ key: "nextDataId", value: function() {
          return s10.nextDataId++;
        } }, { key: "numDataIds", value: function() {
          return this.texData.numDataIds() - this.pendingDeletes;
        } }, { key: "writeTexture", value: function(e11, t11, n11, r11, a11, i11) {
          var o10 = this.makeTensorInfo(t11, n11), s11 = this.texData.get(o10.dataId);
          s11.isPacked = false, s11.texture = { texture: e11, texShape: [r11, a11] }, s11.texShape = [r11, a11];
          var u10 = wNe(t11), c10 = new NSe(u10, false, i11), l10 = this.runWebGLProgram(c10, [o10], n11, [[r11, a11]]);
          return l10.shape = t11, s11.texture = null, this.disposeIntermediateTensorInfo(o10), l10.dataId;
        } }, { key: "write", value: function(e11, t11, n11) {
          if ((k0().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || k0().getBool("DEBUG")) && this.checkNumericalProblems(e11), "complex64" === n11 && null != e11) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
          var r11 = { id: this.nextDataId() };
          return this.texData.set(r11, { shape: t11, dtype: n11, values: e11, usage: MIe.UPLOAD, refCount: 1 }), r11;
        } }, { key: "refCount", value: function(e11) {
          return this.texData.has(e11) ? this.texData.get(e11).refCount : 0;
        } }, { key: "incRef", value: function(e11) {
          this.texData.get(e11).refCount++;
        } }, { key: "decRef", value: function(e11) {
          this.texData.has(e11) && this.texData.get(e11).refCount--;
        } }, { key: "move", value: function(e11, t11, n11, r11, a11) {
          if (k0().getBool("DEBUG") && this.checkNumericalProblems(t11), "complex64" === r11) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
          this.texData.set(e11, { shape: n11, dtype: r11, values: t11, usage: MIe.UPLOAD, refCount: a11 });
        } }, { key: "disposeIntermediateTensorInfo", value: function(e11) {
          this.disposeData(e11.dataId);
        } }, { key: "readSync", value: function(e11) {
          var t11 = this.texData.get(e11), n11 = t11.values, r11 = t11.dtype, a11 = t11.complexTensorInfos, i11 = t11.slice, o10 = t11.shape, s11 = t11.isPacked;
          if (null != i11) {
            var u10;
            u10 = s11 ? new fEe(o10, oEe) : new $Te(o10, oEe);
            var c10 = this.runWebGLProgram(u10, [{ dataId: e11, shape: o10, dtype: r11 }], r11), l10 = this.readSync(c10.dataId);
            return this.disposeIntermediateTensorInfo(c10), l10;
          }
          if (null != n11) return this.convertAndCacheOnCPU(e11);
          if ("string" === r11) return n11;
          var h10, p10, f10 = null != this.activeTimers;
          (f10 && (h10 = z4()), "complex64" === r11) ? p10 = Tie(this.readSync(a11.real.dataId), this.readSync(a11.imag.dataId)) : p10 = this.getValuesFromTexture(e11);
          return f10 && (this.downloadWaitMs += z4() - h10), this.convertAndCacheOnCPU(e11, p10);
        } }, { key: "read", value: (a10 = c(o().mark(function e11(t11) {
          var n11, r11, a11, i11, s11, u10, c10, l10, h10, p10, f10, d10, v10, m10, g10, y10, b10, x10, k10, w10, I10, N10, S10;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!this.pendingRead.has(t11)) {
                  e12.next = 3;
                  break;
                }
                return n11 = this.pendingRead.get(t11), e12.abrupt("return", new Promise(function(e13) {
                  return n11.push(e13);
                }));
              case 3:
                if (r11 = this.texData.get(t11), a11 = r11.values, i11 = r11.shape, s11 = r11.slice, u10 = r11.dtype, c10 = r11.complexTensorInfos, l10 = r11.isPacked, null == s11) {
                  e12.next = 11;
                  break;
                }
                return h10 = l10 ? new fEe(i11, oEe) : new $Te(i11, oEe), p10 = this.runWebGLProgram(h10, [{ dataId: t11, shape: i11, dtype: u10 }], u10), f10 = this.read(p10.dataId), this.disposeIntermediateTensorInfo(p10), e12.abrupt("return", f10);
              case 11:
                if (null == a11) {
                  e12.next = 13;
                  break;
                }
                return e12.abrupt("return", this.convertAndCacheOnCPU(t11));
              case 13:
                if (!k0().getBool("DEBUG")) {
                  e12.next = 16;
                  break;
                }
                if (k0().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") || 2 !== k0().getNumber("WEBGL_VERSION")) {
                  e12.next = 16;
                  break;
                }
                throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
              case 16:
                if (d10 = null, "complex64" !== u10 && k0().get("WEBGL_BUFFER_SUPPORTED") && (v10 = this.decode(t11), g10 = this.texData.get(v10.dataId), d10 = (m10 = this.gpgpu).createBufferFromTexture.apply(m10, [g10.texture.texture].concat(T(VIe(i11))))), this.pendingRead.set(t11, []), "complex64" === u10) {
                  e12.next = 22;
                  break;
                }
                return e12.next = 22, this.gpgpu.createAndWaitForFence();
              case 22:
                if ("complex64" !== u10) {
                  e12.next = 31;
                  break;
                }
                return e12.next = 25, Promise.all([this.read(c10.real.dataId), this.read(c10.imag.dataId)]);
              case 25:
                b10 = e12.sent, x10 = b10[0], k10 = b10[1], y10 = Tie(x10, k10), e12.next = 32;
                break;
              case 31:
                null == d10 ? y10 = this.getValuesFromTexture(t11) : (w10 = L$(i11), y10 = this.gpgpu.downloadFloat32MatrixFromBuffer(d10, w10));
              case 32:
                return null != v10 && this.disposeIntermediateTensorInfo(v10), null != d10 && HIe(I10 = this.gpgpu.gl, function() {
                  return I10.deleteBuffer(d10);
                }), N10 = this.convertAndCacheOnCPU(t11, y10), S10 = this.pendingRead.get(t11), this.pendingRead.delete(t11), S10.forEach(function(e13) {
                  return e13(N10);
                }), this.pendingDisposal.has(t11) && (this.pendingDisposal.delete(t11), this.disposeData(t11) && q5().removeDataId(t11, this), this.pendingDeletes--), e12.abrupt("return", N10);
              case 40:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return a10.apply(this, arguments);
        }) }, { key: "readToGPU", value: function(e11) {
          var t11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n11 = this.texData.get(e11), r11 = n11.values, a11 = n11.shape, i11 = n11.slice, o10 = n11.dtype, s11 = n11.isPacked, u10 = n11.texture;
          if ("complex64" === o10) throw new Error("Does not support reading texture for complex64 dtype.");
          if (null != i11) {
            var c10;
            c10 = s11 ? new fEe(a11, oEe) : new $Te(a11, oEe);
            var l10 = this.runWebGLProgram(c10, [{ dataId: e11, shape: a11, dtype: o10 }], o10), h10 = this.readToGPU(l10, t11);
            return this.disposeIntermediateTensorInfo(l10), h10;
          }
          if (null == u10) throw null != r11 ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
          var p10 = this.decode(e11, t11.customTexShape), f10 = q5().makeTensorFromTensorInfo(p10), d10 = this.texData.get(p10.dataId);
          return Object.assign({ tensorRef: f10 }, d10.texture);
        } }, { key: "bufferSync", value: function(e11) {
          var t11 = this.readSync(e11.dataId);
          if ("string" === e11.dtype) try {
            var n11 = t11.map(function(e12) {
              return W4(e12);
            });
            return l8(e11.shape, e11.dtype, n11);
          } catch (e12) {
            throw new Error("Failed to decode encoded string bytes into utf-8");
          }
          return l8(e11.shape, e11.dtype, t11);
        } }, { key: "checkNumericalProblems", value: function(e11) {
          if (null != e11) for (var t11 = 0; t11 < e11.length; t11++) {
            var n11 = e11[t11];
            if (!qIe(n11)) {
              if (k0().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value ".concat(n11, " cannot be represented with your ") + "current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
              throw Error("The value ".concat(n11, " cannot be represented on this device."));
            }
          }
        } }, { key: "getValuesFromTexture", value: function(e11) {
          var t11 = this.texData.get(e11), n11 = t11.shape, r11 = t11.dtype, a11 = t11.isPacked, i11 = L$(n11);
          if (k0().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
            var o10, s11 = this.decode(e11), u10 = this.texData.get(s11.dataId), c10 = (o10 = this.gpgpu).downloadMatrixFromPackedTexture.apply(o10, [u10.texture.texture].concat(T(VIe(n11)))).subarray(0, i11);
            return this.disposeIntermediateTensorInfo(s11), c10;
          }
          var l10 = k0().getBool("WEBGL_PACK") && true === a11, h10 = l10 ? wNe(n11) : n11, p10 = l10 ? new wSe(h10) : new kSe(h10), f10 = this.runWebGLProgram(p10, [{ shape: h10, dtype: r11, dataId: e11 }], "float32"), d10 = this.texData.get(f10.dataId), v10 = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d10.texture.texture, d10.texShape[0], d10.texShape[1]).subarray(0, i11);
          return this.disposeIntermediateTensorInfo(f10), v10;
        } }, { key: "timerAvailable", value: function() {
          return k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
        } }, { key: "time", value: function(e11) {
          var t11 = this, n11 = this.activeTimers, r11 = [], a11 = false;
          null == this.programTimersStack ? (this.programTimersStack = r11, a11 = true) : this.activeTimers.push(r11), this.activeTimers = r11, e11();
          var i11 = V4(this.activeTimers.map(function(e12) {
            return e12.query;
          })).filter(function(e12) {
            return null != e12;
          }), s11 = V4(this.activeTimers.map(function(e12) {
            return e12.name;
          })).filter(function(e12) {
            return null != e12;
          });
          this.activeTimers = n11, a11 && (this.programTimersStack = null);
          var u10 = { uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: null, wallMs: null };
          return c(o().mark(function e12() {
            var n12;
            return o().wrap(function(e13) {
              for (; ; ) switch (e13.prev = e13.next) {
                case 0:
                  if (!(k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)) {
                    e13.next = 8;
                    break;
                  }
                  return e13.next = 3, Promise.all(i11);
                case 3:
                  n12 = e13.sent, u10.kernelMs = O$(n12), u10.getExtraProfileInfo = function() {
                    return n12.map(function(e14, t12) {
                      return { name: s11[t12], ms: e14 };
                    }).map(function(e14) {
                      return "".concat(e14.name, ": ").concat(e14.ms);
                    }).join(", ");
                  }, e13.next = 9;
                  break;
                case 8:
                  u10.kernelMs = { error: "WebGL query timers are not supported in this environment." };
                case 9:
                  return t11.uploadWaitMs = 0, t11.downloadWaitMs = 0, e13.abrupt("return", u10);
                case 12:
                case "end":
                  return e13.stop();
              }
            }, e12);
          }))();
        } }, { key: "memory", value: function() {
          return { unreliable: false, numBytesInGPU: this.numBytesInGPU, numBytesInGPUAllocated: this.textureManager.numBytesAllocated, numBytesInGPUFree: this.textureManager.numBytesFree };
        } }, { key: "startTimer", value: function() {
          return k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : { startMs: z4(), endMs: null };
        } }, { key: "endTimer", value: function(e11) {
          return k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), e11) : (e11.endMs = z4(), e11);
        } }, { key: "getQueryTime", value: (r10 = c(o().mark(function e11(t11) {
          var n11;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!(k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)) {
                  e12.next = 2;
                  break;
                }
                return e12.abrupt("return", this.gpgpu.waitForQueryAndGetTime(t11));
              case 2:
                return n11 = t11, e12.abrupt("return", n11.endMs - n11.startMs);
              case 4:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return r10.apply(this, arguments);
        }) }, { key: "disposeData", value: function(e11) {
          var t11 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          if (this.pendingDisposal.has(e11)) return false;
          if (!this.texData.has(e11)) return true;
          if (t11 ? this.texData.get(e11).refCount = 0 : this.texData.get(e11).refCount--, !t11 && this.texData.get(e11).refCount > 0) return false;
          if (this.pendingRead.has(e11)) return this.pendingDisposal.add(e11), this.pendingDeletes++, false;
          this.releaseGPUData(e11);
          var n11 = this.texData.get(e11), r11 = n11.complexTensorInfos;
          return null != r11 && (this.disposeData(r11.real.dataId, t11), this.disposeData(r11.imag.dataId, t11)), this.texData.delete(e11), true;
        } }, { key: "releaseGPUData", value: function(e11) {
          var t11 = this.texData.get(e11), n11 = t11.texture, r11 = t11.dtype, a11 = t11.texShape, i11 = t11.usage, o10 = t11.isPacked, s11 = t11.slice, u10 = s11 && s11.origDataId || e11, c10 = this.dataRefCount.get(u10);
          c10 > 1 ? this.dataRefCount.set(u10, c10 - 1) : (this.dataRefCount.delete(u10), null != n11 && (this.numBytesInGPU -= this.computeBytes(a11, r11), this.textureManager.releaseTexture(n11, a11, i11, o10)));
          var l10 = this.texData.get(e11);
          l10.texture = null, l10.texShape = null, l10.isPacked = false, l10.slice = null;
        } }, { key: "getTexture", value: function(e11) {
          return this.uploadToGPU(e11), this.texData.get(e11).texture.texture;
        } }, { key: "getDataInfo", value: function(e11) {
          return this.texData.get(e11);
        } }, { key: "shouldExecuteOnCPU", value: function(e11) {
          var t11 = this, n11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : gEe;
          return k0().getBool("WEBGL_CPU_FORWARD") && e11.every(function(e12) {
            return null == t11.texData.get(e12.dataId).texture && L$(e12.shape) < n11;
          });
        } }, { key: "getGPGPUContext", value: function() {
          return this.gpgpu;
        } }, { key: "where", value: function(e11) {
          z3("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
          var t11 = e11.dataSync();
          return vEe(e11.shape, t11);
        } }, { key: "packedUnaryOp", value: function(e11, t11, n11) {
          var r11 = new fEe(e11.shape, t11), a11 = this.compileAndRun(r11, [e11], n11);
          return q5().makeTensorFromTensorInfo(a11);
        } }, { key: "abs", value: function(e11) {
          if (this.shouldExecuteOnCPU([e11]) && "complex64" !== e11.dtype) {
            var t11 = ATe(this.texData.get(e11.dataId).values);
            return this.makeOutput(e11.shape, e11.dtype, t11);
          }
          if (k0().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(e11, nEe, e11.dtype);
          var n11 = new $Te(e11.shape, nEe), r11 = this.compileAndRun(n11, [e11]);
          return q5().makeTensorFromTensorInfo(r11);
        } }, { key: "makeTensorInfo", value: function(e11, t11, n11) {
          var r11;
          if ("string" === t11 && null != n11 && n11.length > 0 && $$(n11[0])) {
            var a11 = n11.map(function(e12) {
              return B4(e12);
            });
            r11 = this.write(a11, e11, t11);
          } else r11 = this.write(n11, e11, t11);
          return this.texData.get(r11).usage = null, { dataId: r11, shape: e11, dtype: t11 };
        } }, { key: "makeOutput", value: function(e11, t11, n11) {
          return q5().makeTensorFromTensorInfo(this.makeTensorInfo(e11, t11, n11), this);
        } }, { key: "unpackTensor", value: function(e11) {
          var t11 = new dEe(e11.shape);
          return this.runWebGLProgram(t11, [e11], e11.dtype);
        } }, { key: "packTensor", value: function(e11) {
          var t11 = new KTe(e11.shape);
          return this.runWebGLProgram(t11, [e11], e11.dtype, null, true);
        } }, { key: "packedReshape", value: function(e11, t11) {
          var n11 = [xNe(e11.shape)].concat(T(kNe(e11.shape))), r11 = { dtype: e11.dtype, shape: n11, dataId: e11.dataId }, a11 = [xNe(t11)].concat(T(kNe(t11))), i11 = new XTe(a11, n11), o10 = [n11], s11 = this.runWebGLProgram(i11, [r11], e11.dtype, o10, true);
          return { dataId: s11.dataId, shape: t11, dtype: s11.dtype };
        } }, { key: "decode", value: function(e11, t11) {
          var n11 = this.texData.get(e11), r11 = n11.isPacked, a11 = n11.shape, i11 = n11.dtype;
          null != t11 && F$(L$(a11) <= t11[0] * t11[1] * 4, function() {
            return "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.";
          });
          var o10, s11 = wNe(a11);
          o10 = r11 ? new xSe(s11) : new bSe(s11);
          var u10 = [null != t11 ? t11 : VIe(s11)];
          return { dtype: i11, shape: a11, dataId: this.runWebGLProgram(o10, [{ shape: s11, dtype: i11, dataId: e11 }], i11, u10, true, t11).dataId };
        } }, { key: "runWebGLProgram", value: function(e11, t11, n11, r11) {
          var a11 = this, i11 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o10 = arguments.length > 5 ? arguments[5] : void 0, s11 = this.makeTensorInfo(e11.outputShape, n11), u10 = this.texData.get(s11.dataId);
          if (e11.packedOutput && (u10.isPacked = true), e11.outPackingScheme === DIe.DENSE) {
            var c10 = null != o10 ? o10 : VIe(e11.outputShape);
            u10.texShape = c10.map(function(e12) {
              return 2 * e12;
            });
          }
          if (null != e11.outTexUsage && (u10.usage = e11.outTexUsage), 0 === L$(s11.shape)) return u10.values = q$(s11.dtype, 0), s11;
          var l10 = [], h10 = t11.map(function(t12) {
            if ("complex64" === t12.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
            var n12 = a11.texData.get(t12.dataId);
            if (null == n12.texture) {
              if (!e11.packedInputs && L$(t12.shape) <= k0().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return { shape: t12.shape, texData: null, isUniform: true, uniformValues: n12.values };
              e11.packedInputs && (n12.isPacked = true, n12.shape = t12.shape);
            }
            if (a11.uploadToGPU(t12.dataId), !!n12.isPacked != !!e11.packedInputs) t12 = n12.isPacked ? a11.unpackTensor(t12) : a11.packTensor(t12), l10.push(t12), n12 = a11.texData.get(t12.dataId);
            else if (n12.isPacked && !SNe(n12.shape, t12.shape)) {
              var r12 = t12, i12 = t12.shape;
              t12.shape = n12.shape, t12 = a11.packedReshape(t12, i12), l10.push(t12), n12 = a11.texData.get(t12.dataId), r12.shape = i12;
            }
            return { shape: t12.shape, texData: n12, isUniform: false };
          });
          this.uploadToGPU(s11.dataId);
          var p10, f10 = { shape: s11.shape, texData: u10, isUniform: false }, d10 = gSe(e11, h10, f10), v10 = this.getAndSaveBinary(d10, function() {
            return fSe(a11.gpgpu, e11, h10, f10);
          }), m10 = null != this.activeTimers;
          m10 && (p10 = this.startTimer()), k0().get("ENGINE_COMPILE_ONLY") || mSe(this.gpgpu, v10, h10, f10, r11), l10.forEach(function(e12) {
            return a11.disposeIntermediateTensorInfo(e12);
          }), m10 && (p10 = this.endTimer(p10), this.activeTimers.push({ name: e11.constructor.name, query: this.getQueryTime(p10) }));
          var g10 = k0().getNumber("WEBGL_FLUSH_THRESHOLD");
          if (g10 > 0) {
            var y10 = z4();
            y10 - this.lastGlFlushTime > g10 && (this.gpgpu.gl.flush(), this.lastGlFlushTime = y10);
          }
          if (!k0().getBool("WEBGL_LAZILY_UNPACK") && u10.isPacked && false === i11) {
            var b10 = this.unpackTensor(s11);
            return this.disposeIntermediateTensorInfo(s11), b10;
          }
          return s11;
        } }, { key: "compileAndRun", value: function(e11, t11, n11, r11) {
          var a11 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
          n11 = n11 || t11[0].dtype;
          var i11 = this.runWebGLProgram(e11, t11, n11, r11, a11);
          return i11;
        } }, { key: "getAndSaveBinary", value: function(e11, t11) {
          return e11 in this.binaryCache || (this.binaryCache[e11] = t11()), this.binaryCache[e11];
        } }, { key: "getTextureManager", value: function() {
          return this.textureManager;
        } }, { key: "dispose", value: function() {
          var e11 = this;
          if (!this.disposed) {
            if (!k0().getBool("IS_TEST")) Object.keys(this.binaryCache).forEach(function(t11) {
              e11.gpgpu.deleteProgram(e11.binaryCache[t11].webGLProgram), delete e11.binaryCache[t11];
            });
            this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = true;
          }
        } }, { key: "floatPrecision", value: function() {
          var e11 = this;
          return null == this.floatPrecisionValue && (this.floatPrecisionValue = X5(function() {
            if (!k0().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
              var t11 = k0().getBool("DEBUG");
              k0().set("DEBUG", false);
              var n11 = e11.abs(i9(1e-8)).dataSync()[0];
              if (k0().set("DEBUG", t11), n11 > 0) return 32;
            }
            return 16;
          })), this.floatPrecisionValue;
        } }, { key: "epsilon", value: function() {
          return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
        } }, { key: "uploadToGPU", value: function(e11) {
          var t11 = this.texData.get(e11), n11 = t11.shape, r11 = t11.dtype, a11 = t11.values, i11 = t11.texture, o10 = t11.usage, s11 = t11.isPacked;
          if (null == i11) {
            var u10, c10 = null != this.activeTimers;
            c10 && (u10 = z4());
            var l10 = t11.texShape;
            if (null == l10 && (l10 = INe(n11, s11), t11.texShape = l10), null != a11) {
              var h10, p10 = wNe(n11), f10 = l10[1], d10 = l10[0], v10 = a11 instanceof Uint8Array || a11 instanceof Uint8ClampedArray;
              if (s11 || !v10) {
                var m10 = S(GIe(l10[0], l10[1]), 2);
                f10 = m10[0], d10 = m10[1];
              }
              h10 = s11 ? new SSe(p10, v10) : new NSe(p10, v10);
              var g10 = v10 ? [d10, f10] : l10, y10 = this.makeTensorInfo(g10, r11), b10 = this.texData.get(y10.dataId);
              b10.usage = v10 ? MIe.PIXELS : MIe.UPLOAD, b10.texShape = g10, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y10.dataId), f10, d10, a11);
              var x10 = [[d10, f10]], k10 = this.runWebGLProgram(h10, [y10], r11, x10, true), w10 = this.texData.get(k10.dataId);
              t11.texShape = w10.texShape, t11.isPacked = w10.isPacked, t11.usage = w10.usage, k0().get("ENGINE_COMPILE_ONLY") ? this.disposeData(k10.dataId) : (t11.texture = w10.texture, t11.values = null, this.texData.delete(k10.dataId)), this.disposeIntermediateTensorInfo(y10), c10 && (this.uploadWaitMs += z4() - u10);
            } else {
              var I10 = this.acquireTexture(l10, o10, r11, s11);
              t11.texture = I10;
            }
          }
        } }, { key: "convertAndCacheOnCPU", value: function(e11, t11) {
          var n11 = this.texData.get(e11), r11 = n11.dtype;
          return null != t11 && (n11.values = function(e12, t12) {
            if ("float32" === t12 || "complex64" === t12) return e12;
            if ("int32" === t12 || "bool" === t12) {
              for (var n12 = "int32" === t12 ? new Int32Array(e12.length) : new Uint8Array(e12.length), r12 = 0; r12 < n12.length; ++r12) n12[r12] = Math.round(e12[r12]);
              return n12;
            }
            throw new Error("Unknown dtype ".concat(t12));
          }(t11, r11)), n11.values;
        } }, { key: "acquireTexture", value: function(e11, t11, n11, r11) {
          if (this.numBytesInGPU += this.computeBytes(e11, n11), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
            var a11 = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
            this.warnedAboutMemory = true, console.warn("High memory usage in GPU: ".concat(a11, " MB, ") + "most likely due to a memory leak");
          }
          return this.textureManager.acquireTexture(e11, t11, r11);
        } }, { key: "computeBytes", value: function(e11, t11) {
          return e11[0] * e11[1] * Z$(t11);
        } }, { key: "checkCompileCompletion", value: function() {
          for (var e11 = 0, t11 = Object.entries(this.binaryCache); e11 < t11.length; e11++) {
            var n11 = S(t11[e11], 2)[1];
            this.checkCompletion_(n11);
          }
        } }, { key: "checkCompileCompletionAsync", value: (n10 = c(o().mark(function e11() {
          var t11, n11, r11, a11, i11, s11, u10, c10, l10 = this;
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (t11 = [], !this.gpgpu.parallelCompilationExtension) {
                  e12.next = 6;
                  break;
                }
                for (n11 = 0, r11 = Object.entries(this.binaryCache); n11 < r11.length; n11++) a11 = S(r11[n11], 2), i11 = a11[1], t11.push(this.checkCompletionAsync_(i11));
                return e12.abrupt("return", Promise.all(t11));
              case 6:
                s11 = o().mark(function e13() {
                  var n12, r12, a12;
                  return o().wrap(function(e14) {
                    for (; ; ) switch (e14.prev = e14.next) {
                      case 0:
                        n12 = S(c10[u10], 2), r12 = n12[1], a12 = new Promise(function(e15) {
                          try {
                            l10.checkCompletion_(r12), e15(true);
                          } catch (e16) {
                            throw e16;
                          }
                        }), t11.push(a12);
                      case 3:
                      case "end":
                        return e14.stop();
                    }
                  }, e13);
                }), u10 = 0, c10 = Object.entries(this.binaryCache);
              case 8:
                if (!(u10 < c10.length)) {
                  e12.next = 13;
                  break;
                }
                return e12.delegateYield(s11(), "t0", 10);
              case 10:
                u10++, e12.next = 8;
                break;
              case 13:
                return e12.abrupt("return", Promise.all(t11));
              case 14:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function() {
          return n10.apply(this, arguments);
        }) }, { key: "checkCompletionAsync_", value: (t10 = c(o().mark(function e11(t11) {
          return o().wrap(function(e12) {
            for (; ; ) switch (e12.prev = e12.next) {
              case 0:
                if (!this.gpgpu.gl.getProgramParameter(t11.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)) {
                  e12.next = 4;
                  break;
                }
                return e12.abrupt("return", this.checkCompletion_(t11));
              case 4:
                return e12.next = 6, aie();
              case 6:
                return e12.abrupt("return", this.checkCompletionAsync_(t11));
              case 7:
              case "end":
                return e12.stop();
            }
          }, e11, this);
        })), function(e11) {
          return t10.apply(this, arguments);
        }) }, { key: "checkCompletion_", value: function(e11) {
          if (false === this.gpgpu.gl.getProgramParameter(e11.webGLProgram, this.gpgpu.gl.LINK_STATUS)) {
            if (console.log(this.gpgpu.gl.getProgramInfoLog(e11.webGLProgram)), false === this.gpgpu.gl.getShaderParameter(e11.fragmentShader, this.gpgpu.gl.COMPILE_STATUS)) throw eNe(e11.source, this.gpgpu.gl.getShaderInfoLog(e11.fragmentShader)), new Error("Failed to compile fragment shader.");
            throw new Error("Failed to link vertex and fragment shaders.");
          }
          return true;
        } }, { key: "getUniformLocations", value: function() {
          for (var e11 = 0, t11 = Object.values(this.binaryCache); e11 < t11.length; e11++) {
            var n11 = t11[e11];
            this.gpgpu.buildVao(n11.webGLProgram);
            var r11 = dSe(this.gpgpu, n11.program, n11.webGLProgram), a11 = r11.variablesLocations, i11 = r11.customUniformLocations, o10 = r11.infLoc, s11 = r11.nanLoc, u10 = r11.outShapeLocation, c10 = r11.outShapeStridesLocation, l10 = r11.outTexShapeLocation;
            n11.variablesLocations = a11, n11.customUniformLocations = i11, n11.infLoc = o10, n11.nanLoc = s11, n11.outShapeLocation = u10, n11.outShapeStridesLocation = c10, n11.outTexShapeLocation = l10;
          }
        } }, { key: "createTensorFromGPUData", value: function(e11, t11, n11) {
          e11.channels = e11.channels || "RGBA";
          var r11 = e11.texture, a11 = e11.height, i11 = e11.width, o10 = e11.channels, s11 = q5().backend;
          if (!s11.gpgpu.gl.isTexture(r11)) throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");
          var u10 = s11.writeTexture(r11, t11, n11, a11, i11, o10);
          return q5().makeTensorFromDataId(u10, t11, n11, s11);
        } }]), s10;
      }(T$);
      yEe.nextDataId = 0;
      var bEe = "4.17.0";
      function xEe() {
        k0().set("WEBGL_FORCE_F16_TEXTURES", true);
      }
      R5() && $5("webgl", function() {
        return new yEe();
      }, 2);
      var kEe = { forceHalfFloat: xEe }, wEe = p(function e10(t10, n10, r10) {
        l(this, e10), this.variableNames = ["A", "B"], this.outputShape = z7(n10, r10), this.enableShapeUniforms = ySe(this.outputShape.length), this.userCode = "\n      float binaryOperation(float a, float b) {\n        ".concat(t10, "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ");
      }), IEe = "\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n", NEe = p(function e10(t10, n10, r10) {
        var a10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
        l(this, e10), this.variableNames = ["A", "B"], this.supportsBroadcasting = true, this.packedInputs = true, this.packedOutput = true, this.outputShape = z7(n10, r10);
        var i10 = this.outputShape.length;
        this.enableShapeUniforms = ySe(i10);
        var o10 = "";
        if (a10) if (0 === i10 || 1 === L$(this.outputShape)) o10 = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
        else {
          var s10 = cSe(i10);
          if (o10 = "\n          ".concat(s10, " coords = getOutputCoords();\n        "), 1 === i10) this.enableShapeUniforms ? o10 += "\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          " : o10 += "\n            result.y = (coords + 1) >= ".concat(this.outputShape[0], " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");
          else {
            var u10 = qTe("coords", i10);
            this.enableShapeUniforms ? o10 += "\n            bool nextRowOutOfBounds =\n              (".concat(u10[i10 - 2], " + 1) >= outShape[").concat(i10, " - 2];\n            bool nextColOutOfBounds =\n              (").concat(u10[i10 - 1], " + 1) >= outShape[").concat(i10, " - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ") : o10 += "\n            bool nextRowOutOfBounds =\n              (".concat(u10[i10 - 2], " + 1) >= ").concat(this.outputShape[i10 - 2], ";\n            bool nextColOutOfBounds =\n              (").concat(u10[i10 - 1], " + 1) >= ").concat(this.outputShape[i10 - 1], ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ");
          }
        }
        this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(t10, "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(o10, "\n\n        setOutput(result);\n      }\n    ");
      });
      function SEe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.x;
        return n10.incRef(r10.dataId), { dataId: r10.dataId, shape: r10.shape, dtype: r10.dtype };
      }
      var TEe = { kernelName: W1, backendName: "webgl", kernelFunc: SEe };
      function EEe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.real, a10 = t10.imag, i10 = n10.makeTensorInfo(r10.shape, "complex64"), o10 = n10.texData.get(i10.dataId), s10 = SEe({ inputs: { x: r10 }, backend: n10 }), u10 = SEe({ inputs: { x: a10 }, backend: n10 });
        return o10.complexTensorInfos = { real: s10, imag: u10 }, i10;
      }
      var CEe = { kernelName: Z0, backendName: "webgl", kernelFunc: EEe }, AEe = "return (a < 0.) ? b * a : a;", REe = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
      var _Ee = { kernelName: q1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.alpha, o10 = n10.makeTensorInfo([], "float32", M4(i10, "float32")), s10 = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new NEe(REe, a10.shape, o10.shape) : new wEe(AEe, a10.shape, o10.shape), u10 = n10.runWebGLProgram(s10, [a10, o10], "float32");
        return n10.disposeIntermediateTensorInfo(o10), u10;
      } }, OEe = "return (a < 0.) ? b * a : a;", FEe = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
      var DEe = { kernelName: C2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.x, a10 = t10.alpha, i10 = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new NEe(FEe, r10.shape, a10.shape) : new wEe(OEe, r10.shape, a10.shape);
        return n10.runWebGLProgram(i10, [r10, a10], "float32");
      } };
      function MEe(e10) {
        var t10 = e10.opSnippet, n10 = e10.packedOpSnippet, r10 = e10.cpuKernelImpl, a10 = e10.dtype;
        return function(e11) {
          var i10, o10 = e11.inputs, s10 = e11.backend, u10 = o10.x, c10 = s10, l10 = a10 || u10.dtype;
          if (c10.shouldExecuteOnCPU([u10]) && null != r10) {
            var h10 = c10.texData.get(u10.dataId), p10 = r10(h10.values, l10);
            return c10.makeTensorInfo(u10.shape, l10, p10);
          }
          return i10 = k0().getBool("WEBGL_PACK_UNARY_OPERATIONS") && null != n10 ? new fEe(u10.shape, n10) : new $Te(u10.shape, t10), c10.runWebGLProgram(i10, [u10], l10);
        };
      }
      function LEe(e10) {
        var t10 = e10.opSnippet, n10 = e10.packedOpSnippet, r10 = e10.checkOutOfBounds, a10 = void 0 !== r10 && r10, i10 = e10.supportsComplex, o10 = void 0 !== i10 && i10, s10 = e10.cpuKernelImpl, u10 = e10.dtype;
        return function(e11) {
          var r11 = e11.inputs, i11 = e11.backend, c10 = r11.a, l10 = r11.b, h10 = i11;
          if (o10 && "complex64" === c10.dtype) {
            var p10 = h10.texData.get(c10.dataId), f10 = h10.texData.get(l10.dataId), d10 = [[p10.complexTensorInfos.real, f10.complexTensorInfos.real], [p10.complexTensorInfos.imag, f10.complexTensorInfos.imag]].map(function(e12) {
              var n11 = S(e12, 2), r12 = n11[0], a11 = n11[1], i12 = { dataId: r12.dataId, dtype: r12.dtype, shape: c10.shape }, o11 = { dataId: a11.dataId, dtype: a11.dtype, shape: l10.shape }, s11 = new wEe(t10, c10.shape, l10.shape);
              return h10.runWebGLProgram(s11, [i12, o11], h5(r12.dtype, a11.dtype));
            }), v10 = S(d10, 2), m10 = v10[0], g10 = v10[1], y10 = EEe({ inputs: { real: m10, imag: g10 }, backend: h10 });
            return h10.disposeIntermediateTensorInfo(m10), h10.disposeIntermediateTensorInfo(g10), y10;
          }
          var b10, x10 = u10 || h5(c10.dtype, l10.dtype);
          if (("string" === c10.dtype || "string" === l10.dtype || h10.shouldExecuteOnCPU([c10, l10])) && null != s10) {
            var k10 = h10.texData.get(c10.dataId).values, w10 = h10.texData.get(l10.dataId).values, I10 = "string" === c10.dtype ? aoe(k10) : k10, N10 = "string" === c10.dtype ? aoe(w10) : w10, T10 = S(s10(c10.shape, l10.shape, I10, N10, x10), 2), E10 = T10[0], C10 = T10[1], A10 = h10.makeTensorInfo(C10, x10);
            return h10.texData.get(A10.dataId).values = E10, A10;
          }
          return b10 = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") && null != n10 ? new NEe(n10, c10.shape, l10.shape, a10) : new wEe(t10, c10.shape, l10.shape), h10.runWebGLProgram(b10, [c10, l10], x10);
        };
      }
      function zEe(e10) {
        var t10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if ("linear" === e10) return t10 ? uEe : tEe;
        if ("relu" === e10) return t10 ? lEe : aEe;
        if ("elu" === e10) return t10 ? cEe : rEe;
        if ("relu6" === e10) return t10 ? hEe : iEe;
        if ("prelu" === e10) return t10 ? FEe : OEe;
        if ("leakyrelu" === e10) return t10 ? REe : AEe;
        if ("sigmoid" === e10) return t10 ? pEe : sEe;
        throw new Error("Activation ".concat(e10, " has not been implemented for the WebGL backend."));
      }
      var PEe = p(function e10(t10, n10, r10) {
        var a10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i10 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o10 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5], s10 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, u10 = arguments.length > 7 && void 0 !== arguments[7] && arguments[7], c10 = arguments.length > 8 && void 0 !== arguments[8] && arguments[8];
        l(this, e10), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = true, this.packedOutput = true, this.outputShape = r10, this.enableShapeUniforms = ySe(this.outputShape.length);
        var h10 = a10 ? t10[1] : t10[2], p10 = Math.ceil(h10 / 2), f10 = a10 ? "i * 2, rc.y" : "rc.y, i * 2", d10 = i10 ? "rc.z, i * 2" : "i * 2, rc.z", v10 = a10 ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"], m10 = i10 ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"], g10 = "", y10 = "";
        s10 && (g10 = u10 ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(s10, "\n        }") : c10 ? "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(s10, "\n        }") : "vec4 activation(vec4 x) {\n          ".concat(s10, "\n        }"), y10 = "result = activation(result);");
        var b10 = o10 ? "result += getBiasAtOutCoords();" : "";
        o10 && this.variableNames.push("bias"), u10 && this.variableNames.push("preluActivationWeights"), c10 && this.variableNames.push("leakyreluAlpha");
        var x10 = "rc.x", k10 = "rc.x";
        t10[0] < n10[0] ? x10 = "imod(rc.x, ".concat(t10[0], ")") : n10[0] < t10[0] && (k10 = "imod(rc.x, ".concat(n10[0], ")")), this.userCode = "\n      ".concat(g10, "\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(p10, ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(x10, ";\n        int batchB = ").concat(k10, ";\n        for (int i = 0; i < ").concat(p10, "; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(f10, ");\n          vec4 b = getMatrixB(batchB, ").concat(d10, ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(v10[0], " * ").concat(m10[0], ");\n          result += (").concat(v10[1], " * ").concat(m10[1], ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(b10, "\n\n        ").concat(y10, "\n\n        setOutput(result);\n      }\n    ");
      }), BEe = "return areal * breal - aimag * bimag;", WEe = "return areal * bimag + aimag * breal;", UEe = p(function e10(t10, n10, r10) {
        l(this, e10), this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = z7(n10, r10), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(t10, "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ");
      }), VEe = "return a * b;";
      function GEe(e10) {
        var t10, n10 = e10.inputs, r10 = e10.backend, a10 = n10.a, i10 = n10.b, o10 = h5(a10.dtype, i10.dtype);
        if ("complex64" === a10.dtype) {
          var s10 = r10.texData.get(a10.dataId), u10 = r10.texData.get(i10.dataId), c10 = new UEe(BEe, a10.shape, i10.shape), l10 = new UEe(WEe, a10.shape, i10.shape), h10 = [{ dataId: s10.complexTensorInfos.real.dataId, dtype: s10.complexTensorInfos.real.dtype, shape: a10.shape }, { dataId: s10.complexTensorInfos.imag.dataId, dtype: s10.complexTensorInfos.imag.dtype, shape: a10.shape }, { dataId: u10.complexTensorInfos.real.dataId, dtype: u10.complexTensorInfos.real.dtype, shape: i10.shape }, { dataId: u10.complexTensorInfos.imag.dataId, dtype: u10.complexTensorInfos.imag.dtype, shape: i10.shape }], p10 = r10.runWebGLProgram(c10, h10, "float32"), f10 = r10.runWebGLProgram(l10, h10, "float32"), d10 = EEe({ inputs: { real: p10, imag: f10 }, backend: r10 });
          return r10.disposeIntermediateTensorInfo(p10), r10.disposeIntermediateTensorInfo(f10), d10;
        }
        if (r10.shouldExecuteOnCPU([a10, i10])) {
          var v10 = r10.texData.get(a10.dataId), m10 = r10.texData.get(i10.dataId), g10 = S(yTe(a10.shape, i10.shape, v10.values, m10.values, o10), 2), y10 = g10[0], b10 = g10[1], x10 = r10.makeTensorInfo(b10, o10);
          return r10.texData.get(x10.dataId).values = y10, x10;
        }
        return t10 = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new NEe(VEe, a10.shape, i10.shape) : new wEe(VEe, a10.shape, i10.shape), r10.runWebGLProgram(t10, [a10, i10], o10);
      }
      var jEe = { kernelName: g2, backendName: "webgl", kernelFunc: GEe };
      function HEe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.shape, o10 = n10, s10 = L$(a10.shape), u10 = G$(i10, s10), c10 = L$(u10);
        F$(s10 === c10, function() {
          return "The new shape (".concat(u10, ") has ").concat(c10, " elements and the old ") + "shape (".concat(a10.shape, ") has ").concat(s10, " elements. The new shape and old ") + "shape must have the same number of elements.";
        });
        var l10 = o10.texData.get(a10.dataId);
        return !l10.isPacked || SNe(a10.shape, u10) || null !== l10.texture && SNe(l10.shape, u10) ? (o10.incRef(a10.dataId), { dataId: a10.dataId, shape: u10, dtype: a10.dtype }) : function(e11, t11, n11) {
          var r11 = [xNe(e11.shape)].concat(T(kNe(e11.shape))), a11 = { dtype: e11.dtype, shape: r11, dataId: e11.dataId }, i11 = [xNe(t11)].concat(T(kNe(t11))), o11 = new XTe(i11, r11), s11 = [r11], u11 = n11.runWebGLProgram(o11, [a11], e11.dtype, s11, true);
          return { dataId: u11.dataId, shape: t11, dtype: u11.dtype };
        }(a10, u10, o10);
      }
      var qEe = { kernelName: z2, backendName: "webgl", kernelFunc: HEe }, KEe = p(function e10(t10, n10) {
        l(this, e10), this.variableNames = ["x"];
        var r10 = t10.windowSize, a10 = t10.batchSize, i10 = t10.inSize, o10 = t10.outSize;
        this.outputShape = [a10, o10];
        var s10 = 4 * Math.floor(r10 / 4), u10 = r10 % 4, c10 = "sumValue += dot(values, ones);";
        if (null != n10) {
          var h10 = 1 / n10;
          c10 = "sumValue += dot(values * ".concat(B$(h10) ? h10.toPrecision(2) : h10, ", ones);");
        }
        var p10 = "";
        i10 % r10 > 0 && (p10 = "\n        if (inIdx < 0 || inIdx >= ".concat(i10, ") {\n          return 0.0;\n        }\n      ")), this.userCode = "\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(p10, "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(r10, ";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(s10, "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(c10, "\n        }\n\n        int inIdx = inOffset + ").concat(s10, ";\n        if (").concat(1 === u10, ") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(c10, "\n        } else if (").concat(2 === u10, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(c10, "\n        } else if (").concat(3 === u10, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(c10, "\n        }\n        setOutput(sumValue);\n      }\n    ");
      }), XEe = p(function e10(t10, n10) {
        l(this, e10), this.variableNames = ["x"];
        var r10 = t10.windowSize, a10 = t10.batchSize, i10 = t10.inSize, o10 = t10.outSize;
        this.outputShape = [a10, o10];
        var s10 = "0.0", u10 = "";
        "prod" === n10 ? s10 = "1.0" : "min" === n10 ? (s10 = "1.0 / 1e-20", u10 = "min") : "max" === n10 && (s10 = "-1.0 / 1e-20", u10 = "max");
        var c10 = "".concat(n10, "(").concat(n10, "(").concat(n10, "(") + "minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
        "sum" === n10 ? c10 = "sumValue" : "prod" === n10 ? c10 = "prodValue" : "all" === n10 ? c10 = "allValue" : "any" === n10 && (c10 = "anyValue");
        var h10 = 4 * Math.floor(r10 / 4), p10 = r10 % 4, f10 = "\n      if (".concat("sum" === n10, ") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod" === n10, ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(u10, "(values, minMaxValue);\n        if (").concat("min" === n10, " || ").concat("max" === n10, ") {\n          minMaxValue = ").concat(u10, "(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "), d10 = "vec4";
        "all" === n10 ? (s10 = "1.0", f10 = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", d10 = "bvec4") : "any" === n10 && (s10 = "0.0", f10 = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", d10 = "bvec4");
        var v10 = "";
        i10 % r10 > 0 && (v10 = "\n        if (inIdx < 0 || inIdx >= ".concat(i10, ") {\n          return initializationValue;\n        }\n      ")), this.userCode = "\n      const float initializationValue = ".concat(s10, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(v10, "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(r10, ";\n\n        vec4 minMaxValue = vec4(").concat(s10, ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(h10, "; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(d10, " values = ").concat(d10, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(f10, "\n        }\n\n        int inIdx = inOffset + ").concat(h10, ";\n        if (").concat(1 === p10, ") {\n          ").concat(d10, " values = ").concat(d10, "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(f10, "\n        } else if (").concat(2 === p10, ") {\n          ").concat(d10, " values = ").concat(d10, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(f10, "\n        } else if (").concat(3 === p10, ") {\n          ").concat(d10, " values = ").concat(d10, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(f10, "\n        }\n        setOutput(").concat(c10, ");\n      }\n    ");
      });
      function YEe(e10, t10, n10, r10) {
        for (var a10 = function(e11) {
          for (var t11 = []; 0 === t11.length || 1 !== t11[t11.length - 1].outSize; ) {
            var n11 = t11.length ? t11[t11.length - 1].outSize : e11[1], r11 = hie(n11);
            t11.push({ inSize: n11, windowSize: r11, outSize: Math.ceil(n11 / r11) });
          }
          return t11;
        }(e10.shape), i10 = e10, o10 = 0; o10 < a10.length; o10++) {
          var s10, u10 = a10[o10], c10 = u10.inSize, l10 = u10.windowSize, h10 = u10.outSize, p10 = void 0;
          p10 = "mean" === n10 ? 0 === o10 ? new KEe({ windowSize: l10, inSize: c10, batchSize: e10.shape[0], outSize: h10 }, c10) : new KEe({ windowSize: l10, inSize: c10, batchSize: e10.shape[0], outSize: h10 }) : new XEe({ windowSize: l10, inSize: c10, batchSize: e10.shape[0], outSize: h10 }, n10), s10 = i10, i10 = r10.runWebGLProgram(p10, [i10], t10), s10.dataId !== e10.dataId && r10.disposeIntermediateTensorInfo(s10);
        }
        return i10;
      }
      var JEe = p(function e10(t10, n10) {
        l(this, e10), this.variableNames = ["A"];
        for (var r10 = new Array(t10.length), a10 = 0; a10 < r10.length; a10++) r10[a10] = t10[n10[a10]];
        this.outputShape = r10, this.rank = r10.length;
        var i10 = cSe(this.rank), o10 = function(e11) {
          var t11 = e11.length;
          if (t11 > 6) throw Error("Transpose for rank ".concat(t11, " is not yet supported"));
          for (var n11 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], r11 = new Array(t11), a11 = 0; a11 < e11.length; a11++) r11[e11[a11]] = n11[a11];
          return r11.join();
        }(n10);
        this.userCode = "\n    void main() {\n      ".concat(i10, " resRC = getOutputCoords();\n      setOutput(getA(").concat(o10, "));\n    }\n    ");
      });
      var ZEe = p(function e10(t10, n10) {
        l(this, e10), this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true;
        for (var r10 = new Array(t10.length), a10 = 0; a10 < r10.length; a10++) r10[a10] = t10[n10[a10]];
        if (this.outputShape = r10, this.rank = r10.length, this.rank > 6) throw Error("Packed transpose for rank ".concat(this.rank, " is not yet supported."));
        for (var i10 = cSe(this.rank), o10 = HTe("rc", this.rank), s10 = new Array(this.rank), u10 = 0; u10 < n10.length; u10++) s10[n10[u10]] = o10[u10];
        var c10 = "vec2(".concat(s10.slice(-2).join(), ")"), h10 = "++".concat(o10[this.rank - 1], " < ").concat(r10[this.rank - 1]), p10 = "getChannel(getA(".concat(s10.join(), "), ").concat(c10, ")");
        this.userCode = "\n    void main() {\n      ".concat(i10, " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(p10, ";\n      if(").concat(h10, ") {\n        result[1] = ").concat(p10, ";\n      }\n      --").concat(o10[this.rank - 1], ";\n      if(++").concat(o10[this.rank - 2], " < ").concat(r10[this.rank - 2], ") {\n        result[2] = ").concat(p10, ";\n        if(").concat(h10, ") {\n          result[3] = ").concat(p10, ";\n        }\n      }\n      setOutput(result);\n    }\n    ");
      });
      function QEe(e10, t10, n10) {
        var r10 = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ZEe(e10.shape, t10) : new JEe(e10.shape, t10);
        return n10.runWebGLProgram(r10, [e10], e10.dtype);
      }
      function $Ee(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs;
        return function(e11, t11, n11, r11) {
          var a10 = t11, i10 = e11.shape.length, o10 = j$(a10, e11.shape), s10 = o10, u10 = $7(s10, i10), c10 = null != u10, l10 = e11;
          c10 && (l10 = QEe(e11, u10, r11), s10 = t9(s10.length, i10)), Q7("sum", s10, i10);
          var h10 = S(J7(l10.shape, s10), 2), p10 = h10[0], f10 = h10[1], d10 = p10;
          n11 && (d10 = Z7(p10, o10));
          var v10 = L$(f10), m10 = HEe({ inputs: { x: l10 }, attrs: { shape: [L$(e11.shape) / v10, v10] }, backend: r11 }), g10 = YEe(m10, p5(e11.dtype), "sum", r11), y10 = HEe({ inputs: { x: g10 }, attrs: { shape: d10 }, backend: r11 });
          return r11.disposeIntermediateTensorInfo(m10), r11.disposeIntermediateTensorInfo(g10), c10 && r11.disposeIntermediateTensorInfo(l10), y10;
        }(t10.x, r10.axis, r10.keepDims, n10);
      }
      var eCe = { kernelName: a3, backendName: "webgl", kernelFunc: $Ee };
      function tCe(e10) {
        for (var t10, n10 = e10.inputs, r10 = e10.backend, a10 = e10.attrs, i10 = n10.x, o10 = a10.perm, s10 = r10, u10 = i10.shape.length, c10 = new Array(u10), l10 = 0; l10 < c10.length; l10++) c10[l10] = i10.shape[o10[l10]];
        if (s10.shouldExecuteOnCPU([i10])) {
          var h10 = s10.texData.get(i10.dataId).values, p10 = GTe(h10, i10.shape, i10.dtype, o10, c10);
          t10 = s10.makeTensorInfo(c10, i10.dtype), s10.texData.get(t10.dataId).values = p10;
        } else t10 = QEe(i10, o10, s10);
        return t10;
      }
      var nCe = { kernelName: T3, backendName: "webgl", kernelFunc: tCe };
      function rCe(e10) {
        var t10 = e10.a, n10 = e10.b, r10 = e10.transposeA, a10 = e10.transposeB, i10 = e10.backend, o10 = e10.bias, s10 = void 0 === o10 ? null : o10, u10 = e10.preluActivationWeights, c10 = void 0 === u10 ? null : u10, l10 = e10.leakyreluAlpha, h10 = void 0 === l10 ? 0 : l10, p10 = e10.activation, f10 = void 0 === p10 ? null : p10, d10 = t10.shape.length, v10 = n10.shape.length, m10 = r10 ? t10.shape[d10 - 2] : t10.shape[d10 - 1], g10 = a10 ? n10.shape[v10 - 1] : n10.shape[v10 - 2], y10 = r10 ? t10.shape[d10 - 1] : t10.shape[d10 - 2], b10 = a10 ? n10.shape[v10 - 2] : n10.shape[v10 - 1], x10 = t10.shape.slice(0, -2), k10 = n10.shape.slice(0, -2), w10 = L$(x10), I10 = L$(k10), N10 = z7(t10.shape.slice(0, -2), n10.shape.slice(0, -2)).concat([y10, b10]);
        F$(m10 === g10, function() {
          return "Error in matMul: inner shapes (".concat(m10, ") and (") + "".concat(g10, ") of Tensors with shapes ").concat(t10.shape, " and ") + "".concat(n10.shape, " and transposeA=").concat(r10) + " and transposeB=".concat(a10, " must match.");
        });
        var S10, T10 = r10 ? [w10, m10, y10] : [w10, y10, m10], E10 = a10 ? [I10, b10, g10] : [I10, g10, b10], C10 = HEe({ inputs: { x: t10 }, backend: i10, attrs: { shape: T10 } }), A10 = HEe({ inputs: { x: n10 }, backend: i10, attrs: { shape: E10 } }), R10 = [C10, A10], _10 = Math.max(w10, I10), O10 = r10 ? C10.shape[1] : C10.shape[2], F10 = null != s10, D10 = null != c10, M10 = "leakyrelu" === f10, L10 = null != f10 ? zEe(f10, true) : null;
        if ((1 === y10 || 1 === b10) && O10 > 1e3 && false === (F10 || D10 || M10 || null != L10)) {
          var z10 = C10, P10 = A10;
          r10 && (z10 = tCe({ inputs: { x: C10 }, backend: i10, attrs: { perm: [0, 2, 1] } }), R10.push(z10)), a10 && (P10 = tCe({ inputs: { x: A10 }, backend: i10, attrs: { perm: [0, 2, 1] } }), R10.push(P10));
          var B10 = 1 === b10, W10 = z10;
          1 !== b10 && (W10 = HEe({ inputs: { x: z10 }, backend: i10, attrs: { shape: [_10, O10, 1] } }), R10.push(W10));
          var U10 = 1 === b10 ? 2 : 1, V10 = P10;
          B10 && (V10 = HEe({ inputs: { x: P10 }, backend: i10, attrs: { shape: [_10, 1, O10] } }), R10.push(V10));
          var G10 = GEe({ inputs: { a: W10, b: V10 }, backend: i10 });
          S10 = $Ee({ inputs: { x: G10 }, backend: i10, attrs: { axis: U10, keepDims: true } }), R10.push(G10);
        } else {
          var j10 = h5(t10.dtype, n10.dtype), H10 = new PEe(T10, E10, [_10, y10, b10], r10, a10, F10, L10, D10, M10), q10 = [C10, A10];
          if (null != s10 && q10.push(s10), D10 && q10.push(c10), M10) {
            var K10 = i10.makeTensorInfo([], "float32", M4(h10, "float32"));
            q10.push(K10), R10.push(K10);
          }
          S10 = i10.runWebGLProgram(H10, q10, j10);
        }
        var X10 = HEe({ inputs: { x: S10 }, backend: i10, attrs: { shape: N10 } });
        R10.push(S10);
        for (var Y10 = 0, J10 = R10; Y10 < J10.length; Y10++) {
          var Z10 = J10[Y10];
          i10.disposeIntermediateTensorInfo(Z10);
        }
        return X10;
      }
      var aCe = { kernelName: D3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.a, i10 = t10.b, o10 = t10.bias, s10 = t10.preluActivationWeights, u10 = r10.transposeA, c10 = r10.transposeB, l10 = r10.activation;
        return rCe({ a: a10, b: i10, transposeA: u10, transposeB: c10, backend: n10, bias: o10, preluActivationWeights: s10, leakyreluAlpha: r10.leakyreluAlpha, activation: l10 });
      } }, iCe = "return abs(x);";
      var oCe = { kernelName: N0, backendName: "webgl", kernelFunc: function(e10) {
        var t10, n10 = e10.inputs, r10 = e10.backend, a10 = n10.x;
        if (r10.shouldExecuteOnCPU([a10]) && "complex64" !== a10.dtype) {
          var i10 = r10.texData.get(a10.dataId), o10 = ATe(i10.values);
          return r10.makeTensorInfo(a10.shape, a10.dtype, o10);
        }
        return t10 = k0().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new fEe(a10.shape, iCe) : new $Te(a10.shape, iCe), r10.runWebGLProgram(t10, [a10], a10.dtype);
      } }, sCe = MEe({ opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n" }), uCe = { kernelName: S0, backendName: "webgl", kernelFunc: sCe }, cCe = MEe({ opSnippet: "if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));" }), lCe = { kernelName: T0, backendName: "webgl", kernelFunc: cCe }, hCe = "return a + b;", pCe = LEe({ opSnippet: hCe, packedOpSnippet: hCe, supportsComplex: true, cpuKernelImpl: JSe }), fCe = { kernelName: E0, backendName: "webgl", kernelFunc: pCe }, dCe = p(function e10(t10, n10) {
        l(this, e10), this.outputShape = [], this.outputShape = t10, this.variableNames = n10.map(function(e11, t11) {
          return "T".concat(t11);
        });
        var r10 = [];
        this.variableNames.forEach(function(e11) {
          r10.push("float v".concat(e11, " = get").concat(e11, "AtOutCoords();"));
        });
        var a10 = this.variableNames.map(function(e11) {
          return "v".concat(e11);
        }).join(" + ");
        this.userCode = "\n      void main() {\n        ".concat(r10.join("\n        "), "\n\n        float result = ").concat(a10, ";\n        setOutput(result);\n      }\n    ");
      }), vCe = p(function e10(t10, n10) {
        l(this, e10), this.outputShape = [], this.packedInputs = true, this.packedOutput = true, this.outputShape = t10, this.variableNames = n10.map(function(e11, t11) {
          return "T".concat(t11);
        });
        var r10 = [];
        this.variableNames.forEach(function(e11) {
          r10.push("vec4 v".concat(e11, " = get").concat(e11, "AtOutCoords();"));
        });
        var a10 = this.variableNames.map(function(e11) {
          return "v".concat(e11);
        }).join(" + ");
        this.userCode = "\n      void main() {\n        ".concat(r10.join("\n        "), "\n\n        vec4 result = ").concat(a10, ";\n        setOutput(result);\n      }\n    ");
      });
      var mCe = { kernelName: C0, backendName: "webgl", kernelFunc: function e10(t10) {
        var n10 = t10.inputs, r10 = t10.backend, a10 = n10;
        if (1 === a10.length) return SEe({ inputs: { x: a10[0] }, backend: r10 });
        if (a10.length > k0().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
          var i10 = Math.floor(a10.length / 2), o10 = e10({ inputs: a10.slice(0, i10), backend: r10 }), s10 = e10({ inputs: a10.slice(i10), backend: r10 });
          return e10({ inputs: [o10, s10], backend: r10 });
        }
        var u10 = a10.map(function(e11) {
          return e11.dtype;
        }).reduce(function(e11, t11) {
          return h5(e11, t11);
        }), c10 = a10.map(function(e11) {
          return e11.shape;
        }), l10 = k0().getBool("WEBGL_PACK") ? new vCe(a10[0].shape, c10) : new dCe(a10[0].shape, c10);
        return r10.runWebGLProgram(l10, a10, u10);
      } };
      var gCe = { kernelName: A0, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.axis, o10 = r10.keepDims, s10 = a10.shape.length, u10 = j$(i10, a10.shape), c10 = u10, l10 = $7(c10, s10), h10 = a10;
        null != l10 && (h10 = tCe({ inputs: { x: a10 }, backend: n10, attrs: { perm: l10 } }), c10 = t9(c10.length, s10)), Q7("all", c10, s10);
        var p10, f10 = S(J7(h10.shape, c10), 2), d10 = f10[0], v10 = HEe({ inputs: { x: h10 }, backend: n10, attrs: { shape: [-1, L$(f10[1])] } }), m10 = YEe(v10, v10.dtype, "all", n10);
        return p10 = HEe(o10 ? { inputs: { x: m10 }, backend: n10, attrs: { shape: Z7(d10, u10) } } : { inputs: { x: m10 }, backend: n10, attrs: { shape: d10 } }), n10.disposeIntermediateTensorInfo(v10), n10.disposeIntermediateTensorInfo(m10), null != l10 && n10.disposeIntermediateTensorInfo(h10), p10;
      } };
      var yCe = { kernelName: R0, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.axis, o10 = r10.keepDims, s10 = a10.shape.length, u10 = j$(i10, a10.shape), c10 = u10, l10 = $7(c10, s10), h10 = a10;
        null != l10 && (h10 = tCe({ inputs: { x: a10 }, backend: n10, attrs: { perm: l10 } }), c10 = t9(c10.length, s10)), Q7("any", c10, s10);
        var p10, f10 = S(J7(h10.shape, c10), 2), d10 = f10[0], v10 = HEe({ inputs: { x: h10 }, backend: n10, attrs: { shape: [-1, L$(f10[1])] } }), m10 = YEe(v10, v10.dtype, "any", n10);
        return p10 = HEe(o10 ? { inputs: { x: m10 }, backend: n10, attrs: { shape: Z7(d10, u10) } } : { inputs: { x: m10 }, backend: n10, attrs: { shape: d10 } }), n10.disposeIntermediateTensorInfo(v10), n10.disposeIntermediateTensorInfo(m10), null != l10 && n10.disposeIntermediateTensorInfo(h10), p10;
      } }, bCe = p(function e10(t10, n10, r10) {
        l(this, e10), this.variableNames = ["A"];
        var a10 = t10.windowSize, i10 = t10.batchSize, o10 = t10.outSize;
        r10 || this.variableNames.push("bestIndicesA"), this.outputShape = [i10, o10];
        var s10 = "max" === n10 ? ">" : "<", u10 = r10 ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(a10, ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(a10, "; i++) {\n          int inIdx = ").concat(u10, ";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(s10, " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ");
      }), xCe = p(function e10(t10, n10, r10, a10) {
        l(this, e10), this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, F$(t10.length > 2, function() {
          return "Packed arg".concat(r10.charAt(0).toUpperCase() + r10.slice(1), " supports only inputs with rank above 2.");
        });
        var i10 = t10[t10.length - 1], o10 = Math.ceil(i10 / n10);
        this.outputShape = t10.slice(0, -1), o10 > 1 && this.outputShape.push(o10), a10 || this.variableNames.push("bestIndicesA");
        var s10, u10, c10 = this.outputShape, h10 = c10.length, p10 = cSe(h10), f10 = qTe("coords", h10);
        if (1 === o10) {
          var d10 = cSe(u10 = h10 + 1);
          s10 = "\n        ".concat(d10, " sourceLocR = ").concat(d10, "(").concat(f10.join(), ", 0);\n        ++").concat(f10[h10 - 1], ";\n        ").concat(d10, " sourceLocG = ").concat(d10, "(").concat(f10.join(), ", 0);\n        ++").concat(f10[h10 - 2], ";\n        ").concat(d10, " sourceLocA = ").concat(d10, "(").concat(f10.join(), ", 0);\n        --").concat(f10[h10 - 1], ";\n        ").concat(d10, " sourceLocB = ").concat(d10, "(").concat(f10.join(), ", 0);\n        --").concat(f10[h10 - 2], ";");
        } else u10 = h10, s10 = "\n        ".concat(p10, " sourceLocR = coords;\n        ++").concat(f10[h10 - 1], ";\n        ").concat(p10, " sourceLocG = coords;\n        ++").concat(f10[h10 - 2], ";\n        ").concat(p10, " sourceLocA = coords;\n        --").concat(f10[h10 - 1], ";\n        ").concat(p10, " sourceLocB = coords;\n        --").concat(f10[h10 - 2], ";");
        var v10 = ["x", "y", "z", "w", "u", "v"].slice(0, u10), m10 = "." + v10[u10 - 1], g10 = v10.map(function(e11) {
          return "int " + e11;
        }), y10 = qTe("sourceLocR", u10 - 1).concat("inIdx.r"), b10 = qTe("sourceLocG", u10 - 1).concat("inIdx.g"), x10 = qTe("sourceLocB", u10 - 1).concat("inIdx.b"), k10 = qTe("sourceLocA", u10 - 1).concat("inIdx.a"), w10 = "max" === r10 ? "greaterThan" : "lessThan", I10 = a10 ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(y10.join(), "),\n                             getBestIndicesAChannel(").concat(b10.join(), "),\n                             getBestIndicesAChannel(").concat(x10.join(), "),\n                             getBestIndicesAChannel(").concat(k10.join(), ")));"), N10 = "vec4(\n            getAChannel(".concat(y10.join(), "),\n            hasNextCol ? getAChannel(").concat(b10.join(), ") : 0.,\n            hasNextRow ? getAChannel(").concat(x10.join(), ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(k10.join(), ") : 0.)"), S10 = a10 ? "" : "\n      float getBestIndicesAChannel(".concat(g10.join(), ") {\n        return getChannel(getBestIndicesA(").concat(v10.join(), "),\n                                          vec2(").concat(v10.slice(-2).join(), "));\n      }");
        this.userCode = "\n      float getAChannel(".concat(g10.join(), ") {\n        return getChannel(getA(").concat(v10.join(), "),\n                               vec2(").concat(v10.slice(-2).join(), "));\n      }\n      ").concat(S10, "\n      void main() {\n        ").concat(p10, " coords = getOutputCoords();\n        bool hasNextCol = ").concat(f10[h10 - 1], " < ").concat(c10[h10 - 1] - 1, ";\n        bool hasNextRow = ").concat(f10[h10 - 2], " < ").concat(c10[h10 - 2] - 1, ";\n        ").concat(s10, "\n        ivec4 srcIdx = ivec4(sourceLocR").concat(m10, ", sourceLocG").concat(m10, ",\n          sourceLocB").concat(m10, ", sourceLocA").concat(m10, ") * ").concat(n10, ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(N10, ";\n\n        for (int i = 0; i < ").concat(n10, "; i++) {\n          inIdx = srcIdx;\n          ").concat(I10, "\n          vec4 candidate = ").concat(N10, ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(w10, "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ");
      });
      function kCe(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, a10 = t10.shape[0], i10 = t10.shape[1];
        null != r10 && (a10 = r10.shape[0], i10 = r10.shape[1]);
        var o10 = hie(i10), s10 = { windowSize: o10, inSize: i10, batchSize: a10, outSize: Math.ceil(i10 / o10) }, u10 = new bCe(s10, n10, null == r10), c10 = [t10];
        null != r10 && c10.push(r10);
        var l10 = e10.runWebGLProgram(u10, c10, "int32");
        if (1 === l10.shape[1]) return l10;
        var h10 = kCe(e10, t10, n10, l10);
        return e10.disposeIntermediateTensorInfo(l10), h10;
      }
      function wCe(e10, t10, n10) {
        var r10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, a10 = null != r10 ? r10.shape : t10.shape, i10 = a10[a10.length - 1], o10 = hie(i10), s10 = new xCe(a10, o10, n10, null == r10), u10 = null == r10 ? [t10] : [t10, r10], c10 = e10.runWebGLProgram(s10, u10, "int32");
        if (c10.shape.length === t10.shape.length) {
          var l10 = wCe(e10, t10, n10, c10);
          return e10.disposeIntermediateTensorInfo(c10), l10;
        }
        return c10;
      }
      function ICe(e10, t10, n10, r10) {
        var a10 = [n10];
        if (Q7("arg" + r10.charAt(0).toUpperCase() + r10.slice(1), a10, t10.shape.length), !k0().getBool("WEBGL_PACK_REDUCE") || t10.shape.length <= 2) {
          var i10 = [], o10 = e10.texData.get(t10.dataId), s10 = t10;
          null !== o10 && o10.isPacked && (s10 = e10.unpackTensor(t10), i10.push(s10));
          var u10 = S(J7(s10.shape, a10), 2), c10 = u10[0], l10 = L$(u10[1]), h10 = HEe({ inputs: { x: s10 }, backend: e10, attrs: { shape: [-1, l10] } });
          i10.push(h10);
          var p10 = kCe(e10, h10, r10);
          i10.push(p10);
          var f10 = HEe({ inputs: { x: p10 }, backend: e10, attrs: { shape: c10 } });
          return i10.forEach(function(t11) {
            return e10.disposeIntermediateTensorInfo(t11);
          }), f10;
        }
        return wCe(e10, t10, r10);
      }
      var NCe = { kernelName: _0, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = j$(r10.axis, a10.shape), o10 = $7(i10, a10.shape.length), s10 = a10, u10 = [];
        null != o10 && (s10 = tCe({ inputs: { x: a10 }, backend: n10, attrs: { perm: o10 } }), u10.push(s10), i10 = t9(i10.length, s10.shape.length)), Q7("argMax", [i10[0]], s10.shape.length);
        var c10 = ICe(n10, s10, i10[0], "max");
        return u10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), c10;
      } };
      var SCe = { kernelName: O0, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = j$(r10.axis, a10.shape), o10 = $7(i10, a10.shape.length), s10 = a10, u10 = [];
        null != o10 && (s10 = tCe({ inputs: { x: a10 }, backend: n10, attrs: { perm: o10 } }), u10.push(s10), i10 = t9(i10.length, s10.shape.length)), Q7("argMin", [i10[0]], s10.shape.length);
        var c10 = ICe(n10, s10, i10[0], "min");
        return u10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), c10;
      } }, TCe = MEe({ opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n" }), ECe = { kernelName: F0, backendName: "webgl", kernelFunc: TCe }, CCe = MEe({ opSnippet: "if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));" }), ACe = { kernelName: D0, backendName: "webgl", kernelFunc: CCe }, RCe = MEe({ opSnippet: "if (isnan(x)) return x;\n  return atan(x);\n" }), _Ce = { kernelName: M0, backendName: "webgl", kernelFunc: RCe }, OCe = LEe({ opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n", packedOpSnippet: "\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n" }), FCe = { kernelName: z0, backendName: "webgl", kernelFunc: OCe }, DCe = MEe({ opSnippet: "if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;" }), MCe = { kernelName: L0, backendName: "webgl", kernelFunc: DCe }, LCe = p(function e10(t10, n10, r10) {
        var a10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i10 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        if (l(this, e10), this.variableNames = ["x"], "avg" === n10 && r10) throw new Error("Cannot compute positions for average pool.");
        var o10 = t10.filterWidth, s10 = t10.strideHeight, u10 = t10.strideWidth, c10 = t10.dilationHeight, h10 = t10.dilationWidth, p10 = t10.effectiveFilterHeight, f10 = t10.effectiveFilterWidth, d10 = t10.padInfo.top, v10 = t10.padInfo.left;
        this.outputShape = t10.outShape;
        var m10 = "avg" === n10, g10 = "((batch  * ".concat(t10.inHeight, " + xR) * ").concat(t10.inWidth, " + xC) * ").concat(t10.inChannels, " + d"), y10 = "(xR * ".concat(t10.inWidth, " + xC) * ").concat(t10.inChannels, " + d"), b10 = "0.0";
        if (m10 || (b10 = "-1.0 / 1e-20"), r10) {
          var x10 = ">=";
          this.userCode = "\n        const ivec2 strides = ivec2(".concat(s10, ", ").concat(u10, ");\n        const ivec2 pads = ivec2(").concat(d10, ", ").concat(v10, ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(p10, ";\n              wR += ").concat(c10, ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(t10.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(f10, ";\n                wC += ").concat(h10, ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(t10.inWidth, ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(x10, " currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(a10 ? i10 ? g10 : y10 : "wR * ".concat(f10, " + wC"), ";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ");
        } else {
          var k10 = "max", w10 = "".concat(n10, "(").concat(n10, "(").concat(n10, "(") + "minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
          "avg" === n10 && (w10 = "avgValue / max(count, 1.0)");
          var I10 = 4 * Math.floor(o10 / 4), N10 = o10 % 4, S10 = "\n      if (".concat(m10, ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat(k10, "(values, minMaxValue);\n      }\n    ");
          this.userCode = "\n      const ivec2 strides = ivec2(".concat(s10, ", ").concat(u10, ");\n      const ivec2 pads = ivec2(").concat(d10, ", ").concat(v10, ");\n      const float initializationValue = ").concat(b10, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(t10.inWidth, ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(b10, ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(p10, ";\n            wR += ").concat(c10, ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(t10.inHeight, ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(I10, "; wC += 4) {\n            int xC = xCCorner + wC * ").concat(h10, ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(h10, ", d),\n              getValue(batch, xR, xC + 2 * ").concat(h10, ", d),\n              getValue(batch, xR, xC + 3 * ").concat(h10, ", d)\n            );\n\n            ").concat(S10, "\n          }\n\n          int xC = xCCorner + ").concat(I10, ";\n          if (").concat(1 === N10, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(S10, "\n          } else if (").concat(2 === N10, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(h10, ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(S10, "\n          } else if (").concat(3 === N10, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(h10, ", d),\n              getValue(batch, xR, xC + 2 * ").concat(h10, ", d),\n              initializationValue\n            );\n\n            ").concat(S10, "\n          }\n        }\n        setOutput(").concat(w10, ");\n      }\n    ");
        }
      }), zCe = p(function e10(t10, n10, r10) {
        var a10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i10 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        if (l(this, e10), this.variableNames = ["x"], "avg" === n10 && r10) throw new Error("Cannot compute positions for average pool.");
        var o10 = t10.filterWidth, s10 = t10.strideDepth, u10 = t10.strideHeight, c10 = t10.strideWidth, h10 = t10.dilationDepth, p10 = t10.dilationHeight, f10 = t10.dilationWidth, d10 = t10.effectiveFilterDepth, v10 = t10.effectiveFilterHeight, m10 = t10.effectiveFilterWidth, g10 = t10.padInfo.front, y10 = t10.padInfo.top, b10 = t10.padInfo.left;
        this.outputShape = t10.outShape;
        var x10 = "avg" === n10, k10 = "0.0";
        if (x10 || (k10 = "-1.0 / 1e-20"), r10) {
          var w10 = ">=";
          this.userCode = "\n        const ivec3 strides =\n            ivec3(".concat(s10, ", ").concat(u10, ", ").concat(c10, ");\n        const ivec3 pads = ivec3(").concat(g10, ", ").concat(y10, ", ").concat(b10, ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(d10, ";\n              wD += ").concat(h10, ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(t10.inDepth, ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(v10, ";\n                wR += ").concat(p10, ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(t10.inHeight, ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(m10, ";\n                  wC += ").concat(f10, ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(t10.inWidth, ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(w10, " currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(a10 ? i10 ? "(((batch * ".concat(t10.inDepth, " + xD) * ").concat(t10.inHeight, " + xR) * ").concat(t10.inWidth, " + xC) * ").concat(t10.inChannels, " + ch") : "((xD * ".concat(t10.inHeight, " + xR) * ").concat(t10.inWidth, " + xC) * ").concat(t10.inChannels, " + ch") : "wD * ".concat(v10, " * ").concat(m10, " +\n                      wR * ").concat(m10, " + wC"), ";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ");
        } else {
          var I10 = "max", N10 = "".concat(n10, "(").concat(n10, "(").concat(n10, "(") + "minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
          "avg" === n10 && (N10 = "avgValue / max(count, 1.0)");
          var S10 = 4 * Math.floor(o10 / 4), T10 = o10 % 4, E10 = "\n      if (".concat(x10, ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat(I10, "(values, minMaxValue);\n      }\n    ");
          this.userCode = "\n      const ivec3 strides =\n        ivec3(".concat(s10, ", ").concat(u10, ", ").concat(c10, ");\n      const ivec3 pads = ivec3(").concat(g10, ", ").concat(y10, ", ").concat(b10, ");\n      const float initializationValue = ").concat(k10, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(t10.inWidth, ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(k10, ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(d10, ";\n            wD += ").concat(h10, ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(t10.inDepth, ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(v10, ";\n            wR += ").concat(p10, ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(t10.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(S10, "; wC += 4) {\n              int xC = xCCorner + wC * ").concat(f10, ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(f10, ", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(f10, ", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(f10, ", ch)\n              );\n\n              ").concat(E10, "\n            }\n\n            int xC = xCCorner + ").concat(S10, ";\n            if (").concat(1 === T10, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(E10, "\n            } else if (").concat(2 === T10, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(f10, ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(E10, "\n            } else if (").concat(3 === T10, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(f10, ", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(f10, ", ch),\n                initializationValue\n              );\n\n              ").concat(E10, "\n            }\n          }\n        }\n        setOutput(").concat(N10, ");\n      }\n    ");
        }
      });
      var PCe = { kernelName: P0, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x;
        MNe(a10, "avgPool");
        var i10 = r10.filterSize, o10 = r10.strides, s10 = r10.pad, u10 = r10.dimRoundingMode;
        F$(j8(o10, 1), function() {
          return "Error in avgPool: Either strides or dilations must be 1. " + "Got strides ".concat(o10, " and dilations '").concat(1, "'");
        });
        var c10 = O8(a10.shape, i10, o10, 1, s10, u10);
        if (1 === c10.filterWidth && 1 === c10.filterHeight && P$(c10.inShape, c10.outShape)) return SEe({ inputs: { x: a10 }, backend: n10 });
        var l10 = new LCe(c10, "avg", false);
        return n10.runWebGLProgram(l10, [a10], "float32");
      } };
      var BCe = { kernelName: W0, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.filterSize, o10 = r10.strides, s10 = r10.pad, u10 = r10.dimRoundingMode, c10 = r10.dataFormat, l10 = F8(a10.shape, i10, o10, [1, 1, 1], s10, u10, c10), h10 = new zCe(l10, "avg", false);
        return n10.runWebGLProgram(h10, [a10], "float32");
      } }, WCe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["dy"], this.outputShape = t10.inShape;
        var n10 = t10.filterHeight, r10 = t10.filterWidth, a10 = t10.strideHeight, i10 = t10.strideWidth, o10 = t10.dilationHeight, s10 = t10.dilationWidth, u10 = t10.effectiveFilterHeight, c10 = t10.effectiveFilterWidth, h10 = u10 - 1 - t10.padInfo.top, p10 = c10 - 1 - t10.padInfo.left, f10 = 1 / (n10 * r10);
        this.userCode = "\n      const ivec2 pads = ivec2(".concat(h10, ", ").concat(p10, ");\n      const float avgMultiplier = float(").concat(f10, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(u10, ";\n            wR += ").concat(o10, ") {\n          float dyR = float(dyRCorner + wR) / ").concat(a10, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t10.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(c10, ";\n            wC+= ").concat(s10, ") {\n            float dyC = float(dyCCorner + wC) / ").concat(i10, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t10.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
      }), UCe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["dy"], this.outputShape = t10.inShape;
        var n10 = t10.filterDepth, r10 = t10.filterHeight, a10 = t10.filterWidth, i10 = t10.strideDepth, o10 = t10.strideHeight, s10 = t10.strideWidth, u10 = t10.dilationDepth, c10 = t10.dilationHeight, h10 = t10.dilationWidth, p10 = t10.effectiveFilterDepth, f10 = t10.effectiveFilterHeight, d10 = t10.effectiveFilterWidth, v10 = p10 - 1 - t10.padInfo.front, m10 = f10 - 1 - t10.padInfo.top, g10 = d10 - 1 - t10.padInfo.left, y10 = 1 / (n10 * r10 * a10);
        this.userCode = "\n      const ivec3 pads = ivec3(".concat(v10, ", ").concat(m10, ", ").concat(g10, ");\n      const float avgMultiplier = float(").concat(y10, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(p10, ";\n            wD += ").concat(u10, ") {\n          float dyD = float(dyDCorner + wD) / ").concat(i10, ".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(t10.outDepth, ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(f10, ";\n              wR += ").concat(c10, ") {\n            float dyR = float(dyRCorner + wR) / ").concat(o10, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t10.outHeight, ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(d10, ";\n                wC += ").concat(h10, ") {\n              float dyC = float(dyCCorner + wC) / ").concat(s10, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t10.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
      });
      var VCe = { kernelName: U0, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.dy, i10 = t10.input, o10 = r10.filterSize, s10 = r10.strides, u10 = r10.pad, c10 = r10.dimRoundingMode, l10 = F8(i10.shape, o10, s10, [1, 1, 1], u10, c10), h10 = new UCe(l10);
        return n10.runWebGLProgram(h10, [a10], i10.dtype);
      } };
      var GCe = { kernelName: B0, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.dy, i10 = t10.input, o10 = i10;
        MNe([a10, i10], "avgPoolGrad");
        var s10 = r10.filterSize, u10 = r10.strides, c10 = r10.pad, l10 = O8(o10.shape, s10, u10, 1, c10), h10 = new WCe(l10);
        return n10.runWebGLProgram(h10, [a10], o10.dtype);
      } };
      var jCe = { kernelName: V0, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs;
        return rCe({ a: t10.a, b: t10.b, transposeA: r10.transposeA, transposeB: r10.transposeB, backend: n10 });
      } }, HCe = p(function e10(t10, n10, r10, a10, i10, o10) {
        l(this, e10), this.outputShape = [], this.variableNames = ["x", "mean", "variance"], z7(t10, n10), z7(t10, r10);
        var s10 = "0.0";
        null != a10 && (z7(t10, a10), this.variableNames.push("offset"), s10 = "getOffsetAtOutCoords()");
        var u10 = "1.0";
        null != i10 && (z7(t10, i10), this.variableNames.push("scale"), u10 = "getScaleAtOutCoords()"), this.outputShape = t10, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(s10, ";\n        float scale = ").concat(u10, ";\n        float inv = scale * inversesqrt(variance + float(").concat(o10, "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ");
      }), qCe = p(function e10(t10, n10, r10, a10, i10, o10) {
        l(this, e10), this.packedInputs = true, this.packedOutput = true, this.variableNames = ["x", "mean", "variance"], z7(t10, n10), z7(t10, r10);
        var s10 = "vec4(0.0)";
        null != a10 && (z7(t10, a10), this.variableNames.push("offset"), s10 = "getOffsetAtOutCoords()");
        var u10 = "vec4(1.0)";
        null != i10 && (z7(t10, i10), this.variableNames.push("scale"), u10 = "getScaleAtOutCoords()"), this.outputShape = t10, this.userCode = "\n      void main() {\n        vec4 offset = ".concat(s10, ";\n        vec4 scale = ").concat(u10, ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(o10, "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ");
      }), KCe = { kernelName: M1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.mean, o10 = t10.variance, s10 = t10.offset, u10 = t10.scale;
        F$(i10.shape.length === o10.shape.length, function() {
          return "Batch normalization gradient requires mean and variance to have equal ranks.";
        }), F$(null == s10 || i10.shape.length === s10.shape.length, function() {
          return "Batch normalization gradient requires mean and offset to have equal ranks.";
        }), F$(null == u10 || i10.shape.length === u10.shape.length, function() {
          return "Batch normalization gradient requires mean and scale to have equal ranks.";
        });
        var c10 = r10.varianceEpsilon;
        null == c10 && (c10 = 1e-3);
        var l10 = [a10, i10, o10], h10 = null;
        null != s10 && (h10 = s10.shape, l10.push(s10));
        var p10 = null;
        null != u10 && (p10 = u10.shape, l10.push(u10));
        var f10 = k0().getBool("WEBGL_PACK_NORMALIZATION") ? new qCe(a10.shape, i10.shape, o10.shape, h10, p10, c10) : new HCe(a10.shape, i10.shape, o10.shape, h10, p10, c10);
        return n10.runWebGLProgram(f10, l10, l10[0].dtype);
      } }, XCe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["source"], this.outputShape = t10, this.rank = t10.length;
        var n10 = cSe(this.rank);
        this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
        var r10, a10 = function(e11) {
          if (1 === e11) return "sourceLoc";
          if (e11 <= 6) return YCe.slice(0, e11).map(function(e12) {
            return "sourceLoc." + e12;
          }).join(",");
          throw Error("Slicing for rank ".concat(e11, " is not yet supported"));
        }(this.rank), i10 = t10.map(function(e11, t11) {
          return "sourceLoc.".concat(YCe[t11], " = start[").concat(t11, "] + coords.").concat(YCe[t11], ";");
        });
        r10 = "\n        ".concat(n10, " sourceLoc;\n        ").concat(n10, " coords = getOutputCoords();\n        ").concat(i10.join("\n"), "\n      "), this.userCode = "\n      void main() {\n        ".concat(r10, "\n        setOutput(getSource(").concat(a10, "));\n      }\n    ");
      }), YCe = ["x", "y", "z", "w", "u", "v"];
      var JCe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["source"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t10, this.rank = t10.length, this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
        var n10 = cSe(this.rank), r10 = qTe("coords", this.rank), a10 = qTe("sourceLoc", this.rank), i10 = 1 === this.rank ? "sourceLoc" : "vec2(".concat(a10.slice(-2).join(), ")"), o10 = "getChannel(getSource(".concat(a10.join(), "), ").concat(i10, ")"), s10 = "\n      result.x = ".concat(o10, ";\n      if (++").concat(r10[this.rank - 1], " < ").concat(t10[this.rank - 1], ") {\n        ++").concat(a10[this.rank - 1], ";\n        result.y = ").concat(o10, ";\n        --").concat(a10[this.rank - 1], ";\n      }\n    "), u10 = 1 === this.rank ? "" : "\n      --".concat(r10[this.rank - 1], ";\n      if (++").concat(r10[this.rank - 2], " < ").concat(t10[this.rank - 2], ") {\n        ++").concat(a10[this.rank - 2], ";\n        result.z = ").concat(o10, ";\n        if (++").concat(r10[this.rank - 1], " < ").concat(t10[this.rank - 1], ") {\n          ++").concat(a10[this.rank - 1], ";\n          result.w = ").concat(o10, ";\n        }\n      }\n    "), c10 = this.rank <= 4 ? "sourceLoc = coords +\n            ".concat(n10, "(").concat(t10.map(function(e11, t11) {
          return "start[".concat(t11, "]");
        }).join(), ");") : t10.map(function(e11, t11) {
          return "".concat(a10[t11], " = ").concat(r10[t11], " + start[").concat(t11, "];");
        }).join("\n");
        this.userCode = "\n      void main() {\n        ".concat(n10, " coords = getOutputCoords();\n        ").concat(n10, " sourceLoc;\n        ").concat(c10, "\n        vec4 result = vec4(0.);\n        ").concat(s10, "\n        ").concat(u10, "\n        setOutput(result);\n      }\n    ");
      });
      function ZCe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = S(Yae(a10, r10.begin, r10.size), 2), o10 = i10[0], s10 = i10[1];
        if (zae(a10, o10, s10), 0 === L$(s10)) return n10.makeTensorInfo(s10, a10.dtype, []);
        if (n10.shouldExecuteOnCPU([a10]) || "string" === a10.dtype) {
          var u10 = n10.texData.get(a10.dataId), c10 = RTe(u10.values, o10, s10, a10.shape, a10.dtype);
          return n10.makeTensorInfo(s10, a10.dtype, c10);
        }
        var l10 = n10.texData.get(a10.dataId).isPacked, h10 = Kae(a10.shape, o10, s10);
        if (l10 || !h10) {
          var p10 = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new JCe(s10) : new XCe(s10), f10 = [o10];
          return n10.runWebGLProgram(p10, [a10], a10.dtype, f10);
        }
        return n10.uploadToGPU(a10.dataId), function(e11, t11, n11, r11) {
          var a11 = r11.texData.get(e11.dataId), i11 = r11.makeTensorInfo(n11, e11.dtype), o11 = r11.texData.get(i11.dataId);
          Object.assign(o11, a11), o11.refCount = 1, o11.shape = n11, o11.dtype = e11.dtype;
          var s11 = Xae(t11, i0(e11.shape));
          a11.slice && (s11 += a11.slice.flatOffset), o11.slice = { flatOffset: s11, origDataId: a11.slice && a11.slice.origDataId || e11.dataId };
          var u11 = r11.dataRefCount.get(o11.slice.origDataId) || 1;
          return r11.dataRefCount.set(o11.slice.origDataId, u11 + 1), i11;
        }(a10, o10, s10, n10);
      }
      var QCe = { kernelName: Z2, backendName: "webgl", kernelFunc: ZCe }, $Ce = { kernelName: G0, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.blockShape, o10 = r10.crops;
        F$(a10.shape.length <= 4, function() {
          return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
        });
        var s10 = i10.reduce(function(e11, t11) {
          return e11 * t11;
        }), u10 = fie(a10.shape, i10, s10), c10 = die(u10.length, i10.length), l10 = vie(a10.shape, i10, s10), h10 = mie(o10, i10.length), p10 = gie(l10, o10, i10.length), f10 = [], d10 = HEe({ inputs: { x: a10 }, backend: n10, attrs: { shape: u10 } }), v10 = tCe({ inputs: { x: d10 }, backend: n10, attrs: { perm: c10 } }), m10 = HEe({ inputs: { x: v10 }, backend: n10, attrs: { shape: l10 } }), g10 = ZCe({ inputs: { x: m10 }, backend: n10, attrs: { begin: h10, size: p10 } });
        return f10.push(d10), f10.push(v10), f10.push(m10), f10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), g10;
      } };
      var eAe = { kernelName: j0, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.weights, o10 = r10.size, s10 = n10.readSync(a10.dataId), u10 = n10.readSync(i10.dataId), c10 = ZSe(s10, u10, i10.dtype, i10.shape, o10);
        return n10.makeTensorInfo([o10], i10.dtype, c10);
      } };
      var tAe = { kernelName: H0, backendName: "webgl", kernelFunc: function(e10) {
        var t10, n10 = e10.inputs, r10 = e10.backend, a10 = n10.a, i10 = n10.b, o10 = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS"), s10 = k0().getNumber("WEBGL_VERSION");
        if (r10.shouldExecuteOnCPU([a10, i10]) || 1 === s10) {
          var u10 = r10.texData.get(a10.dataId).values, c10 = r10.texData.get(i10.dataId).values, l10 = S($Se(a10.shape, i10.shape, u10, c10, a10.dtype), 2), h10 = l10[0], p10 = l10[1], f10 = r10.makeTensorInfo(p10, a10.dtype);
          return r10.texData.get(f10.dataId).values = h10, f10;
        }
        return t10 = o10 ? new NEe("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n", a10.shape, i10.shape, false) : new wEe("\n  return float(int(a.r) & int(b.r));\n", a10.shape, i10.shape), r10.runWebGLProgram(t10, [a10, i10], a10.dtype);
      } };
      var nAe = { kernelName: K0, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.s0, a10 = t10.s1, i10 = n10.readSync(r10.dataId), o10 = n10.readSync(a10.dataId), s10 = z7(Array.from(i10), Array.from(o10));
        return n10.makeTensorInfo([s10.length], "int32", Int32Array.from(s10));
      } }, rAe = LEe({ opSnippet: "return float(a != b);", cpuKernelImpl: xTe, dtype: "bool" }), aAe = { kernelName: b2, backendName: "webgl", kernelFunc: rAe };
      function iAe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.input;
        return SEe({ inputs: { x: n10.texData.get(r10.dataId).complexTensorInfos.real }, backend: n10 });
      }
      var oAe = { kernelName: D2, backendName: "webgl", kernelFunc: iAe };
      var sAe = { kernelName: X0, backendName: "webgl", kernelFunc: function e10(t10) {
        var n10 = t10.inputs, r10 = t10.backend, a10 = t10.attrs, i10 = n10.x, o10 = a10.dtype;
        if ("complex64" === o10) {
          if ("complex64" === i10.dtype) return SEe({ inputs: { x: i10 }, backend: r10 });
          var s10 = $9(i10.shape), u10 = e10({ inputs: { x: i10 }, backend: r10, attrs: { dtype: "float32" } }), c10 = EEe({ inputs: { real: u10, imag: s10 }, backend: r10 });
          return s10.dispose(), r10.disposeIntermediateTensorInfo(u10), c10;
        }
        if ("complex64" === i10.dtype) {
          var l10 = iAe({ inputs: { input: i10 }, backend: r10 }), h10 = e10({ inputs: { x: l10 }, backend: r10, attrs: { dtype: o10 } });
          return r10.disposeIntermediateTensorInfo(l10), h10;
        }
        if (!J$(i10.dtype, o10)) {
          var p10 = SEe({ inputs: { x: i10 }, backend: r10 });
          return { dataId: p10.dataId, shape: p10.shape, dtype: o10 };
        }
        if (r10.shouldExecuteOnCPU([i10])) {
          var f10 = r10.texData.get(i10.dataId).values, d10 = S(eTe(f10, i10.shape, i10.dtype, o10), 3), v10 = d10[0], m10 = d10[1], g10 = d10[2];
          return r10.makeTensorInfo(v10, m10, g10);
        }
        if ("int32" === o10) return function(e11, t11) {
          var n11 = new $Te(e11.shape, "return float(int(x));"), r11 = t11.runWebGLProgram(n11, [e11], "int32");
          return { dataId: r11.dataId, shape: r11.shape, dtype: r11.dtype };
        }(i10, r10);
        if ("bool" === o10) {
          var y10 = r10.makeTensorInfo([], "bool", q$("bool", 1)), b10 = rAe({ inputs: { a: i10, b: y10 }, backend: r10 });
          return r10.disposeIntermediateTensorInfo(y10), b10;
        }
        throw new Error("Error in Cast: failed to cast ".concat(i10.dtype, " to ").concat(o10));
      } }, uAe = "return ceil(x);", cAe = MEe({ opSnippet: uAe, packedOpSnippet: uAe, cpuKernelImpl: tTe }), lAe = { kernelName: Y0, backendName: "webgl", kernelFunc: cAe }, hAe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["A"], this.customUniforms = [{ name: "minVal", type: "float" }, { name: "maxVal", type: "float" }], this.outputShape = t10, this.userCode = "\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
      }), pAe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "minVal", type: "float" }, { name: "maxVal", type: "float" }], this.outputShape = t10, this.userCode = "\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
      });
      var fAe = { kernelName: J0, backendName: "webgl", kernelFunc: function(e10) {
        var t10, n10 = e10.inputs, r10 = e10.backend, a10 = e10.attrs, i10 = n10.x, o10 = a10.clipValueMin, s10 = a10.clipValueMax;
        t10 = k0().getBool("WEBGL_PACK_CLIP") ? new pAe(i10.shape) : new hAe(i10.shape);
        var u10 = [[o10], [s10]];
        return r10.runWebGLProgram(t10, [i10], i10.dtype, u10);
      } }, dAe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["real", "imag"], this.outputShape = t10, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
      });
      function vAe(e10, t10) {
        return { dataId: t10.dataId, dtype: t10.dtype, shape: e10.shape };
      }
      var mAe = { kernelName: Q0, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.x, a10 = n10.texData.get(r10.dataId), i10 = new dAe(r10.shape), o10 = [vAe(r10, a10.complexTensorInfos.real), vAe(r10, a10.complexTensorInfos.imag)];
        return n10.runWebGLProgram(i10, o10, o10[0].dtype);
      } }, gAe = p(function e10(t10) {
        l(this, e10), this.outputShape = [], this.outputShape = oie(t10, 1), this.variableNames = t10.map(function(e11, t11) {
          return "T".concat(t11);
        });
        var n10 = new Array(t10.length - 1);
        n10[0] = t10[0][1];
        for (var r10 = 1; r10 < n10.length; r10++) n10[r10] = n10[r10 - 1] + t10[r10][1];
        for (var a10 = ["if (yC < ".concat(n10[0], ") setOutput(getT0(yR, yC));")], i10 = 1; i10 < n10.length; i10++) {
          var o10 = n10[i10 - 1];
          a10.push("else if (yC < ".concat(n10[i10], ") ") + "setOutput(getT".concat(i10, "(yR, yC-").concat(o10, "));"));
        }
        var s10 = n10.length, u10 = n10[n10.length - 1];
        a10.push("else setOutput(getT".concat(s10, "(yR, yC-").concat(u10, "));")), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(a10.join("\n        "), "\n      }\n    ");
      }), yAe = p(function e10(t10, n10) {
        l(this, e10), this.packedInputs = true, this.packedOutput = true, this.outputShape = [], this.outputShape = oie(t10, n10);
        var r10 = this.outputShape, a10 = r10.length, i10 = cSe(a10), o10 = qTe("coords", a10), s10 = ["x", "y", "z", "w", "u", "v"].slice(0, a10);
        this.variableNames = t10.map(function(e11, t11) {
          return "T".concat(t11);
        });
        var u10 = new Array(t10.length - 1);
        u10[0] = t10[0][n10];
        for (var c10 = 1; c10 < u10.length; c10++) u10[c10] = u10[c10 - 1] + t10[c10][n10];
        for (var h10 = s10[n10], p10 = s10.slice(-2), f10 = s10.join(), d10 = "if (".concat(h10, " < ").concat(u10[0], ") {\n        return getChannel(\n            getT0(").concat(f10, "), vec2(").concat(p10.join(), "));\n        }"), v10 = 1; v10 < u10.length; v10++) {
          var m10 = u10[v10 - 1];
          d10 += "\n        if (".concat(h10, " < ").concat(u10[v10], "  && ").concat(h10, " >= ").concat(u10[v10 - 1], ") {\n          return getChannel(\n            getT").concat(v10, "(").concat(bAe(s10, h10, m10), "),\n            vec2(").concat(bAe(p10, h10, m10), "));\n        }");
        }
        var g10 = u10.length, y10 = u10[u10.length - 1];
        d10 += "\n        return getChannel(\n          getT".concat(g10, "(").concat(bAe(s10, h10, y10), "),\n          vec2(").concat(bAe(p10, h10, y10), "));"), this.userCode = "\n      float getValue(".concat(s10.map(function(e11) {
          return "int " + e11;
        }), ") {\n        ").concat(d10, "\n      }\n\n      void main() {\n        ").concat(i10, " coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(o10, "), 0., 0., 0.);\n\n        ").concat(o10[a10 - 1], " = ").concat(o10[a10 - 1], " + 1;\n        if (").concat(o10[a10 - 1], " < ").concat(r10[a10 - 1], ") {\n          result.g = getValue(").concat(o10, ");\n        }\n\n        ").concat(o10[a10 - 2], " = ").concat(o10[a10 - 2], " + 1;\n        if (").concat(o10[a10 - 2], " < ").concat(r10[a10 - 2], ") {\n          result.a = getValue(").concat(o10, ");\n        }\n\n        ").concat(o10[a10 - 1], " = ").concat(o10[a10 - 1], " - 1;\n        if (").concat(o10[a10 - 2], " < ").concat(r10[a10 - 2], " &&\n            ").concat(o10[a10 - 1], " < ").concat(r10[a10 - 1], ") {\n          result.b = getValue(").concat(o10, ");\n        }\n        setOutput(result);\n      }\n    ");
      });
      function bAe(e10, t10, n10) {
        var r10 = e10.indexOf(t10);
        return e10.map(function(e11, t11) {
          return t11 === r10 ? "".concat(e11, " - ").concat(n10) : e11;
        }).join();
      }
      function xAe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.input;
        return SEe({ inputs: { x: n10.texData.get(r10.dataId).complexTensorInfos.imag }, backend: n10 });
      }
      var kAe = { kernelName: V1, backendName: "webgl", kernelFunc: xAe };
      function wAe(e10, t10, n10) {
        var r10 = e10[0].dtype;
        if ("complex64" === r10) {
          var a10 = e10.map(function(e11) {
            return iAe({ inputs: { input: e11 }, backend: n10 });
          }), i10 = e10.map(function(e11) {
            return xAe({ inputs: { input: e11 }, backend: n10 });
          }), o10 = wAe(a10, t10, n10), s10 = wAe(i10, t10, n10), u10 = EEe({ inputs: { real: o10, imag: s10 }, backend: n10 });
          return a10.forEach(function(e11) {
            return n10.disposeIntermediateTensorInfo(e11);
          }), i10.forEach(function(e11) {
            return n10.disposeIntermediateTensorInfo(e11);
          }), n10.disposeIntermediateTensorInfo(o10), n10.disposeIntermediateTensorInfo(s10), u10;
        }
        var c10 = n10.shouldExecuteOnCPU(e10);
        if ("string" === r10 && (c10 = true), c10) {
          var l10 = e10.map(function(e11) {
            var r11 = L$(e11.shape.slice(t10));
            return HEe({ inputs: { x: e11 }, backend: n10, attrs: { shape: [-1, r11] } });
          }), h10 = l10.map(function(e11) {
            return { vals: n10.readSync(e11.dataId), shape: e11.shape };
          }), p10 = oie(l10.map(function(e11) {
            return e11.shape;
          }), 1), f10 = 1 === l10[0].shape[0], d10 = nTe(h10, p10, r10, f10), v10 = oie(e10.map(function(e11) {
            return e11.shape;
          }), t10), m10 = n10.makeTensorInfo(v10, r10, d10);
          return l10.forEach(function(e11) {
            return n10.disposeIntermediateTensorInfo(e11);
          }), m10;
        }
        var g10 = e10.filter(function(e11) {
          return L$(e11.shape) > 0;
        }), y10 = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && g10[0].shape.length > 1;
        if (1 === g10.length) {
          var b10 = y10 ? new $Te(e10[0].shape, oEe) : new fEe(e10[0].shape, oEe);
          return n10.runWebGLProgram(b10, e10, r10);
        }
        var x10 = k0().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
        if (g10.length > x10) {
          for (var k10 = [], w10 = 0; w10 < g10.length; w10 += x10) {
            var I10 = g10.slice(w10, w10 + x10);
            k10.push(wAe(I10, t10, n10));
          }
          for (var N10 = wAe(k10, t10, n10), S10 = 0, T10 = k10; S10 < T10.length; S10++) {
            var E10 = T10[S10];
            n10.disposeIntermediateTensorInfo(E10);
          }
          return N10;
        }
        if (y10) {
          var C10 = new yAe(g10.map(function(e11) {
            return e11.shape;
          }), t10);
          return n10.runWebGLProgram(C10, g10, r10);
        }
        var A10 = function(e11, t11, n11) {
          var r11 = oie(e11.map(function(e12) {
            return e12.shape;
          }), t11);
          return { tensors2D: e11.map(function(e12) {
            return HEe({ inputs: { x: e12 }, attrs: { shape: [-1, L$(e12.shape.slice(t11))] }, backend: n11 });
          }), outShape: r11 };
        }(g10, t10, n10), R10 = A10.tensors2D, _10 = A10.outShape, O10 = new gAe(R10.map(function(e11) {
          return e11.shape;
        })), F10 = n10.runWebGLProgram(O10, R10, r10);
        R10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        });
        var D10 = HEe({ inputs: { x: F10 }, attrs: { shape: _10 }, backend: n10 });
        return n10.disposeIntermediateTensorInfo(F10), D10;
      }
      function IAe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = j$(e10.attrs.axis, t10[0].shape)[0];
        iie(t10.map(function(e11) {
          return e11.shape;
        }), r10);
        var a10 = oie(t10.map(function(e11) {
          return e11.shape;
        }), r10);
        if (0 === L$(a10)) return n10.makeTensorInfo(a10, t10[0].dtype, []);
        var i10 = t10.filter(function(e11) {
          return L$(e11.shape) > 0;
        });
        return 1 === i10.length ? SEe({ inputs: { x: i10[0] }, backend: n10 }) : wAe(i10, r10, n10);
      }
      var NAe = { kernelName: $0, backendName: "webgl", kernelFunc: IAe }, SAe = p(function e10(t10) {
        var n10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i10 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        l(this, e10), this.variableNames = ["x", "W"], this.outputShape = t10.outShape;
        var o10 = t10.padInfo.top, s10 = t10.padInfo.left, u10 = t10.strideHeight, c10 = t10.strideWidth, h10 = t10.dilationHeight, p10 = t10.dilationWidth, f10 = t10.filterHeight, d10 = t10.filterWidth, v10 = 4 * Math.floor(t10.inChannels / 4), m10 = t10.inChannels % 4, g10 = "channelsLast" === t10.dataFormat, y10 = g10 ? 1 : 2, b10 = g10 ? 2 : 3, x10 = g10 ? 3 : 1, k10 = "", w10 = "";
        r10 && (k10 = a10 ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(r10, "\n        }") : i10 ? "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(r10, "\n        }") : "\n          float activation(float x) {\n            ".concat(r10, "\n          }\n        "), w10 = "result = activation(result);");
        var I10 = n10 ? "result += getBiasAtOutCoords();" : "";
        n10 && this.variableNames.push("bias"), a10 && this.variableNames.push("preluActivationWeights"), i10 && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(k10, "\n\n      const ivec2 strides = ivec2(").concat(u10, ", ").concat(c10, ");\n      const ivec2 pads = ivec2(").concat(o10, ", ").concat(s10, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(x10, "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(y10, "], coords[").concat(b10, "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(f10, "; wR++) {\n          int xR = xRCorner + wR * ").concat(h10, ";\n\n          if (xR < 0 || xR >= ").concat(t10.inHeight, ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(d10, "; wC++) {\n            int xC = xCCorner + wC * ").concat(p10, ";\n\n            if (xC < 0 || xC >= ").concat(t10.inWidth, ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(v10, "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(g10, ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1 === m10, ") {\n\n              if (").concat(g10, ") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(v10, ") *\n                    getW(wR, wC, ").concat(v10, ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(v10, ", xR, xC) *\n                    getW(wR, wC, ").concat(v10, ", d2);\n              }\n\n            } else if (").concat(2 === m10, ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(v10, ", d2),\n                getW(wR, wC, ").concat(v10, " + 1, d2)\n              );\n\n              if (").concat(g10, ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(v10, "),\n                  getX(batch, xR, xC, ").concat(v10, " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(v10, ", xR, xC),\n                  getX(batch, ").concat(v10, " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3 === m10, ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(v10, ", d2),\n                getW(wR, wC, ").concat(v10, " + 1, d2),\n                getW(wR, wC, ").concat(v10, " + 2, d2)\n              );\n\n              if (").concat(g10, ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(v10, "),\n                  getX(batch, xR, xC, ").concat(v10, " + 1),\n                  getX(batch, xR, xC, ").concat(v10, " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(v10, ", xR, xC),\n                  getX(batch, ").concat(v10, " + 1, xR, xC),\n                  getX(batch, ").concat(v10, " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(I10, "\n        ").concat(w10, "\n        setOutput(result);\n      }\n    ");
      }), TAe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["x", "W"], this.outputShape = t10.outShape;
        var n10 = t10.padInfo.front, r10 = t10.padInfo.top, a10 = t10.padInfo.left, i10 = t10.strideDepth, o10 = t10.strideHeight, s10 = t10.strideWidth, u10 = t10.dilationDepth, c10 = t10.dilationHeight, h10 = t10.dilationWidth, p10 = t10.filterDepth, f10 = t10.filterHeight, d10 = t10.filterWidth, v10 = 4 * Math.floor(t10.inChannels / 4), m10 = t10.inChannels % 4;
        this.userCode = "\n      const ivec3 strides = ivec3(".concat(i10, ", ").concat(o10, ", ").concat(s10, ");\n      const ivec3 pads = ivec3(").concat(n10, ", ").concat(r10, ", ").concat(a10, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(p10, "; wF++) {\n          int xF = xFCorner + wF * ").concat(u10, ";\n\n          if (xF < 0 || xF >= ").concat(t10.inDepth, ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(f10, "; wR++) {\n            int xR = xRCorner + wR * ").concat(c10, ";\n\n            if (xR < 0 || xR >= ").concat(t10.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d10, "; wC++) {\n              int xC = xCCorner + wC * ").concat(h10, ";\n\n              if (xC < 0 || xC >= ").concat(t10.inWidth, ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(v10, "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1 === m10, ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(v10, ") *\n                  getW(wF, wR, wC, ").concat(v10, ", d2);\n              } else if (").concat(2 === m10, ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(v10, "),\n                  getX(batch, xF, xR, xC, ").concat(v10, " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(v10, ", d2),\n                  getW(wF, wR, wC, ").concat(v10, " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3 === m10, ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(v10, "),\n                  getX(batch, xF, xR, xC, ").concat(v10, " + 1),\n                  getX(batch, xF, xR, xC, ").concat(v10, " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(v10, ", d2),\n                  getW(wF, wR, wC, ").concat(v10, " + 1, d2),\n                  getW(wF, wR, wC, ").concat(v10, " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
      }), EAe = p(function e10(t10) {
        var n10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i10 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        l(this, e10), this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "pads", type: "ivec2" }, { name: "strides", type: "ivec2" }, { name: "dilations", type: "ivec2" }, { name: "inDims", type: "ivec2" }], this.outputShape = t10.outShape, this.enableShapeUniforms = ySe(this.outputShape.length);
        for (var o10 = t10.padInfo.left, s10 = t10.strideWidth, u10 = t10.dilationWidth, c10 = t10.filterHeight, h10 = t10.filterWidth, p10 = h10, f10 = "\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;", d10 = 0; d10 < h10; d10++) f10 += "\n           vec4 xTexelC".concat(2 * d10, ";\n           int xTexelC").concat(2 * d10, "Ready;\n           vec4 xTexelC").concat(2 * d10 + 1, ";\n           int xTexelC").concat(2 * d10 + 1, "Ready;\n           vec4 xC").concat(d10, ";");
        f10 += "\n     for (int r = 0; r < ".concat(c10, "; r++) {\n      for (int d1 = 0; d1 < ").concat(t10.inChannels, "; d1 += 2) {\n       ");
        for (var v10 = 0; v10 < h10; v10++) f10 += "\n           xTexelC".concat(2 * v10, " = vec4(0.0);\n           xTexelC").concat(2 * v10, "Ready = 0;\n           xTexelC").concat(2 * v10 + 1, " = vec4(0.0);\n           xTexelC").concat(2 * v10 + 1, "Ready = 0;\n           xC").concat(v10, " = vec4(0.0);");
        f10 += "\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";
        for (var m10 = 0; m10 < (p10 + 1) / 2; m10++) {
          var g10 = 2 * m10;
          if (f10 += "\n           xC = xCCorner + ".concat(g10 * u10, ";\n           "), 1 === s10) {
            if (g10 < h10 && (o10 % 2 == 1 ? (f10 += "\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(g10, "Ready == 0) {\n                   xTexelC").concat(g10, " = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(g10, ".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(g10, "Ready = 1;\n                 }\n               "), f10 += 1 === u10 && g10 > 0 ? "\n                 xC".concat(g10, " = vec4(xTexelC").concat(g10 - 2, ".zw, xTexelC").concat(g10, ".xy);\n                 ") : "\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(g10, " = vec4(previous.zw, xTexelC").concat(g10, ".xy);\n                   } else {\n                     xC").concat(g10, " = vec4(0.0, 0.0, xTexelC").concat(g10, ".xy);\n                   }\n                   ")) : f10 += "\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(g10, "Ready == 0) {\n                   xTexelC").concat(g10, " = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(g10, ".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(g10, "Ready = 1;\n                 }\n\n                 xC").concat(g10, " = xTexelC").concat(g10, ";\n                 "), g10 + 1 < h10)) {
              var y10 = o10 % 2 == 0 ? R$(u10) : u10;
              u10 % 2 == 0 && o10 % 2 == 1 || u10 % 2 != 0 && o10 % 2 != 1 ? (f10 += "\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(y10, ";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(g10 + 1, "Ready == 0) {\n                     xTexelC").concat(g10 + 1, " = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(g10 + 1, ".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(g10 + 1, "Ready = 1;\n                   }\n                   "), f10 += u10 > 1 ? "\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(g10 + 1, " = vec4(previous.zw, xTexelC").concat(g10 + 1, ".xy);\n                     } else {\n                      xC").concat(g10 + 1, " = vec4(0.0, 0.0, xTexelC").concat(g10 + 1, ".xy);\n                     }\n                     ") : "\n                     xC".concat(g10 + 1, " = vec4(xTexelC").concat(g10, ".zw, xTexelC").concat(g10 + 1, ".xy);\n                     ")) : f10 += 1 === y10 ? "\n                     xC".concat(g10 + 1, " = xTexelC").concat(g10, ";\n                     ") : "\n                     xCOffset = xC + ".concat(y10, ";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(g10 + 1, "Ready == 0) {\n                       xTexelC").concat(g10 + 1, " = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(g10 + 1, ".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(g10 + 1, "Ready = 1;\n                     }\n\n                     xC").concat(g10 + 1, " = xTexelC").concat(g10 + 1, ";\n                     ");
            }
          } else g10 < h10 && (o10 % 2 == 1 ? (f10 += "\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(g10, "Ready == 0) {\n                   xTexelC").concat(g10, " = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(g10, ".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(g10, "Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(g10 + 1, "Ready == 0) {\n                   xTexelC").concat(g10 + 1, " = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(g10 + 1, ".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(g10 + 1, "Ready = 1;\n                 }\n\n                 xC").concat(g10, " = vec4(xTexelC").concat(g10, ".zw, xTexelC").concat(g10 + 1, ".zw);\n               "), g10 + 1 < h10 && (f10 += "\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(g10 + 1, " = vec4(xTexelC").concat(g10 + 1, ".xy, final.xy);\n                 "))) : (f10 += "\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(g10, "Ready == 0) {\n                   xTexelC").concat(g10, " = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(g10, ".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(g10, "Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(g10 + 1, "Ready == 0) {\n                   xTexelC").concat(g10 + 1, " = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(g10 + 1, ".zw = vec2(0.);\n                   }\n                   xTexelC").concat(g10 + 1, "Ready = 1;\n                 }\n\n                 xC").concat(g10, " = vec4(\n                   xTexelC").concat(g10, ".xy, xTexelC").concat(g10 + 1, ".xy);\n               "), g10 + 1 < h10 && (f10 += "\n                   xC".concat(g10 + 1, " = vec4(xTexelC").concat(g10, ".zw, xTexelC").concat(g10 + 1, ".zw);\n                 "))));
          g10 < h10 && (f10 += "\n             wTexel = getW(r, ".concat(g10, ", d1, d2);\n             dotProd += xC").concat(g10, ".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(t10.inChannels, ") {\n               dotProd += xC").concat(g10, ".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "), g10 + 1 < h10 && (f10 += "\n               wTexel = getW(r, ".concat(g10 + 1, ", d1, d2);\n               dotProd += xC").concat(g10 + 1, ".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(t10.inChannels, ") {\n                 dotProd += xC").concat(g10 + 1, ".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")));
        }
        f10 += "\n     }\n   ", f10 += "\n     }\n   ", f10 += "\n     }\n   ";
        var b10 = "", x10 = "";
        r10 && (b10 = a10 ? "vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(r10, "\n         }") : i10 ? "vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(r10, "\n         }") : "vec4 activation(vec4 x) {\n           ".concat(r10, "\n         }"), x10 = "result = activation(result);");
        var k10 = n10 ? "result += getBiasAtOutCoords();" : "";
        n10 && this.variableNames.push("bias"), a10 && this.variableNames.push("preluActivationWeights"), i10 && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n       ".concat(b10, "\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(f10, "\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(k10, "\n         ").concat(x10, "\n         setOutput(result);\n       }\n     ");
      }), CAe = p(function e10(t10, n10) {
        l(this, e10), this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "inputShape", type: "ivec4" }, { name: "pad", type: "ivec2" }, { name: "stride", type: "ivec2" }, { name: "dilation", type: "ivec2" }, { name: "inChannels", type: "int" }, { name: "itemsPerBlockRow", type: "int" }, { name: "outWidth", type: "int" }], this.outputShape = t10, this.enableShapeUniforms = ySe(this.outputShape.length);
        for (var r10 = n10.dataFormat, a10 = PNe(), i10 = "channelsLast" === r10, o10 = i10 ? 1 : 2, s10 = i10 ? 2 : 3, u10 = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : "if(blockIndex < ".concat(t10[2], " && pos < ").concat(t10[1], ") {"), c10 = "", h10 = 0; h10 <= 1; h10++) for (var p10 = 0; p10 <= 1; p10++) c10 += "\n          blockIndex = rc.z + ".concat(p10, ";\n          pos = rc.y + ").concat(h10, ";\n\n          ").concat(u10, "\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(o10, "] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(s10, "] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(i10, ") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2 * h10 + p10, "] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2 * h10 + p10, "] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");
        this.userCode = "\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(c10, "\n\n        ").concat(a10.output, " = result;\n      }\n    ");
      });
      function AAe(e10, t10) {
        var n10 = e10.length;
        return n10 >= 3 ? [].concat(T(e10.slice(0, -3)), t10 ? [e10[n10 - 3] * e10[n10 - 2], e10[n10 - 1]] : [e10[n10 - 3], e10[n10 - 2] * e10[n10 - 1]]) : !t10 && 1 === n10 && e10[0] > 1 ? [e10[0], 1] : null;
      }
      function RAe(e10) {
        var t10, n10 = e10.x, r10 = e10.filter, a10 = e10.convInfo, i10 = e10.backend, o10 = e10.bias, s10 = void 0 === o10 ? null : o10, u10 = e10.preluActivationWeights, c10 = void 0 === u10 ? null : u10, l10 = e10.leakyreluAlpha, h10 = void 0 === l10 ? 0 : l10, p10 = e10.activation, f10 = void 0 === p10 ? null : p10, d10 = n10.shape, v10 = i10.texData.get(n10.dataId), m10 = a10.inChannels, g10 = d10[0] * d10[1] * d10[2], y10 = a10.outChannels, b10 = "channelsLast" === a10.dataFormat, x10 = [];
        if (null != c10) {
          var k10 = AAe(c10.shape, b10);
          null != k10 && (c10 = HEe({ inputs: { x: c10 }, backend: i10, attrs: { shape: k10 } }), x10.push(c10));
        }
        if (null != s10) {
          var w10 = AAe(s10.shape, b10);
          null != w10 && (s10 = HEe({ inputs: { x: s10 }, backend: i10, attrs: { shape: w10 } }), x10.push(s10));
        }
        if (!((1 === g10 || 1 === y10) && m10 > 1e3) && v10.isPacked && b10 && null != v10.texture && d10[2] % 2 != 0 && P$(v10.shape.slice(-3), d10.slice(-3))) {
          var I10 = d10[0] * d10[1] * (d10[2] + 1), N10 = { dataId: n10.dataId, shape: [1, I10, a10.inChannels], dtype: n10.dtype }, S10 = v10.shape;
          v10.shape = v10.shape.slice(), v10.shape[v10.shape.length - 2]++, F$(SNe(v10.shape, N10.shape), function() {
            return "packed reshape ".concat(v10.shape, " to ").concat(N10.shape, " isn't free");
          });
          var T10 = HEe({ inputs: { x: r10 }, backend: i10, attrs: { shape: [1, a10.inChannels, a10.outChannels] } });
          x10.push(T10);
          var E10 = rCe({ a: N10, b: T10, backend: i10, transposeA: false, transposeB: false, bias: s10, activation: f10, preluActivationWeights: c10, leakyreluAlpha: h10 }), C10 = i10.texData.get(E10.dataId);
          F$(C10.isPacked, function() {
            return "batchMatMul result is expected to be packed";
          }), v10.shape = S10, C10.shape = a10.outShape, (t10 = SEe({ inputs: { x: E10 }, backend: i10 })).shape = a10.outShape, x10.push(E10);
        } else {
          var A10 = a10.outHeight * a10.outWidth, R10 = HEe({ inputs: { x: n10 }, backend: i10, attrs: { shape: b10 ? [a10.batchSize, A10, a10.inChannels] : [a10.batchSize, a10.inChannels, A10] } }), _10 = HEe({ inputs: { x: r10 }, backend: i10, attrs: { shape: [1, a10.inChannels, a10.outChannels] } }), O10 = rCe({ a: b10 ? R10 : _10, b: b10 ? _10 : R10, transposeA: !b10, transposeB: false, backend: i10, bias: s10, activation: f10, preluActivationWeights: c10, leakyreluAlpha: h10 });
          t10 = HEe({ inputs: { x: O10 }, backend: i10, attrs: { shape: a10.outShape } }), x10.push(R10), x10.push(_10), x10.push(O10);
        }
        for (var F10 = 0, D10 = x10; F10 < D10.length; F10++) {
          var M10 = D10[F10];
          i10.disposeIntermediateTensorInfo(M10);
        }
        return t10;
      }
      function _Ae(e10) {
        var t10 = e10.x, n10 = e10.filter, r10 = e10.convInfo, a10 = e10.backend, i10 = e10.bias, o10 = void 0 === i10 ? null : i10, s10 = e10.preluActivationWeights, u10 = void 0 === s10 ? null : s10, c10 = e10.leakyreluAlpha, l10 = void 0 === c10 ? 0 : c10, h10 = e10.activation, p10 = void 0 === h10 ? null : h10, f10 = r10.filterWidth, d10 = r10.filterHeight, v10 = r10.inChannels, m10 = r10.outWidth, g10 = r10.outHeight, y10 = "channelsLast" === r10.dataFormat, b10 = f10 * d10 * v10, x10 = g10 * m10, k10 = [r10.batchSize, b10, x10], w10 = [];
        if (null != u10) {
          var I10 = AAe(u10.shape, y10);
          null != I10 && (u10 = HEe({ inputs: { x: u10 }, backend: a10, attrs: { shape: I10 } }), w10.push(u10));
        }
        if (null != o10) {
          var N10 = AAe(o10.shape, y10);
          null != N10 && (o10 = HEe({ inputs: { x: o10 }, backend: a10, attrs: { shape: N10 } }), w10.push(o10));
        }
        var S10 = HEe({ inputs: { x: n10 }, backend: a10, attrs: { shape: [1, b10, L$(n10.shape) / b10] } });
        w10.push(S10);
        var T10 = new CAe(k10, r10), E10 = [t10.shape, [r10.padInfo.top, r10.padInfo.left], [r10.strideHeight, r10.strideWidth], [r10.dilationHeight, r10.dilationWidth], [r10.inChannels], [r10.filterWidth * r10.inChannels], [r10.outWidth]], C10 = a10.runWebGLProgram(T10, [t10], "float32", E10), A10 = HEe({ inputs: { x: C10 }, backend: a10, attrs: { shape: k10 } });
        w10.push(C10), w10.push(A10);
        var R10 = null != o10, _10 = null != u10, O10 = "leakyrelu" === p10, F10 = p10 ? zEe(p10, true) : null, D10 = new PEe(y10 ? A10.shape : S10.shape, y10 ? S10.shape : A10.shape, y10 ? [r10.batchSize, x10, r10.outChannels] : [r10.batchSize, r10.outChannels, x10], true, false, R10, F10, _10, O10), M10 = y10 ? [A10, S10] : [S10, A10];
        if (o10 && M10.push(o10), _10 && M10.push(u10), O10) {
          var L10 = a10.makeTensorInfo([], "float32", M4(l10, "float32"));
          M10.push(L10), w10.push(L10);
        }
        var z10 = a10.runWebGLProgram(D10, M10, "float32"), P10 = HEe({ inputs: { x: z10 }, backend: a10, attrs: { shape: r10.outShape } });
        w10.push(z10);
        for (var B10 = 0, W10 = w10; B10 < W10.length; B10++) {
          var U10 = W10[B10];
          a10.disposeIntermediateTensorInfo(U10);
        }
        return P10;
      }
      var OAe = { kernelName: e1, backendName: "webgl", kernelFunc: function(e10) {
        var t10, n10 = e10.inputs, r10 = e10.backend, a10 = e10.attrs, i10 = n10.x, o10 = n10.filter, s10 = a10.strides, u10 = a10.pad, c10 = a10.dataFormat, l10 = a10.dilations, h10 = a10.dimRoundingMode, p10 = q8(c10), f10 = D8(i10.shape, o10.shape, s10, l10, u10, h10, false, p10);
        if (1 !== f10.filterHeight || 1 !== f10.filterWidth || 1 !== f10.dilationHeight || 1 !== f10.dilationWidth || 1 !== f10.strideHeight || 1 !== f10.strideWidth || "SAME" !== f10.padInfo.type && "VALID" !== f10.padInfo.type) if (f10.strideWidth <= 2 && "channelsLast" === p10 && k0().getBool("WEBGL_EXP_CONV")) {
          var d10 = new EAe(f10), v10 = [[f10.padInfo.top, f10.padInfo.left], [f10.strideHeight, f10.strideWidth], [f10.dilationHeight, f10.dilationWidth], [f10.inHeight, f10.inWidth]];
          t10 = r10.runWebGLProgram(d10, [i10, o10], "float32", v10);
        } else if (k0().getBool("WEBGL_CONV_IM2COL")) t10 = _Ae({ x: i10, filter: o10, convInfo: f10, backend: r10 });
        else {
          var m10 = new SAe(f10);
          t10 = r10.runWebGLProgram(m10, [i10, o10], "float32");
        }
        else t10 = RAe({ x: i10, filter: o10, convInfo: f10, backend: r10 });
        var g10 = HEe({ inputs: { x: t10 }, backend: r10, attrs: { shape: f10.outShape } });
        return r10.disposeIntermediateTensorInfo(t10), g10;
      } }, FAe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["x", "dy"], this.outputShape = t10.filterShape;
        var n10 = t10.strideHeight, r10 = t10.strideWidth, a10 = t10.padInfo.top, i10 = t10.padInfo.left, o10 = "channelsLast" === t10.dataFormat;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(t10.batchSize, "; b++) {\n          for (int yR = 0; yR < ").concat(t10.outHeight, "; yR++) {\n            int xR = wR + yR * ").concat(n10, " - ").concat(a10, ";\n\n            if (xR < 0 || xR >= ").concat(t10.inHeight, ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(t10.outWidth, "; yC++) {\n              int xC = wC + yC * ").concat(r10, " - ").concat(i10, ";\n\n              if (xC < 0 || xC >= ").concat(t10.inWidth, ") {\n                continue;\n              }\n\n              ").concat(o10 ? "float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);" : "float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);", "\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
      }), DAe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["dy", "W"], this.outputShape = t10.inShape;
        var n10 = t10.filterHeight, r10 = t10.filterWidth, a10 = t10.strideHeight, i10 = t10.strideWidth, o10 = "channelsLast" === t10.dataFormat, s10 = n10 - 1 - t10.padInfo.top, u10 = r10 - 1 - t10.padInfo.left, c10 = o10 ? 1 : 2, h10 = o10 ? 2 : 3, p10 = o10 ? 3 : 1;
        this.userCode = "\n      const ivec2 pads = ivec2(".concat(s10, ", ").concat(u10, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(p10, "];\n\n        ivec2 dyCorner = ivec2(coords[").concat(c10, "], coords[").concat(h10, "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(n10, "; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a10, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t10.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(n10, " - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(r10, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(i10, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t10.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(r10, " - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(t10.outChannels, "; d2++) {\n\n              if (").concat(o10, ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
      }), MAe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["x", "dy"], this.outputShape = t10.filterShape;
        var n10 = t10.strideDepth, r10 = t10.strideHeight, a10 = t10.strideWidth, i10 = t10.padInfo.front, o10 = t10.padInfo.top, s10 = t10.padInfo.left;
        this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(t10.batchSize, "; b++) {\n          for (int yF = 0; yF < ").concat(t10.outDepth, "; yF++) {\n            int xF = wF + yF * ").concat(n10, " - ").concat(i10, ";\n\n            if (xF < 0 || xF >= ").concat(t10.inDepth, ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(t10.outHeight, "; yR++) {\n              int xR = wR + yR * ").concat(r10, " - ").concat(o10, ";\n\n              if (xR < 0 || xR >= ").concat(t10.inHeight, ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(t10.outWidth, "; yC++) {\n                int xC = wC + yC * ").concat(a10, " - ").concat(s10, ";\n\n                if (xC < 0 || xC >= ").concat(t10.inWidth, ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
      }), LAe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["dy", "W"], this.outputShape = t10.inShape;
        var n10 = t10.filterDepth, r10 = t10.filterHeight, a10 = t10.filterWidth, i10 = t10.strideDepth, o10 = t10.strideHeight, s10 = t10.strideWidth, u10 = n10 - 1 - t10.padInfo.front, c10 = r10 - 1 - t10.padInfo.top, h10 = a10 - 1 - t10.padInfo.left;
        this.userCode = "\n      const ivec3 pads = ivec3(".concat(u10, ", ").concat(c10, ", ").concat(h10, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(n10, "; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(i10, ".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(t10.outDepth, ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(n10, " - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(r10, "; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(o10, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t10.outHeight, ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(r10, " - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(a10, "; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(s10, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t10.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(a10, " - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(t10.outChannels, "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
      });
      var zAe = { kernelName: t1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.dy, o10 = r10.strides, s10 = r10.pad, u10 = r10.dataFormat, c10 = r10.dimRoundingMode, l10 = r10.filterShape, h10 = q8(u10), p10 = D8(a10.shape, l10, o10, 1, s10, c10, false, h10), f10 = new FAe(p10);
        return n10.runWebGLProgram(f10, [a10, i10], "float32");
      } }, PAe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["dy", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "strides", type: "vec2" }], this.outputShape = t10.inShape, this.enableShapeUniforms = ySe(this.outputShape.length);
        var n10 = t10.filterHeight, r10 = t10.filterWidth, a10 = n10 - 1 - t10.padInfo.top, i10 = r10 - 1 - t10.padInfo.left;
        this.userCode = "\n      const ivec2 pads = ivec2(".concat(a10, ", ").concat(i10, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(n10, "; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(t10.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(n10, " - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(r10, "; wC++) {\n            int wCPerm = ").concat(r10, " - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(t10.outWidth, ".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(t10.outWidth, ".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(t10.outChannels, "; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(t10.outChannels, "; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(t10.outChannels, "; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ");
      });
      var BAe = { kernelName: n1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.dy, i10 = t10.filter, o10 = r10.inputShape, s10 = r10.strides, u10 = r10.pad, c10 = r10.dataFormat, l10 = r10.dimRoundingMode, h10 = q8(c10), p10 = D8(o10, i10.shape, s10, 1, u10, l10, false, h10);
        if (k0().getBool("WEBGL_PACK_CONV2DTRANSPOSE") && "channelsLast" === h10) {
          var f10 = [[p10.strideHeight, p10.strideWidth]], d10 = new PAe(p10);
          return n10.runWebGLProgram(d10, [a10, i10], "float32", f10);
        }
        var v10 = new DAe(p10);
        return n10.runWebGLProgram(v10, [a10, i10], "float32");
      } };
      var WAe = { kernelName: r1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.filter, o10 = r10.strides, s10 = r10.pad, u10 = r10.dilations, c10 = M8(a10.shape, i10.shape, o10, u10, s10), l10 = new TAe(c10);
        return n10.runWebGLProgram(l10, [a10, i10], "float32");
      } };
      var UAe = { kernelName: a1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.dy, o10 = r10.strides, s10 = r10.pad, u10 = r10.filterShape, c10 = M8(a10.shape, u10, o10, 1, s10), l10 = new MAe(c10);
        return n10.runWebGLProgram(l10, [a10, i10], "float32");
      } };
      var VAe, GAe = { kernelName: i1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.dy, i10 = t10.filter, o10 = r10.pad, s10 = r10.strides, u10 = M8(r10.inputShape, i10.shape, s10, 1, o10), c10 = new LAe(u10);
        return n10.runWebGLProgram(c10, [a10, i10], "float32");
      } }, jAe = MEe({ opSnippet: "if (isnan(x)) return x;\n  return cos(x);\n", packedOpSnippet: "\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(IEe, "\n  return result;\n") }), HAe = { kernelName: o1, backendName: "webgl", kernelFunc: jAe }, qAe = MEe({ opSnippet: "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n" }), KAe = { kernelName: s1, backendName: "webgl", kernelFunc: qAe }, XAe = p(function e10(t10, n10, r10, a10, i10) {
        l(this, e10), this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
        var o10 = S(t10, 4), s10 = o10[0], u10 = o10[1], c10 = o10[2], h10 = o10[3], p10 = S(n10, 1)[0], f10 = S(r10, 2), d10 = f10[0], v10 = f10[1];
        this.outputShape = [p10, d10, v10, h10];
        var m10 = "bilinear" === a10 ? 1 : 0, g10 = "".concat(u10 - 1, ".0"), y10 = "".concat(c10 - 1, ".0"), b10 = S(d10 > 1 ? ["".concat((u10 - 1) / (d10 - 1)), "(y2-y1) * height_ratio", "y1*".concat(g10, " + float(y)*(height_scale)")] : ["0.0", "0.0", "0.5 * (y1+y2) * ".concat(g10)], 3), x10 = b10[0], k10 = b10[1], w10 = b10[2], I10 = S(v10 > 1 ? ["".concat((c10 - 1) / (v10 - 1)), "(x2-x1) * width_ratio", "x1*".concat(y10, " + float(x)*(width_scale)")] : ["0.0", "0.0", "0.5 * (x1+x2) * ".concat(y10)], 3), N10 = I10[0], T10 = I10[1], E10 = I10[2];
        this.userCode = "\n      const float height_ratio = float(".concat(x10, ");\n      const float width_ratio = float(").concat(N10, ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(s10, ") {\n          return;\n        }\n\n        float height_scale = ").concat(k10, ";\n        float width_scale = ").concat(T10, ";\n\n        float in_y = ").concat(w10, ";\n        if( in_y < 0.0 || in_y > ").concat(g10, " ) {\n          setOutput(float(").concat(i10, "));\n          return;\n        }\n        float in_x = ").concat(E10, ";\n        if( in_x < 0.0 || in_x > ").concat(y10, " ) {\n          setOutput(float(").concat(i10, "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(m10, " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ");
      }), YAe = { kernelName: l1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.image, i10 = t10.boxes, o10 = t10.boxInd, s10 = r10.cropSize, u10 = r10.method, c10 = r10.extrapolationValue, l10 = new XAe(a10.shape, i10.shape, s10, u10, c10);
        return n10.runWebGLProgram(l10, [a10, i10, o10], "float32");
      } };
      !function(e10) {
        e10.Prod = "*", e10.Sum = "+";
      }(VAe || (VAe = {}));
      var JAe = p(function e10(t10, n10, r10, a10) {
        l(this, e10), this.op = t10, this.outputShape = n10, this.variableNames = ["x"], this.customUniforms = [{ name: "index", type: "float" }];
        var i10 = this.outputShape.length, o10 = this.op === VAe.Prod ? "1.0" : "0.0", s10 = r10 ? o10 : "getX(".concat(ZAe(i10, "coords", this.op), ")"), u10 = this.outputShape[this.outputShape.length - 1], c10 = "", h10 = "";
        r10 ? (c10 = a10 ? "end != ".concat(u10 - 1) : "end != 0", h10 = a10 ? "end + 1" : "end - 1") : (c10 = a10 ? "end + pow2 < ".concat(u10) : "end >= pow2", h10 = a10 ? "end + pow2" : "end - pow2"), this.userCode = "\n      void main() {\n        ".concat(cSe(i10), " coords = getOutputCoords();\n        int end = ").concat(QAe(i10, "coords", this.op), ";\n        float val = ").concat(s10, ";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(c10, ") {\n          int idx = ").concat(h10, ";\n          ").concat(QAe(i10, "coords", this.op), " = idx;\n          val ").concat(this.op, "= getX(").concat(ZAe(i10, "coords", this.op), ");\n        }\n        setOutput(val);\n      }\n    ");
      });
      function ZAe(e10, t10, n10) {
        if (1 === e10) return "".concat(t10);
        if (2 === e10) return "".concat(t10, ".x, ").concat(t10, ".y");
        if (3 === e10) return "".concat(t10, ".x, ").concat(t10, ".y, ").concat(t10, ".z");
        if (4 === e10) return "".concat(t10, ".x, ").concat(t10, ".y, ").concat(t10, ".z, ").concat(t10, ".w");
        throw new Error("Cumulative ".concat(n10, " for rank ").concat(e10, " is not yet supported"));
      }
      function QAe(e10, t10, n10) {
        if (1 === e10) return "".concat(t10);
        if (2 === e10) return "".concat(t10, ".y");
        if (3 === e10) return "".concat(t10, ".z");
        if (4 === e10) return "".concat(t10, ".w");
        throw new Error("Cumulative ".concat(n10, " for rank ").concat(e10, " is not yet supported"));
      }
      function $Ae(e10, t10, n10, r10, a10, i10) {
        var o10 = t10.shape.length, s10 = $7([r10], o10), u10 = t10;
        null != s10 && (u10 = tCe({ inputs: { x: t10 }, backend: n10, attrs: { perm: s10 } }));
        var c10 = t9(1, o10)[0];
        if (c10 !== o10 - 1) throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t10.shape.length - 1, " ") + "but got axis=".concat(r10));
        for (var l10 = u10.shape[c10], h10 = SEe({ inputs: { x: u10 }, backend: n10 }), p10 = 0; p10 <= Math.ceil(Math.log2(l10)) - 1; p10++) {
          var f10 = new JAe(e10, u10.shape, false, i10), d10 = [[p10]], v10 = h10;
          h10 = n10.runWebGLProgram(f10, [h10], h10.dtype, d10), n10.disposeIntermediateTensorInfo(v10);
        }
        if (a10) {
          var m10 = new JAe(e10, u10.shape, a10, i10), g10 = h10;
          h10 = n10.runWebGLProgram(m10, [h10], h10.dtype), n10.disposeIntermediateTensorInfo(g10);
        }
        if (null != s10) {
          var y10 = tCe({ inputs: { x: h10 }, backend: n10, attrs: { perm: e9(s10) } });
          return n10.disposeIntermediateTensorInfo(h10), n10.disposeIntermediateTensorInfo(u10), y10;
        }
        return h10;
      }
      var eRe = { kernelName: u1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.axis, o10 = r10.exclusive, s10 = r10.reverse;
        return $Ae(VAe.Prod, a10, n10, i10, o10, s10);
      } };
      var tRe = { kernelName: c1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.axis, o10 = r10.exclusive, s10 = r10.reverse;
        return $Ae(VAe.Sum, a10, n10, i10, o10, s10);
      } };
      var nRe = { kernelName: h1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.weights, o10 = r10.size, s10 = r10.binaryOutput;
        if (1 === a10.shape.length) {
          var u10 = n10.readSync(a10.dataId), c10 = n10.readSync(i10.dataId), l10 = ZSe(u10, c10, i10.dtype, i10.shape, o10);
          return n10.makeTensorInfo([o10], i10.dtype, l10);
        }
        if (2 === a10.shape.length) {
          var h10 = n10.bufferSync(a10), p10 = n10.bufferSync(i10), f10 = QSe(h10, p10, o10, s10);
          return n10.makeTensorInfo(f10.shape, i10.dtype, f10.values);
        }
        throw new Error("Error in denseBincount: input must be at most rank 2, but got rank" + "".concat(a10.shape.length, "."));
      } }, rRe = function() {
        function e10(t10, n10, r10) {
          l(this, e10), this.variableNames = ["x"], this.outputShape = [], this.outputShape = t10, this.blockSize = n10, this.dataFormat = r10, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(), ";\n      int w = ").concat(this.getWidthCoordString(), ";\n      int d = ").concat(this.getDepthCoordString(), ";\n\n      int in_h = h / ").concat(n10, ";\n      int offset_h = imod(h, ").concat(n10, ");\n      int in_w = w / ").concat(n10, ";\n      int offset_w = imod(w, ").concat(n10, ");\n      int offset_d = (offset_h * ").concat(n10, " + offset_w) *\n        ").concat(this.getOutputDepthSize(), ";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(), ";\n      setOutput(result);\n    }\n  ");
        }
        return p(e10, [{ key: "getHeightCoordString", value: function() {
          return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
        } }, { key: "getWidthCoordString", value: function() {
          return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
        } }, { key: "getDepthCoordString", value: function() {
          return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
        } }, { key: "getOutputDepthSize", value: function() {
          return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
        } }, { key: "getInputSamplingString", value: function() {
          return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
        } }]), e10;
      }();
      var aRe = { kernelName: p1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.blockSize, o10 = r10.dataFormat, s10 = a10.shape[0], u10 = ("NHWC" === o10 ? a10.shape[1] : a10.shape[2]) * i10, c10 = ("NHWC" === o10 ? a10.shape[2] : a10.shape[3]) * i10, l10 = ("NHWC" === o10 ? a10.shape[3] : a10.shape[1]) / (i10 * i10), h10 = new rRe("NHWC" === o10 ? [s10, u10, c10, l10] : [s10, l10, u10, c10], i10, o10);
        return n10.runWebGLProgram(h10, [a10], a10.dtype);
      } }, iRe = p(function e10(t10) {
        var n10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i10 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        l(this, e10), this.variableNames = ["x", "W"], this.customUniforms = [{ name: "pads", type: "ivec2" }, { name: "strides", type: "ivec2" }, { name: "dilations", type: "ivec2" }, { name: "inDims", type: "ivec2" }], this.outputShape = t10.outShape, this.enableShapeUniforms = ySe(this.outputShape.length);
        var o10 = t10.filterHeight, s10 = t10.filterWidth, u10 = t10.outChannels / t10.inChannels, c10 = "", h10 = "";
        r10 && (c10 = a10 ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(r10, "\n        }") : i10 ? "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(r10, "\n        }") : "\n          float activation(float x) {\n            ".concat(r10, "\n          }\n        "), h10 = "result = activation(result);");
        var p10 = n10 ? "result += getBiasAtOutCoords();" : "";
        n10 && this.variableNames.push("bias"), a10 && this.variableNames.push("preluActivationWeights"), i10 && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(c10, "\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(u10, ";\n        int q = d2 - d1 * ").concat(u10, ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(o10, "; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(s10, "; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(p10, "\n        ").concat(h10, "\n        setOutput(result);\n      }\n    ");
      }), oRe = p(function e10(t10) {
        var n10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i10 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        l(this, e10), this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "pads", type: "ivec2" }, { name: "strides", type: "ivec2" }, { name: "dilations", type: "ivec2" }, { name: "inDims", type: "ivec2" }], this.outputShape = t10.outShape, this.enableShapeUniforms = ySe(this.outputShape.length);
        for (var o10 = t10.outChannels / t10.inChannels, s10 = t10.padInfo.left, u10 = t10.strideWidth, c10 = t10.dilationWidth, h10 = t10.filterHeight, p10 = t10.filterWidth, f10 = p10, d10 = "\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;", v10 = 0; v10 < p10; v10++) d10 += "\n          vec4 xTexelC".concat(2 * v10, ";\n          int xTexelC").concat(2 * v10, "Ready;\n          vec4 xTexelC").concat(2 * v10 + 1, ";\n          int xTexelC").concat(2 * v10 + 1, "Ready;\n          vec4 xC").concat(v10, ";");
        d10 += "\n    for (int r = 0; r < ".concat(h10, "; r++) {\n      ");
        for (var m10 = 0; m10 < p10; m10++) d10 += "\n          xTexelC".concat(2 * m10, " = vec4(0.0);\n          xTexelC").concat(2 * m10, "Ready = 0;\n          xTexelC").concat(2 * m10 + 1, " = vec4(0.0);\n          xTexelC").concat(2 * m10 + 1, "Ready = 0;\n          xC").concat(m10, " = vec4(0.0);");
        d10 += "\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";
        for (var g10 = 0; g10 < (f10 + 1) / 2; g10++) {
          var y10 = 2 * g10;
          if (d10 += "\n          xC = xCCorner + ".concat(y10 * c10, ";\n          "), 1 === u10) {
            if (y10 < p10 && (s10 % 2 == 1 ? (d10 += "\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(y10, "Ready == 0) {\n                  xTexelC").concat(y10, " = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(y10, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(y10, "Ready = 1;\n                }\n              "), d10 += 1 === c10 && y10 > 0 ? "\n                xC".concat(y10, " = vec4(xTexelC").concat(y10 - 2, ".zw, xTexelC").concat(y10, ".xy);\n                ") : "\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(y10, " = vec4(previous.zw, xTexelC").concat(y10, ".xy);\n                  } else {\n                    xC").concat(y10, " = vec4(0.0, 0.0, xTexelC").concat(y10, ".xy);\n                  }\n                  ")) : d10 += "\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(y10, "Ready == 0) {\n                  xTexelC").concat(y10, " = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(y10, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(y10, "Ready = 1;\n                }\n\n                xC").concat(y10, " = xTexelC").concat(y10, ";\n                "), y10 + 1 < p10)) {
              var b10 = s10 % 2 == 0 ? R$(c10) : c10;
              c10 % 2 == 0 && s10 % 2 == 1 || c10 % 2 != 0 && s10 % 2 != 1 ? (d10 += "\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(b10, ";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(y10 + 1, "Ready == 0) {\n                    xTexelC").concat(y10 + 1, " = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(y10 + 1, ".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(y10 + 1, "Ready = 1;\n                  }\n                  "), d10 += c10 > 1 ? "\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(y10 + 1, " = vec4(previous.zw, xTexelC").concat(y10 + 1, ".xy);\n                    } else {\n                     xC").concat(y10 + 1, " = vec4(0.0, 0.0, xTexelC").concat(y10 + 1, ".xy);\n                    }\n                    ") : "\n                    xC".concat(y10 + 1, " = vec4(xTexelC").concat(y10, ".zw, xTexelC").concat(y10 + 1, ".xy);\n                    ")) : d10 += 1 === b10 ? "\n                    xC".concat(y10 + 1, " = xTexelC").concat(y10, ";\n                    ") : "\n                    xCOffset = xC + ".concat(b10, ";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(y10 + 1, "Ready == 0) {\n                      xTexelC").concat(y10 + 1, " = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(y10 + 1, ".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(y10 + 1, "Ready = 1;\n                    }\n\n                    xC").concat(y10 + 1, " = xTexelC").concat(y10 + 1, ";\n                    ");
            }
          } else y10 < p10 && (s10 % 2 == 1 ? (d10 += "\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(y10, "Ready == 0) {\n                  xTexelC").concat(y10, " = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(y10, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(y10, "Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(y10 + 1, "Ready == 0) {\n                  xTexelC").concat(y10 + 1, " = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(y10 + 1, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(y10 + 1, "Ready = 1;\n                }\n\n                xC").concat(y10, " = vec4(xTexelC").concat(y10, ".zw, xTexelC").concat(y10 + 1, ".zw);\n              "), y10 + 1 < p10 && (d10 += "\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(y10 + 1, " = vec4(xTexelC").concat(y10 + 1, ".xy, final.xy);\n                "))) : (d10 += "\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(y10, "Ready == 0) {\n                  xTexelC").concat(y10, " = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(y10, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(y10, "Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(y10 + 1, "Ready == 0) {\n                  xTexelC").concat(y10 + 1, " = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(y10 + 1, ".zw = vec2(0.);\n                  }\n                  xTexelC").concat(y10 + 1, "Ready = 1;\n                }\n\n                xC").concat(y10, " = vec4(\n                  xTexelC").concat(y10, ".xy, xTexelC").concat(y10 + 1, ".xy);\n              "), y10 + 1 < p10 && (d10 += "\n                  xC".concat(y10 + 1, " = vec4(xTexelC").concat(y10, ".zw, xTexelC").concat(y10 + 1, ".zw);\n                "))));
          y10 < p10 && (d10 += "\n            wTexel = getW(r, ".concat(y10, ", d1, q);\n            dotProd += xC").concat(y10, " * vec4(wTexel.xz, wTexel.xz);\n          "), y10 + 1 < p10 && (d10 += "\n              wTexel = getW(r, ".concat(y10 + 1, ", d1, q);\n              dotProd += xC").concat(y10 + 1, " * vec4(wTexel.xz, wTexel.xz);\n            ")));
        }
        d10 += "\n    }\n  ", d10 += "\n      }\n    ";
        var x10 = "", k10 = "";
        r10 && (x10 = a10 ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(r10, "\n        }") : i10 ? "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(r10, "\n        }") : "vec4 activation(vec4 x) {\n          ".concat(r10, "\n        }"), k10 = "result = activation(result);");
        var w10 = n10 ? "result += getBiasAtOutCoords();" : "";
        n10 && this.variableNames.push("bias"), a10 && this.variableNames.push("preluActivationWeights"), i10 && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(x10, "\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o10, ";\n        int q = d2 - d1 * ").concat(o10, ";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(d10, "\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(w10, "\n        ").concat(k10, "\n        setOutput(result);\n      }\n    ");
      });
      var sRe = { kernelName: f1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.filter, o10 = r10.strides, s10 = r10.pad, u10 = r10.dilations, c10 = r10.dimRoundingMode, l10 = u10;
        null == l10 && (l10 = [1, 1]), F$(j8(o10, l10), function() {
          return "Error in depthwiseConv2d: Either strides or dilations must be " + "1. Got strides ".concat(o10, " and dilations '").concat(l10, "'");
        });
        var h10, p10 = D8(a10.shape, i10.shape, o10, l10, s10, c10, true);
        h10 = k0().getBool("WEBGL_PACK_DEPTHWISECONV") && p10.strideWidth <= 2 && p10.outChannels / p10.inChannels == 1 ? new oRe(p10) : new iRe(p10);
        var f10 = [[p10.padInfo.top, p10.padInfo.left], [p10.strideHeight, p10.strideWidth], [p10.dilationHeight, p10.dilationWidth], [p10.inHeight, p10.inWidth]];
        return n10.runWebGLProgram(h10, [a10, i10], "float32", f10);
      } }, uRe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["x", "dy"], this.outputShape = t10.filterShape;
        var n10 = t10.strideHeight, r10 = t10.strideWidth, a10 = t10.padInfo.top, i10 = t10.padInfo.left, o10 = t10.outChannels / t10.inChannels;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(o10, " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(t10.batchSize, "; b++) {\n          for (int yR = 0; yR < ").concat(t10.outHeight, "; yR++) {\n            int xR = wR + yR * ").concat(n10, " - ").concat(a10, ";\n\n            if (xR < 0 || xR >= ").concat(t10.inHeight, ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(t10.outWidth, "; yC++) {\n              int xC = wC + yC * ").concat(r10, " - ").concat(i10, ";\n\n              if (xC < 0 || xC >= ").concat(t10.inWidth, ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
      }), cRe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["dy", "W"], this.outputShape = t10.inShape;
        var n10 = t10.filterHeight, r10 = t10.filterWidth, a10 = t10.strideHeight, i10 = t10.strideWidth, o10 = n10 - 1 - t10.padInfo.top, s10 = r10 - 1 - t10.padInfo.left, u10 = t10.outChannels / t10.inChannels;
        this.userCode = "\n      const ivec2 pads = ivec2(".concat(o10, ", ").concat(s10, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(n10, "; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a10, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t10.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(n10, " - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(r10, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(i10, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t10.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(r10, " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(u10, "; dm++) {\n              int d2 = d1 * ").concat(u10, " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
      });
      var lRe = { kernelName: d1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.dy, o10 = r10.strides, s10 = r10.dilations, u10 = r10.pad, c10 = r10.dimRoundingMode, l10 = r10.filterShape, h10 = D8(a10.shape, l10, o10, s10, u10, c10, true), p10 = new uRe(h10);
        return n10.runWebGLProgram(p10, [a10, i10], "float32");
      } };
      var hRe = { kernelName: v1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.dy, i10 = t10.filter, o10 = r10.strides, s10 = r10.dilations, u10 = r10.pad, c10 = r10.dimRoundingMode, l10 = D8(r10.inputShape, i10.shape, o10, s10, u10, c10, true), h10 = new cRe(l10);
        return n10.runWebGLProgram(h10, [a10, i10], "float32");
      } }, pRe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["X"], this.outputShape = [t10, t10], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
      });
      var fRe = { kernelName: m1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.x, a10 = [].concat(T(r10.shape), T(r10.shape)), i10 = L$(r10.shape), o10 = HEe({ inputs: { x: r10 }, backend: n10, attrs: { shape: [i10] } }), s10 = new pRe(i10), u10 = n10.runWebGLProgram(s10, [o10], o10.dtype), c10 = HEe({ inputs: { x: u10 }, backend: n10, attrs: { shape: a10 } });
        return n10.disposeIntermediateTensorInfo(o10), n10.disposeIntermediateTensorInfo(u10), c10;
      } }, dRe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["x", "W"], this.outputShape = t10.outShape;
        var n10 = t10.inHeight, r10 = t10.inWidth, a10 = t10.padInfo, i10 = t10.strideHeight, o10 = t10.strideWidth, s10 = t10.filterHeight, u10 = t10.filterWidth, c10 = t10.dilationHeight, h10 = t10.dilationWidth, p10 = a10.top, f10 = a10.left;
        this.userCode = "\n      const ivec2 strides = ivec2(".concat(i10, ", ").concat(o10, ");\n      const ivec2 pads = ivec2(").concat(p10, ", ").concat(f10, ");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(s10, "; h++) {\n          int hIn = hBeg + h * ").concat(c10, ";\n\n          if (hIn >= 0 && hIn < ").concat(n10, ") {\n            for (int w = 0; w < ").concat(u10, "; w++) {\n              int wIn = wBeg + w * ").concat(h10, ";\n\n              if (wIn >= 0 && wIn < ").concat(r10, ") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ");
      });
      var vRe = { kernelName: g1, backendName: "webgl", kernelFunc: function(e10) {
        var t10, n10 = e10.inputs, r10 = e10.backend, a10 = e10.attrs, i10 = n10.x, o10 = n10.filter, s10 = a10.strides, u10 = a10.pad, c10 = a10.dilations, l10 = _8(i10.shape, o10.shape, s10, u10, "NHWC", c10), h10 = new dRe(l10), p10 = HEe({ inputs: { x: t10 = r10.runWebGLProgram(h10, [i10, o10], "float32") }, backend: r10, attrs: { shape: l10.outShape } });
        return r10.disposeIntermediateTensorInfo(t10), p10;
      } };
      var mRe = { kernelName: w1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10, a10 = Lie(e10.attrs.equation, r10.length), i10 = a10.allDims, o10 = a10.summedDims, s10 = a10.idDims;
        Pie(i10.length, s10, r10);
        for (var u10 = Bie(o10, s10), c10 = u10.path, l10 = u10.steps, h10 = l10.length, p10 = null, f10 = i10.length, d10 = [], v10 = 0; v10 < h10; ++v10) {
          var m10, g10 = O(l10[v10]);
          try {
            for (g10.s(); !(m10 = g10.n()).done; ) {
              var y10 = m10.value, b10 = zie(f10, s10[y10]), x10 = b10.permutationIndices, k10 = b10.expandDims, w10 = void 0;
              Wie(x10) ? w10 = r10[y10] : (w10 = tCe({ inputs: { x: r10[y10] }, backend: n10, attrs: { perm: x10 } }), d10.push(w10));
              for (var I10 = w10.shape.slice(), N10 = 0; N10 < k10.length; ++N10) I10.splice(k10[N10], 0, 1);
              P$(w10.shape, I10) || (w10 = HEe({ inputs: { x: w10 }, backend: n10, attrs: { shape: I10 } }), d10.push(w10)), null === p10 ? p10 = w10 : (p10 = GEe({ inputs: { a: w10, b: p10 }, backend: n10 }), d10.push(p10));
            }
          } catch (e11) {
            g10.e(e11);
          } finally {
            g10.f();
          }
          v10 < h10 - 1 && (c10[v10] >= 0 && (p10 = $Ee({ inputs: { x: p10 }, backend: n10, attrs: { axis: c10[v10] - (i10.length - f10), keepDims: false } }), d10.push(p10)), f10--);
        }
        for (var S10 = 0, T10 = d10; S10 < T10.length; S10++) {
          var E10 = T10[S10];
          E10 !== p10 && n10.disposeIntermediateTensorInfo(E10);
        }
        return p10;
      } }, gRe = MEe({ opSnippet: "return (x >= 0.0) ? x : (exp(x) - 1.0);", packedOpSnippet: "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n" }), yRe = { kernelName: I1, backendName: "webgl", kernelFunc: gRe }, bRe = { kernelName: N1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.dy, a10 = t10.y, i10 = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new NEe("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", r10.shape, a10.shape) : new wEe("return (b >= 0.0) ? a : a * (b + 1.0);", r10.shape, a10.shape);
        return n10.runWebGLProgram(i10, [r10, a10], r10.dtype);
      } }, xRe = LEe({ opSnippet: "return float(a == b);", packedOpSnippet: "\n  return vec4(equal(a, b));\n", dtype: "bool", cpuKernelImpl: rTe }), kRe = { kernelName: T1, backendName: "webgl", kernelFunc: xRe }, wRe = MEe({ opSnippet: '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(xie, ";\n  float a1 = ").concat(kie, ";\n  float a2 = ").concat(wie, ";\n  float a3 = ").concat(Iie, ";\n  float a4 = ").concat(Nie, ";\n  float a5 = ").concat(Sie, ";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n") }), IRe = { kernelName: S1, backendName: "webgl", kernelFunc: wRe }, NRe = MEe({ opSnippet: "if (isnan(x)) return x;\n  return exp(x);\n", packedOpSnippet: "\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n", cpuKernelImpl: aTe, dtype: "float32" }), SRe = { kernelName: E1, backendName: "webgl", kernelFunc: NRe };
      function TRe(e10) {
        var t10 = e10.inputs, n10 = e10.attrs, r10 = e10.backend, a10 = n10.dim, i10 = t10.input, o10 = i10.shape.length, s10 = i10.shape.slice(), u10 = a10;
        return a10 < 0 && (F$(-(o10 + 1) <= a10, function() {
          return "Axis must be in the interval [".concat(-(o10 + 1), ", ").concat(o10, "]");
        }), u10 = o10 + a10 + 1), s10.splice(u10, 0, 1), HEe({ inputs: { x: i10 }, backend: r10, attrs: { shape: s10 } });
      }
      var ERe = { kernelName: C1, backendName: "webgl", kernelFunc: TRe }, CRe = "return exp(x) - 1.0;", ARe = MEe({ opSnippet: CRe, packedOpSnippet: CRe, cpuKernelImpl: iTe }), RRe = { kernelName: A1, backendName: "webgl", kernelFunc: ARe }, _Re = p(function e10(t10, n10, r10) {
        l(this, e10), this.variableNames = ["real", "imag"];
        var a10 = n10[1];
        this.outputShape = n10;
        var i10, o10 = r10 ? "2.0 * ".concat(Math.PI) : "-2.0 * ".concat(Math.PI), s10 = r10 ? "".concat(a10, ".0") : "1.0";
        if ("real" === t10) i10 = "return real * expR - imag * expI;";
        else {
          if ("imag" !== t10) throw new Error('FFT component must be either "real" or "imag", got '.concat(t10, "."));
          i10 = "return real * expI + imag * expR;";
        }
        this.userCode = "\n      const float exponentMultiplier = ".concat(o10, ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(i10, "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(a10, ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(a10, "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(s10, ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ");
      });
      function ORe(e10, t10, n10) {
        var r10 = n10.texData.get(e10.dataId), a10 = L$(e10.shape), i10 = e10.shape[e10.shape.length - 1], o10 = HEe({ inputs: { x: e10 }, backend: n10, attrs: { shape: [a10 / i10, i10] } }), s10 = o10.shape, u10 = new _Re("real", s10, t10), c10 = new _Re("imag", s10, t10), l10 = [{ dataId: r10.complexTensorInfos.real.dataId, dtype: r10.complexTensorInfos.real.dtype, shape: s10 }, { dataId: r10.complexTensorInfos.imag.dataId, dtype: r10.complexTensorInfos.imag.dtype, shape: s10 }], h10 = n10.runWebGLProgram(u10, l10, "float32"), p10 = n10.runWebGLProgram(c10, l10, "float32"), f10 = EEe({ inputs: { real: h10, imag: p10 }, backend: n10 });
        n10.disposeIntermediateTensorInfo(h10), n10.disposeIntermediateTensorInfo(p10);
        var d10 = HEe({ inputs: { x: f10 }, backend: n10, attrs: { shape: e10.shape } });
        return n10.disposeIntermediateTensorInfo(o10), n10.disposeIntermediateTensorInfo(f10), d10;
      }
      var FRe = { kernelName: R1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend;
        return ORe(t10.input, false, n10);
      } }, DRe = p(function e10(t10, n10) {
        l(this, e10), this.outputShape = [], this.customUniforms = [{ name: "value", type: "float" }], this.variableNames = ["x"], this.outputShape = t10, this.userCode = "\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
      });
      function MRe(e10) {
        var t10 = e10.backend, n10 = e10.attrs, r10 = n10.shape, a10 = n10.value, i10 = n10.dtype;
        if ("string" === (i10 = i10 || n0(a10))) {
          var o10 = K$(i10, L$(r10));
          return o10.fill(a10), t10.makeTensorInfo(r10, i10, o10);
        }
        var s10 = new DRe(r10, a10), u10 = [[a10]];
        return t10.runWebGLProgram(s10, [], i10, u10);
      }
      var LRe, zRe = { kernelName: _1, backendName: "webgl", kernelFunc: MRe }, PRe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["Image"], this.outputShape = [];
        var n10 = t10[2];
        this.outputShape = t10, this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(n10, " - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(n10, ") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ");
      }), BRe = { kernelName: O1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.image, a10 = n10, i10 = new PRe(r10.shape);
        return a10.runWebGLProgram(i10, [r10], r10.dtype);
      } }, WRe = "return floor(x);", URe = MEe({ opSnippet: WRe, packedOpSnippet: WRe, cpuKernelImpl: oTe }), VRe = { kernelName: F1, backendName: "webgl", kernelFunc: URe }, GRe = LEe({ opSnippet: "\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n", packedOpSnippet: "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n", dtype: "int32" }), jRe = { kernelName: D1, backendName: "webgl", kernelFunc: GRe }, HRe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["A"];
        var n10 = PNe(), r10 = S(t10, 2), a10 = r10[0], i10 = r10[1];
        this.outputShape = t10, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(i10, ".0, ").concat(a10, ".0);\n\n        vec4 values = ").concat(n10.texture2D, "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ");
      }), qRe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true;
        var n10 = PNe(), r10 = S(t10, 2), a10 = r10[0], i10 = r10[1];
        this.outputShape = t10, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(i10, ".0, ").concat(a10, ".0);\n            vec4 values = ").concat(n10.texture2D, "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(n10.output, " = result;\n      }\n    ");
      }), KRe = { kernelName: O3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.pixels, i10 = r10.numChannels, o10 = "undefined" != typeof HTMLVideoElement && a10 instanceof HTMLVideoElement, s10 = "undefined" != typeof HTMLImageElement && a10 instanceof HTMLImageElement, u10 = S(o10 ? [a10.videoWidth, a10.videoHeight] : [a10.width, a10.height], 2), c10 = u10[0], l10 = u10[1], h10 = [l10, c10], p10 = [l10, c10, i10];
        if (s10 || o10) {
          var f10 = k0().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
          null != LRe && f10 === XRe || (XRe = f10, LRe = document.createElement("canvas").getContext("2d", { willReadFrequently: XRe })), LRe.canvas.width = c10, LRe.canvas.height = l10, LRe.drawImage(a10, 0, 0, c10, l10), a10 = LRe.canvas;
        }
        var d10 = n10.makeTensorInfo(h10, "int32");
        n10.texData.get(d10.dataId).usage = MIe.PIXELS, n10.gpgpu.uploadPixelDataToTexture(n10.getTexture(d10.dataId), a10);
        var v10 = k0().getBool("WEBGL_PACK") ? new qRe(p10) : new HRe(p10), m10 = n10.runWebGLProgram(v10, [d10], "int32");
        return n10.disposeData(d10.dataId), m10;
      } }, XRe = k0().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
      var YRe = { kernelName: M3, backendName: "webgl", kernelFunc: function(e10) {
        var t10, n10 = e10.inputs, r10 = e10.backend, a10 = e10.attrs, i10 = n10.x, o10 = n10.filter, s10 = n10.bias, u10 = n10.preluActivationWeights, c10 = a10.strides, l10 = a10.pad, h10 = a10.dataFormat, p10 = a10.dilations, f10 = a10.dimRoundingMode, d10 = a10.activation, v10 = a10.leakyreluAlpha, m10 = q8(h10), g10 = D8(i10.shape, o10.shape, c10, p10, l10, f10, false, m10), y10 = [], b10 = null != s10, x10 = null != u10, k10 = "leakyrelu" === d10, w10 = function() {
          var e11 = [i10, o10], t11 = function(e12, t12) {
            if ("NCHW" === t12 && 1 === e12.shape.length && 1 !== e12.shape[0]) {
              var n12 = HEe({ inputs: { x: e12 }, backend: r10, attrs: { shape: [e12.shape[0], 1, 1] } });
              return y10.push(n12), n12;
            }
            return e12;
          };
          if (b10 && e11.push(t11(s10, h10)), x10 && e11.push(t11(u10, h10)), k10) {
            var n11 = r10.makeTensorInfo([], "float32", M4(v10, "float32"));
            e11.push(n11), y10.push(n11);
          }
          return e11;
        };
        if (1 !== g10.filterHeight || 1 !== g10.filterWidth || 1 !== g10.dilationHeight || 1 !== g10.dilationWidth || 1 !== g10.strideHeight || 1 !== g10.strideWidth || "SAME" !== g10.padInfo.type && "VALID" !== g10.padInfo.type) if (g10.strideWidth <= 2 && "channelsLast" === m10 && k0().getBool("WEBGL_EXP_CONV")) {
          var I10 = d10 ? zEe(d10, true) : null, N10 = new EAe(g10, b10, I10, x10, k10), S10 = [[g10.padInfo.top, g10.padInfo.left], [g10.strideHeight, g10.strideWidth], [g10.dilationHeight, g10.dilationWidth], [g10.inHeight, g10.inWidth]], T10 = w10();
          t10 = r10.runWebGLProgram(N10, T10, "float32", S10);
        } else if (k0().getBool("WEBGL_CONV_IM2COL")) t10 = _Ae({ x: i10, filter: o10, convInfo: g10, backend: r10, bias: s10, activation: d10, preluActivationWeights: u10, leakyreluAlpha: v10 });
        else {
          var E10 = d10 ? zEe(d10, false) : null, C10 = new SAe(g10, b10, E10, x10, k10), A10 = w10();
          t10 = r10.runWebGLProgram(C10, A10, "float32");
        }
        else t10 = RAe({ x: i10, filter: o10, convInfo: g10, backend: r10, bias: s10, activation: d10, preluActivationWeights: u10, leakyreluAlpha: v10 });
        var R10 = HEe({ inputs: { x: t10 }, backend: r10, attrs: { shape: g10.outShape } });
        return y10.push(t10), y10.forEach(function(e11) {
          return r10.disposeIntermediateTensorInfo(e11);
        }), R10;
      } };
      var JRe = { kernelName: L3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.filter, o10 = t10.bias, s10 = t10.preluActivationWeights, u10 = r10.strides, c10 = r10.pad, l10 = r10.dilations, h10 = r10.dimRoundingMode, p10 = r10.activation, f10 = r10.leakyreluAlpha, d10 = [], v10 = l10;
        null == v10 && (v10 = [1, 1]), F$(j8(u10, v10), function() {
          return "Error in depthwiseConv2d: Either strides or dilations must be " + "1. Got strides ".concat(u10, " and dilations '").concat(v10, "'");
        });
        var m10, g10 = D8(a10.shape, i10.shape, u10, v10, c10, h10, true), y10 = k0().getBool("WEBGL_PACK_DEPTHWISECONV") && g10.strideWidth <= 2 && g10.outChannels / g10.inChannels == 1, b10 = p10 ? zEe(p10, y10) : null, x10 = [a10, i10], k10 = null != o10, w10 = null != s10, I10 = "leakyrelu" === p10;
        if (k10 && x10.push(o10), w10 && x10.push(s10), I10) {
          var N10 = n10.makeTensorInfo([], "float32", M4(f10, "float32"));
          x10.push(N10), d10.push(N10);
        }
        m10 = y10 ? new oRe(g10, k10, b10, w10, I10) : new iRe(g10, k10, b10, w10, I10);
        var S10 = [[g10.padInfo.top, g10.padInfo.left], [g10.strideHeight, g10.strideWidth], [g10.dilationHeight, g10.dilationWidth], [g10.inHeight, g10.inWidth]], T10 = n10.runWebGLProgram(m10, x10, "float32", S10);
        return d10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), T10;
      } }, ZRe = p(function e10(t10, n10, r10, a10) {
        l(this, e10), this.sliceDim = t10, this.strides = n10, this.paramsShape = a10, this.variableNames = ["x", "indices"], this.outputShape = r10;
        for (var i10 = cSe(r10.length), o10 = "\n    int index;", s10 = 0; s10 < this.sliceDim; s10++) o10 += "\n          index = round(getIndices(coords[0], ".concat(s10, "));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[s10], ";\n          flattenIndex += index * ").concat(this.strides[s10], ";");
        this.userCode = "\n         void main() {\n          ".concat(i10, " coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(o10, "\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ");
      });
      var QRe = { kernelName: z1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.params, a10 = t10.indices, i10 = a10.shape, o10 = i10[i10.length - 1], s10 = L$(r10.shape), u10 = S(Mae(r10, a10), 4), c10 = u10[0], l10 = u10[1], h10 = u10[2], p10 = u10[3], f10 = HEe({ inputs: { x: a10 }, backend: n10, attrs: { shape: [l10, o10] } }), d10 = HEe({ inputs: { x: r10 }, backend: n10, attrs: { shape: [L$(r10.shape) / h10, h10] } });
        if (n10.shouldExecuteOnCPU([r10, a10]) || "string" === r10.dtype) {
          var v10 = n10.readSync(a10.dataId), m10 = n10.bufferSync(r10), g10 = sTe(v10, m10, r10.dtype, l10, o10, h10, p10, r10.shape, s10);
          return n10.makeTensorInfo(c10, r10.dtype, g10.values);
        }
        var y10 = new ZRe(o10, p10, [l10, h10], r10.shape), b10 = n10.runWebGLProgram(y10, [d10, f10], d10.dtype), x10 = HEe({ inputs: { x: b10 }, backend: n10, attrs: { shape: c10 } });
        return n10.disposeIntermediateTensorInfo(f10), n10.disposeIntermediateTensorInfo(d10), n10.disposeIntermediateTensorInfo(b10), x10;
      } }, $Re = p(function e10(t10, n10) {
        l(this, e10), this.variableNames = ["A", "indices"], this.outputShape = n10, this.rank = n10.length;
        var r10 = cSe(this.rank), a10 = function(e11, t11) {
          for (var n11 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], r11 = [], a11 = 0; a11 < e11.length; a11++) 2 === a11 ? r11.push("index") : r11.push("".concat(n11[a11]));
          return r11.join();
        }(t10);
        this.userCode = "\n      void main() {\n        ".concat(r10, " resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(t10[2], ") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(a10, "));\n      }\n    ");
      });
      function e_e(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.indices, o10 = r10.axis, s10 = r10.batchDims, u10 = j$(o10, a10.shape)[0];
        if (k0().get("DEBUG")) for (var c10 = n10.readSync(i10.dataId), l10 = a10.shape[u10], h10 = function() {
          var e11 = c10[p10];
          F$(e11 <= l10 - 1 && e11 >= 0, function() {
            return "GatherV2: the index value ".concat(e11, " is not in [0, ").concat(l10 - 1, "]");
          });
        }, p10 = 0; p10 < c10.length; ++p10) h10();
        var f10 = roe(a10, i10, u10, s10), d10 = L$(i10.shape), v10 = [], m10 = HEe({ inputs: { x: a10 }, backend: n10, attrs: { shape: [f10.batchSize, f10.outerSize, f10.dimSize, f10.sliceSize] } }), g10 = HEe({ inputs: { x: i10 }, backend: n10, attrs: { shape: [f10.batchSize, d10 / f10.batchSize] } });
        v10.push(m10), v10.push(g10);
        var y10 = [f10.batchSize, f10.outerSize, d10 / f10.batchSize, f10.sliceSize];
        if (n10.shouldExecuteOnCPU([a10, i10]) || "string" === a10.dtype) {
          var b10 = n10.bufferSync(g10), x10 = n10.bufferSync(m10), k10 = uTe(x10, b10, y10);
          return v10.forEach(function(e11) {
            return n10.disposeIntermediateTensorInfo(e11);
          }), n10.makeTensorInfo(f10.outputShape, k10.dtype, k10.values);
        }
        var w10 = new $Re(m10.shape, y10), I10 = n10.runWebGLProgram(w10, [m10, g10], m10.dtype);
        v10.push(I10);
        var N10 = HEe({ inputs: { x: I10 }, backend: n10, attrs: { shape: f10.outputShape } });
        return v10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), N10;
      }
      var t_e = { kernelName: L1, backendName: "webgl", kernelFunc: e_e }, n_e = LEe({ opSnippet: "return float(a > b);", packedOpSnippet: "\n  return vec4(greaterThan(a, b));\n", cpuKernelImpl: cTe, dtype: "bool" }), r_e = { kernelName: P1, backendName: "webgl", kernelFunc: n_e }, a_e = LEe({ opSnippet: "return float(a >= b);", packedOpSnippet: "\n  return vec4(greaterThanEqual(a, b));\n", dtype: "bool", cpuKernelImpl: lTe }), i_e = { kernelName: B1, backendName: "webgl", kernelFunc: a_e };
      var o_e = { kernelName: U1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend;
        return ORe(t10.input, true, n10);
      } }, s_e = MEe({ opSnippet: "return float(!isnan(x) && !isinf(x));", dtype: "bool" }), u_e = { kernelName: G1, backendName: "webgl", kernelFunc: s_e }, c_e = MEe({ opSnippet: "return float(isinf(x));", dtype: "bool" }), l_e = { kernelName: j1, backendName: "webgl", kernelFunc: c_e }, h_e = MEe({ opSnippet: "return float(isnan(x));", dtype: "bool" }), p_e = { kernelName: H1, backendName: "webgl", kernelFunc: h_e }, f_e = LEe({ opSnippet: "return float(a < b);", packedOpSnippet: "\n  return vec4(lessThan(a, b));\n", cpuKernelImpl: hTe, dtype: "bool" }), d_e = { kernelName: K1, backendName: "webgl", kernelFunc: f_e }, v_e = LEe({ opSnippet: "return float(a <= b);", packedOpSnippet: "\n  return vec4(lessThanEqual(a, b));\n", cpuKernelImpl: pTe, dtype: "bool" }), m_e = { kernelName: X1, backendName: "webgl", kernelFunc: v_e };
      var g_e = { kernelName: Y1, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.backend, n10 = e10.attrs, r10 = n10.start, a10 = n10.stop, i10 = n10.num, o10 = fTe(r10, a10, i10);
        return t10.makeTensorInfo([o10.length], "float32", o10);
      } }, y_e = MEe({ opSnippet: "if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n", packedOpSnippet: "\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n", cpuKernelImpl: dTe }), b_e = { kernelName: J1, backendName: "webgl", kernelFunc: y_e }, x_e = MEe({ opSnippet: "if (isnan(x)) return x;\n  return log(1.0 + x);\n" }), k_e = { kernelName: Z1, backendName: "webgl", kernelFunc: x_e }, w_e = LEe({ opSnippet: "return float(a >= 1.0 && b >= 1.0);", packedOpSnippet: "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n", dtype: "bool" }), I_e = { kernelName: Q1, backendName: "webgl", kernelFunc: w_e }, N_e = MEe({ opSnippet: "return float(!(x >= 1.0));" }), S_e = { kernelName: $1, backendName: "webgl", kernelFunc: N_e }, T_e = LEe({ opSnippet: "return float(a >= 1.0 || b >= 1.0);", packedOpSnippet: "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n", dtype: "bool" }), E_e = { kernelName: e2, backendName: "webgl", kernelFunc: T_e }, C_e = p(function e10(t10, n10, r10, a10, i10) {
        l(this, e10), this.variableNames = ["x"], this.outputShape = [];
        var o10, s10 = n10, u10 = t10[3] - 1;
        this.outputShape = t10;
        var c10 = "float(".concat(r10, ") + float(").concat(a10, ") * sum");
        o10 = 0.5 === i10 ? "inversesqrt(".concat(c10, ")") : 1 === i10 ? "1.0/(".concat(c10, ")") : "exp(log(".concat(c10, ") * float(-").concat(i10, "));"), this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(s10, "; j <= ").concat(s10, "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(u10, ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(o10, ";\n        setOutput(val);\n      }\n    ");
      }), A_e = p(function e10(t10, n10, r10, a10, i10) {
        l(this, e10), this.variableNames = ["x"], this.outputShape = [], this.packedInputs = true, this.packedOutput = true;
        var o10, s10 = n10, u10 = t10[3] - 1;
        this.outputShape = t10;
        var c10 = "float(".concat(r10, ") + float(").concat(a10, ") * sum");
        o10 = 0.5 === i10 ? "inversesqrt(".concat(c10, ")") : 1 === i10 ? "1.0/(".concat(c10, ")") : "exp(log(".concat(c10, ") * float(-").concat(i10, "));"), this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3], ";\n        bool hasNextRow = c < ").concat(this.outputShape[2], ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(s10, ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(s10, "; j <= ").concat(s10, "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(u10, "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(o10, ";\n        setOutput(result);\n      }\n    ");
      }), R_e = { kernelName: n2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.depthRadius, o10 = r10.bias, s10 = r10.alpha, u10 = r10.beta, c10 = k0().getBool("WEBGL_PACK_NORMALIZATION") ? new A_e(a10.shape, i10, o10, s10, u10) : new C_e(a10.shape, i10, o10, s10, u10);
        return n10.runWebGLProgram(c10, [a10], a10.dtype);
      } }, __e = p(function e10(t10, n10, r10, a10, i10) {
        l(this, e10), this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = t10, this.depth = t10[3], this.depthRadius = n10, this.bias = r10, this.alpha = a10, this.beta = i10, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth, "; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(n10, ")));\n          int depthEnd = int(min(float(").concat(this.depth, "),\n              float(d + ").concat(n10, " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth, ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(a10, ") * norm + float(").concat(r10, ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(a10, ")\n                * float(").concat(i10, ")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(i10, ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ");
      }), O_e = { kernelName: r2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.y, o10 = t10.dy, s10 = r10.depthRadius, u10 = r10.bias, c10 = r10.alpha, l10 = r10.beta, h10 = new __e(a10.shape, s10, u10, c10, l10);
        return n10.runWebGLProgram(h10, [a10, i10, o10], a10.dtype);
      } };
      function F_e(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.reductionIndices, o10 = r10.keepDims, s10 = a10.shape.length, u10 = j$(i10, a10.shape), c10 = u10, l10 = $7(c10, s10), h10 = null != l10, p10 = n10.shouldExecuteOnCPU([a10]), f10 = a10;
        if (h10) {
          if (p10) {
            for (var d10 = n10.texData.get(f10.dataId).values, v10 = new Array(s10), m10 = 0; m10 < v10.length; m10++) v10[m10] = a10.shape[l10[m10]];
            var g10 = GTe(d10, a10.shape, a10.dtype, l10, v10);
            f10 = n10.makeTensorInfo(v10, a10.dtype), n10.texData.get(f10.dataId).values = g10;
          } else f10 = QEe(a10, l10, n10);
          c10 = t9(c10.length, s10);
        }
        Q7("max", c10, s10);
        var y10, b10 = S(J7(f10.shape, c10), 2), x10 = b10[0], k10 = b10[1], w10 = x10;
        if (o10 && (w10 = Z7(x10, u10)), p10) {
          var I10 = n10.texData.get(f10.dataId).values, N10 = vTe(I10, L$(k10), w10, a10.dtype);
          y10 = n10.makeTensorInfo(w10, a10.dtype), n10.texData.get(y10.dataId).values = N10;
        } else y10 = function(e11, t11, n11, r11) {
          var a11 = L$(t11), i11 = HEe({ inputs: { x: e11 }, attrs: { shape: [L$(e11.shape) / a11, a11] }, backend: r11 }), o11 = YEe(i11, e11.dtype, "max", r11), s11 = HEe({ inputs: { x: o11 }, attrs: { shape: n11 }, backend: r11 });
          return r11.disposeIntermediateTensorInfo(i11), r11.disposeIntermediateTensorInfo(o11), s11;
        }(f10, k10, w10, n10);
        return h10 && n10.disposeIntermediateTensorInfo(f10), y10;
      }
      var D_e = { kernelName: a2, backendName: "webgl", kernelFunc: F_e }, M_e = LEe({ opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n", packedOpSnippet: "\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n", cpuKernelImpl: mTe }), L_e = { kernelName: i2, backendName: "webgl", kernelFunc: M_e };
      var z_e = { kernelName: o2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x;
        MNe(a10, "maxPool");
        var i10 = r10.filterSize, o10 = r10.strides, s10 = r10.pad, u10 = r10.dimRoundingMode;
        F$(j8(o10, 1), function() {
          return "Error in maxPool: Either strides or dilations must be 1. " + "Got strides ".concat(o10, " and dilations '").concat(1, "'");
        });
        var c10 = O8(a10.shape, i10, o10, 1, s10, u10);
        if (1 === c10.filterWidth && 1 === c10.filterHeight && P$(c10.inShape, c10.outShape)) return SEe({ inputs: { x: a10 }, backend: n10 });
        var l10 = new LCe(c10, "max", false);
        return n10.runWebGLProgram(l10, [a10], a10.dtype);
      } };
      var P_e = { kernelName: u2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.filterSize, o10 = r10.strides, s10 = r10.pad, u10 = r10.dataFormat, c10 = r10.dimRoundingMode, l10 = F8(a10.shape, i10, o10, [1, 1, 1], s10, c10, u10), h10 = new zCe(l10, "max", false);
        return n10.runWebGLProgram(h10, [a10], a10.dtype);
      } }, B_e = p(function e10(t10) {
        l(this, e10), this.variableNames = ["dy", "maxPos"], this.outputShape = t10.inShape;
        var n10 = t10.strideHeight, r10 = t10.strideWidth, a10 = t10.dilationHeight, i10 = t10.effectiveFilterHeight, o10 = t10.effectiveFilterWidth, s10 = i10 - 1 - t10.padInfo.top, u10 = o10 - 1 - t10.padInfo.left, c10 = i10 * o10 - 1;
        this.userCode = "\n      const ivec2 pads = ivec2(".concat(s10, ", ").concat(u10, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(i10, ";\n          wR += ").concat(a10, ") {\n          float dyR = float(dyRCorner + wR) / ").concat(n10, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t10.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(o10, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r10, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t10.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(c10, " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(o10, " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
      }), W_e = p(function e10(t10) {
        l(this, e10), this.variableNames = ["dy", "maxPos"], this.outputShape = t10.inShape;
        var n10 = t10.strideDepth, r10 = t10.strideHeight, a10 = t10.strideWidth, i10 = t10.dilationDepth, o10 = t10.dilationHeight, s10 = t10.dilationWidth, u10 = t10.effectiveFilterDepth, c10 = t10.effectiveFilterHeight, h10 = t10.effectiveFilterWidth, p10 = u10 - 1 - t10.padInfo.front, f10 = c10 - 1 - t10.padInfo.top, d10 = h10 - 1 - t10.padInfo.left, v10 = u10 * c10 * h10 - 1;
        this.userCode = "\n      const ivec3 pads = ivec3(".concat(p10, ", ").concat(f10, ", ").concat(d10, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u10, ";\n           wD += ").concat(i10, ") {\n          float dyD = float(dyDCorner + wD) / ").concat(n10, ".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(t10.outDepth, ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(c10, ";\n              wR += ").concat(o10, ") {\n            float dyR = float(dyRCorner + wR) / ").concat(r10, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t10.outHeight, ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(h10, ";\n                wC += ").concat(s10, ") {\n              float dyC = float(dyCCorner + wC) / ").concat(a10, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t10.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(v10, " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(c10, " * ").concat(h10, " +\n                  wR * ").concat(h10, " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
      });
      var U_e = { kernelName: c2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.dy, i10 = t10.input, o10 = r10.filterSize, s10 = r10.strides, u10 = r10.pad, c10 = r10.dimRoundingMode, l10 = F8(i10.shape, o10, s10, [1, 1, 1], u10, c10), h10 = new zCe(l10, "max", true), p10 = n10.runWebGLProgram(h10, [i10], i10.dtype), f10 = new W_e(l10), d10 = n10.runWebGLProgram(f10, [a10, p10], i10.dtype);
        return n10.disposeIntermediateTensorInfo(p10), d10;
      } };
      var V_e = { kernelName: s2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.dy, i10 = t10.input, o10 = i10;
        MNe([i10, t10.output], "maxPoolGrad");
        var s10 = r10.filterSize, u10 = r10.strides, c10 = r10.pad, l10 = r10.dimRoundingMode, h10 = O8(o10.shape, s10, u10, 1, c10, l10), p10 = new LCe(h10, "max", true), f10 = n10.runWebGLProgram(p10, [o10], o10.dtype), d10 = new B_e(h10), v10 = n10.runWebGLProgram(d10, [a10, f10], o10.dtype);
        return n10.disposeIntermediateTensorInfo(f10), v10;
      } };
      var G_e = { kernelName: l2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.attrs, r10 = e10.backend, a10 = t10.x, i10 = n10.filterSize, o10 = n10.strides, s10 = n10.pad, u10 = n10.includeBatchInIndex, c10 = r10;
        F$(4 === a10.shape.length, function() {
          return "Error in maxPool: input must be rank 4 but got rank ".concat(a10.shape.length, ".");
        });
        var l10 = [1, 1];
        F$(j8(o10, l10), function() {
          return "Error in maxPool: Either strides or dilations must be 1. " + "Got strides ".concat(o10, " and dilations '").concat(l10, "'");
        });
        var h10 = O8(a10.shape, i10, o10, l10, s10), p10 = function(e11, t11, n11, r11) {
          var a11 = new LCe(n11, "max", false), i11 = r11.runWebGLProgram(a11, [e11], "float32");
          return a11 = new LCe(n11, "max", true, true, t11), [i11, r11.runWebGLProgram(a11, [e11], "float32")];
        }(a10, u10, h10, c10), f10 = S(p10, 2);
        return [f10[0], f10[1]];
      } };
      var j_e = { kernelName: h2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.attrs, r10 = e10.backend, a10 = t10.x, i10 = n10.keepDims, o10 = n10.axis, s10 = r10, u10 = a10.shape.length, c10 = j$(o10, a10.shape), l10 = c10, h10 = $7(l10, u10), p10 = null != h10, f10 = s10.shouldExecuteOnCPU([a10]), d10 = [], v10 = a10;
        if (p10) {
          if (f10) {
            for (var m10 = s10.texData.get(v10.dataId).values, g10 = new Array(u10), y10 = 0; y10 < g10.length; y10++) g10[y10] = a10.shape[h10[y10]];
            var b10 = GTe(m10, a10.shape, a10.dtype, h10, g10);
            v10 = s10.makeTensorInfo(g10, a10.dtype), s10.texData.get(v10.dataId).values = b10;
          } else v10 = QEe(a10, h10, s10);
          d10.push(v10), l10 = t9(l10.length, u10);
        }
        Q7("sum", l10, u10);
        var x10 = S(J7(v10.shape, l10), 2), k10 = x10[0], w10 = x10[1], I10 = k10;
        i10 && (I10 = Z7(k10, c10));
        for (var N10 = function(e11, t11, n11, r11) {
          var a11 = L$(t11), i11 = HEe({ inputs: { x: e11 }, attrs: { shape: [L$(e11.shape) / a11, a11] }, backend: r11 }), o11 = YEe(i11, "float32", "mean", r11), s11 = HEe({ inputs: { x: o11 }, attrs: { shape: n11 }, backend: r11 });
          return r11.disposeIntermediateTensorInfo(i11), r11.disposeIntermediateTensorInfo(o11), s11;
        }(v10, w10, I10, s10), T10 = 0, E10 = d10; T10 < E10.length; T10++) {
          var C10 = E10[T10];
          s10.disposeIntermediateTensorInfo(C10);
        }
        return N10;
      } };
      var H_e = { kernelName: p2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.axis, o10 = r10.keepDims, s10 = a10.shape.length, u10 = j$(i10, a10.shape), c10 = u10, l10 = $7(c10, s10), h10 = a10;
        null != l10 && (h10 = tCe({ inputs: { x: a10 }, backend: n10, attrs: { perm: l10 } }), c10 = t9(c10.length, a10.shape.length)), Q7("min", c10, s10);
        var p10, f10 = S(J7(h10.shape, c10), 2), d10 = f10[0], v10 = HEe({ inputs: { x: h10 }, backend: n10, attrs: { shape: [-1, L$(f10[1])] } }), m10 = YEe(v10, v10.dtype, "min", n10);
        return p10 = HEe(o10 ? { inputs: { x: m10 }, backend: n10, attrs: { shape: Z7(d10, u10) } } : { inputs: { x: m10 }, backend: n10, attrs: { shape: d10 } }), n10.disposeIntermediateTensorInfo(v10), n10.disposeIntermediateTensorInfo(m10), null != l10 && n10.disposeIntermediateTensorInfo(h10), p10;
      } }, q_e = LEe({ opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n", packedOpSnippet: "\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n", cpuKernelImpl: gTe }), K_e = { kernelName: f2, backendName: "webgl", kernelFunc: q_e }, X_e = p(function e10(t10, n10, r10) {
        l(this, e10), this.variableNames = ["x"], this.outputShape = n10.map(function(e11, n11) {
          return e11[0] + t10[n11] + e11[1];
        });
        var a10 = t10.length, i10 = cSe(a10), o10 = n10.map(function(e11) {
          return e11[0];
        }).join(","), s10 = n10.map(function(e11, n11) {
          return e11[0] + t10[n11];
        }).join(","), u10 = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, a10), c10 = "reflect" === r10 ? 0 : 1;
        this.userCode = 1 !== a10 ? "\n      ".concat(i10, " start = ").concat(i10, "(").concat(o10, ");\n      ").concat(i10, " end = ").concat(i10, "(").concat(s10, ");\n\n      void main() {\n        ").concat(i10, " outC = getOutputCoords();\n        for (int i = 0; i < ").concat(a10, "; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(c10, ";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(c10, ";\n          }\n        }\n        ").concat(i10, " coords = outC - start;\n        setOutput(getX(").concat(u10, "));\n      }\n    ") : "\n        int start = ".concat(o10, ";\n        int end = ").concat(s10, ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(c10, ";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(c10, ";\n          }\n          setOutput(getX(outC - start));\n        }\n      ");
      }), Y_e = p(function e10(t10, n10, r10) {
        l(this, e10), this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.outputShape = n10.map(function(e11, n11) {
          return e11[0] + t10[n11] + e11[1];
        });
        var a10 = t10.length, i10 = cSe(a10), o10 = n10.map(function(e11) {
          return e11[0];
        }).join(","), s10 = n10.map(function(e11, n11) {
          return e11[0] + t10[n11];
        }).join(","), u10 = qTe("rc", a10), c10 = qTe("source", a10), h10 = "".concat(u10[a10 - 1], " < ").concat(this.outputShape[a10 - 1]), p10 = 1 === a10 ? "source" : "vec2(".concat(c10.slice(-2).join(), ")"), f10 = "reflect" === r10 ? 0 : 1, d10 = "";
        if (1 === a10) {
          var v10 = "\n        ".concat(i10, " source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(f10, ";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(f10, ";\n        }\n        source -= start;\n      ");
          d10 = "\n        ".concat(i10, " rc = outputLoc;\n        ").concat(v10, "\n        result[0] = getChannel(getX(").concat(c10.join(), "), ").concat(p10, ");\n        ").concat(u10[a10 - 1], " += 1;\n        if(").concat(h10, ") {\n          ").concat(v10, "\n          result[1] = getChannel(getX(").concat(c10.join(), "), ").concat(p10, ");\n        }\n      ");
        } else {
          var m10 = "\n        ".concat(i10, " source = rc;\n        ").concat(i10, " lt = ").concat(i10, "(lessThan(source, start));\n        ").concat(i10, " gte = ").concat(i10, "(greaterThanEqual(source, end));\n        ").concat(i10, " orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(f10, ") +\n                gte * ((end - 1) * 2 - source + ").concat(f10, ");\n        source -= start;\n      ");
          d10 = "\n        ".concat(i10, " rc = outputLoc;\n        ").concat(m10, "\n        result[0] = getChannel(getX(").concat(c10.join(), "), ").concat(p10, ");\n        ").concat(u10[a10 - 1], " += 1;\n        if(").concat(h10, ") {\n          ").concat(m10, "\n          result[1] = getChannel(getX(").concat(c10.join(), "), ").concat(p10, ");\n        }\n        rc = outputLoc;\n        ").concat(u10[a10 - 2], " += 1;\n        if(").concat(u10[a10 - 2], " < ").concat(this.outputShape[a10 - 2], ") {\n          ").concat(m10, "\n          result[2] = getChannel(getX(").concat(c10.join(), "), ").concat(p10, ");\n          ").concat(u10[a10 - 1], " += 1;\n          if(").concat(h10, ") {\n            ").concat(m10, "\n            result[3] = getChannel(getX(").concat(c10.join(), "), ").concat(p10, ");\n          }\n        }\n      ");
        }
        this.userCode = "\n      const ".concat(i10, " start = ").concat(i10, "(").concat(o10, ");\n      const ").concat(i10, " end = ").concat(i10, "(").concat(s10, ");\n\n      void main() {\n        ").concat(i10, " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(d10, "\n        setOutput(result);\n      }\n    ");
      }), J_e = { kernelName: d2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.paddings, o10 = r10.mode, s10 = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Y_e(a10.shape, i10, o10) : new X_e(a10.shape, i10, o10);
        return n10.runWebGLProgram(s10, [a10], a10.dtype);
      } }, Z_e = LEe({ opSnippet: "if (b == 0.0) return NAN;\n  return mod(a, b);", packedOpSnippet: "\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n" }), Q_e = { kernelName: v2, backendName: "webgl", kernelFunc: Z_e }, $_e = p(function e10(t10, n10, r10) {
        l(this, e10), this.variableNames = ["probs"], this.customUniforms = [{ name: "seed", type: "float" }], this.outputShape = [t10, r10], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(n10 - 1, "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(n10 - 1, "));\n      }\n    ");
      }), eOe = LEe({ opSnippet: "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;", packedOpSnippet: "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n", checkOutOfBounds: true }), tOe = { kernelName: k1, backendName: "webgl", kernelFunc: eOe }, nOe = "return a - b;", rOe = LEe({ opSnippet: nOe, packedOpSnippet: nOe, supportsComplex: true, cpuKernelImpl: WTe }), aOe = { kernelName: x3, backendName: "webgl", kernelFunc: rOe };
      function iOe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.logits, i10 = j$([r10.dim], a10.shape), o10 = F_e({ inputs: { x: a10 }, backend: n10, attrs: { reductionIndices: i10, keepDims: false } }), s10 = Z7(o10.shape, i10), u10 = HEe({ inputs: { x: o10 }, backend: n10, attrs: { shape: s10 } }), c10 = rOe({ inputs: { a: a10, b: u10 }, backend: n10 }), l10 = NRe({ inputs: { x: c10 }, backend: n10 }), h10 = $Ee({ inputs: { x: l10 }, backend: n10, attrs: { axis: i10, keepDims: false } }), p10 = HEe({ inputs: { x: h10 }, backend: n10, attrs: { shape: s10 } }), f10 = eOe({ inputs: { a: l10, b: p10 }, backend: n10 });
        return n10.disposeIntermediateTensorInfo(o10), n10.disposeIntermediateTensorInfo(u10), n10.disposeIntermediateTensorInfo(c10), n10.disposeIntermediateTensorInfo(l10), n10.disposeIntermediateTensorInfo(h10), n10.disposeIntermediateTensorInfo(p10), f10;
      }
      var oOe = { kernelName: s3, backendName: "webgl", kernelFunc: iOe };
      var sOe = { kernelName: m2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.logits, i10 = r10.numSamples, o10 = r10.seed, s10 = r10.normalized, u10 = s10 ? a10 : iOe({ inputs: { logits: a10 }, backend: n10, attrs: { dim: a10.shape.length - 1 } }), c10 = u10.shape[0], l10 = u10.shape[1], h10 = new $_e(c10, l10, i10), p10 = [[o10]], f10 = n10.runWebGLProgram(h10, [u10], "int32", p10);
        return s10 || n10.disposeIntermediateTensorInfo(u10), f10;
      } };
      var uOe = { kernelName: y2, backendName: "webgl", kernelFunc: function(e10) {
        var t10, n10 = e10.inputs, r10 = e10.backend, a10 = n10.x;
        if (r10.shouldExecuteOnCPU([a10])) {
          var i10 = r10.texData.get(a10.dataId), o10 = S(bTe(i10.values, a10.shape, a10.dtype), 2), s10 = o10[0], u10 = o10[1];
          return r10.makeTensorInfo(u10, a10.dtype, s10);
        }
        return t10 = k0().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new fEe(a10.shape, "\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n") : new $Te(a10.shape, "if (isnan(x)) return x;\n  return -x;\n"), r10.runWebGLProgram(t10, [a10], a10.dtype);
      } }, cOe = qne;
      var lOe = { kernelName: x2, backendName: "webgl", kernelFunc: function(e10) {
        z3("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.boxes, i10 = t10.scores, o10 = r10.maxOutputSize, s10 = r10.iouThreshold, u10 = r10.scoreThreshold, c10 = n10.readSync(a10.dataId), l10 = n10.readSync(i10.dataId), h10 = cOe(c10, l10, o10, s10, u10).selectedIndices;
        return n10.makeTensorInfo([h10.length], "int32", new Int32Array(h10));
      } }, hOe = Kne;
      var pOe = { kernelName: k2, backendName: "webgl", kernelFunc: function(e10) {
        z3("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.boxes, i10 = t10.scores, o10 = r10.maxOutputSize, s10 = r10.iouThreshold, u10 = r10.scoreThreshold, c10 = r10.padToMaxOutputSize, l10 = n10.readSync(a10.dataId), h10 = n10.readSync(i10.dataId), p10 = hOe(l10, h10, o10, s10, u10, c10), f10 = p10.selectedIndices, d10 = p10.validOutputs;
        return [n10.makeTensorInfo([f10.length], "int32", new Int32Array(f10)), n10.makeTensorInfo([], "int32", new Int32Array([d10]))];
      } }, fOe = Xne;
      var dOe = { kernelName: w2, backendName: "webgl", kernelFunc: function(e10) {
        z3("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.boxes, i10 = t10.scores, o10 = r10.maxOutputSize, s10 = r10.iouThreshold, u10 = r10.scoreThreshold, c10 = r10.softNmsSigma, l10 = n10.readSync(a10.dataId), h10 = n10.readSync(i10.dataId), p10 = fOe(l10, h10, o10, s10, u10, c10), f10 = p10.selectedIndices, d10 = p10.selectedScores;
        return [n10.makeTensorInfo([f10.length], "int32", new Int32Array(f10)), n10.makeTensorInfo([d10.length], "float32", new Float32Array(d10))];
      } }, vOe = p(function e10(t10, n10, r10, a10) {
        l(this, e10), this.variableNames = ["indices"], this.outputShape = [t10, n10], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(a10, "), float(").concat(r10, "),\n                      float(index == coords.y)));\n      }\n    ");
      }), mOe = { kernelName: N2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.indices, i10 = r10.dtype, o10 = r10.depth, s10 = r10.onValue, u10 = r10.offValue, c10 = L$(a10.shape), l10 = new vOe(c10, o10, s10, u10), h10 = HEe({ inputs: { x: a10 }, backend: n10, attrs: { shape: [c10] } }), p10 = n10.runWebGLProgram(l10, [h10], i10);
        n10.disposeIntermediateTensorInfo(h10);
        var f10 = HEe({ inputs: { x: p10 }, backend: n10, attrs: { shape: [].concat(T(a10.shape), [o10]) } });
        return n10.disposeIntermediateTensorInfo(p10), f10;
      } };
      function gOe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.x;
        if ("complex64" === r10.dtype) {
          var a10 = iAe({ inputs: { input: r10 }, backend: n10 }), i10 = gOe({ inputs: { x: a10 }, backend: n10 }), o10 = xAe({ inputs: { input: r10 }, backend: n10 }), s10 = gOe({ inputs: { x: o10 }, backend: n10 }), u10 = EEe({ inputs: { real: i10, imag: s10 }, backend: n10 });
          return n10.disposeIntermediateTensorInfo(a10), n10.disposeIntermediateTensorInfo(i10), n10.disposeIntermediateTensorInfo(o10), n10.disposeIntermediateTensorInfo(s10), u10;
        }
        return MRe({ attrs: { shape: r10.shape, dtype: r10.dtype, value: "string" === r10.dtype ? "" : 0 }, backend: n10 });
      }
      var yOe = { kernelName: R3, backendName: "webgl", kernelFunc: gOe };
      var bOe = { kernelName: I2, backendName: "webgl", kernelFunc: function e10(t10) {
        var n10 = t10.inputs, r10 = t10.backend, a10 = n10.x;
        if ("string" === a10.dtype) throw new Error("onesLike is not supported under string dtype");
        if ("complex64" === a10.dtype) {
          var i10 = iAe({ inputs: { input: a10 }, backend: r10 }), o10 = e10({ inputs: { x: i10 }, backend: r10 }), s10 = xAe({ inputs: { input: a10 }, backend: r10 }), u10 = gOe({ inputs: { x: s10 }, backend: r10 }), c10 = EEe({ inputs: { real: o10, imag: u10 }, backend: r10 });
          return r10.disposeIntermediateTensorInfo(i10), r10.disposeIntermediateTensorInfo(o10), r10.disposeIntermediateTensorInfo(s10), r10.disposeIntermediateTensorInfo(u10), c10;
        }
        return MRe({ attrs: { shape: a10.shape, dtype: a10.dtype, value: 1 }, backend: r10 });
      } };
      var xOe = { kernelName: S2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs.axis;
        if (1 === t10.length) return TRe({ inputs: { input: t10[0] }, backend: n10, attrs: { dim: r10 } });
        var a10 = t10[0].shape, i10 = t10[0].dtype;
        t10.forEach(function(e11) {
          D$(a10, e11.shape, "All tensors passed to stack must have matching shapes"), F$(i10 === e11.dtype, function() {
            return "All tensors passed to stack must have matching dtypes";
          });
        });
        var o10 = [], s10 = IAe({ inputs: t10.map(function(e11) {
          var t11 = TRe({ inputs: { input: e11 }, backend: n10, attrs: { dim: r10 } });
          return o10.push(t11), t11;
        }), backend: n10, attrs: { axis: r10 } });
        return o10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), s10;
      } }, kOe = p(function e10(t10, n10, r10) {
        l(this, e10), this.variableNames = ["x"], this.customUniforms = [{ name: "value", type: "float" }], this.outputShape = n10.map(function(e11, n11) {
          return e11[0] + t10[n11] + e11[1];
        });
        var a10 = t10.length, i10 = cSe(a10), o10 = n10.map(function(e11) {
          return e11[0];
        }).join(","), s10 = n10.map(function(e11, n11) {
          return e11[0] + t10[n11];
        }).join(","), u10 = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, a10);
        this.userCode = 1 !== a10 ? "\n      ".concat(i10, " start = ").concat(i10, "(").concat(o10, ");\n      ").concat(i10, " end = ").concat(i10, "(").concat(s10, ");\n\n      void main() {\n        ").concat(i10, " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(i10, " coords = outC - start;\n          setOutput(getX(").concat(u10, "));\n        }\n      }\n    ") : "\n        int start = ".concat(o10, ";\n        int end = ").concat(s10, ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ");
      }), wOe = p(function e10(t10, n10, r10) {
        l(this, e10), this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "value", type: "float" }], this.outputShape = n10.map(function(e11, n11) {
          return e11[0] + t10[n11] + e11[1];
        });
        for (var a10 = t10.length, i10 = cSe(a10), o10 = n10.map(function(e11) {
          return e11[0];
        }).join(","), s10 = n10.map(function(e11, n11) {
          return e11[0] + t10[n11];
        }).join(","), u10 = qTe("rc", a10), c10 = qTe("source", a10), h10 = "".concat(u10[a10 - 1], " < ").concat(this.outputShape[a10 - 1]), p10 = 1 === a10 ? "source" : "vec2(".concat(c10.slice(-2).join(), ")"), f10 = ["".concat(i10, " rc = outputLoc;"), "".concat(u10[a10 - 1], " += 1;\n       if(").concat(h10, ") {\n      "), 1 === a10 ? "" : "}\n       rc = outputLoc;\n       ".concat(u10[a10 - 2], " += 1;\n       if(").concat(u10[a10 - 2], " < ").concat(this.outputShape[a10 - 2], ") {"), 1 === a10 ? "" : "  ".concat(u10[a10 - 1], " += 1;\n         if(").concat(h10, ") {")], d10 = 1 === a10 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", v10 = "", m10 = 0, g10 = 1 === a10 ? 2 : 4; m10 < g10; m10++) v10 += "\n        ".concat(f10[m10], "\n        if (").concat(d10, ") {\n          result[").concat(m10, "] = float(value);\n        } else {\n          ").concat(i10, " source = rc - start;\n          result[").concat(m10, "] = getChannel(getX(").concat(c10.join(), "), ").concat(p10, ");\n        }\n      ");
        v10 += 1 === a10 ? "} " : "}}", this.userCode = "\n      const ".concat(i10, " start = ").concat(i10, "(").concat(o10, ");\n      const ").concat(i10, " end = ").concat(i10, "(").concat(s10, ");\n\n      void main() {\n        ").concat(i10, " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(v10, "\n        setOutput(result);\n      }\n    ");
      }), IOe = function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.paddings, o10 = r10.constantValue;
        if (0 === L$(a10.shape)) {
          var s10 = i10.map(function(e11, t11) {
            return e11[0] + a10.shape[t11] + e11[1];
          });
          return MRe({ backend: n10, attrs: { shape: s10, value: o10, dtype: a10.dtype } });
        }
        var u10 = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new wOe(a10.shape, i10, o10) : new kOe(a10.shape, i10, o10), c10 = [[o10]];
        return n10.runWebGLProgram(u10, [a10], a10.dtype, c10);
      }, NOe = { kernelName: T2, backendName: "webgl", kernelFunc: IOe }, SOe = LEe({ opSnippet: "\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n", packedOpSnippet: "\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n" }), TOe = { kernelName: E2, backendName: "webgl", kernelFunc: SOe };
      var EOe = { kernelName: A2, backendName: "webgl", kernelFunc: function(e10) {
        var t10, n10 = e10.inputs, r10 = e10.backend, a10 = e10.attrs, i10 = n10.x, o10 = a10.axis, s10 = a10.keepDims, u10 = i10.shape.length, c10 = [], l10 = j$(o10, i10.shape), h10 = l10, p10 = $7(h10, u10), f10 = i10;
        if (null != p10 && (f10 = tCe({ inputs: { x: i10 }, backend: r10, attrs: { perm: p10 } }), h10 = t9(h10.length, u10), c10.push(f10)), Q7("prod", h10, u10), r10.shouldExecuteOnCPU([f10])) {
          var d10 = r10.texData.get(f10.dataId).values, v10 = kTe(f10.shape, f10.dtype, d10, h10), m10 = v10.outVals, g10 = v10.outShape, y10 = v10.outDtype;
          t10 = r10.makeTensorInfo(g10, y10, m10);
        } else {
          var b10 = S(J7(f10.shape, h10), 2), x10 = b10[0], k10 = L$(b10[1]), w10 = HEe({ inputs: { x: f10 }, backend: r10, attrs: { shape: [-1, k10] } }), I10 = YEe(w10, p5(i10.dtype), "prod", r10);
          t10 = HEe({ inputs: { x: I10 }, backend: r10, attrs: { shape: x10 } }), c10.push(w10), c10.push(I10);
        }
        if (s10) {
          c10.push(t10);
          var N10 = Z7(t10.shape, l10);
          t10 = HEe({ inputs: { x: t10 }, backend: r10, attrs: { shape: N10 } });
        }
        return c10.forEach(function(e11) {
          return r10.disposeIntermediateTensorInfo(e11);
        }), t10;
      } };
      var COe = { kernelName: R2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.paramsNestedSplits, i10 = t10.paramsDenseValues, o10 = t10.indices, s10 = r10.outputRaggedRank, u10 = a10.map(function(e11) {
          return n10.readSync(e11.dataId);
        }), c10 = a10.map(function(e11) {
          return e11.shape;
        }), l10 = n10.readSync(i10.dataId), h10 = n10.readSync(o10.dataId), p10 = S(wTe(u10, c10, l10, i10.shape, i10.dtype, h10, o10.shape, s10), 3), f10 = p10[0], d10 = p10[1], v10 = p10[2], m10 = f10.map(function(e11) {
          return n10.makeTensorInfo([e11.length], "int32", e11);
        }), g10 = n10.makeTensorInfo(v10, i10.dtype, d10);
        return m10.concat([g10]);
      } };
      var AOe = { kernelName: _2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.starts, a10 = t10.limits, i10 = t10.deltas, o10 = n10.readSync(r10.dataId), s10 = n10.readSync(a10.dataId), u10 = n10.readSync(i10.dataId), c10 = S(ITe(o10, r10.shape, r10.dtype, s10, a10.shape, u10, i10.shape), 2), l10 = c10[0], h10 = c10[1];
        return [n10.makeTensorInfo([l10.length], "int32", l10), n10.makeTensorInfo([h10.length], r10.dtype, h10)];
      } };
      var ROe = { kernelName: O2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.shape, i10 = t10.values, o10 = t10.defaultValue, s10 = t10.rowPartitionTensors, u10 = r10.rowPartitionTypes, c10 = n10.readSync(a10.dataId), l10 = n10.readSync(i10.dataId), h10 = n10.readSync(o10.dataId), p10 = s10.map(function(e11) {
          return n10.readSync(e11.dataId);
        }), f10 = s10.map(function(e11) {
          return e11.shape;
        }), d10 = S(NTe(c10, a10.shape, l10, i10.shape, i10.dtype, h10, o10.shape, p10, f10, u10), 2), v10 = d10[0], m10 = d10[1];
        return n10.makeTensorInfo(v10, i10.dtype, m10);
      } }, _Oe = function(e10) {
        var t10 = e10.backend, n10 = e10.attrs, r10 = n10.start, a10 = n10.stop, i10 = n10.step, o10 = n10.dtype, s10 = STe(r10, a10, i10, o10);
        return t10.makeTensorInfo([s10.length], o10, s10);
      }, OOe = { kernelName: F2, backendName: "webgl", kernelFunc: _Oe }, FOe = MEe({ opSnippet: "return 1.0 / x;" }), DOe = { kernelName: M2, backendName: "webgl", kernelFunc: FOe }, MOe = MEe({ opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n", packedOpSnippet: "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" }), LOe = { kernelName: L2, backendName: "webgl", kernelFunc: MOe }, zOe = MEe({ opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n", packedOpSnippet: "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" }), POe = { kernelName: V2, backendName: "webgl", kernelFunc: zOe }, BOe = p(function e10(t10, n10, r10, a10, i10) {
        l(this, e10), this.variableNames = ["A"], this.outputShape = [];
        var o10 = S(t10, 4), s10 = o10[0], u10 = o10[1], c10 = o10[2], h10 = o10[3];
        this.outputShape = [s10, n10, r10, h10];
        var p10, f10 = [a10 && n10 > 1 ? u10 - 1 : u10, a10 && r10 > 1 ? c10 - 1 : c10], d10 = [a10 && n10 > 1 ? n10 - 1 : n10, a10 && r10 > 1 ? r10 - 1 : r10];
        p10 = i10 ? "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(f10[0] / d10[0], ",\n          ").concat(f10[1] / d10[1], ");\n      const vec2 inputShapeRC = vec2(").concat(u10, ".0, ").concat(c10, ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(p10, ";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ");
      }), WOe = p(function e10(t10, n10, r10, a10, i10) {
        l(this, e10), this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
        var o10 = S(t10, 4), s10 = o10[0], u10 = o10[1], c10 = o10[2], h10 = o10[3];
        this.outputShape = [s10, n10, r10, h10];
        var p10, f10 = [a10 && n10 > 1 ? u10 - 1 : u10, a10 && r10 > 1 ? c10 - 1 : c10], d10 = [a10 && n10 > 1 ? n10 - 1 : n10, a10 && r10 > 1 ? r10 - 1 : r10];
        p10 = i10 ? "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(f10[0] / d10[0], ",\n          ").concat(f10[1] / d10[1], ",\n          ").concat(f10[1] / d10[1], ");\n      const vec3 inputShapeRC = vec3(").concat(u10, ".0, ").concat(c10, ".0,\n                                     ").concat(c10, ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(p10, ";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(h10 - 1, ";\n        bool hasNextRow = coords.z < ").concat(r10 - 1, ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ");
      });
      var UOe = { kernelName: W2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.images, i10 = r10.alignCorners, o10 = r10.halfPixelCenters, s10 = S(r10.size, 2), u10 = s10[0], c10 = s10[1], l10 = k0().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new WOe(a10.shape, u10, c10, i10, o10) : new BOe(a10.shape, u10, c10, i10, o10);
        return n10.runWebGLProgram(l10, [a10], "float32");
      } }, VOe = p(function e10(t10, n10, r10) {
        l(this, e10), this.variableNames = ["dy"], this.outputShape = [], this.outputShape = n10;
        var a10 = S(n10, 3), i10 = a10[1], o10 = a10[2], s10 = S(t10, 3), u10 = s10[1], c10 = s10[2], h10 = [r10 && u10 > 1 ? i10 - 1 : i10, r10 && c10 > 1 ? o10 - 1 : o10], p10 = [r10 && u10 > 1 ? u10 - 1 : u10, r10 && c10 > 1 ? c10 - 1 : c10], f10 = h10[0] / p10[0], d10 = h10[1] / p10[1], v10 = 1 / f10, m10 = 1 / d10, g10 = 2 * Math.ceil(v10) + 2, y10 = 2 * Math.ceil(m10) + 2;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(f10, ");\n        const float widthScale = float(").concat(d10, ");\n\n        const float invHeightScale = float(").concat(v10, ");\n        const float invWidthScale = float(").concat(m10, ");\n\n        const int winHeight = int(").concat(g10, ");\n        const int winWidth = int(").concat(y10, ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(u10, ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(c10, ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(i10 - 1, ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(o10 - 1, ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ");
      });
      var GOe = { kernelName: U2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.images, i10 = t10.dy, o10 = r10.alignCorners, s10 = new VOe(i10.shape, a10.shape, o10);
        return n10.runWebGLProgram(s10, [i10], i10.dtype);
      } }, jOe = p(function e10(t10, n10, r10, a10, i10) {
        l(this, e10), this.variableNames = ["A"], this.outputShape = [];
        var o10 = S(t10, 4), s10 = o10[0], u10 = o10[1], c10 = o10[2], h10 = o10[3];
        this.outputShape = [s10, n10, r10, h10];
        var p10, f10 = [a10 && n10 > 1 ? u10 - 1 : u10, a10 && r10 > 1 ? c10 - 1 : c10], d10 = [a10 && n10 > 1 ? n10 - 1 : n10, a10 && r10 > 1 ? r10 - 1 : r10], v10 = a10 ? "0.5" : "0.0";
        p10 = i10 ? "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(f10[0] / d10[0], ",\n          ").concat(f10[1] / d10[1], ");\n      const vec2 inputShapeRC = vec2(").concat(u10, ".0, ").concat(c10, ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(p10, ";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(v10, ")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ");
      }), HOe = p(function e10(t10, n10, r10, a10, i10) {
        l(this, e10), this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
        var o10 = S(t10, 4), s10 = o10[0], u10 = o10[1], c10 = o10[2], h10 = o10[3];
        this.outputShape = [s10, n10, r10, h10];
        var p10, f10 = [a10 && n10 > 1 ? u10 - 1 : u10, a10 && r10 > 1 ? c10 - 1 : c10], d10 = [a10 && n10 > 1 ? n10 - 1 : n10, a10 && r10 > 1 ? r10 - 1 : r10], v10 = a10 ? "0.5" : "0.0";
        p10 = i10 ? "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(f10[0] / d10[0], ",\n          ").concat(f10[1] / d10[1], ",\n          ").concat(f10[1] / d10[1], ");\n      const vec3 inputShapeRC = vec3(").concat(u10, ".0, ").concat(c10, ".0,\n                                     ").concat(c10, ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(p10, ";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(v10, ")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(h10 - 1, ";\n        bool hasNextRow = coords.z < ").concat(r10 - 1, ";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ");
      });
      var qOe = { kernelName: P2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.images, i10 = r10.alignCorners, o10 = r10.halfPixelCenters, s10 = S(r10.size, 2), u10 = s10[0], c10 = s10[1], l10 = k0().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new HOe(a10.shape, u10, c10, i10, o10) : new jOe(a10.shape, u10, c10, i10, o10);
        return n10.runWebGLProgram(l10, [a10], a10.dtype);
      } }, KOe = p(function e10(t10, n10, r10) {
        l(this, e10), this.variableNames = ["dy"], this.outputShape = [], this.outputShape = n10;
        var a10 = S(n10, 3), i10 = a10[1], o10 = a10[2], s10 = S(t10, 3), u10 = s10[1], c10 = s10[2], h10 = [r10 && u10 > 1 ? i10 - 1 : i10, r10 && c10 > 1 ? o10 - 1 : o10], p10 = [r10 && u10 > 1 ? u10 - 1 : u10, r10 && c10 > 1 ? c10 - 1 : c10], f10 = h10[0] / p10[0], d10 = h10[1] / p10[1], v10 = 1 / f10, m10 = 1 / d10, g10 = 2 * Math.ceil(v10) + 2, y10 = 2 * Math.ceil(m10) + 2;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(f10, ");\n        const float widthScale = float(").concat(d10, ");\n\n        const float invHeightScale = float(").concat(v10, ");\n        const float invWidthScale = float(").concat(m10, ");\n\n        const int winHeight = int(").concat(g10, ");\n        const int winWidth = int(").concat(y10, ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(u10, ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(c10, ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(h10[0], ") *\n                (float(dyR) / float(").concat(p10[0], "));\n\n            float sourceFracCol =\n                float(").concat(h10[1], ") *\n                  (float(dyC) / float(").concat(p10[1], "));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(i10, ") - 1),\n                ").concat(r10, " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(o10, ") - 1),\n                ").concat(r10, " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ");
      });
      var XOe = { kernelName: B2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.images, i10 = t10.dy, o10 = r10.alignCorners, s10 = new KOe(i10.shape, a10.shape, o10);
        return n10.runWebGLProgram(s10, [i10], i10.dtype);
      } }, YOe = p(function e10(t10, n10) {
        l(this, e10), this.variableNames = ["x"];
        var r10 = t10.length;
        if (r10 > 4) throw new Error("WebGL backend: Reverse of rank-".concat(r10, " tensor is not yet supported"));
        if (this.outputShape = t10, 1 !== r10) {
          var a10 = t10.map(function(e11, r11) {
            return function(e12) {
              return -1 !== n10.indexOf(e12) && 1 !== t10[e12] ? "".concat(t10[e12], " - coords[").concat(e12, "] - 1") : "coords[".concat(e12, "]");
            }(r11);
          }).join(","), i10 = cSe(r10);
          this.userCode = "\n      void main() {\n        ".concat(i10, " coords = getOutputCoords();\n        setOutput(getX(").concat(a10, "));\n      }\n    ");
        } else this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(t10[0], " - coord - 1));\n        }\n      ");
      }), JOe = p(function e10(t10, n10) {
        l(this, e10), this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true;
        var r10 = t10.length;
        if (r10 > 4) throw new Error("WebGL backend: Reverse of rank-".concat(r10, " tensor is not yet supported"));
        this.outputShape = t10;
        var a10 = qTe("rc", r10), i10 = "".concat(a10[r10 - 1], " + 1 < ").concat(this.outputShape[r10 - 1]), o10 = "".concat(a10[r10 - 2], " + 1 < ").concat(this.outputShape[r10 - 2]), s10 = cSe(r10);
        function u10(e11) {
          var r11 = t10.map(function(r12, a12) {
            return function(e12, r13) {
              return -1 !== n10.indexOf(e12) && 1 !== t10[e12] ? "".concat(t10[e12], " - ").concat(r13[e12], " - 1") : "".concat(r13[e12]);
            }(a12, e11);
          }), a11 = r11.join(","), i11 = r11.slice(-2).join(",");
          return "getChannel(getX(".concat(a11, "), vec2(").concat(i11, "))");
        }
        this.userCode = 1 === r10 ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(t10[0], " - rc - 1),\n            ").concat(t10[0], " - rc - 1);\n          if(").concat(i10, "){\n              result.g = getChannel(getX(").concat(t10[0], " - (rc  + 1) - 1),\n                ").concat(t10[0], " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ") : "\n        void main() {\n          ".concat(s10, " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e11) {
          return u10(e11);
        }(a10.slice()), ";\n          if(").concat(i10, "){\n            result.g = ").concat(function(e11) {
          return e11[r10 - 1] = "(" + e11[r10 - 1] + " + 1)", u10(e11);
        }(a10.slice()), ";\n          }\n          if(").concat(o10, ") {\n            result.b = ").concat(function(e11) {
          return e11[r10 - 2] = "(" + e11[r10 - 2] + " + 1)", u10(e11);
        }(a10.slice()), ";\n            if(").concat(i10, ") {\n              result.a = ").concat(function(e11) {
          return e11[r10 - 1] = "(" + e11[r10 - 1] + " + 1)", e11[r10 - 2] = "(" + e11[r10 - 2] + " + 1)", u10(e11);
        }(a10.slice()), ";\n            }\n          }\n          setOutput(result);\n        }\n    ");
      });
      var ZOe = { kernelName: G2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.dims, o10 = a10.shape.length, s10 = j$(i10, a10.shape);
        if (0 === o10) return SEe({ inputs: { x: a10 }, backend: n10 });
        var u10 = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new JOe(a10.shape, s10) : new YOe(a10.shape, s10);
        return n10.runWebGLProgram(u10, [a10], a10.dtype);
      } }, QOe = p(function e10(t10, n10) {
        l(this, e10), this.variableNames = ["Image"], this.outputShape = [], this.customUniforms = [{ name: "params", type: "vec4" }];
        var r10 = t10[1], a10 = t10[2];
        this.outputShape = t10;
        var i10 = "";
        i10 = "number" == typeof n10 ? "float outputValue = ".concat(n10.toFixed(2), ";") : "\n        vec3 fill = vec3(".concat(n10.join(","), ");\n        float outputValue = fill[coords[3]];"), this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(i10, "\n          if(coordX >= 0 && coordX < ").concat(a10, " && coordY >= 0 && coordY < ").concat(r10, ") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ");
      }), $Oe = { kernelName: F3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.attrs, r10 = e10.backend, a10 = t10.image, i10 = n10.radians, o10 = n10.fillValue, s10 = n10.center, u10 = r10, c10 = new QOe(a10.shape, o10), l10 = S(pie(s10, a10.shape[1], a10.shape[2]), 2), h10 = [[l10[0], l10[1], Math.sin(i10), Math.cos(i10)]];
        return u10.runWebGLProgram(c10, [a10], a10.dtype, h10);
      } }, eFe = MEe({ opSnippet: "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n" }), tFe = { kernelName: j2, backendName: "webgl", kernelFunc: eFe }, nFe = MEe({ opSnippet: "return inversesqrt(x);", cpuKernelImpl: TTe }), rFe = { kernelName: H2, backendName: "webgl", kernelFunc: nFe }, aFe = p(function e10(t10, n10, r10, a10, i10, o10) {
        var s10 = arguments.length > 7 && void 0 !== arguments[7] && arguments[7];
        l(this, e10), this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = o10;
        var u10 = cSe(i10.length), c10 = cSe(o10.length), h10 = "";
        1 === r10 ? h10 = "i" : 2 === r10 && (h10 = "i, j");
        var p10 = "getIndices(".concat(h10, ")"), f10 = "";
        1 === a10 ? f10 = "i" : 2 === a10 && (f10 = "i, coords[1]");
        var d10 = "getUpdates(".concat(f10, ")"), v10 = "";
        s10 && (v10 = "coords[0], coords[1]");
        var m10 = "getDefaultValue(".concat(v10, ")"), g10 = n10 > 1 ? "strides[j]" : "strides";
        this.userCode = "\n        ".concat(u10, " strides = ").concat(u10, "(").concat(i10, ");\n\n        void main() {\n          ").concat(c10, " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(t10, "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(n10, "; j++) {\n              int index = round(").concat(p10, ");\n              flattenedIndex += index * ").concat(g10, ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(d10, ";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(m10, ", sum, float(found)));\n        }\n      ");
      }), iFe = p(function e10(t10, n10, r10, a10, i10, o10) {
        var s10 = arguments.length > 7 && void 0 !== arguments[7] && arguments[7];
        l(this, e10), this.variableNames = ["updates", "indices", "defaultValue"], this.packedInputs = true, this.packedOutput = true, this.outputShape = o10;
        var u10 = cSe(i10.length), c10 = cSe(o10.length), h10 = "";
        1 === r10 ? h10 = "i" : 2 === r10 && (h10 = "i, j");
        var p10 = "getIndices(".concat(h10, ")"), f10 = "";
        1 === a10 ? f10 = "i" : 2 === a10 && (f10 = "i, coords[1]");
        var d10 = "getUpdates(".concat(f10, ")"), v10 = "";
        s10 && (v10 = "coords[0], coords[1]");
        var m10 = "getDefaultValue(".concat(v10, ")"), g10 = n10 > 1 ? "strides[j]" : "strides", y10 = n10 > 1 ? "strides[j + 1]" : "strides";
        this.userCode = "\n        ".concat(u10, " strides = ").concat(u10, "(").concat(i10, ");\n\n        void main() {\n          ").concat(c10, " coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(t10, "; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(n10, "; j+=2) {\n              ivec4 index = round(").concat(p10, ");\n              flattenedIndex += index.xz * ").concat(g10, ";\n              if (j + 1 < ").concat(n10, ") {\n                flattenedIndex += index.yw * ").concat(y10, ";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(d10, ";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(m10, ", sum, found));\n        }\n      ");
      });
      var oFe = { kernelName: q2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.indices, i10 = t10.updates, o10 = r10.shape, s10 = Jte(0, a10, o10), u10 = s10.sliceRank, c10 = s10.numUpdates, l10 = s10.sliceSize, h10 = s10.strides, p10 = s10.outputSize, f10 = [p10 / l10, l10];
        if (0 === p10) return n10.makeTensorInfo(o10, a10.dtype);
        var d10, v10 = HEe({ inputs: { x: a10 }, backend: n10, attrs: { shape: [c10, u10] } }), m10 = HEe({ inputs: { x: i10 }, backend: n10, attrs: { shape: [c10, l10] } }), g10 = n10.makeTensorInfo([], "float32", new Float32Array([0]));
        d10 = k0().getBool("WEBGL_PACK") ? new iFe(c10, u10, v10.shape.length, m10.shape.length, h10, f10) : new aFe(c10, u10, v10.shape.length, m10.shape.length, h10, f10);
        var y10 = n10.runWebGLProgram(d10, [m10, v10, g10], m10.dtype), b10 = HEe({ inputs: { x: y10 }, backend: n10, attrs: { shape: o10 } });
        return n10.disposeIntermediateTensorInfo(v10), n10.disposeIntermediateTensorInfo(m10), n10.disposeIntermediateTensorInfo(y10), n10.disposeIntermediateTensorInfo(g10), b10;
      } }, sFe = p(function e10(t10, n10, r10, a10) {
        l(this, e10), this.variableNames = ["sortedSequence", "values"], this.customUniforms = [{ name: "numInputs", type: "int" }], this.outputShape = [t10, r10];
        var i10 = "for (int i = 0; i < ".concat(Math.ceil(Math.log2(n10 + 1)), "; ++i) { if (left >= right) break;"), o10 = 2 === k0().getNumber("WEBGL_VERSION") ? "while (left < right) {" : i10, s10 = "left" === a10 ? "<" : "<=";
        this.userCode = "\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(o10, "\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(s10, " value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ");
      });
      var uFe = { kernelName: X2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.sortedSequence, i10 = t10.values, o10 = r10.side, s10 = new sFe(a10.shape[0], a10.shape[1], i10.shape[1], o10), u10 = [[a10.shape[1]]];
        return n10.runWebGLProgram(s10, [a10, i10], "int32", u10);
      } }, cFe = p(function e10(t10, n10, r10) {
        var a10, i10;
        if (l(this, e10), this.variableNames = ["c", "a", "b"], this.outputShape = n10, r10 > 4) throw Error("Where for rank ".concat(r10, " is not yet supported"));
        if (1 === r10) i10 = "resRC", a10 = "resRC";
        else {
          for (var o10 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], s10 = [], u10 = [], c10 = 0; c10 < n10.length; c10++) u10.push("".concat(o10[c10])), c10 < t10 && s10.push("".concat(o10[c10]));
          a10 = s10.join(), i10 = u10.join();
        }
        var h10 = cSe(r10);
        this.userCode = "\n      void main() {\n        ".concat(h10, " resRC = getOutputCoords();\n        float cVal = getC(").concat(a10, ");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(i10, "));\n        } else {\n          setOutput(getB(").concat(i10, "));\n        }\n      }\n    ");
      });
      var lFe = { kernelName: Y2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.condition, a10 = t10.t, i10 = t10.e, o10 = new cFe(r10.shape.length, a10.shape, a10.shape.length);
        return n10.runWebGLProgram(o10, [r10, a10, i10], h5(a10.dtype, i10.dtype));
      } }, hFe = MEe({ opSnippet: "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(yie, ";\n  float scale = ").concat(bie, ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n") }), pFe = { kernelName: J2, backendName: "webgl", kernelFunc: hFe }, fFe = MEe({ opSnippet: "if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n", packedOpSnippet: "\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n", cpuKernelImpl: CTe }), dFe = { kernelName: t3, backendName: "webgl", kernelFunc: fFe }, vFe = MEe({ opSnippet: "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n" }), mFe = { kernelName: e3, backendName: "webgl", kernelFunc: vFe }, gFe = MEe({ opSnippet: "if (isnan(x)) return x;\n  return sin(x);\n", packedOpSnippet: "\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(IEe, "\n  return result;\n") }), yFe = { kernelName: Q2, backendName: "webgl", kernelFunc: gFe }, bFe = MEe({ opSnippet: "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n" }), xFe = { kernelName: $2, backendName: "webgl", kernelFunc: bFe }, kFe = MEe({ opSnippet: "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n" }), wFe = { kernelName: n3, backendName: "webgl", kernelFunc: kFe }, IFe = { kernelName: i3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.blockShape, o10 = r10.paddings;
        F$(a10.shape.length <= 4, function() {
          return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
        });
        var s10 = i10.reduce(function(e11, t11) {
          return e11 * t11;
        }), u10 = [[0, 0]];
        u10.push.apply(u10, T(o10));
        for (var c10 = 1 + i10.length; c10 < a10.shape.length; ++c10) u10.push([0, 0]);
        var l10 = [], h10 = IOe({ inputs: { x: a10 }, backend: n10, attrs: { paddings: u10, constantValue: 0 } }), p10 = fie(h10.shape, i10, s10, false), f10 = die(p10.length, i10.length, false), d10 = vie(h10.shape, i10, s10, false), v10 = HEe({ inputs: { x: h10 }, backend: n10, attrs: { shape: p10 } }), m10 = tCe({ inputs: { x: v10 }, backend: n10, attrs: { perm: f10 } }), g10 = HEe({ inputs: { x: m10 }, backend: n10, attrs: { shape: d10 } });
        return l10.push(h10), l10.push(v10), l10.push(m10), l10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), g10;
      } };
      var NFe = { kernelName: u3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.indices, a10 = t10.values, i10 = t10.denseShape, o10 = t10.defaultValue;
        if (1 !== i10.shape.length) throw new Error("Dense shape must be a vector, saw:\n         ".concat(i10.shape));
        if (2 !== r10.shape.length) throw new Error("Indices must be a matrix, saw:\n         ".concat(r10.shape));
        if (1 !== a10.shape.length) throw new Error("Values must be a vector, saw:\n         ".concat(a10.shape));
        if (0 !== o10.shape.length) throw new Error("Default value must be a scalar, saw:\n        ".concat(o10.shape));
        var s10 = n10.readSync(r10.dataId), u10 = n10.readSync(a10.dataId), c10 = n10.readSync(i10.dataId), l10 = n10.readSync(o10.dataId)[0], h10 = S(_Te(s10, r10.shape, r10.dtype, u10, a10.dtype, c10, l10), 5), p10 = h10[0], f10 = h10[1], d10 = h10[2], v10 = h10[3], m10 = h10[4];
        return [n10.makeTensorInfo(f10, r10.dtype, p10), n10.makeTensorInfo([f10[0]], a10.dtype, d10), n10.makeTensorInfo([v10.length], "bool", new Uint8Array(v10.map(function(e11) {
          return Number(e11);
        }))), n10.makeTensorInfo([m10.length], r10.dtype, new Int32Array(m10))];
      } };
      var SFe = { kernelName: c3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.inputIndices, a10 = t10.inputShape, i10 = t10.newShape;
        if (2 !== r10.shape.length) throw new Error("Input indices should be a matrix but received shape ".concat(r10.shape));
        if (1 !== a10.shape.length) throw new Error("Input shape should be a vector but received shape ".concat(a10.shape));
        if (1 !== i10.shape.length) throw new Error("Target shape should be a vector but received shape ".concat(i10.shape));
        var o10 = Array.from(n10.readSync(a10.dataId)), s10 = n10.readSync(r10.dataId), u10 = Array.from(n10.readSync(i10.dataId)), c10 = S(OTe(s10, r10.shape, r10.dtype, o10, u10), 3), l10 = c10[0], h10 = c10[1], p10 = c10[2];
        return [n10.makeTensorInfo(h10, r10.dtype, l10), n10.makeTensorInfo([p10.length], i10.dtype, new Int32Array(p10))];
      } };
      var TFe = { kernelName: l3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.data, a10 = t10.indices, i10 = t10.segmentIds;
        if (r10.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
        if (1 !== a10.shape.length) throw new Error("Indices should be a vector but received shape\n              ".concat(a10.shape));
        if (1 !== i10.shape.length) throw new Error("Segment ids should be a vector but received shape\n              ".concat(i10.shape));
        var o10 = n10.readSync(r10.dataId), s10 = n10.readSync(a10.dataId), u10 = n10.readSync(i10.dataId), c10 = S(FTe(o10, r10.shape, r10.dtype, s10, u10, true), 2), l10 = c10[0], h10 = c10[1];
        return n10.makeTensorInfo(h10, r10.dtype, l10);
      } };
      var EFe = { kernelName: h3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = t10.data, a10 = t10.indices, i10 = t10.segmentIds;
        if (r10.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
        if (1 !== a10.shape.length) throw new Error("Indices should be a vector but received shape\n             ".concat(a10.shape));
        if (1 !== i10.shape.length) throw new Error("Segment ids should be a vector but received shape\n             ".concat(i10.shape));
        var o10 = n10.readSync(r10.dataId), s10 = n10.readSync(a10.dataId), u10 = n10.readSync(i10.dataId), c10 = S(FTe(o10, r10.shape, r10.dtype, s10, u10), 2), l10 = c10[0], h10 = c10[1];
        return n10.makeTensorInfo(h10, r10.dtype, l10);
      } };
      var CFe = { kernelName: p3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.sparseIndices, i10 = t10.sparseValues, o10 = t10.defaultValue, s10 = r10.outputShape, u10 = Jte(0, a10, s10), c10 = u10.sliceRank, l10 = u10.numUpdates, h10 = u10.sliceSize, p10 = u10.strides, f10 = u10.outputSize;
        if ("string" === i10.dtype) {
          var d10 = n10.bufferSync(a10), v10 = n10.bufferSync(i10), m10 = W4(n10.readSync(o10.dataId)[0]), g10 = ETe(d10, v10, s10, f10, h10, l10, c10, p10, m10, false);
          return n10.makeTensorInfo(s10, g10.dtype, g10.values);
        }
        var y10 = new aFe(l10, c10, a10.shape.length, i10.shape.length, p10, [f10, 1], false), b10 = n10.runWebGLProgram(y10, [i10, a10, o10], i10.dtype), x10 = HEe({ inputs: { x: b10 }, backend: n10, attrs: { shape: s10 } });
        return n10.disposeIntermediateTensorInfo(b10), x10;
      } };
      var AFe = { kernelName: o3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.numOrSizeSplits, o10 = j$(r10.axis, a10.shape)[0], s10 = Vie(a10, i10, o10), u10 = a10.shape.length, c10 = new Array(u10).fill(0), l10 = a10.shape.slice();
        return s10.map(function(e11) {
          var t11 = T(l10);
          t11[o10] = e11;
          var r11 = ZCe({ inputs: { x: a10 }, backend: n10, attrs: { begin: c10, size: t11 } });
          return c10[o10] += e11, r11;
        });
      } }, RFe = "return sqrt(x);", _Fe = MEe({ opSnippet: RFe, packedOpSnippet: RFe, cpuKernelImpl: DTe }), OFe = { kernelName: r3, backendName: "webgl", kernelFunc: _Fe }, FFe = { kernelName: d3, backendName: "webgl", kernelFunc: MEe({ opSnippet: "return x * x;" }) }, DFe = "return (a - b) * (a - b);", MFe = LEe({ opSnippet: DFe, packedOpSnippet: DFe }), LFe = { kernelName: f3, backendName: "webgl", kernelFunc: MFe };
      var zFe = { kernelName: v3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x;
        if ("string" !== a10.dtype) throw new Error("Input must be of datatype string");
        var i10 = aoe(n10.readSync(a10.dataId)), o10 = MTe(i10, "string", r10);
        return n10.makeTensorInfo(a10.shape, "string", o10);
      } };
      var PFe = { kernelName: _3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.attrs, r10 = e10.backend, a10 = t10.x, i10 = eEe + "\n    return x > 0.0 ? 1.0 : float(".concat(n10.alpha, ");\n  "), o10 = new $Te(a10.shape, i10);
        return r10.runWebGLProgram(o10, [a10], a10.dtype);
      } }, BFe = p(function e10(t10, n10, r10) {
        l(this, e10), this.variableNames = ["x"], this.outputShape = r10;
        var a10 = r10.length, i10 = cSe(r10.length), o10 = cSe(r10.length), s10 = "";
        if (1 === a10) s10 = "coords * strides + begin";
        else {
          var u10 = 0;
          s10 = r10.map(function(e11, t11) {
            return u10++, 1 === r10.length ? "coords * strides[".concat(t11, "] + begin[").concat(t11, "]") : "coords[".concat(u10 - 1, "] * strides[").concat(t11, "] + begin[").concat(t11, "]");
          }).join(",");
        }
        this.userCode = "\n      ".concat(i10, " begin = ").concat(i10, "(").concat(t10, ");\n      ").concat(i10, " strides = ").concat(i10, "(").concat(n10, ");\n\n      void main() {\n        ").concat(o10, " coords = getOutputCoords();\n        setOutput(getX(").concat(s10, "));\n      }\n    ");
      });
      var WFe = { kernelName: m3, backendName: "webgl", kernelFunc: function(e10) {
        var t10, n10 = e10.inputs, r10 = e10.backend, a10 = e10.attrs, i10 = n10.x, o10 = a10.begin, s10 = a10.end, u10 = a10.strides, c10 = a10.beginMask, l10 = a10.endMask, h10 = a10.ellipsisMask, p10 = a10.newAxisMask, f10 = a10.shrinkAxisMask, d10 = Jae(i10.shape, o10, s10, u10, c10, l10, h10, p10, f10), v10 = d10.finalShapeSparse, m10 = d10.finalShape, g10 = d10.isIdentity, y10 = d10.sliceDim0, b10 = d10.isSimpleSlice, x10 = d10.begin, k10 = d10.end, w10 = d10.strides;
        if (g10) t10 = HEe({ inputs: { x: i10 }, backend: r10, attrs: { shape: m10 } });
        else if (y10 || b10) {
          F$(i10.shape.length >= 1, function() {
            return "Input must have rank at least 1, got: ".concat(i10.shape.length);
          });
          var I10 = Pae(x10, k10, w10), N10 = ZCe({ inputs: { x: i10 }, backend: r10, attrs: { begin: x10, size: I10 } });
          t10 = HEe({ inputs: { x: N10 }, backend: r10, attrs: { shape: m10 } }), r10.disposeIntermediateTensorInfo(N10);
        } else {
          if (r10.shouldExecuteOnCPU([i10])) {
            var S10 = r10.readSync(i10.dataId), T10 = l8(i10.shape, i10.dtype, S10), E10 = LTe(v10, T10, w10, x10);
            t10 = r10.makeTensorInfo(m10, i10.dtype, E10.values);
          } else {
            var C10 = new BFe(x10, w10, v10);
            t10 = r10.runWebGLProgram(C10, [i10], i10.dtype);
          }
        }
        var A10 = HEe({ inputs: { x: t10 }, backend: r10, attrs: { shape: m10 } });
        return r10.disposeIntermediateTensorInfo(t10), A10;
      } };
      var UFe = { kernelName: g3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = r10.separator, i10 = r10.nGramWidths, o10 = r10.leftPad, s10 = r10.rightPad, u10 = r10.padWidth, c10 = r10.preserveShortSequences, l10 = t10.data, h10 = t10.dataSplits, p10 = n10.readSync(l10.dataId), f10 = n10.readSync(h10.dataId), d10 = S(zTe(p10, f10, a10, i10, o10, s10, u10, c10), 2), v10 = d10[0], m10 = d10[1];
        return [n10.makeTensorInfo([v10.length], "string", v10), n10.makeTensorInfo(h10.shape, "int32", m10)];
      } };
      var VFe = { kernelName: y3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs.skipEmpty, a10 = t10.input, i10 = t10.delimiter;
        if ("string" !== a10.dtype) throw new Error("Input must be of datatype string");
        if (1 !== a10.shape.length) throw new Error("Input must be a vector, got shape: ".concat(a10.shape));
        if (0 !== i10.shape.length) throw new Error("Delimiter must be a scalar, got shape: ".concat(i10.shape));
        var o10 = n10.readSync(a10.dataId), s10 = n10.readSync(i10.dataId)[0], u10 = S(PTe(o10, s10, r10), 3), c10 = u10[0], l10 = u10[1], h10 = u10[2], p10 = l10.length;
        return [n10.makeTensorInfo([p10, 2], "int32", c10), n10.makeTensorInfo([p10], "string", l10), n10.makeTensorInfo([2], "int32", new Int32Array(h10))];
      } };
      var GFe = { kernelName: b3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs.numBuckets, a10 = t10.input;
        if ("string" !== a10.dtype) throw new Error("Input must be of datatype string");
        if (r10 <= 0) throw new Error("Number of buckets must be at least 1");
        var i10 = n10.readSync(a10.dataId), o10 = BTe(i10, r10);
        return n10.makeTensorInfo(a10.shape, "int32", o10);
      } }, jFe = MEe({ opSnippet: "return tan(x);" }), HFe = { kernelName: k3, backendName: "webgl", kernelFunc: jFe }, qFe = MEe({ opSnippet: "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n" }), KFe = { kernelName: w3, backendName: "webgl", kernelFunc: qFe };
      var XFe = { kernelName: K2, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.tensor, i10 = t10.indices, o10 = t10.updates;
        !function(e11) {
          if (null == e11) throw new TypeError("Cannot destructure " + e11);
        }(r10);
        var s10 = Jte(0, i10, a10.shape), u10 = s10.sliceRank, c10 = s10.numUpdates, l10 = s10.sliceSize, h10 = s10.strides, p10 = s10.outputSize, f10 = [p10 / l10, l10];
        if (0 === p10) return n10.makeTensorInfo(a10.shape, i10.dtype);
        var d10 = HEe({ inputs: { x: i10 }, backend: n10, attrs: { shape: [c10, u10] } }), v10 = HEe({ inputs: { x: o10 }, backend: n10, attrs: { shape: [c10, l10] } }), m10 = HEe({ inputs: { x: a10 }, backend: n10, attrs: { shape: f10 } }), g10 = new aFe(c10, u10, d10.shape.length, v10.shape.length, h10, f10, false, true), y10 = n10.runWebGLProgram(g10, [v10, d10, m10], m10.dtype), b10 = HEe({ inputs: { x: y10 }, backend: n10, attrs: { shape: a10.shape } });
        return n10.disposeIntermediateTensorInfo(d10), n10.disposeIntermediateTensorInfo(v10), n10.disposeIntermediateTensorInfo(m10), n10.disposeIntermediateTensorInfo(y10), b10;
      } }, YFe = p(function e10(t10, n10) {
        l(this, e10), this.variableNames = ["A"];
        for (var r10 = new Array(t10.length), a10 = 0; a10 < r10.length; a10++) r10[a10] = t10[a10] * n10[a10];
        this.outputShape = r10, this.rank = r10.length;
        var i10 = cSe(this.rank), o10 = function(e11) {
          var t11 = e11.length;
          if (t11 > 5) throw Error("Tile for rank ".concat(t11, " is not yet supported"));
          if (1 === t11) return "imod(resRC, ".concat(e11[0], ")");
          for (var n11 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r11 = [], a11 = 0; a11 < e11.length; a11++) r11.push("imod(".concat(n11[a11], ", ").concat(e11[a11], ")"));
          return r11.join();
        }(t10);
        this.userCode = "\n      void main() {\n        ".concat(i10, " resRC = getOutputCoords();\n        setOutput(getA(").concat(o10, "));\n      }\n    ");
      });
      function JFe(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.reps;
        if ("string" === a10.dtype || a10.shape.length > 5) {
          var o10 = n10.readSync(a10.dataId), s10 = "string" === a10.dtype ? o10.map(function(e11) {
            return W4(e11);
          }) : o10, u10 = l8(a10.shape, a10.dtype, s10), c10 = UTe(u10, i10);
          return n10.makeTensorInfo(c10.shape, c10.dtype, c10.values);
        }
        var l10 = new YFe(a10.shape, i10);
        return n10.runWebGLProgram(l10, [a10], a10.dtype);
      }
      var ZFe = { kernelName: I3, backendName: "webgl", kernelFunc: JFe }, QFe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["x", "indices"], this.customUniforms = [{ name: "n", type: "int" }, { name: "firstPass", type: "int" }, { name: "negativeInf", type: "float" }, { name: "dir", type: "int" }, { name: "inc", type: "int" }], this.outputShape = t10, this.userCode = "\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     ";
      }), $Fe = p(function e10(t10) {
        l(this, e10), this.variableNames = ["x", "indices"], this.customUniforms = [{ name: "n", type: "int" }, { name: "firstPass", type: "int" }, { name: "k", type: "int" }], this.outputShape = t10, this.userCode = "\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     ";
      });
      function eDe(e10, t10) {
        null !== t10 && e10.disposeIntermediateTensorInfo(t10);
      }
      function tDe(e10) {
        for (var t10 = 1; t10 < e10; ) t10 *= 2;
        return t10;
      }
      var nDe = { kernelName: N3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = r10.k, o10 = r10.sorted, s10 = k0().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"), u10 = k0().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"), c10 = a10.shape, l10 = c10[c10.length - 1];
        if (n10.shouldExecuteOnCPU([a10]) || l10 < s10 || i10 > u10) {
          var h10 = n10.readSync(a10.dataId), p10 = S(VTe(h10, c10, a10.dtype, i10, o10), 2), f10 = p10[0], d10 = p10[1];
          return [n10.makeTensorInfo(f10.shape, f10.dtype, f10.values), n10.makeTensorInfo(d10.shape, d10.dtype, d10.values)];
        }
        if (0 === i10) return c10[c10.length - 1] = 0, [n10.makeTensorInfo(c10, a10.dtype, []), n10.makeTensorInfo(c10, "int32", [])];
        if (1 === l10) return [a10, MRe({ attrs: { shape: c10, dtype: "int32", value: 0 }, backend: n10 })];
        var v10 = n10.texData.get(a10.dataId), m10 = null !== v10 && v10.isPacked, g10 = m10 ? n10.unpackTensor(a10) : a10, y10 = L$(c10) / l10, b10 = HEe({ inputs: { x: g10 }, attrs: { shape: [y10, l10] }, backend: n10 });
        m10 && eDe(n10, g10);
        for (var x10 = tDe(i10), k10 = tDe(l10), w10 = null, I10 = function() {
          return null === w10 ? [b10, b10] : [b10, w10];
        }, N10 = function(e11, t11, r11) {
          var a11 = I10(), i11 = new QFe(r11), o11 = [[l10], [null === w10 ? 1 : 0], [Number.NEGATIVE_INFINITY], [e11], [t11]], s11 = w10;
          w10 = n10.runWebGLProgram(i11, a11, "int32", o11), eDe(n10, s11);
        }, T10 = 1; T10 < x10; T10 *= 2) for (var E10 = 2 * T10, C10 = T10; C10 >= 1; C10 /= 2) N10(E10, C10, [y10, k10]);
        for (var A10 = k10; A10 > x10; A10 /= 2) {
          var R10 = I10(), _10 = new $Fe([y10, A10 / 2]), O10 = [[l10], [null === w10 ? 1 : 0], [x10]], F10 = w10;
          w10 = n10.runWebGLProgram(_10, R10, "int32", O10), eDe(n10, F10);
          for (var D10 = x10 / 2, M10 = 2 * D10, L10 = D10; L10 >= 1; L10 /= 2) N10(M10, L10, w10.shape);
        }
        var z10 = w10;
        w10 = ZCe({ inputs: { x: w10 }, backend: n10, attrs: { begin: 0, size: [y10, i10] } }), eDe(n10, z10);
        var P10 = e_e({ inputs: { x: b10, indices: w10 }, backend: n10, attrs: { axis: 1, batchDims: 1 } });
        eDe(n10, b10);
        var B10 = c10.slice(0, -1);
        B10.push(i10), z10 = w10, w10 = HEe({ inputs: { x: w10 }, attrs: { shape: B10 }, backend: n10 }), eDe(n10, z10);
        var W10 = P10;
        return P10 = HEe({ inputs: { x: P10 }, attrs: { shape: B10 }, backend: n10 }), eDe(n10, W10), [P10, w10];
      } }, rDe = p(function e10(t10, n10, r10, a10, i10, o10) {
        l(this, e10), this.variableNames = ["Image", "Transforms"], this.outputShape = o10;
        var s10, u10 = "nearest" === r10 ? 1 : 2;
        switch (a10) {
          case "constant":
          default:
            s10 = 1;
            break;
          case "reflect":
            s10 = 2;
            break;
          case "wrap":
            s10 = 3;
            break;
          case "nearest":
            s10 = 4;
        }
        this.userCode = "\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(s10, " == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(s10, " == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(s10, " == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(t10, " && 0 <= coordX && coordX < ").concat(n10, ") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(i10, ");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(i10, ");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(n10, "));\n                float mapY = mapCoord(inY, float(").concat(t10, "));\n\n                if (").concat(u10, " == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ");
      });
      var aDe = { kernelName: S3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.image, i10 = t10.transforms, o10 = r10.interpolation, s10 = r10.fillMode, u10 = r10.fillValue, c10 = r10.outputShape, l10 = S(a10.shape, 4), h10 = l10[0], p10 = l10[1], f10 = l10[2], d10 = l10[3], v10 = S(null != c10 ? c10 : [p10, f10], 2), m10 = v10[0], g10 = v10[1], y10 = new rDe(p10, f10, o10, s10, u10, [h10, m10, g10, d10]);
        return n10.runWebGLProgram(y10, [a10, i10], "float32");
      } };
      var iDe = { kernelName: E3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.attrs, r10 = e10.backend, a10 = n10.axis, i10 = t10.x;
        MNe(i10, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
        var o10 = r10.readSync(i10.dataId), s10 = jTe(o10, a10, i10.shape, i10.dtype), u10 = s10.outputValues, c10 = s10.outputShape, l10 = s10.indices;
        return [r10.makeTensorInfo(c10, i10.dtype, u10), r10.makeTensorInfo([l10.length], "int32", l10)];
      } };
      var oDe = { kernelName: C3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.value, i10 = r10.axis;
        i10 < 0 && (i10 += a10.shape.length);
        for (var o10 = a10, s10 = o10.shape.length, u10 = a10.shape[i10], c10 = new Array(s10 - 1), l10 = 0, h10 = 0; h10 < s10; h10++) h10 !== i10 && (c10[l10++] = o10.shape[h10]);
        var p10 = [], f10 = new Array(s10).fill(0), d10 = o10.shape.slice();
        d10[i10] = 1;
        for (var v10 = new Array(u10), m10 = 0; m10 < v10.length; m10++) {
          f10[i10] = m10;
          var g10 = ZCe({ inputs: { x: o10 }, backend: n10, attrs: { begin: f10, size: d10 } }), y10 = HEe({ inputs: { x: g10 }, backend: n10, attrs: { shape: c10 } });
          v10[m10] = y10, p10.push(g10);
        }
        return p10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), v10;
      } }, sDe = p(function e10(t10, n10) {
        l(this, e10), this.variableNames = ["x", "segmentIds"];
        var r10 = t10.windowSize, a10 = t10.batchSize, i10 = t10.inSize, o10 = t10.numSegments, s10 = o10 * Math.ceil(i10 / r10);
        this.outputShape = [a10, s10];
        var u10 = 4 * Math.floor(r10 / 4), c10 = r10 % 4, h10 = "\n        sumValue += dot(values, segFilter);\n    ", p10 = "";
        i10 % r10 > 0 && (p10 = "\n        if (inIdx < 0 || inIdx >= ".concat(i10, ") {\n          return initializationValue;\n        }\n      "));
        var f10 = "";
        i10 % r10 > 0 && (f10 = "\n        if (inIdx < 0 || inIdx >= ".concat(i10, ") {\n          return -1.0;\n        }\n      ")), this.userCode = "\n      const float initializationValue = ".concat("0.0", ";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p10, "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(f10, "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(o10, ")) * float(").concat(r10, "));\n        int currentSeg = int(mod(float(outIdx), float(").concat(o10, ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(u10, "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(h10, "\n        }\n\n        int inIdx = inOffset + ").concat(u10, ";\n        if (").concat(1 === c10, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(h10, "\n        } else if (").concat(2 === c10, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(h10, "\n        } else if (").concat(3 === c10, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(h10, "\n        }\n        setOutput(").concat("sumValue", ");\n      }\n    ");
      });
      for (var uDe = { kernelName: A3, backendName: "webgl", kernelFunc: function(e10) {
        var t10 = e10.inputs, n10 = e10.backend, r10 = e10.attrs, a10 = t10.x, i10 = t10.segmentIds, o10 = r10.numSegments, s10 = a10.shape.length, u10 = [], c10 = 0, l10 = $7([c10], s10), h10 = a10;
        null != l10 && (h10 = tCe({ inputs: { x: a10 }, backend: n10, attrs: { perm: l10 } }), u10.push(h10), c10 = t9(1, s10)[0]);
        var p10 = noe(h10.shape, c10, o10), f10 = L$([h10.shape[c10]]), d10 = HEe({ inputs: { x: h10 }, backend: n10, attrs: { shape: [-1, f10] } });
        u10.push(d10);
        var v10 = function e11(t11, r11, a11, i11, o11) {
          var s11 = t11.shape[0], c11 = t11.shape[1], l11 = toe(c11, o11), h11 = new sDe({ windowSize: l11, inSize: c11, batchSize: s11, numSegments: o11 }, r11), p11 = n10.compileAndRun(h11, [t11, a11], i11);
          if (u10.push(p11), p11.shape[1] === o11) return p11;
          var f11 = _Oe({ backend: n10, attrs: { start: 0, stop: o11, step: 1, dtype: "float32" } }), d11 = JFe({ inputs: { x: f11 }, backend: n10, attrs: { reps: [c11 / l11] } });
          return u10.push(f11), u10.push(d11), e11(p11, r11, d11, i11, o11);
        }(d10, "unsortedSegmentSum", i10, p5(a10.dtype), o10), m10 = HEe({ inputs: { x: v10 }, backend: n10, attrs: { shape: p10 } }), g10 = m10;
        if (null != l10) {
          u10.push(m10);
          var y10 = e9(l10);
          g10 = tCe({ inputs: { x: g10 }, backend: n10, attrs: { perm: y10 } });
        }
        return u10.forEach(function(e11) {
          return n10.disposeIntermediateTensorInfo(e11);
        }), g10;
      } }, cDe = 0, lDe = [aCe, oCe, uCe, lCe, fCe, mCe, gCe, yCe, NCe, SCe, ECe, ACe, _Ce, FCe, MCe, PCe, BCe, VCe, GCe, jCe, KCe, $Ce, eAe, tAe, nAe, sAe, lAe, fAe, CEe, mAe, NAe, OAe, zAe, BAe, WAe, UAe, GAe, HAe, KAe, YAe, eRe, tRe, nRe, aRe, sRe, lRe, hRe, fRe, vRe, mRe, yRe, bRe, kRe, IRe, SRe, ERe, RRe, FRe, zRe, BRe, VRe, jRe, KRe, YRe, JRe, QRe, t_e, r_e, i_e, TEe, o_e, kAe, u_e, l_e, p_e, _Ee, d_e, m_e, g_e, b_e, k_e, I_e, S_e, E_e, R_e, O_e, D_e, L_e, z_e, P_e, U_e, V_e, G_e, j_e, H_e, K_e, J_e, Q_e, sOe, jEe, uOe, lOe, pOe, dOe, aAe, mOe, bOe, xOe, NOe, TOe, DEe, EOe, COe, AOe, ROe, OOe, oAe, tOe, DOe, LOe, POe, qEe, UOe, GOe, qOe, XOe, ZOe, $Oe, tFe, rFe, oFe, uFe, lFe, pFe, dFe, mFe, yFe, xFe, QCe, oOe, wFe, IFe, NFe, SFe, TFe, EFe, CFe, AFe, OFe, FFe, LFe, zFe, PFe, WFe, UFe, VFe, GFe, aOe, eCe, HFe, KFe, XFe, ZFe, nDe, aDe, nCe, iDe, oDe, uDe, yOe]; cDe < lDe.length; cDe++) {
        G3(lDe[cDe]);
      }
      var hDe = { "tfjs-core": eie, "tfjs-backend-cpu": Mbe, "tfjs-backend-webgl": bEe, "tfjs-data": rge, "tfjs-layers": Ble, "tfjs-converter": Kve, tfjs: "4.17.0" };
      e.Abs = N0, e.Acos = S0, e.Acosh = T0, e.AdadeltaOptimizer = Jre, e.AdagradOptimizer = Zre, e.AdamOptimizer = Qre, e.AdamaxOptimizer = $re, e.Add = E0, e.AddN = C0, e.All = A0, e.Any = R0, e.ArgMax = _0, e.ArgMin = O0, e.Asin = F0, e.Asinh = D0, e.Atan = M0, e.Atan2 = z0, e.Atanh = L0, e.AvgPool = P0, e.AvgPool3D = W0, e.AvgPool3DGrad = U0, e.AvgPoolGrad = B0, e.BatchMatMul = V0, e.BatchToSpaceND = G0, e.Bincount = j0, e.BitwiseAnd = H0, e.BroadcastArgs = K0, e.BroadcastTo = q0, e.Callback = $fe, e.CallbackList = Jce, e.Cast = X0, e.Ceil = Y0, e.ClipByValue = J0, e.Complex = Z0, e.ComplexAbs = Q0, e.Concat = $0, e.Conv2D = e1, e.Conv2DBackpropFilter = t1, e.Conv2DBackpropInput = n1, e.Conv3D = r1, e.Conv3DBackpropFilterV2 = a1, e.Conv3DBackpropInputV2 = i1, e.Cos = o1, e.Cosh = s1, e.CropAndResize = l1, e.Cumprod = u1, e.Cumsum = c1, e.CustomCallback = $ce, e.DataStorage = S$, e.DenseBincount = h1, e.DepthToSpace = p1, e.DepthwiseConv2dNative = f1, e.DepthwiseConv2dNativeBackpropFilter = d1, e.DepthwiseConv2dNativeBackpropInput = v1, e.Diag = m1, e.Dilation2D = g1, e.Dilation2DBackpropFilter = b1, e.Dilation2DBackpropInput = y1, e.Draw = x1, e.EarlyStopping = nde, e.Einsum = w1, e.Elu = I1, e.EluGrad = N1, e.Environment = y0, e.Equal = T1, e.Erf = S1, e.Exp = E1, e.ExpandDims = C1, e.Expm1 = A1, e.FFT = R1, e.Fill = _1, e.FlipLeftRight = O1, e.Floor = F1, e.FloorDiv = D1, e.FromPixels = O3, e.FusedBatchNorm = M1, e.FusedConv2D = M3, e.FusedDepthwiseConv2D = L3, e.GPGPUContext = YSe, e.GatherNd = z1, e.GatherV2 = L1, e.GraphModel = jve, e.Greater = P1, e.GreaterEqual = B1, e.History = Qce, e.IFFT = U1, e.Identity = W1, e.Imag = V1, e.InputSpec = gce, e.IsFinite = G1, e.IsInf = j1, e.IsNan = H1, e.KernelBackend = T$, e.LRN = n2, e.LRNGrad = r2, e.LayerVariable = dce, e.LayersModel = vhe, e.LeakyRelu = q1, e.Less = K1, e.LessEqual = X1, e.LinSpace = Y1, e.Log = J1, e.Log1p = Z1, e.LogSoftmax = t2, e.LogicalAnd = Q1, e.LogicalNot = $1, e.LogicalOr = e2, e.LogicalXor = "LogicalXor", e.LowerBound = "LowerBound", e.MathBackendCPU = sge, e.MathBackendWebGL = yEe, e.MatrixBandPart = "MatrixBandPart", e.Max = a2, e.MaxPool = o2, e.MaxPool3D = u2, e.MaxPool3DGrad = c2, e.MaxPoolGrad = s2, e.MaxPoolWithArgmax = l2, e.Maximum = i2, e.Mean = h2, e.Min = p2, e.Minimum = f2, e.MirrorPad = d2, e.Mod = v2, e.MomentumOptimizer = tae, e.Multinomial = m2, e.Multiply = g2, e.Neg = y2, e.NonMaxSuppressionV3 = x2, e.NonMaxSuppressionV4 = k2, e.NonMaxSuppressionV5 = w2, e.NotEqual = b2, e.OP_SCOPE_SUFFIX = P5, e.OneHot = N2, e.OnesLike = I2, e.Optimizer = Yre, e.OptimizerConstructors = tie, e.Pack = S2, e.PadV2 = T2, e.Pool = "Pool", e.Pow = E2, e.Prelu = C2, e.Prod = A2, e.RMSPropOptimizer = nae, e.RNN = Ipe, e.RaggedGather = R2, e.RaggedRange = _2, e.RaggedTensorToTensor = O2, e.Range = F2, e.Real = D2, e.RealDiv = k1, e.Reciprocal = M2, e.Relu = L2, e.Relu6 = V2, e.Reshape = z2, e.ResizeBilinear = W2, e.ResizeBilinearGrad = U2, e.ResizeNearestNeighbor = P2, e.ResizeNearestNeighborGrad = B2, e.Reverse = G2, e.RotateWithOffset = F3, e.Round = j2, e.Rsqrt = H2, e.SGDOptimizer = eae, e.ScatterNd = q2, e.SearchSorted = X2, e.Select = Y2, e.Selu = J2, e.Sequential = whe, e.Sigmoid = t3, e.Sign = e3, e.Sin = Q2, e.Sinh = $2, e.Slice = Z2, e.Softmax = s3, e.Softplus = n3, e.SpaceToBatchND = i3, e.SparseFillEmptyRows = u3, e.SparseReshape = c3, e.SparseSegmentMean = l3, e.SparseSegmentSum = h3, e.SparseToDense = p3, e.SplitV = o3, e.Sqrt = r3, e.Square = d3, e.SquaredDifference = f3, e.StaticRegexReplace = v3, e.Step = _3, e.StridedSlice = m3, e.StringNGrams = g3, e.StringSplit = y3, e.StringToHashBucketFast = b3, e.Sub = x3, e.Sum = a3, e.SymbolicTensor = yce, e.Tan = k3, e.Tanh = w3, e.Tensor = n5, e.TensorBuffer = $4, e.TensorScatterUpdate = K2, e.Tile = I3, e.TopK = N3, e.Transform = S3, e.Transpose = T3, e.Unique = E3, e.Unpack = C3, e.UnsortedSegmentSum = A3, e.UpperBound = "UpperBound", e.Variable = c5, e.ZerosLike = R3, e._FusedMatMul = D3, e.abs = y8, e.acos = b8, e.acosh = x8, e.add = d8, e.addN = k8, e.all = w8, e.any = I8, e.argMax = N8, e.argMin = S8, e.asin = T8, e.asinh = E8, e.atan = C8, e.atan2 = A8, e.atanh = R8, e.avgPool = Y8, e.avgPool3d = J8, e.backend = e6, e.backend_util = ooe, e.basicLSTMCell = n7, e.batchNorm = a7, e.batchNorm2d = i7, e.batchNorm3d = o7, e.batchNorm4d = s7, e.batchToSpaceND = r7, e.bincount = u7, e.bitwiseAnd = c7, e.booleanMaskAsync = lne, e.broadcastArgs = l7, e.broadcastTo = h7, e.broadcast_util = P7, e.browser = Dae, e.buffer = l8, e.callbacks = ide, e.cast = h8, e.ceil = p7, e.clipByValue = d7, e.clone = p8, e.complex = W5, e.concat = Z8, e.concat1d = v7, e.concat2d = m7, e.concat3d = g7, e.concat4d = y7, e.constraints = Gce, e.conv1d = x7, e.conv2d = b7, e.conv2dTranspose = w7, e.conv3d = I7, e.conv3dTranspose = S7, e.copyRegisteredKernels = function(e10, t10) {
        V3(e10).forEach(function(e11) {
          G3(Object.assign({}, e11, { backendName: t10 }));
        });
      }, e.cos = T7, e.cosh = E7, e.cosineWindow = bne, e.cumprod = C7, e.cumsum = A7, e.customGrad = F9, e.data = age, e.denseBincount = R7, e.deprecationWarn = H5, e.depthToSpace = _7, e.depthwiseConv2d = O7, e.deregisterOp = function(e10) {
        delete ode[e10];
      }, e.device_util = _5, e.diag = F7, e.dilation2d = D7, e.disableDeprecationWarnings = function() {
        k0().set("DEPRECATION_WARNINGS_ENABLED", false), console.warn("TensorFlow.js deprecation warnings have been disabled.");
      }, e.dispose = Y5, e.disposeVariables = function() {
        E5.disposeVariables();
      }, e.div = m8, e.divNoNan = V7, e.dot = G7, e.dropout = gne, e.einsum = j7, e.elu = H7, e.enableDebugMode = function() {
        k0().set("DEBUG", true);
      }, e.enableProdMode = function() {
        k0().set("PROD", true);
      }, e.enclosingPowerOfTwo = yne, e.engine = q5, e.ensureShape = q7, e.env = k0, e.equal = B7, e.erf = K7, e.euclideanNorm = h9, e.exp = p9, e.expandDims = f9, e.expm1 = d9, e.eye = m9, e.fft = _te, e.fill = f7, e.findBackend = function(e10) {
        return E5.findBackend(e10);
      }, e.findBackendFactory = function(e10) {
        return E5.findBackendFactory(e10);
      }, e.floor = g9, e.floorDiv = v8, e.forceHalfFloat = xEe, e.fused = One, e.gather = y9, e.gatherND = mne, e.gather_util = Lae, e.getBackend = Q5, e.getGradient = U3, e.getKernel = W3, e.getKernelsForBackend = V3, e.gpgpu_util = XSe, e.grad = function(e10) {
        return F$(r0(e10), function() {
          return "The f passed in grad(f) must be a function";
        }), function(t10, n10) {
          var r10 = L5(t10, "x", "tf.grad", "string_or_numeric"), a10 = null != n10 ? L5(n10, "dy", "tf.grad") : null;
          return E5.tidy(function() {
            var t11 = E5.gradients(function() {
              return e10(r10);
            }, [r10], a10), n11 = t11.value, i10 = t11.grads;
            return null != a10 && D$(n11.shape, a10.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), D9(i10), i10[0];
          });
        };
      }, e.grads = function(e10) {
        return F$(r0(e10), function() {
          return "The f passed in grads(f) must be a function";
        }), function(t10, n10) {
          F$(Array.isArray(t10), function() {
            return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s";
          });
          var r10 = z5(t10, "args", "tf.grads", "string_or_numeric"), a10 = null != n10 ? L5(n10, "dy", "tf.grads") : null;
          return E5.tidy(function() {
            var t11 = E5.gradients(function() {
              return e10.apply(void 0, T(r10));
            }, r10, a10), n11 = t11.value, i10 = t11.grads;
            return null != a10 && D$(n11.shape, a10.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), D9(i10), i10;
          });
        };
      }, e.greater = b9, e.greaterEqual = x9, e.ifft = Ote, e.imag = k9, e.image = Pre, e.inTopKAsync = kne, e.initializers = Hce, e.input = Ihe, e.io = Nae, e.irfft = Fte, e.isFinite = w9, e.isInf = I9, e.isNaN = N9, e.keep = J5, e.kernel_impls = soe, e.layers = Yfe, e.leakyRelu = S9, e.less = T9, e.lessEqual = E9, e.linalg = Bre, e.linspace = C9, e.loadGraphModel = function(e10) {
        return Hve.apply(this, arguments);
      }, e.loadGraphModelSync = function(e10) {
        if (null == e10) throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");
        var t10;
        if (e10 instanceof Array) {
          var n10 = S(e10, 2), r10 = n10[0], a10 = n10[1];
          if (!r10) throw new Error("modelJSON must be the first element of the array");
          if (!(a10 && a10 instanceof ArrayBuffer)) throw new Error("An ArrayBuffer of weights must be the second element of the array");
          if (!("modelTopology" in r10)) throw new Error("Model JSON is missing 'modelTopology'");
          if (!("weightsManifest" in r10)) throw new Error("Model JSON is missing 'weightsManifest'");
          t10 = Iae(x6(r10, N6(r10.weightsManifest), a10));
        } else if ("load" in e10) t10 = e10;
        else {
          if (!("modelTopology" in e10 && "weightSpecs" in e10 && "weightData" in e10)) throw new Error("Unknown model format");
          t10 = Iae(e10);
        }
        var i10 = new jve(t10);
        return i10.load(), i10;
      }, e.loadLayersModel = function(e10, t10) {
        return yhe.apply(this, arguments);
      }, e.localResponseNormalization = A9, e.log = R9, e.log1p = _9, e.logSigmoid = z9, e.logSoftmax = B9, e.logSumExp = W9, e.logicalAnd = U9, e.logicalNot = V9, e.logicalOr = G9, e.logicalXor = j9, e.losses = Wre, e.lowerBound = K9, e.matMul = Q8, e.math = Tae, e.max = n9, e.maxPool = X9, e.maxPool3d = Y9, e.maxPoolWithArgmax = J9, e.maximum = Z9, e.mean = Q9, e.memory = K5, e.meshgrid = tee, e.metrics = Jfe, e.min = r9, e.minimum = nee, e.mirrorPad = ree, e.mod = aee, e.model = function(e10) {
        return new vhe(e10);
      }, e.models = Zfe, e.moments = iee, e.movingAverage = pne, e.mul = g8, e.multiRNNCell = oee, e.multinomial = see, e.neg = M9, e.nextFrame = aie, e.norm = l9, e.notEqual = uee, e.oneHot = cee, e.ones = eee, e.onesLike = lee, e.op = B5, e.outerProduct = hee, e.pad = pee, e.pad1d = fee, e.pad2d = dee, e.pad3d = vee, e.pad4d = mee, e.pool = yee, e.pow = a9, e.prelu = bee, e.print = f8, e.prod = xee, e.profile = function(e10) {
        return E5.profile(e10);
      }, e.raggedGather = kee, e.raggedRange = wee, e.raggedTensorToTensor = Iee, e.rand = Nee, e.randomGamma = nte, e.randomNormal = rte, e.randomStandardNormal = ate, e.randomUniform = ite, e.randomUniformInt = ote, e.range = ste, e.ready = function() {
        return E5.ready();
      }, e.real = ute, e.reciprocal = cte, e.registerBackend = $5, e.registerCallbackConstructor = function(e10, t10) {
        tle.registerCallbackConstructor(e10, t10);
      }, e.registerGradient = j3, e.registerKernel = G3, e.registerOp = function(e10, t10) {
        var n10 = { tfOpName: e10, category: "custom", inputs: [], attrs: [], customExecutor: t10 };
        ode[e10] = n10;
      }, e.regularizers = Qfe, e.relu = lte, e.relu6 = hte, e.removeBackend = function(e10) {
        E5.removeBackend(e10);
      }, e.reshape = X8, e.reverse = pte, e.reverse1d = fte, e.reverse2d = dte, e.reverse3d = vte, e.reverse4d = mte, e.rfft = Mte, e.round = gte, e.rsqrt = yte, e.scalar = i9, e.scatterND = fne, e.scatter_util = Zte, e.searchSorted = q9, e.selu = bte, e.separableConv2d = xte, e.sequential = function(e10) {
        return new whe(e10);
      }, e.serialization = Xre, e.setBackend = Z5, e.setPlatform = function(e10, t10) {
        k0().setPlatform(e10, t10);
      }, e.setWebGLContext = BIe, e.setdiff1dAsync = wte, e.shared = Dbe, e.sigmoid = $8, e.sign = Ite, e.signal = zre, e.sin = Nte, e.sinh = Ste, e.slice = e7, e.slice1d = Tte, e.slice2d = Ete, e.slice3d = Cte, e.slice4d = Ate, e.slice_util = $ae, e.softmax = Rte, e.softplus = L9, e.spaceToBatchND = gee, e.sparse = Ure, e.sparseToDense = vne, e.spectral = Lre, e.split = Dte, e.sqrt = o9, e.square = s9, e.squaredDifference = Lte, e.squeeze = zte, e.stack = Pte, e.step = Bte, e.stridedSlice = Wte, e.string = Vre, e.sub = P9, e.sum = u9, e.sumOutType = p5, e.tan = Ute, e.tanh = t7, e.tensor = V5, e.tensor1d = Vte, e.tensor2d = Gte, e.tensor3d = jte, e.tensor4d = Hte, e.tensor5d = qte, e.tensor6d = Kte, e.tensorScatterUpdate = Qte, e.tensor_util = x5, e.test_util = Qee, e.tidy = X5, e.tile = v9, e.time = function(e10) {
        return E5.time(e10);
      }, e.topk = $te, e.train = nie, e.transpose = hne, e.truncatedNormal = ene, e.unique = tne, e.unregisterGradient = function(e10) {
        if (!B3.has(e10)) throw new Error("The gradient '".concat(e10, "' for backend is not registered"));
        B3.delete(e10);
      }, e.unregisterKernel = function(e10, t10) {
        var n10 = H3(e10, t10);
        if (!P3.has(n10)) throw new Error("The kernel '".concat(e10, "' for backend ") + "'".concat(t10, "' is not registered"));
        P3.delete(n10);
      }, e.unsortedSegmentSum = nne, e.unstack = rne, e.upcastType = h5, e.upperBound = ane, e.util = G4, e.valueAndGrad = function(e10) {
        return F$(r0(e10), function() {
          return "The f passed in valueAndGrad(f) must be a function";
        }), function(t10, n10) {
          F$(t10 instanceof n5, function() {
            return "The x passed in valueAndGrad(f)(x) must be a tensor";
          }), F$(null == n10 || n10 instanceof n5, function() {
            return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor";
          });
          var r10 = E5.gradients(function() {
            return e10(t10);
          }, [t10], n10), a10 = r10.grads, i10 = r10.value;
          return D9(a10), { grad: a10[0], value: i10 };
        };
      }, e.valueAndGrads = function(e10) {
        return F$(r0(e10), function() {
          return "The f passed in valueAndGrads(f) must be a function";
        }), function(t10, n10) {
          F$(Array.isArray(t10) && t10.every(function(e11) {
            return e11 instanceof n5;
          }), function() {
            return "The args passed in valueAndGrads(f)(args) must be array of tensors";
          }), F$(null == n10 || n10 instanceof n5, function() {
            return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor";
          });
          var r10 = E5.gradients(function() {
            return e10.apply(void 0, T(t10));
          }, t10, n10);
          return null != n10 && D$(r10.value.shape, n10.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), D9(r10.grads), r10;
        };
      }, e.variable = ine, e.variableGrads = O9, e.version = hDe, e.version_converter = Kve, e.version_core = eie, e.version_cpu = Mbe, e.version_layers = Ble, e.version_webgl = bEe, e.webgl = kEe, e.webgl_util = LNe, e.where = W7, e.whereAsync = une, e.zeros = $9, e.zerosLike = U7;
    });
  }
});
export default require_tf_min();
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@tensorflow/tfjs/dist/tf.min.js:
  (**
   * @license
   * Copyright 2024 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   *)
*/
//# sourceMappingURL=@tensorflow_tfjs.js.map
